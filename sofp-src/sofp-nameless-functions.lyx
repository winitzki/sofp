#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.1cm
\topmargin 1cm
\rightmargin 1.4cm
\bottommargin 1.45cm
\headsep 0.4cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Mathematical formulas as code.
 I.
 Nameless functions
\begin_inset CommandInset label
LatexCommand label
name "chap:1-Values,-types,-expressions,"

\end_inset


\end_layout

\begin_layout Section
Translating mathematics into code
\end_layout

\begin_layout Subsection
First examples
\end_layout

\begin_layout Standard
We begin by writing Scala code for some computational tasks.
\end_layout

\begin_layout Paragraph
Factorial of 10
\end_layout

\begin_layout Standard
Find the product of integers from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $10$
\end_inset

 (the 
\series bold
factorial
\begin_inset Index idx
status open

\begin_layout Plain Layout
factorial function
\end_layout

\end_inset


\series default
 of 10).
\end_layout

\begin_layout Standard
First, we write a mathematical formula for the result:
\begin_inset Formula 
\[
\prod_{k=1}^{10}k\quad.
\]

\end_inset

We can then write Scala code in a way that resembles this formula:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).product
\end_layout

\begin_layout Plain Layout

res0: Int = 3628800
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Scala interpreter indicates that the result is the value 
\begin_inset Formula $3628800$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 To define a name for this value, we use the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val fac10 = (1 to 10).product
\end_layout

\begin_layout Plain Layout

fac10: Int = 3628800
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fac10 == 3628800
\end_layout

\begin_layout Plain Layout

res1: Boolean = true
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to 10).product
\end_layout

\end_inset


\family default
 is an 
\series bold
expression
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
expression
\end_layout

\end_inset

, which means that (1) the code can be evaluated (e.g.
\begin_inset space ~
\end_inset

using the Scala interpreter) and yields a value, and (2) the code can be
 inserted as a part of a larger expression.
 For example, we could write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> 100 + (1 to 10).product + 100
\end_layout

\begin_layout Plain Layout

res0: Int = 3629000
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Factorial as a function
\end_layout

\begin_layout Standard
Define a function that takes an integer 
\begin_inset Formula $n$
\end_inset

 and computes the factorial of 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
A mathematical formula for this function can be written as
\begin_inset Formula 
\[
f\left(n\right)=\prod_{k=1}^{n}k\quad.
\]

\end_inset

The corresponding Scala code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(n:Int) = (1 to n).product
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Scala's 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset


\family default
 syntax, we need to specify the type of a function's argument; in this case,
 we write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n:Int
\end_layout

\end_inset

.
 In the usual mathematical notation, types of arguments are either not written
 at all, or written separately from the formula:
\begin_inset Formula 
\[
f(n)=\prod_{k=1}^{n}k,\quad\forall n\in\mathbb{N}\quad.
\]

\end_inset

This indicates that 
\begin_inset Formula $n$
\end_inset

 must be from the set of non-negative integers (denoted by 
\begin_inset Formula $\mathbb{N}$
\end_inset

 in mathematics).
 This is similar to specifying the type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset


\family default
 in the Scala code.
 So, the argument's type in the code specifies the 
\emph on
domain
\emph default
 of a function.
\end_layout

\begin_layout Standard
Having defined the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

, we can now apply it to an integer argument: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f(10)
\end_layout

\begin_layout Plain Layout

res6: Int = 3628800
\end_layout

\end_inset

It is an error to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to a non-integer value, e.g.
\begin_inset space \space{}
\end_inset

to a string:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f("abc")
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : String("abc")
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       f("abc")
\end_layout

\begin_layout Plain Layout

         ^ 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Nameless functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Nameless-functions"

\end_inset


\end_layout

\begin_layout Standard
The formula and the code, as written above, both involve 
\emph on
naming
\emph default
 the function as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Sometimes a function does not really need a name, – for instance, if the
 function is used only once.
 
\begin_inset Quotes eld
\end_inset

Nameless
\begin_inset Quotes erd
\end_inset

 mathematical functions are denoted using the symbol 
\begin_inset Formula $\mapsto$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

mapped to
\begin_inset Quotes erd
\end_inset

) like this: 
\begin_inset Formula 
\[
x\mapsto\left(\text{some formula}\right)\quad.
\]

\end_inset

So the mathematical notation for the nameless factorial function is
\begin_inset Formula 
\[
n\mapsto\prod_{k=1}^{n}k\quad.
\]

\end_inset

This reads as 
\begin_inset Quotes eld
\end_inset

a function that maps 
\begin_inset Formula $n$
\end_inset

 to the product of all 
\begin_inset Formula $k$
\end_inset

 where 
\begin_inset Formula $k$
\end_inset

 goes from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The Scala expression implementing this mathematical formula is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(n: Int) => (1 to n).product
\end_layout

\end_inset

This expression shows Scala's syntax for a 
\series bold
nameless
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
nameless function
\end_layout

\end_inset

 function.
 Here, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

n: Int
\end_layout

\end_inset

is the function's 
\series bold
argument
\series default
, while
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to n).product
\end_layout

\end_inset

is the function's 
\series bold
body
\series default
.
 The arrow symbol 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 separates the argument from the body.
\begin_inset Foot
status open

\begin_layout Plain Layout
In Scala, the two ASCII characters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 and the single Unicode character 
\begin_inset Formula $\Rightarrow$
\end_inset

 have the same meaning.
 This book uses the symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 for symbolic calculations and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 for Scala code.
 However, when doing calculations 
\emph on
by hand
\emph default
, one could write 
\begin_inset Formula $\rightarrow$
\end_inset

 instead of 
\begin_inset Formula $\Rightarrow$
\end_inset

 since it is faster.
 Several programming languages, such as OCaml and Haskell, use the symbols
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

 or the Unicode equivalent, 
\begin_inset Formula $\rightarrow$
\end_inset

, for the function arrow.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Functions in Scala (whether named or nameless) are treated as values
\begin_inset Index idx
status open

\begin_layout Plain Layout
function value
\end_layout

\end_inset

, which means that we can also define a Scala value as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val fac = (n: Int) => (1 to n).product
\end_layout

\begin_layout Plain Layout

fac: Int => Int = <function1>
\end_layout

\end_inset

We see that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac
\end_layout

\end_inset

 has the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, which means that the function takes an integer (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

) argument and returns an integer result value.
 What is the value of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac
\end_layout

\end_inset

 
\emph on
itself
\emph default
? As we have just seen, the Scala interpreter prints 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<function1>
\end_layout

\end_inset

 as the 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac
\end_layout

\end_inset

.
 An alternative Scala interpreter
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://ammonite.io/"
target "https://ammonite.io/"
literal "false"

\end_inset


\end_layout

\end_inset

 called 
\family typewriter
ammonite
\family default
 prints something like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala@ val fac = (n: Int) => (1 to n).product
\end_layout

\begin_layout Plain Layout

fac: Int => Int = ammonite.$sess.cmd0$$$Lambda$1675/2107543287@1e44b638
\end_layout

\end_inset

This seems to indicate some identifying number, or perhaps a memory location.
\end_layout

\begin_layout Standard
One may imagine that a 
\begin_inset Quotes eld
\end_inset

function value
\begin_inset Quotes erd
\end_inset

 represents a block
\emph on
 
\emph default
of compiled machine code,  –  code that will actually run and evaluate the
 function's body when the function is applied to its argument.
\end_layout

\begin_layout Standard
Once defined, a function can be applied to an argument like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fac(10)
\end_layout

\begin_layout Plain Layout

res1: Int = 3628800
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, functions can be used without naming them.
 We can directly apply a nameless factorial function to an integer argument
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

 instead of writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac(10)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((n: Int) => (1 to n).product)(10)
\end_layout

\begin_layout Plain Layout

res2: Int = 3628800
\end_layout

\end_inset

One would not often write code like this because there is no advantage in
 creating a nameless function and then applying it right away to an argument.
 This is so because we can evaluate the expression
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

((n: Int) => (1 to n).product)(10)
\end_layout

\end_inset

by substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 in the function body, which gives us
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to 10).product
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If a nameless function uses the argument several times, for example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

((n: Int) => n*n*n + n*n)(12345)
\end_layout

\end_inset

it is still better to substitute the argument and to eliminate the nameless
 function.
 We could write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

12345*12345*12345 + 12345*12345
\end_layout

\end_inset

but, of course, it is better to avoid repeating the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

12345
\end_layout

\end_inset

.
 To achieve that, we may define 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset


\family default
 as a value in an 
\series bold
expression block
\begin_inset Index idx
status open

\begin_layout Plain Layout
expression block
\end_layout

\end_inset


\series default
 like this: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> { val n = 12345; n*n*n + n*n }
\end_layout

\begin_layout Plain Layout

res3: Int = 322687002
\end_layout

\end_inset

Defined in this way, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 is visible only within the expression block.
 Outside the block, another value named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 could be defined independently of this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

.
 For this reason, the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 is called a 
\series bold
locally
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
local scope
\end_layout

\end_inset

 
\series bold
scoped
\series default
 definition.
\end_layout

\begin_layout Standard
Nameless functions are convenient when they are themselves arguments of
 other functions, as we will see next.
\end_layout

\begin_layout Paragraph
Example: prime numbers
\end_layout

\begin_layout Standard
Let us define a function that takes an integer argument 
\begin_inset Formula $n$
\end_inset

 and determines whether 
\begin_inset Formula $n$
\end_inset

 is a prime number.
\end_layout

\begin_layout Standard
A simple mathematical formula for this function can be written as
\begin_inset Formula 
\begin{equation}
\text{is\_prime}\left(n\right)=\forall k\in\left[2,n-1\right]\ :\ n\neq0\text{ mod }k\quad.\label{eq:is_prime_def}
\end{equation}

\end_inset

This formula has two clearly separated parts: first, a range of integers
 from 
\begin_inset Formula $2$
\end_inset

 to 
\begin_inset Formula $n-1$
\end_inset

, and second, a requirement that all these integers should satisfy a given
 condition, 
\begin_inset Formula $n\neq0\text{ mod }k$
\end_inset

.
 Formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is translated into Scala code as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def is_prime(n: Int) = (2 to n-1).forall(k => n % k != 0)
\end_layout

\end_inset

In this code, the two parts of the mathematical formula are implemented
 in a way that is closely similar to the mathematical notation, except for
 the arrow after 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
We can now apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset

 to some integer values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> is_prime(12)
\end_layout

\begin_layout Plain Layout

res3: Boolean = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> is_prime(13)
\end_layout

\begin_layout Plain Layout

res4: Boolean = true
\end_layout

\end_inset

As we can see from the output above, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset

 returns a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

.
 Therefore, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Boolean
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A function that returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 value is called a 
\series bold
predicate
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
predicate
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In Scala, it is optional – but strongly recommended – to specify the return
 type of named functions.
 The required syntax looks like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def is_prime(n: Int): Boolean = (2 to n-1).forall(k => n % k != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, we do not need to specify the type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset


\family default
 for the argument 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset


\family default
 of the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k => n % k != 0
\end_layout

\end_inset

.
 The Scala compiler knows that 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset


\family default
 is going to iterate over the 
\emph on
integer
\emph default
 elements of the range 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(2 to n-1)
\end_layout

\end_inset

, which effectively forces 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset


\family default
 to be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Nameless functions and bound variables
\end_layout

\begin_layout Standard
The code for 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset


\family default
 differs from the mathematical formula
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

) in two ways.
\end_layout

\begin_layout Standard
One difference is that the interval 
\begin_inset Formula $\left[2,n-1\right]$
\end_inset

 is in front of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset

.
 Another is that the Scala code uses a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k => n % k != 0)
\end_layout

\end_inset

, while Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) does not seem to involve any functions.
\end_layout

\begin_layout Standard
To understand the first difference, we need to keep in mind that the Scala
 syntax such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(2 to n-1).forall(k => ...)
\end_layout

\end_inset


\family default
 means to apply a function called 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset


\family default
 to 
\emph on
two
\emph default
 arguments: the first argument is the range 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(2 to n-1)
\end_layout

\end_inset

,
\family default
 and the second argument is the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k => ...)
\end_layout

\end_inset

.
 In Scala, the 
\series bold
infix
\series default
 syntax
\begin_inset Index idx
status open

\begin_layout Plain Layout
infix syntax
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.f(z)
\end_layout

\end_inset

, or equivalently 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x f z
\end_layout

\end_inset

, means that a function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset


\family default
 is applied to its 
\emph on
two
\emph default
 arguments, 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

.
 In the ordinary mathematical notation, this would be 
\begin_inset Formula $f(x,z)$
\end_inset

.
 Infix notation is often easier to read and is widely used, e.g.
\begin_inset space ~
\end_inset

when we write 
\begin_inset Formula $x+y$
\end_inset

 rather than something like 
\begin_inset Formula $plus(x,y)$
\end_inset

.
\end_layout

\begin_layout Standard
A single-argument function could be also defined with infix notation, and
 then the syntax is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.f
\end_layout

\end_inset

, as in the expression 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).product
\end_layout

\end_inset


\family default
 we have seen before.
\end_layout

\begin_layout Standard
The infix methods 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.product
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.forall
\end_layout

\end_inset


\family default
 are already provided in the Scala standard library, so it is natural to
 use them.
 If we want to avoid the infix syntax, we could define a function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for_all
\end_layout

\end_inset


\family default
 with two arguments and write code like this,
\begin_inset space \hfill{}
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for_all(2 to n-1, k => n % k != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset

This would have brought the syntax somewhat closer to the formula
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

).
 
\end_layout

\begin_layout Standard
However, there still remains the second difference: The symbol 
\begin_inset Formula $k$
\end_inset

 is used as an 
\emph on
argument
\emph default
 of a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k => n % k != 0)
\end_layout

\end_inset

 in the Scala code,  –  while the mathematical formula 
\begin_inset Formula 
\begin{equation}
\forall k\in\left[2,n-1\right]\ :\ n\neq0\text{ mod }k\label{eq:prime-formula-function}
\end{equation}

\end_inset

does not seem to use any functions but defines the symbol 
\begin_inset Formula $k$
\end_inset

 that goes over the range 
\begin_inset Formula $\left[2,n-1\right]$
\end_inset

.
 The variable 
\begin_inset Formula $k$
\end_inset

 is then used for writing the predicate 
\begin_inset Formula $n\neq0\text{ mod }k$
\end_inset

.
 
\end_layout

\begin_layout Standard
Let us investigate the role of 
\begin_inset Formula $k$
\end_inset

 more closely.
 The mathematical variable 
\begin_inset Formula $k$
\end_inset

 is actually defined 
\emph on
only inside
\emph default
 the expression 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\forall k:...$
\end_inset


\begin_inset Quotes erd
\end_inset

 and makes no sense outside that expression.
 This becomes clear by looking at Eq.
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

): The variable 
\begin_inset Formula $k$
\end_inset

 is not present in the left-hand side and could not possibly be used there.
 The name 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $k$
\end_inset


\begin_inset Quotes erd
\end_inset

 is defined only in the right-hand side, where it is first mentioned as
 the arbitrary element 
\begin_inset Formula $k\in\left[2,n-1\right]$
\end_inset

 and then used in the sub-expression 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $...\text{ mod }k$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
So, the mathematical notation in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:prime-formula-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

) says two things: First, we use the name 
\begin_inset Formula $k$
\end_inset

 for integers from 
\begin_inset Formula $2$
\end_inset

 to 
\begin_inset Formula $n-1$
\end_inset

.
 Second, for each of those 
\begin_inset Formula $k$
\end_inset

 we evaluate the expression 
\begin_inset Formula $n\neq0\text{ mod }k$
\end_inset

, which can be viewed as a certain given 
\emph on
function
\emph default
 
\emph on
of
\emph default
 
\begin_inset Formula $k$
\end_inset

 that returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 value.
 Translating the mathematical notation into code, it is therefore natural
 to use the nameless function
\begin_inset Formula 
\[
k\mapsto n\neq0\text{ mod }k
\]

\end_inset

and to write Scala code applying this nameless function to each element
 of the range 
\begin_inset Formula $\left[2,n-1\right]$
\end_inset

 and checking that all result values be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\begin_inset space \hfill{}
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(2 to n-1).forall(k => n % k != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset

Just as the mathematical notation defines the variable 
\begin_inset Formula $k$
\end_inset

 only in the right-hand side of Eq.
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

), the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 of the nameless Scala function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k => n % k != 0
\end_layout

\end_inset

 is defined only within that function's body and cannot be used in any code
 outside the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n % k != 0
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Variables that are defined only inside an expression and are invisible outside
 are called 
\series bold
bound variables
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
bound variable
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

variables bound in an expression
\begin_inset Quotes erd
\end_inset

.
 Variables that are used in an expression but are defined outside it are
 called 
\series bold
free variables
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
free variable
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

variables occurring free in an expression
\begin_inset Quotes erd
\end_inset

.
 These concepts apply equally well to mathematical formulas and to Scala
 code.
 For example, in the mathematical expression 
\begin_inset Formula $k\Rightarrow n\neq0\text{ mod }k$
\end_inset

 (which is a nameless function), the variable 
\begin_inset Formula $k$
\end_inset

 is bound (it is defined only within that expression) but the variable 
\begin_inset Formula $n$
\end_inset

 is free (it is defined outside that expression).
\end_layout

\begin_layout Standard
The main difference between free and bound variables is that bound variables
 can be 
\emph on
locally renamed
\emph default
 at will, unlike free variables.
 To see this, consider that we could rename 
\begin_inset Formula $k$
\end_inset

 to 
\begin_inset Formula $z$
\end_inset

 and write instead of Eq.
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

) an equivalent definition
\begin_inset Formula 
\[
\text{is\_prime}\left(n\right)=\forall z\in\left[2,n-1\right]\ :\ n\neq0\text{ mod }z\quad,
\]

\end_inset

or in Scala code,
\begin_inset space \hfill{}
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(2 to n-1).forall(z => n % z != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset

The argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 in the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z => n % z != 0
\end_layout

\end_inset

 may be renamed without changing the result of the entire program.
 No code outside that function needs to be changed after renaming 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

.
 But the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 is defined outside and cannot be renamed 
\begin_inset Quotes eld
\end_inset

locally
\begin_inset Quotes erd
\end_inset

 (i.e.
\begin_inset space ~
\end_inset

only within the sub-expression).
 If we wanted to rename 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 in the sub-expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z => n % z != 0
\end_layout

\end_inset

, we would also need to change every place in the code that defines and
 uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 
\emph on
outside
\emph default
 that expression, or else the program would become incorrect.
\end_layout

\begin_layout Standard
Mathematical formulas use bound variables in various constructions such
 as 
\begin_inset Formula $\forall k:p(k)$
\end_inset

, 
\begin_inset Formula $\exists k:p(k)$
\end_inset

, 
\begin_inset Formula $\sum_{k=a}^{b}f(k)$
\end_inset

, 
\begin_inset Formula $\int_{0}^{1}k^{2}dk$
\end_inset

, 
\begin_inset Formula $\lim_{n\rightarrow\infty}f(n)$
\end_inset

, and 
\begin_inset Formula $\text{argmax}_{k}f\left(k\right)$
\end_inset

.
 When translating mathematical expressions into code, we need to recognize
 the presence of bound variables, which the mathematical notation does not
 make quite so explicit.
 For each bound variable, we need to create a nameless function whose argument
 is that variable, e.g.
\begin_inset space \space{}
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k=>p(k)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k=>f(k)
\end_layout

\end_inset

 for the examples just shown.
 Only then will our code correctly reproduce the behavior of bound variables
 in mathematical expressions.
\end_layout

\begin_layout Standard
As an example, the mathematical formula 
\begin_inset Formula $\forall k\in\left[1,n\right]:p\left(k\right)$
\end_inset

 has a bound variable 
\begin_inset Formula $k$
\end_inset

 and is translated into Scala code as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to n).forall(k => p(k))
\end_layout

\end_inset

At this point we can apply a simplification trick to this code.
 The nameless function 
\begin_inset Formula $k\Rightarrow p(k)$
\end_inset

 does exactly the same thing as the (named) function 
\begin_inset Formula $p$
\end_inset

: It takes an argument, which we may call 
\begin_inset Formula $k$
\end_inset

, and returns 
\begin_inset Formula $p(k)$
\end_inset

.
 So, we can simplify the Scala code above to
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to n).forall(p)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The simplification of 
\begin_inset Formula $x\Rightarrow f(x)$
\end_inset

 to just 
\begin_inset Formula $f$
\end_inset

 is always possible for functions 
\begin_inset Formula $f$
\end_inset

 of a single argument.
\begin_inset Foot
status open

\begin_layout Plain Layout
Certain features of Scala allow programmers to write code that looks like
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

 but actually involves additional implicit or default arguments of the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

, or an implicit type conversion for its argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 In those cases, replacing the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => f(x)
\end_layout

\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 will fail to compile.
 But these complications do not arise when working with simple functions.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Aggregating data from sequences
\end_layout

\begin_layout Standard
Consider the task of counting how many even numbers there are in a given
 list 
\begin_inset Formula $L$
\end_inset

 of integers.
 For example, the list 
\begin_inset Formula $\left[5,6,7,8,9\right]$
\end_inset

 contains 
\emph on
two
\emph default
 even numbers: 
\begin_inset Formula $6$
\end_inset

 and 
\begin_inset Formula $8$
\end_inset

.
\end_layout

\begin_layout Standard
A mathematical formula for this task can be written like this,
\begin_inset Formula 
\begin{align*}
\text{count\_even}\left(L\right) & =\sum_{k\in L}\text{is\_even}\left(k\right)\quad,\\
\text{is\_even}\left(k\right) & =\begin{cases}
1 & \text{if }k=0\text{ mod }2\\
0 & \text{otherwise}
\end{cases}\quad.
\end{align*}

\end_inset

Here we defined a helper function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_even
\end_layout

\end_inset


\family default
 in order to write more easily a formula for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count_even
\end_layout

\end_inset

.
 In mathematics, complicated formulas are often split into simpler parts
 by defining helper expressions.
 
\end_layout

\begin_layout Standard
We can write the Scala code similarly.
 We first define the helper function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_even
\end_layout

\end_inset

; the Scala code can be written in a style quite similar to the mathematical
 formula:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def is_even(k: Int): Int = (k % 2) match {
\end_layout

\begin_layout Plain Layout

  case 0 => 1 // First, check if it is zero.
\end_layout

\begin_layout Plain Layout

  case _ => 0 // The underscore matches everything else.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For such a simple computation, we could also write shorter code using a
 nameless function,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val is_even = (k: Int) => if (k % 2 == 0) 1 else 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given this function, we now need to translate into Scala code the expression
 
\begin_inset Formula $\sum_{k\in L}\text{is\_even}\left(k\right)$
\end_inset

.
 We can represent the list 
\begin_inset Formula $L$
\end_inset

 using the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

 from the Scala standard library.
\end_layout

\begin_layout Standard
To compute 
\begin_inset Formula $\sum_{k\in L}\text{is\_even}\left(k\right)$
\end_inset

, we must apply the function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_even
\end_layout

\end_inset


\family default
 to each element of the list 
\begin_inset Formula $L$
\end_inset

, which will produce a list of some (integer) results, and then we will
 need to add all those results together.
 It is convenient to perform these two steps separately.
 This can be done with the functions 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, defined in the Scala standard library as infix methods for the data type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The method 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset


\family default
 is similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.product
\end_layout

\end_inset

 and is defined for any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 of numerical types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, etc.).
 It computes the sum of all numbers in the list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3).sum
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset


\family default
 needs more explanation.
 This method takes a 
\emph on
function
\emph default
 as its second argument, applies that function to each element of the list,
 and puts all the results into a 
\emph on
new 
\emph default
list, which is then returned as the result value:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3).map(x => x*x + 100*x)
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(101, 204, 309)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example, the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 is the nameless function 
\begin_inset Formula $x\mapsto x^{2}+100x$
\end_inset

.
 This function will be used repeatedly by 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset


\family default
 to transform each integer from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1, 2, 3)
\end_layout

\end_inset

, creating a new list as a result.
\end_layout

\begin_layout Standard
It is equally possible to define the transforming function separately, give
 it a name, and then use it as the argument to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def func1(x: Int): Int = x*x + 100*x
\end_layout

\begin_layout Plain Layout

func1: (x: Int)Int 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(1, 2, 3).map(func1)
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(101, 204, 309)
\end_layout

\end_inset

Usually, short functions are defined inline, and longer functions are given
 a name and defined separately.
\end_layout

\begin_layout Standard
An infix method, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, can be also used with a 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3) map func1
\end_layout

\begin_layout Plain Layout

res3: List[Int] = List(101, 204, 309)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the transforming function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func1
\end_layout

\end_inset

 is used only once, and especially for a simple operation such as 
\begin_inset Formula $x\mapsto x^{2}+100x$
\end_inset

, it is easier to work with a nameless function.
\end_layout

\begin_layout Standard
We can now combine the methods 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset


\family default
 to define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count_even
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def count_even(s: List[Int]) = s.map(is_even).sum
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This code can be also written using a nameless function instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_even
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def count_even(s: List[Int]): Int = s
\end_layout

\begin_layout Plain Layout

    .map { k => if (k % 2 == 0) 1 else 0 }
\end_layout

\begin_layout Plain Layout

    .sum
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is customary in Scala to use infix methods when chaining several operations.
 For instance 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.map(...).sum
\end_layout

\end_inset

 means first apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.map(...)
\end_layout

\end_inset

, which returns a 
\emph on
new
\emph default
 list, and then apply 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset


\family default
 to that list.
 To make the code more readable, we put each of the chained methods on a
 new line.
 
\end_layout

\begin_layout Standard
To test this code, let us run it in the Scala interpreter.
 In order to let the interpreter work correctly with code entered line by
 line, the dot character needs to be at the 
\emph on
end
\emph default
 of the line.
 (In a compiled code, the dots can be at the beginning of the lines since
 the compiler reads the entire code at once.)
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def count_even(s: List[Int]): Int = s .
\end_layout

\begin_layout Plain Layout

         map { k => if (k % 2 == 0) 1 else 0 } .
\end_layout

\begin_layout Plain Layout

         sum
\end_layout

\begin_layout Plain Layout

count_even: (s: List[Int])Int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> count_even(List(1,2,3,4,5))
\end_layout

\begin_layout Plain Layout

res0: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> count_even( List(1,2,3,4,5).map(x => x * 2) )
\end_layout

\begin_layout Plain Layout

res1: Int = 5
\end_layout

\end_inset

Note that the Scala interpreter prints the types differently for functions
 defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

.
 It prints 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(s: List[Int])Int
\end_layout

\end_inset

 for a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int] => Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Filtering and truncating a sequence 
\end_layout

\begin_layout Standard
In addition to the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.product
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.forall
\end_layout

\end_inset


\family default
 that we have already seen, the Scala standard library defines many other
 useful methods.
 We will now take a look at using the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.exists
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.size
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.min
\end_layout

\end_inset

, and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.size
\end_layout

\end_inset


\family default
 are self-explanatory:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(10, 20, 30).max
\end_layout

\begin_layout Plain Layout

res2: Int = 30
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(10, 20, 30).min
\end_layout

\begin_layout Plain Layout

res3: Int = 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(10, 20, 30).size
\end_layout

\begin_layout Plain Layout

res4: Int = 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.forall
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.exists
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset


\family default
 require a predicate as an argument.
 The 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.forall
\end_layout

\end_inset


\family default
 method returns 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\family default
 if and only if the predicate returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 for all values in the list; the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.exists
\end_layout

\end_inset


\family default
 method returns 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\family default
 if and only if the predicate holds (returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

) for at least one value in the list.
 These methods can be written as mathematical formulas like this:
\begin_inset Formula 
\begin{align*}
\text{forall}\left(S,p\right) & =\forall k\in S:p(k)=\text{true}\\
\text{exists}\left(S,p\right) & =\exists k\in S:p(k)=\text{true}
\end{align*}

\end_inset

However, there is no mathematical notation for operations such as 
\begin_inset Quotes eld
\end_inset

removing elements from a list
\begin_inset Quotes erd
\end_inset

, so we will focus on the Scala syntax for these functions.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 method returns a list that contains only the values for which the predicate
 returns 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3, 4, 5).filter(k => k % 3 != 0)
\end_layout

\begin_layout Plain Layout

res5: List[Int] = List(1, 2, 4, 5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset


\family default
 method truncates a given list, returning a new list with the initial portion
 of values from the original list for which predicate keeps being 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3, 4, 5).takeWhile(k => k % 3 != 0)
\end_layout

\begin_layout Plain Layout

res6: List[Int] = List(1, 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all these cases, the predicate's argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 must be of the same type as the elements in the list.
 In the examples shown above, the elements are integers (i.e.
\begin_inset space \space{}
\end_inset

the lists have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

), therefore 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset


\family default
 must be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.product
\end_layout

\end_inset


\family default
 are defined on lists of 
\emph on
numeric types
\emph default
, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

.
 The other methods are defined on lists of all types.
\end_layout

\begin_layout Standard
Using these methods, we can solve many problems that involve transforming
 and aggregating data stored in lists (as well as in arrays, sets, or other
 similar data structures).
 A 
\series bold
transformation
\begin_inset Index idx
status open

\begin_layout Plain Layout
transformation
\end_layout

\end_inset


\series default
 is a function taking a list of values and returning another list of values;
 examples of transformation functions are 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

.
 An 
\series bold
aggregation
\begin_inset Index idx
status open

\begin_layout Plain Layout
aggregation
\end_layout

\end_inset


\series default
 is a function taking a list of values and returning a 
\emph on
single
\emph default
 value; examples of aggregation functions are 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.max
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Writing programs by chaining together various methods of transformation
 and aggregation is known as programming in the 
\series bold
map/reduce
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
map/reduce style
\end_layout

\end_inset

 
\series bold
style
\series default
.
\end_layout

\begin_layout Section
Solved examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aggregation 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Improve the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset

 by limiting the search to 
\begin_inset Formula $k^{2}\leq n$
\end_inset

:
\begin_inset Formula 
\[
\text{is\_prime}\left(n\right)=\forall k\in\left[2,n-1\right]\text{ such that }k^{2}\leq n\ :\ n\neq0\text{ mod }k\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution:
\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

 to truncate the initial list when 
\begin_inset Formula $k^{2}\leq n$
\end_inset

 becomes false:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def is_prime(n: Int): Boolean =
\end_layout

\begin_layout Plain Layout

  (2 to n-1)
\end_layout

\begin_layout Plain Layout

    .takeWhile(k => k*k + 1 < n)
\end_layout

\begin_layout Plain Layout

    .forall(k => n % k != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute 
\begin_inset Formula $\prod_{k\in\left[1,10\right]}\left|\sin\left(k+2\right)\right|$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to 10)
\end_layout

\begin_layout Plain Layout

  .map(k => math.abs(math.sin(k + 2)))
\end_layout

\begin_layout Plain Layout

  .product
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute 
\begin_inset Formula $\sum_{k\in[1,10];~\cos k>0}\sqrt{\cos k}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to 10)
\end_layout

\begin_layout Plain Layout

  .filter(k => math.cos(k) > 0)
\end_layout

\begin_layout Plain Layout

  .map(k => math.sqrt(math.cos(k)))
\end_layout

\begin_layout Plain Layout

  .sum
\end_layout

\end_inset

It is safe to compute 
\begin_inset Formula $\sqrt{\cos k}$
\end_inset

, because we have first filtered the list by keeping only values 
\begin_inset Formula $k$
\end_inset

 for which 
\begin_inset Formula $\cos k>0$
\end_inset

.
 Let us check that this is so:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).toList.filter(k => math.cos(k) > 0).map(x => math.cos(x))
\end_layout

\begin_layout Plain Layout

res0: List[Double] = List(0.5403023058681398, 0.28366218546322625, 0.96017028665036
61, 0.7539022543433046)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute the average of a non-empty list of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Double]
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{average}\left(s\right)=\frac{1}{n}\sum_{i=0}^{n-1}s_{i}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to divide the sum by the length of the list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def average(s: List[Double]): Double = s.sum / s.size
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> average(List(1.0, 2.0, 3.0))
\end_layout

\begin_layout Plain Layout

res0: Double = 2.0
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-5-Wallis-product"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-5-Wallis-product"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $n$
\end_inset

, compute the Wallis product
\begin_inset Index idx
status open

\begin_layout Plain Layout
Wallis product
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Wallis_product"
target "https://en.wikipedia.org/wiki/Wallis_product"
literal "false"

\end_inset


\end_layout

\end_inset

 truncated up to 
\begin_inset Formula $\frac{2n}{2n+1}$
\end_inset

: 
\begin_inset Formula 
\[
\text{wallis}\left(n\right)=\frac{2}{1}\frac{2}{3}\frac{4}{3}\frac{4}{5}\frac{6}{5}\frac{6}{7}...\frac{2n}{2n+1}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Define the helper function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wallis_frac(i)
\end_layout

\end_inset

 that computes the 
\begin_inset Formula $i^{\text{th}}$
\end_inset

 fraction.
 The method 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.toDouble
\end_layout

\end_inset


\family default
 converts integers to 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset


\family default
 numbers.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def wallis_frac(i: Int): Double = (2*i).toDouble/(2*i - 1)*(2*i)/(2*i + 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def wallis(n: Int) = (1 to n).map(wallis_frac).product
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> math.cos(wallis(10000))  // Should be close to 0.
\end_layout

\begin_layout Plain Layout

res0: Double = 3.9267453954401036E-5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> math.cos(wallis(100000)) // Should be even closer to 0.
\end_layout

\begin_layout Plain Layout

res1: Double = 3.926966362362075E-6
\end_layout

\end_inset

The limit of the Wallis product is 
\begin_inset Formula $\frac{\pi}{2}$
\end_inset

, so the cosine of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wallis(n)
\end_layout

\end_inset

 tends to zero in the limit of large 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Check numerically that 
\begin_inset Formula $\sum_{k=1}^{\infty}\frac{1}{k^{2}}=\frac{\pi^{2}}{6}$
\end_inset

: First, define a function of 
\begin_inset Formula $n$
\end_inset

 that computes a partial sum of this series until 
\begin_inset Formula $k=n$
\end_inset

.
 Then compute the partial sum for a large value of 
\begin_inset Formula $n$
\end_inset

 and compare with the limit value.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def euler_series(n: Int): Double = (1 to n).map(k => 1.0/k/k).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> euler_series(100000)
\end_layout

\begin_layout Plain Layout

res0: Double = 1.6449240668982423
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val pi = 4*math.atan(1)
\end_layout

\begin_layout Plain Layout

pi: Double = 3.141592653589793
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> pi*pi/6
\end_layout

\begin_layout Plain Layout

res1: Double = 1.6449340668482264 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Check numerically the infinite product formula
\begin_inset Formula 
\[
\prod_{k=1}^{\infty}\left(1-\frac{x^{2}}{k^{2}}\right)=\frac{\sin\pi x}{\pi x}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Compute this product up to 
\begin_inset Formula $k=n$
\end_inset

 for 
\begin_inset Formula $x=0.1$
\end_inset

 and a large value of 
\begin_inset Formula $n$
\end_inset

, say 
\begin_inset Formula $n=10^{5}$
\end_inset

, and compare with the right-hand side:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sine_product(n: Int, x: Double): Double = (1 to n).map(k => 1.0 - x*x/k/k).prod
uct
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> sine_product(n = 100000, x = 0.1) // Arguments may be named, for clarity.
\end_layout

\begin_layout Plain Layout

res0: Double = 0.9836317414461351
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> math.sin(pi*0.1)/pi/0.1
\end_layout

\begin_layout Plain Layout

res1: Double = 0.9836316430834658
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset Formula $p$
\end_inset

 that takes a list of integers and a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Int
\end_layout

\end_inset

, and returns the largest value of 
\begin_inset Formula $f(x)$
\end_inset

 among all 
\begin_inset Formula $x$
\end_inset

 in the list.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p(s: List[Int], f: Int => Int): Int = s.map(f).max
\end_layout

\end_inset

Here is a test for this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> p(List(2, 3, 4, 5), x => 60 / x)
\end_layout

\begin_layout Plain Layout

res0: Int = 30
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Transformation
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-Example-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-Example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a list of lists, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s: List[List[Int]]
\end_layout

\end_inset

, select the inner lists of size at least 
\begin_inset Formula $3$
\end_inset

.
 The result must be again of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[Int]]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To 
\begin_inset Quotes eld
\end_inset

select the inner lists
\begin_inset Quotes erd
\end_inset

 means to compute a 
\emph on
new
\emph default
 list containing only the desired inner lists.
 We use 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset


\family default
 on the outer list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

.
 The predicate for the filter is a function that takes an inner list and
 returns 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\family default
 if the size of that list is at least 
\begin_inset Formula $3$
\end_inset

.
 Write the predicate as a nameless function, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t => t.size >= 3
\end_layout

\end_inset

, where 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset


\family default
 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(s: List[List[Int]]): List[List[Int]] = s.filter(t => t.size >= 3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(List( List(1,2), List(1,2,3), List(1,2,3,4) ))
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(1, 2, 3), List(1, 2, 3, 4)) 
\end_layout

\end_inset

The Scala compiler deduces the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 from the code; no other type would work since we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 to a 
\emph on
list of lists
\emph default
 of integers.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-Example-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-Example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find all integers 
\begin_inset Formula $k\in\left[1,10\right]$
\end_inset

 such that there are at least three different integers 
\begin_inset Formula $j$
\end_inset

, where 
\begin_inset Formula $1\leq j\leq k$
\end_inset

, each 
\begin_inset Formula $j$
\end_inset

 satisfying the condition 
\begin_inset Formula $j^{2}>2k$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).toList.filter(k => (1 to k).filter(j => j*j > 2*k).size >=
 3)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(6, 7, 8, 9, 10) 
\end_layout

\end_inset

The argument of the outer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

 is a nameless function that also uses a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

.
 The inner expression
\end_layout

\begin_layout Standard
\noindent
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to k).filter(j => j*j > 2*k).size >= 3
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset

 (shown at left) computes the list of 
\begin_inset Formula $j$
\end_inset

's that satisfy the condition 
\begin_inset Formula $j^{2}>2k$
\end_inset

, and then compares the size of that list with 
\begin_inset Formula $3$
\end_inset

.
 In this way, we impose the requirement that there should be at least 
\begin_inset Formula $3$
\end_inset

 values of 
\begin_inset Formula $j$
\end_inset

.
 We can see how the Scala code closely follows the mathematical formulation
 of the task.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
Functional programs are mathematical formulas translated into code.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:translating-mathematics-into-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how to implement some often used mathematical constructions in Scala.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Mathematical notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Scala code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x\mapsto\sqrt{x^{2}+1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => math.sqrt(x*x + 1)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
list 
\begin_inset Formula $\left[1,~2,~...,~n\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
list 
\begin_inset Formula $\left[f(1),~...,~f(n)\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).map(k => f(k))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\sum_{k=1}^{n}k^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).map(k => k*k).sum
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\prod_{k=1}^{n}f(k)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).map(f).product
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall k\text{ such that }1\leq k\leq n:p(k)~\text{holds}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).forall(k => p(k))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\exists k,\:1\leq k\leq n\text{ such that }p(k)~\text{holds}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).exists(k => p(k))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \sum_{k\in S\text{ such that }p(k)\text{ holds}}}f(k)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.filter(p).map(f).sum
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Translating mathematics into code.
\begin_inset CommandInset label
LatexCommand label
name "tab:translating-mathematics-into-code"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
What problems can one solve with this knowledge?
\end_layout

\begin_layout Itemize
Compute mathematical expressions involving sums, products, and quantifiers,
 based on integer ranges, such as 
\begin_inset Formula $\sum_{k=1}^{n}f(k)$
\end_inset

 etc.
\end_layout

\begin_layout Itemize
Transform and aggregate data from lists using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

,
\series bold
 
\series default

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, and other methods from the Scala standard library.
\end_layout

\begin_layout Standard
What are examples of problems that are 
\emph on
not
\emph default
 solvable with these tools?
\end_layout

\begin_layout Itemize
Example
\begin_inset space ~
\end_inset

1: Compute the smallest 
\begin_inset Formula $n\geq1$
\end_inset

 such that 
\begin_inset Formula 
\[
f(f(f(...f(0)...)>1000\quad,
\]

\end_inset

where the given function 
\begin_inset Formula $f$
\end_inset

 is applied 
\begin_inset Formula $n$
\end_inset

 times.
\end_layout

\begin_layout Itemize
Example
\begin_inset space ~
\end_inset

2: Given a list 
\begin_inset Formula $s$
\end_inset

 of numbers, compute the list 
\begin_inset Formula $r$
\end_inset

 of running averages: 
\begin_inset Formula 
\[
r_{n}=\frac{1}{n}\sum_{k=0}^{n-1}s_{k}\quad.
\]

\end_inset


\end_layout

\begin_layout Itemize
Example
\begin_inset space ~
\end_inset

3: Perform binary search over a sorted list of integers.
\end_layout

\begin_layout Standard
These computations involve 
\emph on
mathematical induction
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction
\end_layout

\end_inset

, which we have not yet learned to translate into code in the general case.
\end_layout

\begin_layout Standard
Library functions we have seen so far, such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, implement a restricted class of iterative operations on lists: namely,
 operations that process each element of a given list independently and
 accumulate results.
 For instance, when computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.map(f)
\end_layout

\end_inset

, the number of function applications is given by the size of the initial
 list.
 However, Example
\begin_inset space \space{}
\end_inset

1 requires applying a function 
\begin_inset Formula $f$
\end_inset

 repeatedly until a given condition holds – that is, repeating for an 
\emph on
initially unknown
\emph default
 number of times.
 So it is impossible to write an expression containing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.takeWhile
\end_layout

\end_inset

, etc., that solves Example
\begin_inset space \space{}
\end_inset

1.
 We could write the solution of Example
\begin_inset space \space{}
\end_inset

1 as a formula by using mathematical induction, but we have not yet seen
 how to implement that in Scala code.
 
\end_layout

\begin_layout Standard
Example
\begin_inset space \space{}
\end_inset

2 can be formulated as a definition of a new list 
\begin_inset Formula $r$
\end_inset

 by induction, 
\begin_inset Formula 
\[
r_{0}=s_{0}\quad;\quad\quad r_{i}=s_{i}+r_{i-1}\text{ for }i=1,2,3,...
\]

\end_inset

However, operations such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset


\family default
 cannot compute 
\begin_inset Formula $r_{i}$
\end_inset

 depending on the value of 
\begin_inset Formula $r_{i-1}$
\end_inset

.
\end_layout

\begin_layout Standard
Example
\begin_inset space \space{}
\end_inset

3 defines the search result by induction: the list is split in half, and
 search is performed by inductive hypothesis in the half that contains the
 required value.
 This computation requires an initially unknown number of steps.
\end_layout

\begin_layout Standard
Chapter
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 explains how to implement these tasks by translating mathematical induction
 into code using recursion.
\end_layout

\begin_layout Section
Exercises
\begin_inset CommandInset label
LatexCommand label
name "sec:Chapter-1-Exercises"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aggregation
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Machin's formula
\begin_inset Index idx
status open

\begin_layout Plain Layout
Machin's formula
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "http://turner.faculty.swau.edu/mathematics/materialslibrary/pi/machin.html"
target "http://turner.faculty.swau.edu/mathematics/materialslibrary/pi/machin.html"
literal "false"

\end_inset


\end_layout

\end_inset

 converges to 
\begin_inset Formula $\pi$
\end_inset

 faster than Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-5-Wallis-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\begin{align*}
\frac{\pi}{4} & =4\arctan\frac{1}{5}-\arctan\frac{1}{239}\quad,\\
\arctan\frac{1}{n} & =\frac{1}{n}-\frac{1}{3}\frac{1}{n^{3}}+\frac{1}{5}\frac{1}{n^{5}}-...=\sum_{k=1}^{\infty}\frac{\left(-1\right)^{k}}{2k+1}n^{-2k-1}\quad.
\end{align*}

\end_inset

Implement a function that computes the series for 
\begin_inset Formula $\arctan\frac{1}{n}$
\end_inset

 up to a given number of terms, and compute an approximation of 
\begin_inset Formula $\pi$
\end_inset

 using this formula.
 Show that about 
\begin_inset Formula $12$
\end_inset

 terms of the series are already sufficient for a full-precision 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 approximation of 
\begin_inset Formula $\pi$
\end_inset

.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Code: def at(n: Double, l: Int) = (1 to l).map(k => 1.0*(k % 2 * 2 - 1) /
 (2*k-1) / math.pow(n, 2*k-1) ).sum ; def p(l: Int) = 16*at(5, l) - 4*at(239,
 l); p(12)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset

, check numerically the Euler product
\begin_inset Index idx
status open

\begin_layout Plain Layout
Euler product
\end_layout

\end_inset

 formula
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Proof_of_the_Euler_product_formula_for_the_Riemann_zeta_function"
target "https://en.wikipedia.org/wiki/Proof_of_the_Euler_product_formula_for_the_Riemann_zeta_function"
literal "false"

\end_inset


\end_layout

\end_inset

 for the Riemann zeta function
\begin_inset Index idx
status open

\begin_layout Plain Layout
Riemann zeta function
\end_layout

\end_inset

 
\begin_inset Formula $\zeta(4)$
\end_inset

; it is known
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://tinyurl.com/yxey4tsd"
target "https://ocw.mit.edu/courses/mathematics/18-104-seminar-in-analysis-applications-to-number-theory-fall-2006/projects/chan.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 that 
\begin_inset Formula $\zeta(4)=\frac{\pi^{4}}{90}$
\end_inset

:
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Code: def is_prime(n: Int) = (2 to n-1).takeWhile(k => k*k <= n).forall(k
 => n % k != 0); def ep(n: Int): Double = (2 to n).filter(is_prime).map(k
 => 1.0 / (1.0 - 1.0 / k/k/k/k)).product; ep(100); pi*pi*pi*pi/90;
\end_layout

\end_inset


\begin_inset Formula 
\[
\prod_{k\geq2;~k\text{ is prime}}\frac{1}{1-p^{-4}}=\frac{\pi^{4}}{90}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsection
Transformation
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_20
\end_layout

\end_inset


\family default
 of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[Int]] => List[List[Int]]
\end_layout

\end_inset


\family default
 that adds 
\begin_inset Formula $20$
\end_inset

 to every element of every inner list.
 A sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add_20( List( List(1), List(2, 3) ) )
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(21), List(22, 23))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
An integer 
\begin_inset Formula $n$
\end_inset

 is called a 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $3$
\end_inset

-factor
\begin_inset Quotes erd
\end_inset

 if it is divisible by only three different integers 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $2\leq j<n$
\end_inset

.
 Compute the set of all 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $3$
\end_inset

-factor
\begin_inset Quotes erd
\end_inset

 integers 
\begin_inset Formula $n$
\end_inset

 among 
\begin_inset Formula $n\in[1,...,1000]$
\end_inset

 .
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Boolean
\end_layout

\end_inset

, an integer 
\begin_inset Formula $n$
\end_inset

 is called a 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $3$
\end_inset

-
\begin_inset Formula $f$
\end_inset


\begin_inset Quotes erd
\end_inset

 if there are only three different integers 
\begin_inset Formula $j\in[1,...,n]$
\end_inset

 such that 
\begin_inset Formula $f(j)$
\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 Define a function that takes 
\begin_inset Formula $f$
\end_inset

 as an argument and returns a sequence of all 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $3$
\end_inset

-
\begin_inset Formula $f$
\end_inset


\begin_inset Quotes erd
\end_inset

 integers among 
\begin_inset Formula $n\in[1,...,1000]$
\end_inset

.
 What is the type of that function? Implement Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using that function.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

see100
\end_layout

\end_inset

 of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[Int]] => List[List[Int]]
\end_layout

\end_inset


\family default
 that selects only those inner lists whose largest value is at least 
\begin_inset Formula $100$
\end_inset

.
 Test with:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> see100( List( List(0, 1, 100), List(60, 80), List(1000) ) )
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(0, 1, 100), List(1000))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Double] => List[Double]
\end_layout

\end_inset


\family default
 that 
\begin_inset Quotes eld
\end_inset

normalizes
\begin_inset Quotes erd
\end_inset

 the list: finds the element having the largest absolute value and, if that
 value is nonzero, divides all elements by that factor and returns a new
 list; otherwise returns the original list.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Functional programming as a paradigm
\end_layout

\begin_layout Standard
Functional programming
\begin_inset Index idx
status open

\begin_layout Plain Layout
functional programming
\end_layout

\end_inset

 (FP) is a 
\series bold
paradigm
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
paradigm
\end_layout

\end_inset

 of programming, – that is, an approach that guides programmers to write
 code in specific ways, for a wide range of programming tasks.
\end_layout

\begin_layout Standard
The main principle of FP is to write code 
\emph on
as a mathematical expression or formula
\emph default
.
 This approach allows programmers to derive code through logical reasoning
 rather than through guessing, – similarly to how books on mathematics reason
 about mathematical formulas and derive results systematically, without
 guessing or 
\begin_inset Quotes eld
\end_inset

debugging.
\begin_inset Quotes erd
\end_inset

 Similarly to mathematicians and scientists who reason about formulas, functiona
l programmers can 
\emph on
reason about code
\emph default
 systematically and logically, based on rigorous principles.
 This is possible only because code is written as a mathematical formula.
\end_layout

\begin_layout Standard
Mathematical intuition is backed by the vast experience accumulated while
 working with data over millennia of human history.
 It took centuries to invent flexible and powerful notation such as 
\begin_inset Formula $\sum_{k\in S}p(k)$
\end_inset

 and to develop the corresponding rules of calculation.
 Functional programmers are fortunate to have these reasoning tools at their
 disposal.
\end_layout

\begin_layout Standard
As we have seen, the Scala code for certain computational tasks corresponds
 quite closely to mathematical formulas.
 (Scala conventions and syntax, of course, require programmers to spell
 out certain things that are omitted in the mathematical notation.) Just
 as in mathematics, large code expressions may be split into smaller expressions
 when needed.
 Expressions can be easily reused, flexibly composed together, and written
 independently from each other.
 The FP community has developed a toolkit of functions (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset


\family default
, etc.) that proved to be especially useful in real-life programming, although
 many of them are not standard in mathematical literature.
\end_layout

\begin_layout Standard
Mastering FP involves practicing to reason about programs as formulas, building
 up the specific kind of applied mathematical intuition, familiarizing oneself
 with concepts adapted to a programmer's needs, and learning how to translate
 the mathematics into code in various cases.
 The FP community has discovered a number of specific design patterns founded
 on mathematical principles but driven by practical necessities of programming
 (rather than by the needs of academic mathematics).
 This book explains the required mathematical design patterns in detail,
 developing them through intuition and examples of Scala code.
\end_layout

\begin_layout Subsection
Functional programming languages
\end_layout

\begin_layout Standard
It is possible to apply the FP paradigm while writing code in any programming
 language.
 However, some languages lack certain features that make FP techniques much
 easier to use in practice.
 For example, in a language such as Python or Ruby, one can productively
 use only a limited number of FP idioms, such as the map/reduce operations.
 More advanced FP constructions are impractical in these languages because
 the required code becomes too hard to read and to write without errors,
 which negates the advantages of rigorous reasoning about functional programs.
\end_layout

\begin_layout Standard
Some programming languages, such as Haskell and OCaml, were designed specificall
y for advanced use in the FP paradigm.
 Other languages, such as ML, F#, Scala, Swift, Elm, and PureScript, have
 different design goals but still support enough FP features to be considered
 FP languages.
 This book uses Scala, but the same constructions may be implemented in
 other FP languages in a similar way.
 At the level of detail needed in this book, the differences between languages
 such as ML, OCaml, Haskell, F#, Scala, Swift, Elm, or PureScript do not
 play a significant role.
\end_layout

\begin_layout Subsection
The mathematical meaning of 
\begin_inset Quotes eld
\end_inset

variables
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The usage of variables in functional programming is similar to how mathematical
 literature uses variables.
 In mathematics, 
\series bold
variables
\begin_inset Index idx
status open

\begin_layout Plain Layout
variable
\end_layout

\end_inset


\series default
 are used first of all as 
\emph on
arguments
\emph default
 of functions; e.g.
 the formula 
\begin_inset Formula 
\[
f(x)=x^{2}+x
\]

\end_inset

contains the variable 
\begin_inset Formula $x$
\end_inset

 and defines a function 
\begin_inset Formula $f$
\end_inset

 that takes 
\begin_inset Formula $x$
\end_inset

 as its argument (to be definite, let us assume that 
\begin_inset Formula $x$
\end_inset

 is an integer) and computes the value 
\begin_inset Formula $x^{2}+x$
\end_inset

.
 The body of the function is the expression 
\begin_inset Formula $x^{2}+x$
\end_inset

.
 
\end_layout

\begin_layout Standard
Mathematics has the convention that a variable, such as 
\begin_inset Formula $x$
\end_inset

, does not change its value within a formula.
 Indeed, there is no mathematical notation even to talk about 
\begin_inset Quotes eld
\end_inset

changing
\begin_inset Quotes erd
\end_inset

 the value of 
\begin_inset Formula $x$
\end_inset

 
\emph on
inside
\emph default
 the formula 
\begin_inset Formula $x^{2}+x$
\end_inset

.
 It would be quite confusing if a mathematics textbook said 
\begin_inset Quotes eld
\end_inset

before adding the last 
\begin_inset Formula $x$
\end_inset

 in the formula 
\begin_inset Formula $x^{2}+x$
\end_inset

, we change that 
\begin_inset Formula $x$
\end_inset

 by adding 
\begin_inset Formula $4$
\end_inset

 to it
\begin_inset Quotes erd
\end_inset

.
 If the 
\begin_inset Quotes eld
\end_inset

last 
\begin_inset Formula $x$
\end_inset


\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Formula $x^{2}+x$
\end_inset

 needs to have a 
\begin_inset Formula $4$
\end_inset

 added to it, a mathematics textbook will just write the formula 
\begin_inset Formula $x^{2}+x+4$
\end_inset

.
\end_layout

\begin_layout Standard
Arguments of nameless functions are also immutable.
 Consider, for example,
\begin_inset Formula 
\[
f(n)=\sum_{k=0}^{n}(k^{2}+k)\quad.
\]

\end_inset

Here, 
\begin_inset Formula $n$
\end_inset

 is the argument of the function 
\begin_inset Formula $f$
\end_inset

, while 
\begin_inset Formula $k$
\end_inset

 is the argument of the nameless function 
\begin_inset Formula $k\mapsto k^{2}+k$
\end_inset

.
 Neither 
\begin_inset Formula $n$
\end_inset

 nor 
\begin_inset Formula $k$
\end_inset

 can be 
\begin_inset Quotes eld
\end_inset

modified
\begin_inset Quotes erd
\end_inset

 in any sense within the expressions where they are used.
 The symbols 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 stand for some integer values, and these values are immutable.
 Indeed, it is meaningless to say that we 
\begin_inset Quotes eld
\end_inset

modified the integer 
\begin_inset Formula $4$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 In the same way, we cannot modify 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
So, a variable in mathematics remains constant 
\emph on
within
\emph default
 
\emph on
the expression
\emph default
 where it is defined; in that expression, a variable is essentially a 
\begin_inset Quotes eld
\end_inset

named constant
\begin_inset Quotes erd
\end_inset

.
 Of course, a function 
\begin_inset Formula $f$
\end_inset

 can be applied to different values 
\begin_inset Formula $x$
\end_inset

, to compute a different result 
\begin_inset Formula $f(x)$
\end_inset

 each time.
 However, a given value of 
\begin_inset Formula $x$
\end_inset

 will remain unmodified within the body of the function 
\begin_inset Formula $f$
\end_inset

 while 
\begin_inset Formula $f(x)$
\end_inset

 is being computed.
\end_layout

\begin_layout Standard
Functional programming adopts this convention from mathematics: variables
 are immutable named constants.
 (Scala also has 
\emph on
mutable
\emph default
 variables, but we will not consider them in this book.)
\end_layout

\begin_layout Standard
In Scala, function arguments are immutable within the function body:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int) = x * x + x // Cannot modify `x` here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
type
\emph default
 of each mathematical variable (such as integer, vector, etc.) is also fixed.
 Each variable is a value from a specific set (e.g.
\begin_inset space ~
\end_inset

the set of all integers, the set of all vectors, etc.).
 Mathematical formulas such as 
\begin_inset Formula $x^{2}+x$
\end_inset

 do not express any 
\begin_inset Quotes eld
\end_inset

checking
\begin_inset Quotes erd
\end_inset

 that 
\begin_inset Formula $x$
\end_inset

 is indeed an integer and not, say, a vector, in the middle of evaluating
 
\begin_inset Formula $x^{2}+x$
\end_inset

.
 The types of all variables are checked in advance.
\end_layout

\begin_layout Standard
Functional programming adopts the same view: Each argument of each function
 must have a 
\series bold
type
\begin_inset Index idx
status open

\begin_layout Plain Layout
type
\end_layout

\end_inset


\series default
, which represents 
\emph on
the set of possible allowed values
\emph default
 for that function argument.
 The programming language's compiler will automatically check the types
 of all arguments 
\emph on
before
\emph default
 the program runs.
 A program that calls functions on arguments of incorrect types will not
 compile.
\end_layout

\begin_layout Standard
The second usage of 
\series bold
variables
\begin_inset Index idx
status open

\begin_layout Plain Layout
variable
\end_layout

\end_inset


\series default
 in mathematics is to denote expressions that will be reused.
 For example, one writes: let 
\begin_inset Formula $z=\frac{x-y}{x+y}$
\end_inset

 and now compute 
\begin_inset Formula $\cos z+\cos2z+\cos3z$
\end_inset

.
 Again, the variable 
\begin_inset Formula $z$
\end_inset

 remains immutable, and its type remains fixed.
\end_layout

\begin_layout Standard
In Scala, this construction (defining an expression to be reused later)
 is written with the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax.
 Each variable defined using 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a named constant, and its type and value are fixed at the time of definition.
 Type annotations for 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

s are optional in Scala: for instance we could write 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: Int = 123
\end_layout

\end_inset

or we could omit the type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

:Int
\end_layout

\end_inset

 and write more concisely
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x = 123
\end_layout

\end_inset

because it is clear that this 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\family default
 is an integer.
 However, it is often helpful to write out types.
 If we do so, the compiler will check that the types match correctly and
 give an error message whenever wrong types are used.
 For example, a type error is detected when using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 instead of an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: Int = "123"
\end_layout

\begin_layout Plain Layout

<console>:11: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : String("123")
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

        val x: Int = "123"
\end_layout

\begin_layout Plain Layout

                     ^
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Iteration without loops
\end_layout

\begin_layout Standard
Another distinctive feature of the FP paradigm is handling of iteration
 without writing loops.
\end_layout

\begin_layout Standard
Iterative computations are ubiquitous in mathematics.
 As an example, consider the formula for the standard deviation estimated
 from a sample,
\begin_inset Formula 
\[
\sigma(s)=\sqrt{\frac{1}{n-1}\sum_{i=1}^{n}\sum_{j=1}^{n}s_{i}s_{j}-\frac{1}{n\left(n-1\right)}\left(\sum_{i=1}^{n}s_{i}\right)^{2}}\quad.
\]

\end_inset

These expressions are computed by iterating over values of 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

.
 And yet, no mathematics textbook uses 
\begin_inset Quotes eld
\end_inset

loops
\begin_inset Quotes erd
\end_inset

 or says 
\begin_inset Quotes eld
\end_inset

now repeat this formula ten times
\begin_inset Quotes erd
\end_inset

.
 Indeed, it would be pointless to evaluate a formula such as 
\begin_inset Formula $x^{2}+x$
\end_inset

 ten times in a loop, or to 
\begin_inset Quotes eld
\end_inset

repeat
\begin_inset Quotes erd
\end_inset

 an equation such as
\begin_inset Formula 
\[
\left(x-1\right)(x^{2}+x+1)=x^{3}-1\quad.
\]

\end_inset

Instead of loops, mathematicians write 
\emph on
expressions
\emph default
 such as 
\begin_inset Formula $\sum_{i=1}^{n}s_{i}$
\end_inset

, where symbols such as 
\begin_inset Formula $\sum_{i=1}^{n}$
\end_inset

 or 
\begin_inset Formula $\prod_{i=1}^{n}$
\end_inset

 denote iterative computations.
 Such computations are defined using mathematical induction
\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction
\end_layout

\end_inset

.
 The functional programming paradigm has developed rich tools for translating
 mathematical induction into code.
 In this chapter, we have seen methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, which implement certain kinds of iterative computations.
 These and other operations can be combined in very flexible ways, which
 allows programmers to write iterative code without loops.
\end_layout

\begin_layout Standard
The programmer can avoid writing loops because the iteration is delegated
 to the library functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sum
\end_layout

\end_inset

, and so on.
 It is the job of the library and the compiler to translate these functions
 into machine code.
 The machine code most likely 
\emph on
will
\emph default
 contain loops; but the functional programmer does not need to see that
 code or to reason about it.
\end_layout

\begin_layout Subsection
Nameless functions in mathematical notation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Nameless-functions-in-mathematical-notation"

\end_inset


\end_layout

\begin_layout Standard
Functions in mathematics are mappings from one set to another.
 A function does not necessarily 
\emph on
need
\emph default
 a name; the mapping just needs to be defined.
 However, nameless functions have not been widely used in the conventional
 mathematical notation.
 It turns out that nameless functions are quite important in functional
 programming because, in particular, they allow programmers to write code
 more concisely and use a straightforward, consistent syntax.
\end_layout

\begin_layout Standard
Nameless functions contain bound variables that are invisible outside the
 function's scope.
 This property is directly reflected by the prevailing mathematical conventions.
 Compare the formulas
\begin_inset Formula 
\[
f\left(x\right)=\int_{0}^{x}\frac{dx}{1+x}\quad;\quad f\left(x\right)=\int_{0}^{x}\frac{dz}{1+z}\quad.
\]

\end_inset

The mathematical convention is that one may rename the integration variable
 at will, and so these formulas define the same function 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
In programming, the only situation when a variable 
\begin_inset Quotes eld
\end_inset

may be renamed at will
\begin_inset Quotes erd
\end_inset

 is when the variable represents an argument of a function.
 It follows that the notations 
\begin_inset Formula $\frac{dx}{1+x}$
\end_inset

 and 
\begin_inset Formula $\frac{dz}{1+z}$
\end_inset

 correspond to a nameless function whose argument was renamed from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $z$
\end_inset

.
 In FP notation, this nameless function would be denoted as 
\begin_inset Formula $z\Rightarrow\frac{1}{1+z}$
\end_inset

, and the integral rewritten as code such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

integration(0, x, { z => 1.0 / (1 + z) } )
\end_layout

\end_inset

Now consider the traditional mathematical notations for summation, e.g.
\begin_inset Formula 
\[
\sum_{k=0}^{x}\frac{1}{1+k}\quad.
\]

\end_inset

In sums, the bound variable 
\begin_inset Formula $k$
\end_inset

 is introduced under the 
\begin_inset Formula $\sum$
\end_inset

 symbol; but in integrals, the bound variable follows the special symbol
 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $d$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 This notational inconsistency could be removed if we were to use nameless
 functions explicitly, for example:
\begin_inset Formula 
\begin{align*}
\sum_{0}^{x} & \left(k\mapsto\frac{1}{1+k}\right)\text{ instead of }\sum_{k=0}^{x}\frac{1}{1+k}\quad,\\
\int_{0}^{x} & \left(z\mapsto\frac{1}{1+z}\right)\text{ instead of }\int_{0}^{x}\frac{dz}{1+z}\quad.
\end{align*}

\end_inset

In this notation, the new summation symbol 
\begin_inset Formula $\sum_{0}^{x}$
\end_inset

 does not mention the name “
\begin_inset Formula $k$
\end_inset

” but takes a function as an argument.
 Similarly, the new integration symbol 
\begin_inset Formula $\int_{0}^{x}$
\end_inset

 does not mention 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $z$
\end_inset


\begin_inset Quotes erd
\end_inset

 and does not use the special symbol 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $d$
\end_inset


\begin_inset Quotes erd
\end_inset

 but now takes a function as an argument.
 Written in this way, the operations of summation and integration become
 
\emph on
functions
\emph default
 that take a function as argument.
 The above summation may be written in a consistent and straightforward
 manner as a Scala function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

summation(0, x, { y => 1.0 / (1 + y) } )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We could implement 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation(a,b,g)
\end_layout

\end_inset


\family default
 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def summation(a: Int, b: Int, g: Int => Double) = (a to b).map(g).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> summation(1, 10, x => math.sqrt(x))
\end_layout

\begin_layout Plain Layout

res0: Double = 22.4682781862041
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Numerical integration requires longer code, since the formulas are more
 complicated.
 For instance, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Simpson's rule
\end_layout

\end_inset

Simpson's rule
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Simpson%27s_rule"
literal "false"

\end_inset


\end_layout

\end_inset

 can be written as
\begin_inset Formula 
\begin{align*}
\text{integration}\left(a,b,g\right) & =\frac{\delta}{3}\left(g(a)+g(b)+4s_{1}+2s_{2}\right)\quad,\\
\text{where }~~~n & =2\left\lfloor \frac{b-a}{\varepsilon}\right\rfloor ,\quad\delta_{x}=\frac{b-a}{n}\quad,\\
s_{1}=\sum_{i=1,3,...,n-1}g(a+i\delta_{x}) & \quad,\quad\quad s_{2}=\sum_{i=2,4,...,n-2}g(a+i\delta_{x})\quad.
\end{align*}

\end_inset

 A straightforward translation of this formula into Scala is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def integration(a: Double, b: Double, g: Double => Double, eps: Double)
 = {
\end_layout

\begin_layout Plain Layout

  // First, we define some helper values and functions that replace
\end_layout

\begin_layout Plain Layout

  // the definitions 
\begin_inset Quotes eld
\end_inset

where n = ...
\begin_inset Quotes erd
\end_inset

 in the mathematical formula.
\end_layout

\begin_layout Plain Layout

   val n: Int = 2*((b - a)/eps).toInt
\end_layout

\begin_layout Plain Layout

   val delta_x = (b - a) / n
\end_layout

\begin_layout Plain Layout

   val g_i = (i: Int) => g(a + i*delta_x)
\end_layout

\begin_layout Plain Layout

   val s1 = (1 to (n-1) by 2).map(g_i).sum
\end_layout

\begin_layout Plain Layout

   val s2 = (2 to (n-2) by 2).map(g_i).sum
\end_layout

\begin_layout Plain Layout

   // Now we write the expression for the final result.
\end_layout

\begin_layout Plain Layout

   delta_x / 3 * (g(a) + g(b) + 4*s1 + 2*s2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> integration(0, 5, x => x*x*x*x, eps = 0.01)     // Exact answer is
 625.
\end_layout

\begin_layout Plain Layout

res0: Double = 625.0000000004167
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> integration(0, 7, x => x*x*x*x*x*x, eps = 0.01) // Exact answer is
 117649.
\end_layout

\begin_layout Plain Layout

res1: Double = 117649.00000014296
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The entire code is one large 
\emph on
expression
\emph default
, with a few sub-expressions defined for convenience as a few helper values
 and helper functions.
 In other words, this code is written in the FP paradigm.
\end_layout

\begin_layout Subsection
Named and nameless expressions and their uses
\end_layout

\begin_layout Standard
It is a significant advantage if a programming language supports unnamed
 (or 
\begin_inset Quotes eld
\end_inset

nameless
\begin_inset Quotes erd
\end_inset

) expressions.
 To see this, consider a familiar situation where we take the absence of
 names for granted.
\end_layout

\begin_layout Standard
In most programming languages today, we can directly write arithmetical
 expressions such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x+123)*y/(2+x)
\end_layout

\end_inset


\family default
.
 Here, 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset


\family default
 are variables with names.
 Note, however, that the entire expression does not need to have a name.
 Parts of that expression (such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x+123
\end_layout

\end_inset


\family default
 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2+x
\end_layout

\end_inset

) also do not have separate names.
 It would be quite inconvenient if we 
\emph on
needed
\emph default
 to assign a name separately to each sub-expression.
 The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x+123)*y/(2+x)
\end_layout

\end_inset

 could then look like this:
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

r1 = 123
\end_layout

\begin_layout Plain Layout

r2 = x + r1
\end_layout

\begin_layout Plain Layout

r3 = r2 * y
\end_layout

\begin_layout Plain Layout

r4 = 2
\end_layout

\begin_layout Plain Layout

r5 = r4 + x
\end_layout

\begin_layout Plain Layout

r6 = r3 / r5
\end_layout

\begin_layout Plain Layout

return r6
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This style of programming resembles assembly languages
\begin_inset Index idx
status open

\begin_layout Plain Layout
assembly language
\end_layout

\end_inset

, where 
\emph on
every
\emph default
 sub-expression – that is, every step of every calculation, – must be named
 separately (and, in the assembly languages, assigned a memory address or
 a CPU register).
\end_layout

\begin_layout Standard
So, programmers become more productive when their programming language supports
 nameless expressions.
\end_layout

\begin_layout Standard
This is also common practice in mathematics; names are assigned when needed,
 but most expressions remain nameless.
\end_layout

\begin_layout Standard
It is similarly useful if data structures can be created without names.
 For instance, a 
\series bold
dictionary
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dictionary
\end_layout

\end_inset

 (also called a 
\begin_inset Quotes eld
\end_inset

hashmap
\begin_inset Index idx
status open

\begin_layout Plain Layout
hashmap
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) is created in Scala as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map("a" -> 1, "b" -> 2, "c" -> 3)
\end_layout

\end_inset

This code is a nameless expression whose value is a dictionary.
 In programming languages that do not have such a construction, programmers
 have to write repetitive code that creates an initially empty dictionary
 and then fills it step by step with values:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "38col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

// Scala code creating a dictionary:
\end_layout

\begin_layout Plain Layout

Map("a" -> 1, "b" -> 2, "c" -> 3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Shortest Java code for the same:
\end_layout

\begin_layout Plain Layout

new HashMap<String, Integer>() {{
\end_layout

\begin_layout Plain Layout

   put("a", 1);
\end_layout

\begin_layout Plain Layout

   put("b", 2);
\end_layout

\begin_layout Plain Layout

   put(
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 3);
\end_layout

\begin_layout Plain Layout

 }}; */
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 0baselineskip%
\end_inset


\end_layout

\end_inset


\begin_inset Wrap table
lines 0
placement o
overhang 0in
width "60col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset VSpace -700baselineskip%
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="24" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Language
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Year
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code for 
\series default

\begin_inset Formula $k\mapsto k+1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1936
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lambda k.~add~k~1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1940
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lambda k:int.~add~k~1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
LISP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1958
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(lambda (k) (+ k 1))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Standard ML
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1973
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fn (k:int) => k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Scheme
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1975
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(lambda (k) (+ k 1))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
OCaml
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1985
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fun k -> k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Haskell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1990
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
 k -> k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Oz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1991
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fun {$ K} K + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1993
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function(k) k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Python 1.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1994
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lambda k: k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
JavaScript
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1995
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function(k) { return k + 1; }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Mercury
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1995
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func(K) = K + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Ruby
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1995
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lambda { |k| k + 1 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Lua 3.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1998
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function(k) return k + 1 end
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Scala
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2003
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k:Int) => k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
F#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2005
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fun (k:int) -> k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
C# 3.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2007
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delegate(int k) { return k + 1; }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
C++ 11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2011
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[] (int k) { return k + 1; }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Go
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2012
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func(k int) { return k + 1 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Kotlin
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2012
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ k:Int -> k + 1 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Swift
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2014
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ (k:int) -> int in return k + 1 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Java 8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2014
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(int k) -> k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Rust
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2015
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

|k:i32| k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Nameless functions in programming languages.
\begin_inset CommandInset label
LatexCommand label
name "lambda-functions-table"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -200baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Nameless functions are useful for the same reason as nameless values of
 other types: they allow us to build larger programs from simpler parts
 in a uniform way.
\end_layout

\begin_layout Subsection
Nameless functions: historical perspective
\end_layout

\begin_layout Standard
Nameless functions were first used in 1936 in a theoretical programming
 language called 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\lambda$
\end_inset

-calculus
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 In that language,
\begin_inset Foot
status open

\begin_layout Plain Layout
Although called a 
\begin_inset Quotes eld
\end_inset

calculus,
\begin_inset Quotes erd
\end_inset

 it is in reality a (drastically simplified) programming language.
 It has nothing to do with 
\begin_inset Quotes eld
\end_inset

calculus
\begin_inset Quotes erd
\end_inset

 as known in mathematics, such as differential or integral calculus.
 Also, the letter 
\begin_inset Formula $\lambda$
\end_inset

 has no particular significance; it plays a purely syntactic role in the
 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 Practitioners of functional programming usually do not need to study any
 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 All practically relevant knowledge related to 
\begin_inset Formula $\lambda$
\end_inset

-calculus is explained in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Higher-order-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 of this book.
\end_layout

\end_inset

 all functions are nameless and have a single argument.
 The letter 
\begin_inset Formula $\lambda$
\end_inset

 is a syntax separator denoting function arguments in nameless functions.
 For example, the nameless function 
\begin_inset Formula $x\mapsto x+1$
\end_inset

 could be written as 
\begin_inset Formula $\lambda x.add~x~1$
\end_inset

 in 
\begin_inset Formula $\lambda$
\end_inset

-calculus, if it had a function 
\begin_inset Formula $add$
\end_inset

 for adding integers (which it does not).
\end_layout

\begin_layout Standard
In most programming languages that were in use until around 1990, all functions
 required names.
 But by 2015, most languages added support for nameless functions, because
 programming in the map/reduce style (which invites frequent use of nameless
 functions) turned out to be immensely productive.
 Table
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lambda-functions-table"

\end_inset

 shows the year when nameless functions were introduced in each language.
\end_layout

\begin_layout Standard
What this book calls a 
\begin_inset Quotes eld
\end_inset

nameless function
\begin_inset Quotes erd
\end_inset

 is also called anonymous function, function expression, function literal,
 closure, lambda function, lambda expression, or just a 
\begin_inset Quotes eld
\end_inset

lambda
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_body
\end_document
