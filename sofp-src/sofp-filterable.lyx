#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Computations in functor blocks.
 I.
 Filterable functors and contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "chap:Filterable-functors"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{{\color{teal}#1}}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\end_layout

\begin_layout Standard
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 studied the mathematical properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and derived the concept of 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

 as a general type constructor that permits a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method with useful properties.
 In this chapter, we will study the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 method in a similar way.
 We will start from practical examples and then derive the relevant mathematical
 properties.
 This will give us a precise definition of 
\begin_inset Quotes eld
\end_inset

filterable
\begin_inset Quotes erd
\end_inset

 type constructors — those that permit useful implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Practical uses of filtering
\begin_inset CommandInset label
LatexCommand label
name "sec:Practical-uses-of-filterable-functors"

\end_inset


\end_layout

\begin_layout Standard
The Scala standard library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 method on sequences, sets, and other data structures.
 An example of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is the following calculation:
\begin_inset Formula 
\[
\sum_{x\in\mathbb{Z};\,0\leq x\leq100;\,\cos x>0}\sqrt{\cos\left(x\right)}\approx38.71\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (0 to 100).map(x => math.cos(x)).filter(_ > 0).map(math.sqrt).sum
\end_layout

\begin_layout Plain Layout

res0: Double = 38.71218949848382
\end_layout

\end_inset

The role of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 in this computation is to select only the positive values of 
\begin_inset Formula $\cos\left(x\right)$
\end_inset

.
 It is safe to apply the square root function to positive values, so the
 code will work correctly.
\end_layout

\begin_layout Standard
The code above is a chain of methods, but the same code can be written using
 Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 syntax, which is called a 
\series bold
functor block
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
functor block
\end_layout

\end_inset

 in this book.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation is represented by an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 keyword embedded in a functor block.
 Compare each line of the functor block code with the corresponding line
 of the code written via method chains:
\end_layout

\begin_layout Standard
\noindent

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47.5col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(for { x <- 0 to 100
\end_layout

\begin_layout Plain Layout

    y = math.cos(x)
\end_layout

\begin_layout Plain Layout

    if y > 0
\end_layout

\begin_layout Plain Layout

  } yield math.sqrt(y)
\end_layout

\begin_layout Plain Layout

).sum
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47.5col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(0 to 100).map { x =>
\end_layout

\begin_layout Plain Layout

   math.cos(x) }.filter { y => 
\end_layout

\begin_layout Plain Layout

   y > 0 }.map { y =>
\end_layout

\begin_layout Plain Layout

     math.sqrt(y)
\end_layout

\begin_layout Plain Layout

  }.sum
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\begin_layout Standard
Functor blocks require the first line to have a left arrow placed before
 a 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor block!source
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, i.e., a value of a functor type (e.g., a sequence or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

).
 Each line of a functor block can be viewed as a computation that creates
 an intermediate value of the same 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Quotes erd
\end_inset

 functor type.
 The result value of the entire functor block is again a value of the same
 functor type.
 So, a functor block manipulates data wrapped by a functor without changing
 the type of the wrapper.
\end_layout

\begin_layout Standard
The name 
\begin_inset Quotes eld
\end_inset

functor block
\begin_inset Quotes erd
\end_inset

 is chosen because the code is a single expression (a 
\begin_inset Quotes eld
\end_inset

block
\begin_inset Quotes erd
\end_inset

) whose type is required to be a functor.
 The functor's type is selected by the source's type in the first line.
\end_layout

\begin_layout Standard
We have seen in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the functor block syntax becomes available for a type constructor
 that has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method (i.e., for a functor).
 To support the embedded 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 keyword, the type constructor must support a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

withFilter
\end_layout

\end_inset

 with the same type signature as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 method.
 The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

withFilter
\end_layout

\end_inset

 methods for a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class F[A] {  // F[A] is some type constructor that has .map and .withFilter
 methods.
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): F[B] = ...
\end_layout

\begin_layout Plain Layout

  def withFilter(p: A => Boolean): F[A] = ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A type constructor
\begin_inset Index idx
status open

\begin_layout Plain Layout
filterable!type constructor
\end_layout

\end_inset

 that supports the filtering operation is called 
\series bold
filterable
\series default
.
 
\end_layout

\begin_layout Standard
The main focus of this chapter is to explore filterable functors in detail.
 Programmers would intuitively expect the filtering operation to have certain
 properties.
 We will now examine the expected properties and translate them into mathematica
l laws for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

withFilter
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Examples and intuitions for the filtering operation
\end_layout

\begin_layout Standard
Examples of often used filterable functors defined in the Scala library
 are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(64, 128).filter(_ > 100).map(_ * 2)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(256)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Some(128).filter(_ > 100).map(_ * 2)
\end_layout

\begin_layout Plain Layout

res1: Option[Int] = Some(256)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Some(64).filter(_ > 100).map(_ * 2)
\end_layout

\begin_layout Plain Layout

res2: Option[Int] = None
\end_layout

\end_inset

In an intuitive view, a functor wraps one or more data values, and the filtering
 operation may decrease the number of values wrapped.
 e.g., the length of the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(64, 128)
\end_layout

\end_inset

 is decreased from 
\begin_inset Formula $2$
\end_inset

 to 
\begin_inset Formula $1$
\end_inset

 after filtering with the condition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_ > 100
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 functor can wrap at most one value, so filtering with a predicate returning
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 will return an empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 value (i.e., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

).
 In all cases, the resulting collection will not contain values that fail
 the filtering predicate.
\end_layout

\begin_layout Standard
Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[T]
\end_layout

\end_inset

 is written in the type notation as a disjunctive type 
\begin_inset Formula $\bbnum 1+T$
\end_inset

, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[T]
\end_layout

\end_inset

 can be viewed as an 
\begin_inset Quotes eld
\end_inset

infinite disjunction
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{List}^{T}=1+T+T\times T+T\times T\times T+...\label{eq:list-infinite-disjunction}
\end{equation}

\end_inset

Disjunctive type constructors are able to hold a different number of values
 of type 
\begin_inset Formula $T$
\end_inset

 in different parts of the disjunction (e.g., 
\begin_inset Formula $T\times T$
\end_inset

 for 
\begin_inset Formula $2$
\end_inset

 values and 
\begin_inset Formula $T\times T\times T$
\end_inset

 for 
\begin_inset Formula $3$
\end_inset

 values of 
\begin_inset Formula $T$
\end_inset

).
 
\end_layout

\begin_layout Standard
So, we expect that a filterable functor should contain a disjunctive type
 supporting a different number of values of 
\begin_inset Formula $T$
\end_inset

, including 
\emph on
zero
\emph default
 values.
 When the filtering operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter(p)
\end_layout

\end_inset

 is applied, some values of type 
\begin_inset Formula $T$
\end_inset

 will fail the predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 and will be removed from the collection.
 This example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(64, 128).filter(_ > 100)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(128)
\end_layout

\end_inset

corresponds to mapping a disjunctive part of type 
\begin_inset Formula $T\times T$
\end_inset

 to a part of type 
\begin_inset Formula $T$
\end_inset

 within 
\begin_inset Formula $\text{List}^{T}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:list-infinite-disjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Consider now a custom data type that implements a given application's business
 requirements:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-filtering-orders-tue-fri"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filtering-orders-tue-fri"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
On a given week, an order (data type 
\begin_inset Formula $A$
\end_inset

) can be placed on Tuesday and/or on Friday.
 An order is approved under certain conditions given by a predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: A => Boolean
\end_layout

\end_inset

.
 Can we represent the order approval by a filtering operation on a suitable
 data type?
\end_layout

\begin_layout Standard
The data type describing a week's orders must describe a possible order
 on Tuesday (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

) and a possible order on Friday (again 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

).
 So, we can represent a week's orders as a product 
\begin_inset Formula $F^{A}\triangleq\left(\bbnum 1+A\right)\times\left(\bbnum 1+A\right)$
\end_inset

 and implement it as a case class having methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

withFilter
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Orders[A](tue: Option[A], fri: Option[A]) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): Orders[B] = Orders(tue.map(f), fri.map(f))      
            // Functor.
\end_layout

\begin_layout Plain Layout

  def withFilter(p: A => Boolean): Orders[A] = Orders(tue.filter(p), fri.filter(p)
)  // Filterable.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Orders(Some(500), Some(2000)).withFilter(_ < 1000) // Approved if
 the amount is below $1000.
\end_layout

\begin_layout Plain Layout

res0: Orders[Int] = Orders(Some(500),None)
\end_layout

\end_inset

This code applies filtering independently to both parts of the product.
 With this definition, we will be able to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Orders
\end_layout

\end_inset

 as a 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Quotes erd
\end_inset

 of data in functor blocks:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for {
\end_layout

\begin_layout Plain Layout

  x <- Orders(Some(500), Some(2000))  // 
\begin_inset Quotes eld
\end_inset

Source
\begin_inset Quotes erd
\end_inset

 of type Orders[Int].
\end_layout

\begin_layout Plain Layout

  y = x - 200     // Apply discount of $200 to each order.
\end_layout

\begin_layout Plain Layout

  if y < 500      // Orders are approved if the amount is below $500 after
 discount.
\end_layout

\begin_layout Plain Layout

} yield y * 1.10  // Add 10% tax.
 Result is of type Orders[Double].
\end_layout

\begin_layout Plain Layout

res1: Orders[Double] = Orders(Some(330.0), None)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Suppose we are considering an additional business rule, such as:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Both orders must be approved, or else no orders can be placed that week.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Both orders can be placed that week if at least one of them is approved.
\end_layout

\begin_layout Standard
We could modify the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

withFilter
\end_layout

\end_inset

 to implement one of the rules 
\series bold
(a)
\series default
 or 
\series bold
(b)
\series default
.
 Will the resulting function still be a 
\begin_inset Quotes eld
\end_inset

filtering
\begin_inset Quotes erd
\end_inset

 operation?
\end_layout

\begin_layout Standard
We cannot decide this without knowing the mathematical laws that a filtering
 operation must satisfy.
 Let us now consider what intuitive expectations we have for the concept
 of filtering.
\end_layout

\begin_layout Subsection
The laws of filtering: Motivation and derivation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Motivation-for-and-derivation-of-laws-of-filtering"

\end_inset


\end_layout

\begin_layout Standard
Computations in a functor block will 
\begin_inset Quotes eld
\end_inset

make sense
\begin_inset Quotes erd
\end_inset

 if we easily understand what the program does when we look at the code.
 Consider this schematic example of a functor block program that uses a
 filterable functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

:
\family roman
\size footnotesize
\color darkgray

\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

val result = for {  // Some computations in the context of the `List` functor.
\end_layout

\begin_layout Plain Layout

  x <- List(...) // For each x in the given list...
\end_layout

\begin_layout Plain Layout

  y = f(x)       // ...
 compute y
\end_layout

\begin_layout Plain Layout

  if p1(y)       // ...
 impose condition p1: discard all y for which p1(y) == false
\end_layout

\begin_layout Plain Layout

  if p2(y)       // ...
 same for condition p2 
\end_layout

\begin_layout Plain Layout

  z = g(x, y)    // ...
 compute z
\end_layout

\begin_layout Plain Layout

  if q(x, y, z)  // ...
 impose another condition
\end_layout

\begin_layout Plain Layout

} yield          // For all x in the given list, such that all the conditions
 hold,
\end_layout

\begin_layout Plain Layout

  k(x, y, z)     // compute the values k, put them into a list, and return
 as the list `result`.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are several properties that one intuitively expects such programs
 to have.
 One property is that computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = f(x)
\end_layout

\end_inset

 in line 
\begin_inset Formula $3$
\end_inset

 and then checking a condition for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, such as 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if p1(y)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 in line 
\begin_inset Formula $4$
\end_inset

, should be the same as checking the condition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1(f(x))
\end_layout

\end_inset

 and then computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = f(x)
\end_layout

\end_inset

: since the code says that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = f(x)
\end_layout

\end_inset

, we expect the conditions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1(y)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1(f(x))
\end_layout

\end_inset

 to be equivalent.
\end_layout

\begin_layout Standard
Translating this equivalence into code, we obtain the requirement that the
 following two expressions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result2
\end_layout

\end_inset

) should be equal to each other:
\end_layout

\begin_layout Standard
\begin_inset VSpace 30baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47.5col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result1 = for {
\end_layout

\begin_layout Plain Layout

  x <- xs
\end_layout

\begin_layout Plain Layout

  y = f(x)
\end_layout

\begin_layout Plain Layout

  if p(y)
\end_layout

\begin_layout Plain Layout

} yield y
\end_layout

\begin_layout Plain Layout

 // Rewritten via method chains:
\end_layout

\begin_layout Plain Layout

val result1 = xs.map(f).filter(p)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47.5col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result2 = for {
\end_layout

\begin_layout Plain Layout

  x <- xs
\end_layout

\begin_layout Plain Layout

  if p(f(x))
\end_layout

\begin_layout Plain Layout

  y = f(x)
\end_layout

\begin_layout Plain Layout

} yield y
\end_layout

\begin_layout Plain Layout

 // Rewritten via method chains:
\end_layout

\begin_layout Plain Layout

val result2 = xs.filter(x => p(f(x))).map(f)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0baselineskip%
\end_inset


\end_layout

\begin_layout Standard
Lines 4–5 of the listing above show two filtering operations, 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if p1(y)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if p2(y)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, applied one after another.
 We expect that the first filtering operation keeps only values that satisfy
 the condition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1
\end_layout

\end_inset

, and the second filtering operation is applied to the results of the first
 one, additionally imposing the condition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2
\end_layout

\end_inset

.
 So, we expect that applying these two filtering operations is equivalent
 to filtering by the condition 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if p1(y) && p2(y)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
We can translate this expectation into equality of the following two code
 expressions:
\end_layout

\begin_layout Standard
\begin_inset VSpace 30baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47.5col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result1 = for {
\end_layout

\begin_layout Plain Layout

  x <- xs
\end_layout

\begin_layout Plain Layout

  if p1(x)
\end_layout

\begin_layout Plain Layout

  if p2(x)
\end_layout

\begin_layout Plain Layout

} yield x
\end_layout

\begin_layout Plain Layout

 // Rewritten via method chains:
\end_layout

\begin_layout Plain Layout

val result1 = xs.filter(p1).filter(p2)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47.5col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result2 = for {
\end_layout

\begin_layout Plain Layout

  x <- xs
\end_layout

\begin_layout Plain Layout

  if (p1(x) && p2(x))
\end_layout

\begin_layout Plain Layout

 } yield x
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 // Rewritten via method chains:
\end_layout

\begin_layout Plain Layout

val result2 = xs.filter(x => p1(x) && p2(x))
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0baselineskip%
\end_inset


\end_layout

\begin_layout Standard
When a filter predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(x)
\end_layout

\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, the filtering call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.filter(p)
\end_layout

\end_inset

 will never discard any values.
 So, we expect the result to remain the same if we 
\emph on
delete
\emph default
 the line 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if true
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 from a functor block program.
 The corresponding code equivalence can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.filter(_ => true) == xs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, suppose a predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(x)
\end_layout

\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 for certain values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 Then we expect those values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 to be excluded from any computations performed 
\emph on
after
\emph default
 the line 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if p(x)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 In particular, we should be able to use a partial function safely as long
 as that function is defined for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 such that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(x) == true
\end_layout

\end_inset

.
 To express this in code, first define a general 
\begin_inset Quotes eld
\end_inset

factory
\begin_inset Quotes erd
\end_inset

 for partial functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def if_p[A, B](p: A => Boolean)(f: A => B): A => B = x => p(x) match { case
 true => f(x) }
\end_layout

\end_inset

This 
\begin_inset Quotes eld
\end_inset

factory
\begin_inset Quotes erd
\end_inset

 takes a predicate 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

 and a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and returns a partial function with the same signature, 
\begin_inset Formula $A\rightarrow B$
\end_inset

, but defined only for values 
\begin_inset Formula $x$
\end_inset

 for which 
\begin_inset Formula $p(x)=\text{true}$
\end_inset

.
 Let us denote that function for brevity by 
\begin_inset Formula $f_{|p}$
\end_inset

.
 Since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type is equivalent to a disjunction of two 
\begin_inset Quotes eld
\end_inset

named unit types
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Formula $\bbnum 2\cong\bbnum 1+\bbnum 1$
\end_inset

 (meaning 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 + 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

), we can write the code notation for the function 
\begin_inset Formula $f_{|p}$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
(f^{:A\rightarrow B})_{|p}\triangleq x^{:A}\rightarrow p(x)\triangleright\,\begin{array}{|c||c|}
 & B\\
\hline \bbnum 1~(\text{false}) & \bbnum 0\\
\bbnum 1~(\text{true}) & 1\rightarrow f(x)
\end{array}\quad.\label{eq:def-partial-f}
\end{equation}

\end_inset

The top row contains the void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type!in matrix notation
\end_layout

\end_inset

 
\begin_inset Formula $\bbnum 0$
\end_inset

, indicating that the partial function 
\begin_inset Formula $f_{|p}$
\end_inset

 will crash if applied to a value 
\begin_inset Formula $x$
\end_inset

 for which 
\begin_inset Formula $p(x)=\text{false}$
\end_inset

.
\end_layout

\begin_layout Standard
Using the partial function 
\begin_inset Formula $f_{|p}$
\end_inset

, we write the last property of the filtering operation as the equality
 of the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result2
\end_layout

\end_inset

 defined like this:
\end_layout

\begin_layout Standard
\begin_inset VSpace 30baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47.5col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result1 = for {
\end_layout

\begin_layout Plain Layout

  x <- xs
\end_layout

\begin_layout Plain Layout

  if p(x)
\end_layout

\begin_layout Plain Layout

  y = f(x)
\end_layout

\begin_layout Plain Layout

} yield y
\end_layout

\begin_layout Plain Layout

 // Rewritten via method chains:
\end_layout

\begin_layout Plain Layout

val result1 = xs.filter(p).map(f)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47.5col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result2 = for {
\end_layout

\begin_layout Plain Layout

  x <- xs
\end_layout

\begin_layout Plain Layout

  if p(x)
\end_layout

\begin_layout Plain Layout

  y = fp(x) // Here fp = if_p(p)(f)
\end_layout

\begin_layout Plain Layout

 } yield y
\end_layout

\begin_layout Plain Layout

 // Rewritten via method chains:
\end_layout

\begin_layout Plain Layout

val result2 = xs.filter(p).map(fp)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0baselineskip%
\end_inset


\end_layout

\begin_layout Standard
We found 
\begin_inset Formula $4$
\end_inset

 requirements for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function, written in terms of equal code fragments.
 These requirements are the four 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

 (i.e., equations) that any reasonable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 must satisfy.
 In the code notation, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is 
\begin_inset Formula $\text{filt}_{F}$
\end_inset

:
\begin_inset Formula 
\[
\text{filt}_{F}:(A\rightarrow\bbnum 2)\rightarrow F^{A}\rightarrow F^{A}\quad.
\]

\end_inset

The 
\begin_inset Formula $4$
\end_inset

 laws (called the naturality, identity, composition, and partial function
 laws) are formulated for arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

, 
\begin_inset Formula $p_{1}^{:A\rightarrow\bbnum 2}$
\end_inset

, 
\begin_inset Formula $p_{2}^{:A\rightarrow\bbnum 2}$
\end_inset

, and 
\begin_inset Formula $q^{:B\rightarrow\bbnum 2}$
\end_inset

:
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
composition law!of 
\family typewriter
filter
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
naturality law!of 
\family typewriter
filter
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
identity laws!of 
\family typewriter
filter
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
partial function law!of 
\family typewriter
filter
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
\text{naturality law}:\quad & f^{\uparrow F}\bef\text{filt}_{F}(q)=\text{filt}_{F}(f\bef q)\bef f^{\uparrow F}\quad.\label{eq:naturality-law-of-filter}\\
\text{identity law}:\quad & \text{filt}_{F}(\_\rightarrow\text{true})=\text{id}^{:F^{A}\rightarrow F^{A}}\quad.\label{eq:identity-law-of-filter}\\
\text{composition law}:\quad & \text{filt}_{F}(p_{1})\bef\text{filt}_{F}(p_{2})=\text{filt}_{F}(x\rightarrow p_{1}(x)\wedge p_{2}(x))\quad.\label{eq:composition-law-of-filter}\\
\text{partial function law}:\quad & \text{filt}_{F}(p)\bef f^{\uparrow F}=\text{filt}_{F}(p)\bef f_{|p}^{\uparrow F}\quad.\label{eq:partial-function-law-of-filter}
\end{align}

\end_inset

The following type diagram illustrates the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{7.0pc}F^{A}\ar[r]\sp(0.5){\text{filt}_{F}(f^{:A\rightarrow B}\bef q^{:B\rightarrow\bbnum 2})}\ar[d]\sb(0.45){(f^{:A\rightarrow B})^{\uparrow F}} & F^{A}\ar[d]\sp(0.45){(f^{:A\rightarrow B})^{\uparrow F}}\\
F^{B}\ar[r]\sp(0.5){\text{filt}_{F}(q^{:B\rightarrow\bbnum 2})} & F^{B}
}
\]

\end_inset


\end_layout

\begin_layout Standard
A functor 
\begin_inset Formula $F$
\end_inset

 is called 
\series bold
filterable
\series default
 if there is a function 
\begin_inset Formula $\text{filt}_{F}$
\end_inset

 satisfying these laws.
\begin_inset Index idx
status open

\begin_layout Plain Layout
filterable!functor
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
We may define a typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 and extension methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

withFilter
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Filterable[F[_]] { def filt[A](p: A => Boolean)(fa: F[A]): F[A] }
\end_layout

\begin_layout Plain Layout

implicit class FilterableSyntax[F[_], A](fa: F[A])(implicit ev: Filterable[F])
 {
\end_layout

\begin_layout Plain Layout

  def filter(p: A => Boolean): F[A] = ev.filt(p)(fa)
\end_layout

\begin_layout Plain Layout

  def withFilter(p: A => Boolean): F[A] = filter(p)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is intuitively clear why functors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 obey the filtering laws: those types can be viewed as 
\begin_inset Quotes eld
\end_inset

containers
\begin_inset Quotes erd
\end_inset

 holding zero or more items of data, and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation removes all data that fails the filtering condition.
 What about the custom data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Orders
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filtering-orders-tue-fri"
plural "false"
caps "false"
noprefix "false"

\end_inset

? In principle, we would need to verify all four laws symbolically, using
 the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

withFilter
\end_layout

\end_inset

 as we implemented it for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Orders
\end_layout

\end_inset

.
 Later in this chapter we will see that the four laws can be simplified,
 reduced to just two laws, and proved more quickly.
 For now, we can use the 
\family typewriter
scalacheck
\family default
 library
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
scalacheck
\family default
 library
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
verifying laws with 
\family typewriter
scalacheck
\end_layout

\end_inset

2 to implement randomized tests for the four filtering laws:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def checkFilteringLaws[F[_] : Filterable : Functor, A, B](implicit
\end_layout

\begin_layout Plain Layout

    faEv: Arbitrary[F[A]], fbEv: Arbitrary[F[B]], abEv: Arbitrary[A => B],
\end_layout

\begin_layout Plain Layout

    aEv: Arbitrary[A => Boolean], bEv: Arbitrary[B => Boolean]): Assertion
 = {
\end_layout

\begin_layout Plain Layout

  forAll { (f: A => B, p: B => Boolean, fa: F[A]) =>         // Naturality
 law.
\end_layout

\begin_layout Plain Layout

      fa.map(f).filter(p) shouldEqual fa.filter(f andThen p).map(f)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  forAll { (p1: B => Boolean, p2: B => Boolean, fa: F[B]) => // Composition
 law.
\end_layout

\begin_layout Plain Layout

      fa.filter(p1).filter(p2) shouldEqual fa.filter(b => p1(b) && p2(b))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  forAll { (fb: F[B]) => fb.filter(_ => true) shouldEqual fb }  // Identity
 law.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  forAll { (f: A => B, p: A => Boolean, fa: F[A]) =>    // Partial function
 law.
\end_layout

\begin_layout Plain Layout

      fa.filter(p).map(f) shouldEqual fa.filter(p).map[B](x => p(x) match {
 case true => f(x) })
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Creating a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 typeclass instance for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Orders
\end_layout

\end_inset

 and running the tests will show no errors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val filterableOrders = new Filterable[Orders] {
\end_layout

\begin_layout Plain Layout

  def filt[A](p: A => Boolean)(fa: F[A]): F[A] = fa.filter(p)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

checkFilteringLaws[Orders, Int, String]          // Need to set type parameters.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Examples of non-filterable functors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Examples-of-non-filterable-functors"

\end_inset


\end_layout

\begin_layout Standard
As usual with typeclasses, the code of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 typeclass fixes the type signature of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function but does not enforce its laws.
 It is up to the programmer to verify that the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 satisfies the laws.
\end_layout

\begin_layout Standard
If we define the filtering operation for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Orders
\end_layout

\end_inset

 data type (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filtering-orders-tue-fri"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with the extra business rule 
\series bold
(a)
\series default
, we get:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val filterableOrdersRuleA = new Filterable[Orders] {
\end_layout

\begin_layout Plain Layout

  def filt[A](p: A => Boolean)(fa: F[A]): F[A] =
\end_layout

\begin_layout Plain Layout

    if (fa.tue.forall(p) && fa.fri.forall(p))) fa.filter(p)
\end_layout

\begin_layout Plain Layout

    else Orders(None, None)        // Rule (a): No orders are approved unless
 both are approved.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

checkFilteringLaws[Orders, Int, String]    // Tests pass.
\end_layout

\end_inset

However, implementing business rule 
\series bold
(b)
\series default
 will violate some laws:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val filterableOrdersRuleB = new Filterable[Orders] {
\end_layout

\begin_layout Plain Layout

  def filt[A](p: A => Boolean)(fa: F[A]): F[A] =
\end_layout

\begin_layout Plain Layout

    if (fa.tue.exists(p) || fa.fri.exists(p)) fa      // Here, the value `fa`
 remains unchanged.
\end_layout

\begin_layout Plain Layout

    else Orders(None, None)   // Rule (b): Both orders are approved if at
 least one is approved.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

checkFilteringLaws[Orders, Boolean, Boolean]()      // Tests will fail!
 A specific failing case:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Orders(Some(500), Some(2000)).filter(x => x < 1000).filter(x => x >
 1000)
\end_layout

\begin_layout Plain Layout

res0: Orders[Int] = Orders(Some(500),Some(2000))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Orders(Some(500), Some(2000)).filter(x => x < 1000 && x > 1000) //
 Composition law fails:
\end_layout

\begin_layout Plain Layout

res1: Orders[Int] = Orders(None, None)
\end_layout

\end_inset

If we implement rule 
\series bold
(b)
\series default
, the filtering operation will not correspond to an intuitive understanding
 of computations in functor blocks:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for { x <- Orders(Some(500), Some(2000))
\end_layout

\begin_layout Plain Layout

  if x < 1000 // Intuition says that values of x must be below 1000 from
 now on.
\end_layout

\begin_layout Plain Layout

  y = s"Amount: $x"  // So, the value x = 2000 should never appear in this
 line.
\end_layout

\begin_layout Plain Layout

} yield y         // But the final result does not correspond to this intuition:
\end_layout

\begin_layout Plain Layout

res2: Orders[String] = Orders(Some("Amount: 500"), Some("Amount: 2000"))
\end_layout

\end_inset

This computation violates the partial function law because the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = 2000
\end_layout

\end_inset

 is not excluded from further computations despite filtering with the predicate
 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x < 1000
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 This happened because the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 does not remove the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = 2000
\end_layout

\end_inset

 from the data structure in that case.
\end_layout

\begin_layout Standard
The four laws of filtering are a rigorous formulation of our intuitions
 about what it means to 
\begin_inset Quotes eld
\end_inset

filter data
\begin_inset Quotes erd
\end_inset

.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Orders
\end_layout

\end_inset

 with business rule 
\series bold
(b)
\series default
 is an example of a filtering operation that does not correspond to our
 intuitions and, as a consequence, violates the filtering laws.
 This does not mean that business rule 
\series bold
(b)
\series default
 cannot be used in real-world programs; it only means that order approval
 according to rule 
\series bold
(b)
\series default
 is not a filtering operation.
 For instance, applying two order approvals one after another will not give
 the intuitively expected results.
 Nevertheless, this may be acceptable in applications where only one order
 approval is ever applied.
\end_layout

\begin_layout Standard
Violations of the filtering laws by business rule 
\series bold
(b)
\series default
 also does not mean that the functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Orders
\end_layout

\end_inset

 is not filterable.
 The same functor with business rule 
\series bold
(a)
\series default
 has a lawful implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
What are examples of functors that are not filterable? One way of implementing
 the type signature of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function is to use the identity function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filt[A](p: A => Boolean)(fa: F[A]): F[A] = fa  // Ignore the predicate
 `p`; always return `fa`.
\end_layout

\end_inset

This implementation never removes any data and so will violate the partial
 function law if the functor 
\begin_inset Formula $F^{A}$
\end_inset

 wraps a value of type 
\begin_inset Formula $A$
\end_inset

 that does not pass the filter.
 However, the identity function is the 
\emph on
only
\emph default
 possible implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 for certain functors 
\begin_inset Formula $F$
\end_inset

, e.g., the identity functor 
\begin_inset Formula $F^{A}\triangleq A$
\end_inset

 or the exponential functor 
\begin_inset Formula $F^{A}\triangleq Z\rightarrow A$
\end_inset

.
 So, functors of the form 
\begin_inset Formula $F^{A}\triangleq Z\rightarrow A$
\end_inset

 (where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type) are not filterable.
\end_layout

\begin_layout Standard
The functor 
\begin_inset Formula $F^{A}\triangleq A\times(\bbnum 1+A)$
\end_inset

 is not filterable because the filtering operation 
\begin_inset Formula $\text{filt}_{F}(p)$
\end_inset

 cannot remove the first value of type 
\begin_inset Formula $A$
\end_inset

 when it does not pass the filter predicate 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Standard
Functors such as 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times A$
\end_inset

 are filterable because the function 
\begin_inset Formula $\text{filt}_{F}$
\end_inset

 can be defined correctly; but incorrect implementations are also possible.
 For example, one could imagine defining 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 for an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val wrongFilterableOption = new Filterable[Option] {
\end_layout

\begin_layout Plain Layout

  def filt[A](p: A => Boolean)(fa: Option[A]): Option[A] = None // Discard
 input, always return None.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code discards information and violates the identity law: the result
 of filtering with an identically 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 predicate is not the identity function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Finally, one could violate the naturality law by defining 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 in a special way when the type parameter 
\begin_inset Formula $A$
\end_inset

 is set to, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 To obey the naturality law, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function must be fully parametric and must not use hard-coded values of
 specific types or make decisions based on specific types.
\end_layout

\begin_layout Standard
Note that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type is equivalent to 
\begin_inset Formula $\bbnum 2\cong\bbnum 1+\bbnum 1$
\end_inset

; in other words, this type can be expressed via the basic type constructions
 (disjunction and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type) without using any externally defined values.
 For this reason, it is allowed to use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type in fully parametric functions.
\end_layout

\begin_layout Subsection
Examples: Programming with filterable functors
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-solved-example-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A cluster has 
\begin_inset Formula $2$
\end_inset

 servers; each server needs to have valid credentials, which expire periodically.
 If credentials expire for one server, it may copy valid credentials from
 the other server.
 If no server has valid credentials, the cluster is down.
 Is this setup described by a filterable functor?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Assuming that credentials have type 
\begin_inset Formula $A$
\end_inset

, we can have two possibilities: both servers have valid credentials, or
 the cluster is down.
 The corresponding data type is the functor 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times A$
\end_inset

.
 This functor is filterable if we can implement a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function.
 Begin writing code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

type F[A] = Option[(A, A)]
\end_layout

\begin_layout Plain Layout

def filter[A](p: A => Boolean): F[A] => F[A] = {
\end_layout

\begin_layout Plain Layout

    case None             => None
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))   => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In line
\begin_inset space ~
\end_inset

4, we need to compute a value of type 
\begin_inset Formula $F^{A}$
\end_inset

 using the given values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

.
 We need to check whether the predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

.
 What if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(a1) == false
\end_layout

\end_inset

 but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(a2) == true
\end_layout

\end_inset

? We need to remove 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 from the result, or else the filtering laws will not hold.
 But the functor 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times A$
\end_inset

 does not allow us to keep just one of the values of type 
\begin_inset Formula $A$
\end_inset

; it requires two such values or none.
 So, we may return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((a2, a2))
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Looking at the business requirements, we see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(a1) == false
\end_layout

\end_inset

 means the first server's credentials expired.
 In that case, if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(a2) == true
\end_layout

\end_inset

, the first server copies the second server's valid credentials, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

.
 So, we must return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((a2, a2))
\end_layout

\end_inset

.
 Other cases are handled similarly.
 The full code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean): F[A] => F[A] = {
\end_layout

\begin_layout Plain Layout

    case None             => None                    // Cluster is down,
 no valid credentials.
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))   => (p(a1), p(a2)) match {
\end_layout

\begin_layout Plain Layout

        case (true, true)     => Some((a1, a2))  // Both credentials are
 still valid.
\end_layout

\begin_layout Plain Layout

        case (true, false)    => Some((a1, a1))  // Server 2 copies credentials
 from server 1.
\end_layout

\begin_layout Plain Layout

        case (false, true)    => Some((a2, a2))  // Server 1 copies credentials
 from server 2.
\end_layout

\begin_layout Plain Layout

        case (false, false)   => None        // Both credentials expired,
 the cluster is down.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It remains to check that the filtering laws hold.
 The naturality law requires that the equation 
\begin_inset Formula $f^{\uparrow F}\bef\text{filt}_{F}(p)=\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}$
\end_inset

 must hold for any values 
\begin_inset Formula $s^{:F^{A}}$
\end_inset

, 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and 
\begin_inset Formula $p^{:B\rightarrow\bbnum 2}$
\end_inset

.
 The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): F[A] => F[B] = {
\end_layout

\begin_layout Plain Layout

    case None             => None
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))   => Some((f(a1), f(a2)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code for the left-hand side of the law, 
\begin_inset Formula $f^{\uparrow F}\bef\text{filt}_{F}(p)$
\end_inset

, is written by composing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fmap(f) andThen filter(p) == {
\end_layout

\begin_layout Plain Layout

    case None            => None
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))  => (p(f(a1)), p(f(a2))) match {
\end_layout

\begin_layout Plain Layout

        case (true, true)     => Some((f(a1), f(a2)))
\end_layout

\begin_layout Plain Layout

        case (true, false)    => Some((f(a1), f(a1)))
\end_layout

\begin_layout Plain Layout

        case (false, true)    => Some((f(a2), f(a2)))
\end_layout

\begin_layout Plain Layout

        case (false, false)   => None
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code for the right-hand side of the law, 
\begin_inset Formula $\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}$
\end_inset

, is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

filter(f andThen p) = {
\end_layout

\begin_layout Plain Layout

    case None            => None
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))  => (p(f(a1)), p(f(a2))) match {
\end_layout

\begin_layout Plain Layout

        case (true, true)     => Some((a1, a2))
\end_layout

\begin_layout Plain Layout

        case (true, false)    => Some((a1, a1))
\end_layout

\begin_layout Plain Layout

        case (false, true)    => Some((a2, a2))
\end_layout

\begin_layout Plain Layout

        case (false, false)   => None
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} andThen fmap(f) = {
\end_layout

\begin_layout Plain Layout

    case None            => None
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))  => (p(f(a1)), p(f(a2))) match {
\end_layout

\begin_layout Plain Layout

        case (true, true)     => Some((f(a1), f(a2)))
\end_layout

\begin_layout Plain Layout

        case (true, false)    => Some((f(a1), f(a1)))
\end_layout

\begin_layout Plain Layout

        case (false, true)    => Some((f(a2), f(a2)))
\end_layout

\begin_layout Plain Layout

        case (false, false)   => None
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Since the code is exactly the same, the law holds.
 
\end_layout

\begin_layout Standard
This computation illustrates why fully parametric functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 obey the naturality law: such functions manipulate their arguments purely
 as symbols of unknown types, without referring to any specific types or
 values.
 Applying a lifted function 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 before 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is the same as inserting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(...)
\end_layout

\end_inset

 around values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 at every place in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter(p)
\end_layout

\end_inset

 where a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is used.
 Applying a lifted function 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is the same as inserting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(...)
\end_layout

\end_inset

 at every place where a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is 
\emph on
returned
\emph default
; but this does not put 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(...)
\end_layout

\end_inset

 around values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 used by the predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 To compensate, the right-hand side of the naturality law replaces the predicate
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 by the new predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen p
\end_layout

\end_inset

, which inserts 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(...)
\end_layout

\end_inset

 into the remaining places in the code.
\end_layout

\begin_layout Standard
This turns out to be the rule: fully parametric functions always satisfy
 a suitably formulated naturality law.
 We will see many more examples of naturality laws in this book, and we
 will find that the naturality law of a method 
\begin_inset Formula $q$
\end_inset

 often has the form 
\begin_inset Formula $f^{\uparrow}\bef q=\text{<modified }q\text{>}\bef f^{\uparrow}$
\end_inset

, i.e., the composition of a lifted function 
\begin_inset Formula $f^{\uparrow}$
\end_inset

 and a method 
\begin_inset Formula $q$
\end_inset

 can be interchanged, possibly after some modifications.
\end_layout

\begin_layout Standard
The identity law holds because the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter(p)
\end_layout

\end_inset

 is the identity function when 
\begin_inset Formula $p=(\_\rightarrow\text{true})$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

filter[A](_ => true) == {
\end_layout

\begin_layout Plain Layout

    case None             => None
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))   => Some((a1, a2))
\end_layout

\begin_layout Plain Layout

} == identity[F[A]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It takes a bit more work to show that the composition law holds.
 We need to consider two cases: the cluster is down, or both servers have
 valid credentials.
\end_layout

\begin_layout Standard
In the first case, the value of 
\begin_inset Formula $F^{A}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and remains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 after any filtering operation.
 (If the cluster is down, a check of credentials will not bring it up.) So,
 the composition law holds for that case.
 
\end_layout

\begin_layout Standard
In the second case, we have two credentials 
\begin_inset Formula $a_{1},a_{2}$
\end_inset

 in a value 
\begin_inset Formula $s\triangleq\bbnum 0+a_{1}\times a_{2}$
\end_inset

.
 The filtering operation 
\begin_inset Formula $s\triangleright\text{filt}_{F}(p_{1})\triangleright\text{filt}_{F}(p_{2})$
\end_inset

 will produce different results according to the values of the predicates
 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

 applied to 
\begin_inset Formula $a_{1}$
\end_inset

 and 
\begin_inset Formula $a_{2}$
\end_inset

.
 We can summarize all results in a table, where we denote for brevity the
 left-hand side of the composition law by 
\begin_inset Formula $\text{L.H.S.}\triangleq s\triangleright\text{filt}_{F}(p_{1})\triangleright\text{filt}_{F}(p_{2})$
\end_inset

 and the right-hand side by 
\begin_inset Formula $\text{R.H.S.}\triangleq s\triangleright\text{filt}_{F}(p_{12})$
\end_inset

, where 
\begin_inset Formula $p_{12}\triangleq x\rightarrow p_{1}(x)\wedge p_{2}(x)$
\end_inset

:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $p_{1}(a_{1})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $p_{1}(a_{2})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $p_{2}(a_{1})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $p_{2}(a_{2})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $p_{12}(a_{1})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $p_{12}(a_{2})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $s\triangleright\text{filt}_{F}(p_{1})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{L.H.S.}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{R.H.S.}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+a_{1}\times a_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+a_{1}\times a_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+a_{1}\times a_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+a_{1}\times a_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+a_{1}\times a_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+a_{1}\times a_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

???
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

???
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

???
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+\bbnum 0^{:A\times A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+\bbnum 0^{:A\times A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+a_{1}\times a_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+\bbnum 0^{:A\times A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+\bbnum 0^{:A\times A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

???
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

???
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+\bbnum 0^{:A\times A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+\bbnum 0^{:A\times A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+\bbnum 0^{:A\times A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
We see that the last two columns are always equal, which verifies the compositio
n law.
 We omitted some rows from the table because the filtering code is completely
 symmetric with respect to interchanging 
\begin_inset Formula $a_{1}$
\end_inset

 and 
\begin_inset Formula $a_{2}$
\end_inset

, and because the composition law is trivial when 
\begin_inset Formula $p_{1}=p_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
The partial function law holds because the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 will always remove the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

, or both of them when the filtering predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 for any of those values.
\end_layout

\begin_layout Standard
So, we have proved that all filtering laws hold for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function shown above.
 If the program's requirements change, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function will need to be changed.
 For instance, suppose the first server is now the only source of credentials.
 The second server may copy the first server's credentials if needed, but
 the cluster will go down whenever the first server's credentials expire.
 This corresponds to the code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean): F[A] => F[A] = {
\end_layout

\begin_layout Plain Layout

    case None             => None
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))   => (p(a1), p(a2)) match {
\end_layout

\begin_layout Plain Layout

        case (true, true)     => Some((a1, a2))
\end_layout

\begin_layout Plain Layout

        case (true, false)    => Some((a1, a1))
\end_layout

\begin_layout Plain Layout

        case (false, _)       => None    // The cluster is down if credentials
 expire for server 1.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Alternatively, we may have a requirement that copying credentials between
 servers is not possible:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean): F[A] => F[A] = {
\end_layout

\begin_layout Plain Layout

    case None             => None
\end_layout

\begin_layout Plain Layout

    case Some((a1, a2))   => (p(a1), p(a2)) match {
\end_layout

\begin_layout Plain Layout

        case (true, true)     => Some((a1, a2))   // Both credentials are
 valid.
\end_layout

\begin_layout Plain Layout

        case _                => None    // The cluster is down when any
 of the credentials expire.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The filtering laws will still hold with these alternative implementations.
 We omit the proofs.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-solved-example-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
John can have up to 
\begin_inset Formula $3$
\end_inset

 coupons, and Jill up to 
\begin_inset Formula $2$
\end_inset

.
 All of John's coupons must be valid on purchase day, while each of Jill's
 coupons is checked independently.
 Implement a filterable functor describing this situation.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We use a type parameter 
\begin_inset Formula $A$
\end_inset

 for the type of 
\begin_inset Quotes eld
\end_inset

coupons
\begin_inset Quotes erd
\end_inset

.
 A data structure holding 
\begin_inset Quotes eld
\end_inset

up to 
\begin_inset Formula $3$
\end_inset


\begin_inset Quotes erd
\end_inset

 values of type 
\begin_inset Formula $A$
\end_inset

 is written as 
\begin_inset Formula $\bbnum 1+A+A\times A+A\times A\times A$
\end_inset

 and can be implemented in Scala by:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

sealed trait JohnsCoupons[A]  // This represents the type $
\backslash
color{dkgreen}
\backslash
bbnum 1+A+A
\backslash
times A+A
\backslash
times A
\backslash
times A$.
\end_layout

\begin_layout Plain Layout

final case class John0[A]()                    extends JohnsCoupons[A]
\end_layout

\begin_layout Plain Layout

final case class John1[A](c1: A)               extends JohnsCoupons[A]
\end_layout

\begin_layout Plain Layout

final case class John2[A](c1: A, c2: A)        extends JohnsCoupons[A]
\end_layout

\begin_layout Plain Layout

final case class John3[A](c1: A, c2: A, c3: A) extends JohnsCoupons[A] 
\end_layout

\end_inset

This code models John's coupons.
 Jill's coupons are implemented similarly:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

sealed trait JillsCoupons[A]    // This represents the type $
\backslash
color{dkgreen}
\backslash
bbnum 1+A+A
\backslash
times A$.
\end_layout

\begin_layout Plain Layout

final case class Jill0[A]()             extends JillsCoupons[A]
\end_layout

\begin_layout Plain Layout

final case class Jill1[A](c1: A)        extends JillsCoupons[A]
\end_layout

\begin_layout Plain Layout

final case class Jill2[A](c1: A, c2: A) extends JillsCoupons[A] 
\end_layout

\end_inset

The full data type is the product of John's and Jill's coupons:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Coupons[A](johns: JohnsCoupons[A], jills: JillsCoupons[A])
\end_layout

\end_inset

It is convenient to define the filtering functions separately for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

JohnsCoupons
\end_layout

\end_inset

 and for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

JillsCoupons
\end_layout

\end_inset

:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def filterJohn[A](p: A => Boolean): JohnsCoupons[A] => JohnsCoupons[A] =
 {
\end_layout

\begin_layout Plain Layout

  case John0()             => John0()  // We return John0() unless ${
\backslash
color{dkgreen}
\backslash
text{
\backslash
emph{all}}}$ coupons are valid:
\end_layout

\begin_layout Plain Layout

  case John1(c1)           => if (p(c1)) John1(c1) else John0()
\end_layout

\begin_layout Plain Layout

  case John2(c1, c2)       => if (p(c1) && p(c2)) John2(c1, c2) else John0()
\end_layout

\begin_layout Plain Layout

  case John3(c1, c2, c3)   => if (p(c1) && p(c2) && p(c3)) John3(c1, c2,
 c3) else John0()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def filterJill[A](p: A => Boolean): JillsCoupons[A] => JillsCoupons[A] =
 {
\end_layout

\begin_layout Plain Layout

  case Jill0() => Jill0()  // We must remove all the invalid coupons.
\end_layout

\begin_layout Plain Layout

  case Jill1(c1) => if (p(c1)) Jill1(c1) else Jill0()
\end_layout

\begin_layout Plain Layout

  case Jill2(c1, c2) => (p(c1), p(c2)) match {
\end_layout

\begin_layout Plain Layout

     case (true, true)     => Jill2(c1, c2)
\end_layout

\begin_layout Plain Layout

     case (true, false)    => Jill1(c1)
\end_layout

\begin_layout Plain Layout

     case (false, true)    => Jill1(c2)
\end_layout

\begin_layout Plain Layout

     case (false, false)   => Jill0()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Coupons
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(fa: Coupons[A]): Coupons[A] =
\end_layout

\begin_layout Plain Layout

  Coupons(filterJohn(p)(fa.johns), filterJill(p)(fa.jills))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will not prove the laws for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function because its code follows from general constructions derived later
 in this chapter.
 Running the 
\family typewriter
scalacheck
\family default
 tests shows no failures:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val filterableCoupons = new Filterable[Coupons] {
\end_layout

\begin_layout Plain Layout

  def filt[A](p: A => Boolean)(fa: Coupons[A]): Coupons[A] = filter(p)(coupons)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

checkFilteringLaws[Coupons, Int, String]        // Tests pass.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-solved-example-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A server receives a sequence of requests.
 Each request must be authenticated.
 Once a non-authenticated request is found, no further requests are accepted.
 Is this situation described by a filterable functor?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We represent the requests by a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 wrapped in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Server
\end_layout

\end_inset

 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Server[A](requests: Seq[A])
\end_layout

\end_inset

The filtering operation truncates the sequence when the predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 first returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

:
\begin_inset Index idx
status open

\begin_layout Plain Layout
filterable!defined via 
\family typewriter
takeWhile
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(s: Server[A]): Server[A] = Server(s.requests.takeWh
ile(p))
\end_layout

\end_inset

We will not prove the laws because this implementation reduces to general
 constructions of filterable functors (see page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "proof-that-takeWhile-is-a-lawful-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
 Intuitively, we expect laws to hold because the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function always removes values that fail the predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 The filtering function also removes other values that may or may not fail
 the predicate, but the filtering laws allow removing 
\emph on
more
\emph default
 values.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-solved-example-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If possible, implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 typeclass instance for:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The functor 
\begin_inset Formula $F^{T}$
\end_inset

 defined by the Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class F[T](x: Option[T], yy: Option[(T, T)])
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $F^{A}\triangleq\text{Int}+\text{Int}\times A+\text{Int}\times A\times A+\text{Int}\times A\times A\times A\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 A non-empty list functor, 
\begin_inset Formula $F^{A}=\text{NEList}^{A}$
\end_inset

, defined recursively as 
\begin_inset Formula $F^{A}\triangleq A+A\times F^{A}\quad.$
\end_inset

 
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $F^{Z,A}\triangleq Z+\text{Int}\times Z\times A\times A$
\end_inset

 (with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 
\begin_inset Formula $F^{Z,A}\triangleq Z+\text{Int}\times A\times\text{List}^{A}$
\end_inset

 (with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The functor 
\begin_inset Formula $F$
\end_inset

 is written in the code notation as 
\begin_inset Formula $F^{T}\triangleq\left(\bbnum 1+T\right)\times\left(\bbnum 1+T\times T\right)$
\end_inset

.
 This is a product of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[T]
\end_layout

\end_inset

, which is filterable, and the functor 
\begin_inset Formula $\bbnum 1+T\times T$
\end_inset

, which was shown to be filterable in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We can apply the corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation to each part of the product:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[T](p: T => Boolean): F[T] => F[T] = {
\end_layout

\begin_layout Plain Layout

  case F(t, None)             => F(t.filter(p), None)
\end_layout

\begin_layout Plain Layout

  case F(t, Some((t1, t2)))   => F(t.filter(p), if (p(t1) && p(t2)) Some((t1,
 t2)) else None)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Each part of the product type satisfies the filtering laws separately (see
 Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The functor 
\begin_inset Formula $F$
\end_inset

 can be written equivalently as:
\begin_inset Formula 
\[
F^{A}\cong\text{Int}\times\left(\bbnum 1+A+A\times A+A\times A\times A\right)=\text{Int}\times\text{JohnsCoupons}^{A}\quad,
\]

\end_inset

where we used the functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

JohnsCoupons
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 So, we use the same filtering operation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

JohnsCoupons
\end_layout

\end_inset

 as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

, while keeping the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value unchanged:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class F[A](n: Int, johns: JohnsCoupons[A])
\end_layout

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(fa: F[A]): F[A] = fa.copy(johns = filterJohn(p)(jo
hns))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An interesting alternative implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 uses the integer value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 for tracking the total number of data items 
\emph on
removed
\emph default
 by filtering:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(fa: F[A]): F[A] = {
\end_layout

\begin_layout Plain Layout

  val (removed, newJohnsCoupons) = fa.johns match {
\end_layout

\begin_layout Plain Layout

    case John0()             => (0, John0())
\end_layout

\begin_layout Plain Layout

    case John1(c1)           => if (p(c1)) (0, John1(c1)) else (1, John0())
\end_layout

\begin_layout Plain Layout

    case John2(c1, c2)       => if (p(c1) && p(c2)) (0, John2(c1, c2)) else
 (2, John0())
\end_layout

\begin_layout Plain Layout

    case John3(c1, c2, c3)   => if (p(c1) && p(c2) && p(c3)) (0, John3(c1,
 c2, c3)) else (3, John0())
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  F(fa.n + removed, newJohnsCoupons)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The new code still satisfies the filtering laws (we omit the proof).
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 A type definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEList
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait NEList[A]
\end_layout

\begin_layout Plain Layout

final case class Last[A](x: A)                  extends NEList[A]
\end_layout

\begin_layout Plain Layout

final case class More[A](x: A, tail: NEList[A]) extends NEList[A]
\end_layout

\end_inset

We find that we 
\emph on
cannot
\emph default
 implement the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean): NEList[A] => NEList[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(x)       => if (p(x)) ??? else ???    // Need to compute a value
 of type NEList[A] here.
\end_layout

\begin_layout Plain Layout

  case More(x, tail) => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The problem is in line
\begin_inset space ~
\end_inset

2 above when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(x) == false
\end_layout

\end_inset

: we need to remove the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, making the list empty, but the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEList[A]
\end_layout

\end_inset

 disallows empty lists.
 So, line
\begin_inset space ~
\end_inset

2 must always return a list containing the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, which violates the partial function law of filtering.
 We conclude that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEList
\end_layout

\end_inset

 is not filterable.
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 Looking at the type expression 
\begin_inset Formula $F^{Z,A}\triangleq Z+\text{Int}\times Z\times A\times A$
\end_inset

, we need to check whether we could remove the values of type 
\begin_inset Formula $A$
\end_inset

 that do not pass the filter.
 If none of the two values of type 
\begin_inset Formula $A$
\end_inset

 within 
\begin_inset Formula $\text{Int}\times Z\times A\times A$
\end_inset

 pass the filter, we will need to remove both of them and to return a value
 of type 
\begin_inset Formula $Z$
\end_inset

.
 Luckily, we have a value of type 
\begin_inset Formula $Z$
\end_inset

 within 
\begin_inset Formula $\text{Int}\times Z\times A\times A$
\end_inset

.
 So we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 e.g., like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = Either[Z, (Int, Z, A, A)]  // The type `Z` must be already defined.
\end_layout

\begin_layout Plain Layout

def filter[A](p: A => Boolean): F[A] => F[A] = {
\end_layout

\begin_layout Plain Layout

  case Left(z)                 => Left(z)
\end_layout

\begin_layout Plain Layout

  case Right((n, z, a1, a2))   => if (p(a1) && p(a2)) Right((n, z, a1, a2))
\end_layout

\begin_layout Plain Layout

                                  else Left(z) // If anything fails the
 filter condition, use the value `z`.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The filtering laws will hold similarly to Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 If 
\begin_inset Formula $x$
\end_inset

 is a value of type 
\begin_inset Formula $Z+\text{Int}\times A\times\text{List}^{A}$
\end_inset

, we may compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.filter(_ => false)
\end_layout

\end_inset

.
 Since 
\emph on
no
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

 pass the test, we may not return a data structure containing any values
 of type 
\begin_inset Formula $A$
\end_inset

 (or else the partial function law will fail).
 The only alternative is to return a value of type 
\begin_inset Formula $Z$
\end_inset

.
 But 
\begin_inset Formula $Z$
\end_inset

 is a type parameter, and we cannot create values of type 
\begin_inset Formula $Z$
\end_inset

 from scratch.
 We conclude that 
\begin_inset Formula $F^{Z,A}$
\end_inset

 is not filterable with respect to 
\begin_inset Formula $A$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = Either[Z, (Int, A, List[A])]
\end_layout

\begin_layout Plain Layout

def filter[A](p: A => Boolean): F[A] => F[A] = {
\end_layout

\begin_layout Plain Layout

  case Left(z)             => Left(z)
\end_layout

\begin_layout Plain Layout

  case Right((n, a, as))   =>  // What to compute in case p(a) == false
 and as.filter(p) == List() ?
\end_layout

\begin_layout Plain Layout

                           ??? // In that case, we will have neither values
 of type A nor of type Z.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises: Programming with filterable functors
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Confucius
\begin_inset Index idx
status open

\begin_layout Plain Layout
Confucius
\end_layout

\end_inset

 gave a proverb on each of the 7 days of a week.
 Sometimes the wise proverbs were hard to remember.
 If Confucius forgets what he said on a given day, he also forgets what
 he said on all the 
\emph on
previous
\emph default
 days of the week.
 Is this situation described by a filterable functor?
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define an extension method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenFilter(p)
\end_layout

\end_inset

 on the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IndexedSeq[T]
\end_layout

\end_inset

 such that a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: T
\end_layout

\end_inset

 is kept in the sequence if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(x) == true
\end_layout

\end_inset

 and only if the initial sequence has an 
\emph on
even
\emph default
 total number of elements 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 for which 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(y) == false
\end_layout

\end_inset

.
 Does 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenFilter
\end_layout

\end_inset

 define a lawful filterable functor? 
\begin_inset Note Note
status open

\begin_layout Plain Layout
No
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-exercise-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Three times each week (on Mondays, Wednesdays, and Fridays) a data set is
 collected and a test is run.
 If a test fails, the corresponding data set is discarded.
 Is this situation described by a lawful filterable functor if we impose
 one of the following additional requirements:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 All data sets for a given week are discarded if at least 
\emph on
two
\emph default
 of the tests failed that week?
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 All data sets for a given week are retained if at least 
\emph on
two
\emph default
 of the tests passed that week?
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If possible, implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 typeclass instance (law checking is optional) for:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The functor 
\begin_inset Formula $Q^{A,Z}$
\end_inset

 with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

, where 
\begin_inset Formula $Q^{\bullet,\bullet}$
\end_inset

 is defined by this Scala code:
\family typewriter
\size footnotesize
\color blue

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Q[A, Z](id: Long, user1: Option[(A, Z)], user2: Option[(A,
 Z)])
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The functor 
\begin_inset Formula $R^{A}$
\end_inset

 defined by the Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class R[A](x: Int, y: Int, z: A, data: List[A])
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $F^{P,Q,A}\triangleq(P\rightarrow P)+(Q\rightarrow Q)\times A\times A\times A$
\end_inset

 (with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 The functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MyTree[A] = Option[Tree2[A]]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tree2
\end_layout

\end_inset

 was defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Binary-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 The functor 
\begin_inset Formula $\text{MyTree}^{A}$
\end_inset

 defined recursively as 
\begin_inset Formula $\text{MyTree}^{A}\triangleq\bbnum 1+A\times A\times\text{MyTree}^{A}\times\text{MyTree}^{A}\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-exercise-4-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-4-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Is the simplest perfect-shaped tree 
\begin_inset Formula $R^{A}$
\end_inset

 defined by 
\begin_inset Formula $R^{A}\triangleq A+R^{A\times A}$
\end_inset

 filterable? Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function for a perfect-shaped
\begin_inset Index idx
status open

\begin_layout Plain Layout
perfect-shaped tree
\end_layout

\end_inset

 tree 
\begin_inset Formula $R^{A}$
\end_inset

 defined by:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $R^{A}\triangleq\bbnum 1+A+R^{A\times A}\quad.\quad$
\end_inset

 
\series bold
(b)
\series default
 
\begin_inset Formula $R^{A}\triangleq A+R^{(\bbnum 1+A)\times(\bbnum 1+A)}\quad.$
\end_inset


\end_layout

\begin_layout Section
Laws and structure
\end_layout

\begin_layout Subsection
Simplifying the filtering laws: Motivation for 
\family typewriter
deflate
\begin_inset CommandInset label
LatexCommand label
name "subsec:Simplifying-the-filtering-laws-deflate"

\end_inset


\end_layout

\begin_layout Standard
The four laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Motivation-for-and-derivation-of-laws-of-filtering"
plural "false"
caps "false"
noprefix "false"

\end_inset

) require considerable work to verify directly.
 Is there a shorter reformulation of the laws that is easier to understand
 and to verify?
\end_layout

\begin_layout Standard
To motivate that, begin by considering a heuristic picture of a filter operation
 (
\begin_inset Formula $\text{filt}_{F}(p):F^{A}\rightarrow F^{A}$
\end_inset

) that may remove some values of type 
\begin_inset Formula $A$
\end_inset

 from a wrapper 
\begin_inset Formula $F^{A}$
\end_inset

.
 For example, if 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

 then the filtering operation will sometimes remove the value of type 
\begin_inset Formula $A$
\end_inset

 and return the result 
\begin_inset Formula $1+\bbnum 0$
\end_inset

.
 It appears that the filtering operation, at the type level, replaces the
 type 
\begin_inset Formula $A$
\end_inset

 by the void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 
\begin_inset Formula $\bbnum 0$
\end_inset

 whenever a value does not pass the filtering condition.
 In examples of non-filterable functors 
\begin_inset Formula $F$
\end_inset

, such as 
\begin_inset Formula $F^{A}\triangleq A\times\left(\bbnum 1+A\right)$
\end_inset

, the type expression for 
\begin_inset Formula $F^{A}$
\end_inset

 cannot accommodate replacing the type 
\begin_inset Formula $A$
\end_inset

 by 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 
\end_layout

\begin_layout Standard
If we had the functor 
\begin_inset Formula $F^{\bbnum 1+A}$
\end_inset

 instead of 
\begin_inset Formula $F^{A}$
\end_inset

, we would be able to replace 
\begin_inset Formula $A$
\end_inset

 by 
\begin_inset Formula $\bbnum 0$
\end_inset

 whenever necessary:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[F[_]: Functor, A](p: A => Boolean): F[Option[A]] => F[Option[A]]
 =
\end_layout

\begin_layout Plain Layout

    _.map(_.filter(p))    // Using the standard .filter method on Option.
\end_layout

\end_inset

We can always convert a value of type 
\begin_inset Formula $F^{A}$
\end_inset

 back into a value of type 
\begin_inset Formula $F^{\bbnum 1+A}$
\end_inset

 (as long as 
\begin_inset Formula $F$
\end_inset

 is a functor):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def inflate[F[_]: Functor, A]: F[A] => F[Option[A]] = _.map(x => Some(x))
\end_layout

\end_inset

The code notation for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{inflate}^{F,A}\triangleq(x^{:A}\rightarrow\bbnum 0^{:\bbnum 1}+x)^{\uparrow F}\quad.
\]

\end_inset

It remains to convert 
\begin_inset Formula $F^{\bbnum 1+A}$
\end_inset

 to 
\begin_inset Formula $F^{A}$
\end_inset

.
 If we could 
\emph on
somehow
\emph default
 do that, say, via a function we will call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

deflate
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def deflate[F[_], A]: F[Option[A]] => F[A] = ???
\end_layout

\end_inset

or, in the code notation:
\begin_inset Formula 
\[
\text{deflate}^{F,A}:F^{\bbnum 1+A}\rightarrow F^{A}\quad,
\]

\end_inset

we would then be able to express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

filter
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

deflate
\end_layout

\end_inset

 like this:
\begin_inset Formula 
\begin{align*}
 & \quad\quad\quad\quad\left(\text{filt}_{F}(p)\right)^{:F^{A}\rightarrow F^{A}}=\text{inflate}\bef\big(\text{filt}_{\text{Opt}}(p)\big)^{\uparrow F}\bef\text{deflate}\quad.\\
 & \xymatrix{\xyScaleX{5pc}\xyScaleY{0.8pc}F^{A}\ar[r]\sp(0.45){\text{inflate}} & F^{\bbnum 1+A}\ar[r]\sp(0.55){\big(\text{filt}_{\text{Opt}}(p)\big)^{\uparrow F}} & F^{\bbnum 1+A}\ar[r]\sp(0.55){\text{deflate}} & F^{A}}
\end{align*}

\end_inset

Here 
\begin_inset Formula $\text{filt}_{\text{Opt}}$
\end_inset

 is the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

filter
\end_layout

\end_inset

 method defined for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Option[_]
\end_layout

\end_inset

 types.
 
\end_layout

\begin_layout Standard
We notice that both functions in the composition 
\begin_inset Formula $\text{inflate}\bef(\text{filt}_{\text{Opt}}(p))^{\uparrow F}$
\end_inset

 are some lifted functions in the functor 
\begin_inset Formula $F$
\end_inset

, and so we can simplify that composition to a single lifted function:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{inflate}}\bef(\text{filt}_{\text{Opt}}(p))^{\uparrow F}\\
\text{definition of }\text{inflate}:\quad & =(x^{:A}\rightarrow\bbnum 0^{:\bbnum 1}+x)^{\uparrow F}\bef(\text{filt}_{\text{Opt}}(p))^{\uparrow F}\\
\text{functor composition law of }F:\quad & =\big(x\rightarrow\text{filt}_{\text{Opt}}(p)(\bbnum 0+x)\big)^{\uparrow F}\quad.
\end{align*}

\end_inset

We will need to use this function often, so let us call it 
\begin_inset Formula $\psi(p)$
\end_inset

 or even shorter, 
\begin_inset Formula $\psi_{p}$
\end_inset

, for convenience:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def psi[A](p: A => Boolean): A => Option[A] =
\end_layout

\begin_layout Plain Layout

  x => Some(x).filter(p)
\end_layout

\end_inset

In the code notation:
\begin_inset Formula 
\begin{align*}
 & \psi^{A}:(A\rightarrow\bbnum 2)\rightarrow A\rightarrow\bbnum 1+A\quad,\\
 & \psi_{p}\triangleq\psi(p^{:A\rightarrow\bbnum 2})\triangleq x^{:A}\rightarrow\text{filt}_{\text{Opt}}(p)(\bbnum 0+x)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Using the function 
\begin_inset Formula $\psi$
\end_inset

, we can express the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

filter
\end_layout

\end_inset

 operation as:
\begin_inset Formula 
\begin{align}
 & \xymatrix{\xyScaleX{4pc}F^{A}\ar[r]\sp(0.5){\psi_{p}^{\uparrow F}} & F^{\bbnum 1+A}\ar[r]\sp(0.55){\text{deflate}} & F^{A}}
\quad\quad\quad\quad\quad\text{filt}_{F}(p)=\psi_{p}^{\uparrow F}\bef\text{deflate}\quad.\label{eq:def-filter-through-deflate}
\end{align}

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(fa: F[A]): F[A] = deflate(fa.map(psi(p)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We derived the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 assuming that a suitable function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 exists.
 Can we derive the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 for a given filterable functor 
\begin_inset Formula $F$
\end_inset

, e.g., for 
\begin_inset Formula $F=~$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

? The required type signature is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate: Seq[Option[T]] => Seq[T]
\end_layout

\end_inset

.
 The Scala library has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 with exactly that type signature; it removes all empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 values from a sequence.
 This shows how to derive the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 method for any filterable 
\begin_inset Formula $F$
\end_inset

: just use 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 to remove the empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 values from 
\begin_inset Formula $F^{\bbnum 1+A}$
\end_inset

.
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def deflate[F[_]: Filterable : Functor, A]: F[Option[A]] => F[A] =
\end_layout

\begin_layout Plain Layout

    _.filter(_.nonEmpty).map(_.get)
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
 & \text{deflate}:\xymatrix{\xyScaleX{4.5pc}F^{\bbnum 1+A}\ar[r]\sp(0.5){\text{filt}_{F}(\text{nonEmpty)}} & F^{\bbnum 1+A}\ar[r]\sp(0.5){\text{get}^{\uparrow F}} & F^{A}}
\nonumber \\
 & \text{deflate}^{:F^{\bbnum 1+A}\rightarrow F^{A}}=\text{filt}_{F}(\text{nonEmpty})\bef\text{get}^{\uparrow F}\quad.\label{eq:def-deflate-via-filter}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 is a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function
\end_layout

\end_inset

partial function and will fail on empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 values (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

).
 However, it is safe to use 
\begin_inset Formula $\text{get}^{\uparrow F}$
\end_inset

 here, because the partial function law of filtering guarantees that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter(_.nonEmpty)
\end_layout

\end_inset

 will prevent 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 from being applied to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 values.
 Because of this, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is a 
\emph on
total
\emph default
 function when defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

), as long as 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 obeys its partial function law.
\end_layout

\begin_layout Standard
The ability to express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 means that a functor's filtering logic is fully described as long as we
 know how to exclude empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 values from 
\begin_inset Formula $F^{\bbnum 1+A}$
\end_inset

 and convert the result to 
\begin_inset Formula $F^{A}$
\end_inset

.
 We can define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 typeclass through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

, providing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 as extension methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

abstract class Filterable[F[_]: Functor] {    // Need a `Functor` instance
 to use `.map`.
\end_layout

\begin_layout Plain Layout

  def deflate[A]: F[Option[A]] => F[A]   // Typeclass instances will implement
 `deflate`.
\end_layout

\begin_layout Plain Layout

  def filt[A](p: A => Boolean)(fa: F[A]): F[A] = deflate(fa.map(x => Some(x).filte
r(p)))
\end_layout

\begin_layout Plain Layout

} // Typeclass instances do not have to implement `filt` but may override
 it for performance reasons.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit class FilterableSyntax[F[_]: Filterable, A](fa: F[Option[A]]) {
\end_layout

\begin_layout Plain Layout

  def deflate: F[A] = implicitly[Filterable[F]].deflate(fa)
\end_layout

\begin_layout Plain Layout

  def withFilter(p: A => Boolean): F[A] = implicitly[Filterable[F]].filt(p)(fa)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ff-deflate-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ff-deflate-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 to implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 instance for the functor 
\begin_inset Formula $F^{A}\triangleq Z\rightarrow\text{List}^{A}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is implemented as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = Z => List[A]   // The type Z must be defined before.
\end_layout

\begin_layout Plain Layout

def deflateF[A](fa: F[Option[A]]): F[A] = { z => fa(z).flatten }
\end_layout

\end_inset

We used Scala's library method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 with the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Option[A]] => Seq[A]
\end_layout

\end_inset

.
 This method is defined for all sequences, similarly to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method that has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Seq[A]] => Seq[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Using this function, we implement the typeclass instance as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val filterableF = new Filterable[F] {
\end_layout

\begin_layout Plain Layout

  def deflate[A]: F[Option[A]] => F[A] = deflateF
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ff-deflate-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ff-deflate-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 for the functor 
\begin_inset Formula $F^{A}\triangleq A\times A+(Z\rightarrow Z)$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is 
\begin_inset Formula $F^{\bbnum 1+A}\rightarrow F^{A}$
\end_inset

 and can be implemented, e.g., as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = Either[(A, A), Z => Z]   // The type Z must be defined before.
\end_layout

\begin_layout Plain Layout

def deflateF[A]: F[Option[A]] => F[A] = { // Pattern-match on Either[(Option[A],
 Option[A]), Z => Z].
\end_layout

\begin_layout Plain Layout

  case Left((Some(a1), Some(a2)))   => Left((a1, a2))   // Both values pass
 the filter.
\end_layout

\begin_layout Plain Layout

  case Left(_)                      => Right(identity)  // We can use a
 fixed value of type Z => Z.
\end_layout

\begin_layout Plain Layout

  case Right(zz)                    => Right(zz)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code implements a 
\begin_inset Quotes eld
\end_inset

greedy
\begin_inset Quotes erd
\end_inset

 filter that requires both values in the pair 
\begin_inset Formula $A\times A$
\end_inset

 to satisfy the predicate.
 Otherwise, the filter returns the special 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 value 
\begin_inset Formula $\bbnum 0^{:A\times A}+\text{id}^{:Z\rightarrow Z}$
\end_inset

 of type 
\begin_inset Formula $F^{A}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ff-deflate-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ff-deflate-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 to verify that the functor 
\begin_inset Formula $F^{A}\triangleq A+A\times A\times\text{String}$
\end_inset

 is not filterable.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We begin by checking whether the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 can be implemented:
\begin_inset Formula 
\[
\text{deflate}_{F}:\bbnum 1+A+\left(\bbnum 1+A\right)\times\left(\bbnum 1+A\right)\times\text{String}\rightarrow A+A\times A\times\text{String}\quad.
\]

\end_inset

An immediate problem is that we need to map all disjunctive cases, including
 
\begin_inset Formula $\bbnum 1+0+0$
\end_inset

, into a value of type 
\begin_inset Formula $F^{A}$
\end_inset

, which contains values of type 
\begin_inset Formula $A$
\end_inset

 in every disjunctive case.
 So, implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 requires us to produce a value of type 
\begin_inset Formula $A$
\end_inset

 from scratch, 
\begin_inset Formula $\forall A.\,\bbnum 1\rightarrow A$
\end_inset

, which is impossible in a fully parametric function.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is not implementable, the functor 
\begin_inset Formula $F$
\end_inset

 is not filterable.
\end_layout

\begin_layout Standard
These examples show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is easier to implement and to reason about than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Equivalence of 
\family typewriter
filter
\family default
 and 
\family typewriter
deflate
\family default

\begin_inset CommandInset label
LatexCommand label
name "subsec:Equivalence-of-filter-and-deflate"

\end_inset


\end_layout

\begin_layout Standard
We have expressed 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-filter-through-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Are the types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 equivalent? It turns out that Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-filter-through-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are inverses of each other only if we assume certain laws.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filter-to-deflate-equivalence"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filter-to-deflate-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Begin with a filterable functor 
\begin_inset Formula $F$
\end_inset

's function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 through Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and then define a new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-filter-through-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence!examples
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{deflate}=\text{filt}_{F}(\text{nonEmpty})\bef\text{get}^{\uparrow F}\quad,\quad\quad\text{filter}^{\prime}(p)=\psi_{p}^{\uparrow F}\bef\text{deflate}\quad.
\]

\end_inset

Then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, assuming that the partial function law holds.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{filt}_{F}(p)$
\end_inset

 is the same as 
\begin_inset Formula $\text{filter}^{\prime}(p)$
\end_inset

 for any predicate 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

:
\begin_inset Formula 
\begin{align}
\text{expect to equal }\text{filt}_{F}(p):\quad & \text{filter}^{\prime}(p)=\gunderline{\psi_{p}^{\uparrow F}\bef\text{filt}_{F}}(\text{nonEmpty})\bef\text{get}^{\uparrow F}\nonumber \\
\text{naturality law of }\text{filt}_{F}:\quad & =\text{filt}_{F}(\psi_{p}\bef\text{nonEmpty})\bef\gunderline{\psi_{p}^{\uparrow F}\bef\text{get}^{\uparrow F}}\nonumber \\
\text{composition law of }F:\quad & =\text{filt}_{F}(\psi_{p}\bef\text{nonEmpty})\bef\big(\psi_{p}\bef\text{get}\big)^{\uparrow F}\quad.\label{eq:filter-prime-derivation-1}
\end{align}

\end_inset

To proceed with the calculation, we need to simplify the two expressions
 
\begin_inset Formula $\psi_{p}\bef\text{nonEmpty}$
\end_inset

 and 
\begin_inset Formula $\psi_{p}\bef\text{get}$
\end_inset

.
 Begin with writing the code for the standard methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nonEmpty
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

, using the equivalent type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Unit]
\end_layout

\end_inset

 (i.e., 
\begin_inset Formula $\bbnum 1+\bbnum 1$
\end_inset

) instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 (i.e., 
\begin_inset Formula $\bbnum 2$
\end_inset

):
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def nonEmpty[A]: Option[A] => Option[Unit] = _.map(_ => ())  // Option[Unit]
 $
\backslash
color{dkgreen}
\backslash
cong$ Boolean
\end_layout

\begin_layout Plain Layout

def get[A]: Option[A] => A = { case Some(a) => a }
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
 & \text{nonEmpty}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1\,(\text{false}) & \bbnum 1\,(\text{true})\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & (\_^{:A}\rightarrow1)
\end{array}\,=\,\begin{array}{|c||c|}
 & \bbnum 2\\
\hline \bbnum 1 & \_\rightarrow\text{false}\\
A & \_\rightarrow\text{true}
\end{array}\quad,\quad\quad\text{get}^{:\bbnum 1+A\rightarrow A}\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & \text{id}
\end{array}\quad.\label{eq:def-of-nonEmpty-and-get}
\end{align}

\end_inset

These methods are fully parametric since their code is defined purely through
 the eight standard code constructions of functional programming (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

), with no externally defined types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 The function 
\begin_inset Formula $\psi$
\end_inset

 is also fully parametric since we can write it as:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def psi[A](p: A => Option[Unit]): A => Option[A] = x => p(x).map(_ => x)
  // Option[Unit] $
\backslash
color{dkgreen}
\backslash
cong$ Boolean
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{view }p^{:A\rightarrow\bbnum 2}(x^{:A})\text{ as having type }\bbnum 1+\bbnum 1:\quad & x^{:A}\triangleright\psi_{p}\triangleq p(x)\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1\,(\text{false}) & \text{id} & \bbnum 0\\
\bbnum 1\,(\text{true}) & \bbnum 0 & 1\rightarrow x
\end{array}\quad.
\end{align*}

\end_inset

We may write that code equivalently as 
\begin_inset Formula $\text{nonEmpty}\triangleq(\_^{:A}\rightarrow1)^{\uparrow\text{Opt}}$
\end_inset

 and 
\begin_inset Formula $\psi_{p}(x)\triangleq x\triangleright p\bef(1\rightarrow x)^{\uparrow\text{Opt}}$
\end_inset

.
\end_layout

\begin_layout Standard
Now we compute the function compositions we need.
 First, we show that 
\begin_inset Formula $\psi_{p}\bef\text{nonEmpty}=p$
\end_inset

:
\begin_inset Formula 
\begin{align}
\text{expect to equal }x\triangleright p:\quad & x^{:A}\triangleright\psi_{p}\bef\text{nonEmpty}\nonumber \\
 & =x\triangleright p\bef(1\rightarrow x)^{\uparrow\text{Opt}}\bef(\_^{:A}\rightarrow1)^{\uparrow\text{Opt}}\nonumber \\
\text{composition under }^{\uparrow\text{Opt}}:\quad & =x\triangleright p\bef(\gunderline{1\rightarrow1})^{\uparrow\text{Opt}}\nonumber \\
\text{identity function of type }\bbnum 1\rightarrow\bbnum 1:\quad & =x\triangleright p\bef\big(\text{id}^{:\bbnum 1\rightarrow\bbnum 1}\gunderline{\big)^{\uparrow\text{Opt}}}\nonumber \\
\text{identity law of }\text{Opt}:\quad & =x\triangleright p\bef\text{id}=x\triangleright p\quad.\label{eq:composition-of-psi-p-and-nonEmpty-simplified}
\end{align}

\end_inset

The expression 
\begin_inset Formula $\psi_{p}\bef\text{get}$
\end_inset

 is simplified to the partial function 
\begin_inset Formula $\text{id}_{|p}$
\end_inset

 by matrix composition:
\begin_inset Formula 
\begin{align}
\text{definitions of }\psi_{p}\text{ and }\text{get}:\quad & \gunderline{x^{:A}\triangleright\psi_{p}}\bef\gunderline{\text{get}}=p(x)\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1\,(\text{false}) & \text{id} & \bbnum 0\\
\bbnum 1\,(\text{true}) & \bbnum 0 & 1\rightarrow x
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & \text{id}
\end{array}\nonumber \\
\text{matrix composition}:\quad & =p(x)\triangleright\,\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1\,(\text{false}) & \bbnum 0\\
\bbnum 1\,(\text{true}) & 1\rightarrow x
\end{array}\nonumber \\
\text{use Eq.~(\ref{eq:def-partial-f}) as definition of }_{|p}:\quad & =x\triangleright\text{id}_{|p}\quad.\label{eq:composition-of-psi-p-and-get-simplified}
\end{align}

\end_inset

The same derivation performed in Scala syntax looks like this:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

psi(p)(x).get    // Expand the code for `psi` and `get`:
\end_layout

\begin_layout Plain Layout

== p(x) match {
\end_layout

\begin_layout Plain Layout

     case false  => None
\end_layout

\begin_layout Plain Layout

     case true   => Some(x)
\end_layout

\begin_layout Plain Layout

   }) match {
\end_layout

\begin_layout Plain Layout

     case Some(x)  => x
\end_layout

\begin_layout Plain Layout

   }             // Compute function composition:
\end_layout

\begin_layout Plain Layout

         == p(x) match { case true => x }   // Rewrite this code equivalently
 as 
\end_layout

\begin_layout Plain Layout

         == x match { case x if p(x) => x } // $
\backslash
color{dkgreen}x
\backslash
triangleright
\backslash
text{id}_{|p}$
\end_layout

\end_inset

We can now finish the calculation in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:filter-prime-derivation-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{filt}_{F}(p):\quad & \text{filter}^{\prime}(p)=\text{filt}_{F}(\gunderline{\psi_{p}\bef\text{nonEmpty}})\bef(\gunderline{\psi_{p}\bef\text{get}})^{\uparrow F}\\
\text{simplify using Eqs.~(\ref{eq:composition-of-psi-p-and-nonEmpty-simplified})--(\ref{eq:composition-of-psi-p-and-get-simplified}) }:\quad & =\text{filt}_{F}(p)\bef(\gunderline{\text{id}_{|p}})^{\uparrow F}\\
\text{partial function law~(\ref{eq:partial-function-law-of-filter}) of }\text{filt}_{F}:\quad & =\text{filt}_{F}(p)\bef\gunderline{(\text{id})^{\uparrow F}}\\
\text{identity law of }F:\quad & =\text{filt}_{F}(p)\,\gunderline{\bef\text{id}}=\text{filt}_{F}(p)\quad.
\end{align*}

\end_inset

So, the new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 equals the original 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-deflate-to-filter-equivalence"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-deflate-to-filter-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Beginning with a given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 function, define the corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-filter-through-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to define a new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

:
\begin_inset Formula 
\[
\text{filt}_{F}(p)=\psi_{p}^{\uparrow F}\bef\text{deflate}\quad,\quad\quad\text{deflate}^{\prime}=\text{filt}_{F}(\text{nonEmpty})\bef\text{get}^{\uparrow F}\quad.
\]

\end_inset

Then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

, assuming that the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Try showing that the new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{deflate}^{\prime}=\text{filt}_{F}(\text{nonEmpty})\bef\text{get}^{\uparrow F}=\psi_{\text{nonEmpty}}^{\uparrow F}\bef\text{deflate}\bef\text{get}^{\uparrow F}\overset{?}{=}\text{deflate}\quad.\label{eq:deflate-prime-derivation-2}
\end{equation}

\end_inset

The derivation is stuck here: we cannot simplify the last expression unless
 we can somehow switch the order of function compositions so that 
\begin_inset Formula $\psi_{\text{nonEmpty}}^{\uparrow F}$
\end_inset

 and 
\begin_inset Formula $\text{get}^{\uparrow F}$
\end_inset

 are placed together and the functor composition law of 
\begin_inset Formula $F$
\end_inset

 can be applied.
 To achieve that, we need a law that switches the order of lifted function
 compositions around 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

.
 The naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 has that form, so we can try deriving a similar naturality law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

.
 To switch the order of composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 with a lifted function, the law must have the form:
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "30col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.0pc}\xyScaleX{5.0pc}F^{\bbnum 1+A}\ar[r]\sp(0.5){\text{deflate}} & F^{A}\ar[d]\sb(0.45){f^{\uparrow F}}\\
\text{???}\ar[r]\sp(0.5){\text{deflate}} & F^{B}
}
\]

\end_inset


\begin_inset VSpace 30baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -45baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{deflate}\bef f^{\uparrow F}=(\text{???})^{\uparrow F}\bef\text{deflate}\quad,
\]

\end_inset

as illustrated by the type diagram on the left.
 The types will match in the right-hand side only if the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

deflate
\end_layout

\end_inset

 is of type 
\begin_inset Formula $F^{\bbnum 1+B}$
\end_inset

.
 So, the law must have the form: 
\begin_inset Formula 
\[
\text{deflate}\bef f^{\uparrow F}=(\text{???}^{:\bbnum 1+A\rightarrow\bbnum 1+B})^{\uparrow F}\bef\text{deflate}\quad.
\]

\end_inset

The typed hole 
\begin_inset Formula $\text{???}^{:\bbnum 1+A\rightarrow\bbnum 1+B}$
\end_inset

 must be filled with a value, say, 
\begin_inset Formula $g^{:\bbnum 1+A\rightarrow\bbnum 1+B}$
\end_inset

, which is somehow related to 
\begin_inset Formula $f$
\end_inset

.
 The only way to obtain 
\begin_inset Formula $g$
\end_inset

 is to lift the function 
\begin_inset Formula $f$
\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Option
\end_layout

\end_inset

 functor, i.e., to define 
\begin_inset Formula $g\triangleq f^{\uparrow\text{Opt}}$
\end_inset

.
 So, the 
\series bold
naturality law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
deflate
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

deflate
\end_layout

\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "30col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5.0pc}F^{\bbnum 1+A}\ar[r]\sp(0.5){\text{deflate}}\ar[d]\sp(0.45){(f^{\uparrow\text{Opt}})^{\uparrow F}} & F^{A}\ar[d]\sb(0.45){f^{\uparrow F}}\\
F^{\bbnum 1+B}\ar[r]\sp(0.5){\text{deflate}} & F^{B}
}
\]

\end_inset


\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -45baselineskip%
\end_inset


\begin_inset Formula 
\begin{equation}
\text{deflate}\bef f^{\uparrow F}=f^{\uparrow\text{Opt}\uparrow F}\bef\text{deflate}\quad,\label{eq:naturality-law-of-deflate}
\end{equation}

\end_inset

where 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is an arbitrary function.
 
\end_layout

\begin_layout Standard
Assuming that the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds, we continue the derivation in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:deflate-prime-derivation-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) towards showing that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align}
\text{expect to equal }\text{deflate}:\quad & \text{deflate}^{\prime}=\psi_{\text{nonEmpty}}^{\uparrow F}\bef\gunderline{\text{deflate}\bef\text{get}^{\uparrow F}}\nonumber \\
\text{naturality law~(\ref{eq:naturality-law-of-deflate}) of }\text{deflate}:\quad & =\gunderline{\psi_{\text{nonEmpty}}^{\uparrow F}\bef\text{get}^{\uparrow\text{Opt}\uparrow F}}\bef\text{deflate}\nonumber \\
\text{composition law of }F:\quad & =\big(\psi_{\text{nonEmpty}}\bef\text{get}^{\uparrow\text{Opt}}\big)^{\uparrow F}\bef\text{deflate}\quad.\label{eq:deflate-derivation-3}
\end{align}

\end_inset

We now need to perform a separate calculation in order to simplify the function
 
\begin_inset Formula $\psi_{\text{nonEmpty}}\bef\text{get}^{\uparrow\text{Opt}}$
\end_inset

, which must be a function of type 
\begin_inset Formula $\bbnum 1+A\rightarrow\bbnum 1+A$
\end_inset

 for the types to match.
 Writing this calculation in Scala syntax, we obtain (skipping some steps
 for brevity):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

psi[Option[A]](nonEmpty)(x).map(get) == (nonEmpty(x) match {
\end_layout

\begin_layout Plain Layout

  case false   => None
\end_layout

\begin_layout Plain Layout

  case true    => Some(x)
\end_layout

\begin_layout Plain Layout

}).map { case Some(y) => y } == // Expand code for `nonEmpty`.
\end_layout

\begin_layout Plain Layout

( ( x match {
\end_layout

\begin_layout Plain Layout

      case None    => false
\end_layout

\begin_layout Plain Layout

      case Some(_) => true
\end_layout

\begin_layout Plain Layout

    }) match {
\end_layout

\begin_layout Plain Layout

        case false   => None
\end_layout

\begin_layout Plain Layout

        case true    => Some(x)  // This will be of the form Some(Some(y)).
\end_layout

\begin_layout Plain Layout

}).map { case Some(y) => y } ==  // Compute all function compositions.
\end_layout

\begin_layout Plain Layout

  x match {
\end_layout

\begin_layout Plain Layout

    case None    => None
\end_layout

\begin_layout Plain Layout

    case Some(y) => Some(y)
\end_layout

\begin_layout Plain Layout

  } == x  // Identity function applied to `x`.
\end_layout

\end_inset

To perform the same calculation in the code notation, we first prepare a
 formula for the lifting operation 
\begin_inset Formula $^{\uparrow\text{Opt}}$
\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 functor:
\begin_inset Formula 
\begin{equation}
(h^{:C\rightarrow D})^{\uparrow\text{Opt}}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & D\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
C & \bbnum 0 & h
\end{array}\quad,\text{ so }\quad\quad\text{get}^{\uparrow\text{Opt}}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1+A & \bbnum 0 & \text{get}
\end{array}\,=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1 & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \text{id}
\end{array}\quad,\label{eq:def-of-get-lifted-Option}
\end{equation}

\end_inset

where we expanded the matrix to accommodate the disjunctive type 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 Then we compute:
\begin_inset Formula 
\begin{align*}
 & x^{:\bbnum 1+A}\triangleright\psi_{\text{nonEmpty}}=\gunderline{\text{nonEmpty}\left(x\right)}\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & \bbnum 1+A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1 & \bbnum 0 & 1\rightarrow x
\end{array}\\
\text{definition~(\ref{eq:def-of-nonEmpty-and-get})}:\quad & =x\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & \bbnum 1\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \_\rightarrow1
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & \bbnum 1+A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1 & \bbnum 0 & 1\rightarrow x
\end{array}\\
\text{matrix composition}:\quad & =x\triangleright\,\,\begin{array}{|c||cc|}
 & \bbnum 1 & \bbnum 1+A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \_\rightarrow x
\end{array}\,=x\triangleright\,\begin{array}{|c||ccc|}
 & \bbnum 1 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\quad.
\end{align*}

\end_inset

The last matrix was derived using the fact that 
\begin_inset Formula $x$
\end_inset

 matches the bottom row where the type is 
\begin_inset Formula $\bbnum 0+A$
\end_inset

.
 Finally:
\begin_inset Formula 
\begin{align}
 & x^{:\bbnum 1+A}\triangleright\psi_{\text{nonEmpty}}\bef\text{get}^{\uparrow\text{Opt}}=x\triangleright\,\begin{array}{|c||ccc|}
 & \bbnum 1 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\,\bef\gunderline{\text{get}^{\uparrow\text{Opt}}}\nonumber \\
\text{use Eq.~(\ref{eq:def-of-get-lifted-Option})}:\quad & =x\triangleright\,\begin{array}{|c||ccc|}
 & \bbnum 1 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1 & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \text{id}
\end{array}\,=x\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \text{id}
\end{array}\,=x\triangleright\text{id}=x\quad.\label{eq:simplify-psi-nonEmpty-get-opt}
\end{align}

\end_inset

So, we find 
\begin_inset Formula $\psi_{\text{nonEmpty}}\bef\text{get}^{\uparrow\text{Opt}}=\text{id}$
\end_inset

 and thus Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:deflate-derivation-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) gives 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We conclude that the types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 are equivalent as long as the partial function law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:partial-function-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-partial-functionlaw-deflate-to-filter"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-partial-functionlaw-deflate-to-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The partial function law always holds for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 function, define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 through Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-filter-through-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then the partial function law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:partial-function-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is transformed into an equation illustrated by the following diagram:
 
\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.1pc}\xyScaleX{2.8pc} & F^{\bbnum 1+A}\ar[r]\sp(0.5){\text{deflate}} & F^{A}\ar[rd]\sp(0.5){~(f^{:A\rightarrow B})^{\uparrow F}}\\
F^{A}\ar[ru]\sp(0.5){\psi_{p}^{\uparrow F}}\ar[rd]\sb(0.5){\psi_{p}^{\uparrow F}} &  &  & F^{B} & \psi_{p}^{\uparrow F}\bef\text{deflate}\bef f^{\uparrow F}=\psi_{p}^{\uparrow F}\bef\text{deflate}\bef f_{|p}^{\uparrow F}\quad.\\
 & F^{\bbnum 1+A}\ar[r]\sp(0.5){\text{deflate}} & F^{A}\ar[ru]\sb(0.5){(f_{|p}^{:A\rightarrow B})^{\uparrow F}}
}
\]

\end_inset


\end_layout

\end_inset

To show that the law holds, we transform both sides using the naturality
 law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \psi_{p}^{\uparrow F}\bef\gunderline{\text{deflate}\bef f^{\uparrow F}}=\gunderline{\psi_{p}^{\uparrow F}\bef f^{\uparrow\text{Opt}\uparrow F}}\bef\text{deflate}=\big(\psi_{p}\bef f^{\uparrow\text{Opt}}\big)^{\uparrow F}\bef\text{deflate}\quad.\\
\text{right-hand side}:\quad & \psi_{p}^{\uparrow F}\bef\gunderline{\text{deflate}\bef f_{|p}^{\uparrow F}}=\gunderline{\psi_{p}^{\uparrow F}\bef f_{|p}^{\uparrow\text{Opt}\uparrow F}}\bef\text{deflate}=\big(\psi_{p}\bef f_{|p}^{\uparrow\text{Opt}}\big)^{\uparrow F}\bef\text{deflate}\quad.
\end{align*}

\end_inset

It remains to show that 
\begin_inset Formula $\psi_{p}\bef f_{|p}^{\uparrow\text{Opt}}=\psi_{p}\bef f^{\uparrow\text{Opt}}$
\end_inset

.
 Apply the function 
\begin_inset Formula $\psi_{p}\bef f^{\uparrow\text{Opt}}$
\end_inset

 to an 
\begin_inset Formula $x^{:A}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset VSpace 15baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

psi(p)(x).map(f) == (p(x) match {
\end_layout

\begin_layout Plain Layout

  case false   => None
\end_layout

\begin_layout Plain Layout

  case true    => Some(x)
\end_layout

\begin_layout Plain Layout

}) match {
\end_layout

\begin_layout Plain Layout

  case None    => None
\end_layout

\begin_layout Plain Layout

  case Some(y) => Some(f(y))
\end_layout

\begin_layout Plain Layout

}  == p(x) match {
\end_layout

\begin_layout Plain Layout

  case false   => None
\end_layout

\begin_layout Plain Layout

  case true    => Some(f(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The same calculation in the code notation looks like this:
\begin_inset Formula 
\begin{align*}
x^{:A}\triangleright\psi_{p}\bef f^{\uparrow\text{Opt}} & =p(x)\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1\,(\text{false}) & \text{id} & \bbnum 0\\
\bbnum 1\,(\text{true}) & \bbnum 0 & 1\rightarrow x
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & f
\end{array}\\
 & =p(x)\triangleright\,\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1\,(\text{false}) & \text{id} & \bbnum 0\\
\bbnum 1\,(\text{true}) & \bbnum 0 & 1\rightarrow f(x)
\end{array}\quad.
\end{align*}

\end_inset

In the last expression, the function 
\begin_inset Formula $f$
\end_inset

 is applied to 
\begin_inset Formula $x$
\end_inset

 only when 
\begin_inset Formula $p(x)=\text{true}$
\end_inset

.
 So, the result will be the same if we replace 
\begin_inset Formula $f(x)$
\end_inset

 by the partial function 
\begin_inset Formula $f_{|p}(x)$
\end_inset

, which was defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-partial-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to be equal to 
\begin_inset Formula $f(x)$
\end_inset

 when 
\begin_inset Formula $p(x)$
\end_inset

 holds.
 It follows that 
\begin_inset Formula $\psi_{p}\bef f_{|p}^{\uparrow\text{Opt}}=\psi_{p}\bef f^{\uparrow\text{Opt}}$
\end_inset

, concluding the proof.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The equivalence between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 extend to their respective naturality laws.
 In other words, the naturality laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 hold at the same time.
 We only need to check the naturality law for one of these two functions;
 the other naturality law will then hold automatically.
 The following statement proves this equivalence in one direction:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-naturality-law-of-deflate-from-filter"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-naturality-law-of-deflate-from-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will also hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 if it is defined through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Compare the two sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side of Eq.~(\ref{eq:naturality-law-of-deflate})}:\quad & f^{\uparrow\text{Opt}\uparrow F}\bef\gunderline{\text{deflate}}=\gunderline{f^{\uparrow\text{Opt}\uparrow F}\bef\text{filt}_{F}(\text{nonEmpty})}\bef\text{get}^{\uparrow F}\\
\text{naturality law~(\ref{eq:naturality-law-of-filter}) of }\text{filt}_{F}:\quad & \quad=\text{filt}_{F}(f^{\uparrow\text{Opt}}\bef\text{nonEmpty})\bef f^{\uparrow\text{Opt}\uparrow F}\bef\text{get}^{\uparrow F}\quad.\\
\text{right-hand side of Eq.~(\ref{eq:naturality-law-of-deflate})}:\quad & \gunderline{\text{deflate}}\bef f^{\uparrow F}=\text{filt}_{F}(\text{nonEmpty})\bef\text{get}^{\uparrow F}\bef f^{\uparrow F}\quad.
\end{align*}

\end_inset

The two sides will be equal if we prove that 
\begin_inset Formula $f^{\uparrow\text{Opt}}\bef\text{nonEmpty}=\text{nonEmpty}$
\end_inset

 and that 
\begin_inset Formula $f^{\uparrow\text{Opt}}\bef\text{get}=\text{get}\bef f$
\end_inset

, which can be viewed as the two naturality laws specific to these functions.
 Use the definitions
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-nonEmpty-and-get"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nonEmpty
\end_layout

\end_inset

, set the type parameters as needed to match the types, and compute:
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow\text{Opt}}\bef\text{nonEmpty}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & B\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & f
\end{array}\,\bef\,\begin{array}{|c||c|}
 & \bbnum 2\\
\hline \bbnum 1 & \_\rightarrow\text{false}\\
B & \_\rightarrow\text{true}
\end{array}\,=\,\begin{array}{|c||c|}
 & \bbnum 2\\
\hline \bbnum 1 & \_\rightarrow\text{false}\\
A & \_\rightarrow\text{true}
\end{array}\,=\text{nonEmpty}\quad,\\
 & f^{\uparrow\text{Opt}}\bef\text{get}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & B\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & f
\end{array}\,\bef\,\begin{array}{|c||c|}
 & B\\
\hline \bbnum 1 & \bbnum 0\\
B & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & B\\
\hline \bbnum 1 & \bbnum 0\\
A & f
\end{array}\quad,\\
 & \text{get}\bef f=\,\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & \text{id}
\end{array}\,\bef\,f^{:A\rightarrow B}=\,\begin{array}{|c||c|}
 & B\\
\hline \bbnum 1 & \bbnum 0\\
A & \text{id}\bef f
\end{array}\,=\,\begin{array}{|c||c|}
 & B\\
\hline \bbnum 1 & \bbnum 0\\
A & f
\end{array}\,=f^{\uparrow\text{Opt}}\bef\text{get}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We have just shown that the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 guarantees that the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 holds.
 To show that the naturality laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 are equivalent, it remains to show that the converse statement is also
 true:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-naturality-for-deflate-entails-naturality-for-filter"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-naturality-for-deflate-entails-naturality-for-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 and the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-filter-through-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) then the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Begin by writing the two sides of the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side of Eq.~(\ref{eq:naturality-law-of-filter})}:\quad & f^{\uparrow F}\bef\gunderline{\text{filt}\,(p)}=\gunderline{f^{\uparrow F}\bef\psi_{p}^{\uparrow F}}\bef\text{deflate}=(f\bef\psi_{p})^{\uparrow F}\bef\text{deflate}\quad.\\
\text{right-hand side of Eq.~(\ref{eq:naturality-law-of-filter})}:\quad & \text{filt}\,(f\bef p)\bef f^{\uparrow F}=\psi_{(f\bef p)}^{\uparrow F}\bef\gunderline{\text{deflate}\bef f^{\uparrow F}}\\
\text{naturality law~(\ref{eq:naturality-law-of-deflate}) of }\text{deflate}:\quad & \quad=\gunderline{\psi_{(f\bef p)}^{\uparrow F}\bef f^{\uparrow\text{Opt}\uparrow F}}\bef\text{deflate}=(\psi_{(f\bef p)}\bef f^{\uparrow\text{Opt}})^{\uparrow F}\bef\text{deflate}\quad.
\end{align*}

\end_inset

The remaining difference is in the order of composition of 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

.
 The proof will be complete if we show that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $p^{:B\rightarrow\bbnum 2}$
\end_inset

,
\begin_inset Formula 
\begin{equation}
f\bef\psi_{p}=\psi_{(f\bef p)}\bef f^{\uparrow\text{Opt}}\quad.\label{eq:naturality-law-of-psi}
\end{equation}

\end_inset

This equation can be viewed as a naturality law specific to the function
 
\begin_inset Formula $\psi$
\end_inset

.
 To prove Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

), it is convenient to use a definition of 
\begin_inset Formula $\psi_{p}$
\end_inset

 that represents 
\begin_inset Formula $p$
\end_inset

 as a function of type 
\begin_inset Formula $A\rightarrow\bbnum 1+\bbnum 1\cong A\rightarrow\text{Opt}^{\bbnum 1}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
x^{:A}\triangleright\psi_{p}\triangleq x^{:A}\triangleright p^{:A\rightarrow\text{Opt}^{\bbnum 1}}\bef(1\rightarrow x)^{\uparrow\text{Opt}}\quad.\label{eq:def-of-psi}
\end{equation}

\end_inset

Using this definition of 
\begin_inset Formula $\psi_{p}$
\end_inset

, we can derive Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by applying both sides to an 
\begin_inset Formula $x^{:A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & x\triangleright f\bef\psi_{p}=x\triangleright f\triangleright\psi_{p}\\
\text{use Eq.~(\ref{eq:def-of-psi})}:\quad & \quad=x\triangleright f\triangleright p\bef(1\rightarrow x\triangleright f)^{\uparrow\text{Opt}}=x\triangleright f\bef p\bef(1\rightarrow x\triangleright f)^{\uparrow\text{Opt}}\quad.\\
\text{right-hand side}:\quad & x\triangleright\psi_{(f\bef p)}\bef f^{\uparrow\text{Opt}}\\
\text{use Eq.~(\ref{eq:def-of-psi})}:\quad & \quad=x\triangleright f\bef p\bef\gunderline{(1\rightarrow x)^{\uparrow\text{Opt}}\bef f^{\uparrow\text{Opt}}}\\
\text{composition law of }\text{Opt}:\quad & \quad=x\triangleright f\bef p\bef\big(\gunderline{(1\rightarrow x)\bef f}\big)^{\uparrow\text{Opt}}\\
\text{compute composition}:\quad & \quad=x\triangleright f\bef p\bef(\gunderline{1\rightarrow x\triangleright f})^{\uparrow\text{Opt}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Motivation and laws for 
\family typewriter
liftOpt
\family default

\begin_inset CommandInset label
LatexCommand label
name "subsec:Motivation-and-laws-for-liftopt-and-equivalence"

\end_inset


\end_layout

\begin_layout Standard
In several derivations we just saw, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 was composed with 
\begin_inset Formula $\psi_{p}^{\uparrow F}$
\end_inset

 or another lifted function that mapped types as 
\begin_inset Formula $A\rightarrow\bbnum 1+A$
\end_inset

.
 This suggests considering a more general type signature, 
\begin_inset Formula $f^{:A\rightarrow\bbnum 1+B}$
\end_inset

, and composing 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 into a function that maps 
\begin_inset Formula $F^{A}\rightarrow F^{B}$
\end_inset

.
 It turns out that the resulting function, which we will call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 and denote by 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B]): F[A] => F[B] = _.map(f).deflate
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{F}^{A,B}(f^{:A\rightarrow\bbnum 1+B})\triangleq f^{\uparrow F}\bef\text{deflate}_{F}\quad,\label{eq:def-liftOpt-via-deflate}
\end{equation}

\end_inset

has simpler laws and is helpful for developing the theory of filterable
 functors.
\end_layout

\begin_layout Standard
The name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 (
\begin_inset Quotes eld
\end_inset

lifting from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) is motivated by the type signature:
\begin_inset Formula 
\[
\text{liftOpt}_{F}^{A,B}:\left(A\rightarrow\bbnum 1+B\right)\rightarrow F^{A}\rightarrow F^{B}\quad.
\]

\end_inset

This lifts a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Option[B]
\end_layout

\end_inset

 into a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] => F[B]
\end_layout

\end_inset

.
 Except for using a 
\begin_inset Quotes eld
\end_inset

twisted
\begin_inset Quotes erd
\end_inset

 type 
\begin_inset Formula $A\rightarrow\bbnum 1+B$
\end_inset

 instead of 
\begin_inset Formula $A\rightarrow B$
\end_inset

, this is similar to lifting via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function:
\begin_inset Formula 
\[
\text{fmap}_{F}^{A,B}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}\quad.
\]

\end_inset

As this chapter will show, similarities between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 go well beyond type signatures.
\end_layout

\begin_layout Standard
We will now derive some properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
 The definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is illustrated by the diagram:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{4.4pc}F^{A}\ar[r]\sp(0.5){(f^{:A\rightarrow\bbnum 1+B})^{\uparrow F}}\ar[rd]\sb(0.4){\text{liftOpt}\,(f)\triangleq~~} & F^{\bbnum 1+B}\ar[d]\sp(0.4){\text{deflate}}\\
 & F^{B}
}
\]

\end_inset

Since 
\begin_inset Formula $f$
\end_inset

 is arbitrary in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-liftOpt-via-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we may set 
\begin_inset Formula $f=\text{id}^{:A\rightarrow A}$
\end_inset

 and the type parameter 
\begin_inset Formula $A=\bbnum 1+B$
\end_inset

 to find:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}^{\bbnum 1+B,B}(\text{id}^{:\bbnum 1+B\rightarrow\bbnum 1+B})=\gunderline{\text{id}^{\uparrow F}}\bef\text{deflate}=\text{deflate}\quad.\label{eq:def-deflate-via-liftOpt}
\end{equation}

\end_inset

This expresses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

deflate
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

liftOpt
\end_layout

\end_inset

.
 Are these two functions equivalent?
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence!examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-liftOpt-equivalent-to-deflate"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-liftOpt-equivalent-to-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The types of functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

liftOpt
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

deflate
\end_layout

\end_inset

 are equivalent via Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-liftOpt-via-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), assuming that a naturality law (Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) below) holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to show that the equivalence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

liftOpt
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

deflate
\end_layout

\end_inset

 holds in both directions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 function, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 function via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-liftOpt-via-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 function via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then the new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 will be the same function as the initial 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 function, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 function via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 function via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 will be the same as the initial 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, assuming Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Proof for 
\series bold
(a)
\series default
 directly derives the formula 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $^{\prime}\negmedspace=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 by this calculation:
\begin_inset Formula 
\begin{align*}
\text{use Eq.~(\ref{eq:def-deflate-via-liftOpt}) to define }\text{deflate}^{\prime}:\quad & \text{deflate}^{\prime}=\text{liftOpt}\,(\text{id})\\
\text{use Eq.~(\ref{eq:def-liftOpt-via-deflate}) to define }\text{liftOpt}:\quad & =\gunderline{\text{id}^{\uparrow F}}\bef\text{deflate}=\text{deflate}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Proof for 
\series bold
(b)
\series default
 begins by expressing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 through the initial 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}^{\prime}(f)=f^{\uparrow F}\bef\text{deflate}=f^{\uparrow F}\bef\text{liftOpt}\,(\text{id})\quad.\label{eq:liftOpt-equivalent-deflate-derivation-1}
\end{equation}

\end_inset

If nothing is known about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, the calculation will get stuck at this point.
 To proceed, we need to assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 obeys a law that switches the order of function compositions around 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 and allows us to pull 
\begin_inset Formula $f$
\end_inset

 inside of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 in the equation above.
 Laws that switch the order of lifted function compositions are often naturality
 laws, as we have already seen.
 So, let us derive a suitable naturality law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, beginning with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 function defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

:
\begin_inset Formula 
\[
(h^{:A\rightarrow B})^{\uparrow F}\bef\text{liftOpt}^{B,C}(f^{:B\rightarrow\bbnum 1+C})=h^{\uparrow F}\bef f^{\uparrow F}\bef\text{deflate}=(h\bef f)^{\uparrow F}\bef\text{deflate}=\text{liftOpt}^{A,C}(h\bef f)\quad.
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{4.5pc}F^{A}\ar[d]\sb(0.5){h^{\uparrow F}}\ar[rd]\sp(0.5){~~\text{ liftOpt}\,(h\bef f)}\\
F^{B}\ar[r]\sp(0.42){\text{liftOpt}\,(f)} & F^{C}
}
\]

\end_inset

It follows that 
\emph on
if
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 were defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 would automatically satisfy the naturality law
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
liftOpt
\end_layout

\end_inset

 (see diagram at left):
\begin_inset Formula 
\begin{equation}
(h^{:A\rightarrow B})^{\uparrow F}\bef\text{liftOpt}_{F}^{B,C}(f^{:B\rightarrow\bbnum 1+C})=\text{liftOpt}_{F}^{A,C}(h^{:A\rightarrow B}\bef f^{:B\rightarrow\bbnum 1+C})\quad.\label{eq:left-naturality-law-of-liftOpt}
\end{equation}

\end_inset

This motivates 
\emph on
imposing
\emph default
 that law on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
 We can then finish the proof, resuming from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:liftOpt-equivalent-deflate-derivation-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{liftOpt}\,(f):\quad & \text{liftOpt}^{\prime}(f)=\gunderline{f^{\uparrow F}}\bef\text{liftOpt}\,(\gunderline{\text{id}})=\text{liftOpt}\,(\gunderline{f\bef\text{id}})=\text{liftOpt}\,(f)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-deflate-to-filter-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), it follows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is  equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
 The next step is to translate the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 into the corresponding laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
 Do the laws become simpler when formulated for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

?
\end_layout

\begin_layout Standard
We have already seen that the partial function law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is satisfied automatically when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-partial-functionlaw-deflate-to-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It appears that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 has only 
\begin_inset Formula $3$
\end_inset

 laws while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 has 
\begin_inset Formula $4$
\end_inset

.
 We will now show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 has only 
\begin_inset Formula $2$
\end_inset

 laws, and yet they are 
\emph on
equivalent
\emph default
 to the 
\begin_inset Formula $4$
\end_inset

 laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To see that, we first express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 and then finally through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{filt}\,(p^{:A\rightarrow\bbnum 2})=\psi_{p}^{\uparrow F}\bef\text{deflate}=\text{liftOpt}\,(\psi_{p})\quad.\label{eq:filter-via-liftOpt}
\end{equation}

\end_inset

Conversely, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 is expressed via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 like this:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}^{A,B}(f^{:A\rightarrow\bbnum 1+B})\triangleq f^{\uparrow F}\bef\text{deflate}=f^{\uparrow F}\bef\text{filt}\,(\psi_{\text{nonEmpty}})\quad,\label{eq:def-liftOpt-via-filter}
\end{equation}

\end_inset


\end_layout

\begin_layout Paragraph
Identity law
\end_layout

\begin_layout Standard
Let us now translate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

's identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the corresponding law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
 Begin by expressing 
\begin_inset Formula $\text{filt}\,(\_\rightarrow\text{true})$
\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:filter-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{filt}\,(\_\rightarrow\text{true})=\text{liftOpt}\,(\psi_{(\_\rightarrow\text{true})})=\text{liftOpt}\,(x^{:A}\rightarrow\bbnum 0+x)\quad.
\]

\end_inset

The function 
\begin_inset Formula $\psi_{(\_\rightarrow\text{true})}$
\end_inset

 is equivalent to a simpler function 
\begin_inset Formula $x^{:A}\rightarrow\bbnum 0+x$
\end_inset

 (i.e., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => Some(x)
\end_layout

\end_inset

 in Scala):
\begin_inset Formula 
\begin{align}
\text{use Eq.~(\ref{eq:def-of-psi})}:\quad & x^{:A}\triangleright\psi_{(\_\rightarrow\text{true})}=x^{:A}\triangleright(\_^{:A}\rightarrow\gunderline{\text{true}^{:\text{Opt}^{\bbnum 1}}})\bef(1\rightarrow x)^{\uparrow\text{Opt}}\nonumber \\
\text{use equivalence }\bbnum 0+1\cong\text{true}^{:\text{Opt}^{\bbnum 1}}:\quad & =\gunderline{x^{:A}\triangleright(\_^{:A}\rightarrow\bbnum 0+1)}\bef(1\rightarrow x)^{\uparrow\text{Opt}}\nonumber \\
\text{apply function to }x:\quad & =(\bbnum 0+1)\triangleright(1\rightarrow x)^{\uparrow\text{Opt}}=\begin{array}{||cc|}
\bbnum 0 & 1\end{array}\,\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1 & \bbnum 0 & 1\rightarrow x
\end{array}\nonumber \\
\text{substitute the row into the matrix}:\quad & =\,\begin{array}{||cc|}
\bbnum 0 & x\end{array}\,=\bbnum 0+x^{:A}\quad.\label{eq:psi-of-true-equals-Some-derivation}
\end{align}

\end_inset

So, we expect the 
\series bold
identity law
\series default
 of
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
liftOpt
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 to be:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}^{A,A}(x^{:A}\rightarrow\bbnum 0+x)=\text{id}^{:F^{A}\rightarrow F^{A}}\quad.\label{eq:identity-law-of-liftOpt}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-identity-law-of-liftOpt"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 obeys its naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 is defined via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-liftOpt-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

  obeys its identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 obeys its identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, defined via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:filter-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), obeys its law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Compute the identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}^{A}:\quad & \text{liftOpt}\,(x^{:A}\rightarrow\bbnum 0+x)=\gunderline{(x^{:A}\rightarrow\bbnum 0+x)^{\uparrow F}\bef\text{filt}^{\bbnum 1+A}}(\text{nonEmpty})\bef\text{get}^{\uparrow F}\\
\text{naturality law~(\ref{eq:naturality-law-of-filter})}:\quad & =\text{filt}^{A}\big(\gunderline{(x^{:A}\rightarrow\bbnum 0+x)\bef\text{nonEmpty}}\big)\bef(x^{:A}\rightarrow\bbnum 0+x)^{\uparrow F}\bef\text{get}^{\uparrow F}\\
\text{compute composition}:\quad & =\gunderline{\text{filt}^{A}(x^{:A}\rightarrow\text{true})}\bef(x^{:A}\rightarrow\bbnum 0+x)^{\uparrow F}\bef\text{get}^{\uparrow F}\\
\text{identity law~(\ref{eq:identity-law-of-filter})}:\quad & =\text{id}^{A}\bef\gunderline{(x^{:A}\rightarrow\bbnum 0+x)^{\uparrow F}\bef\text{get}^{\uparrow F}}=\big(\gunderline{(x^{:A}\rightarrow\bbnum 0+x)\bef\text{get}}\big)^{\uparrow F}\\
\text{compute composition}:\quad & =(\text{id}^{A})^{\uparrow F}=\text{id}^{A}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Compute the identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:psi-of-true-equals-Some-derivation"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{use Eq.~(\ref{eq:filter-via-liftOpt})}:\quad & \text{filt}\,(\_\rightarrow\text{true})=\text{liftOpt}\,(\psi_{(\_\rightarrow\text{true})})\\
\text{use Eq.~(\ref{eq:psi-of-true-equals-Some-derivation})}:\quad & =\text{liftOpt}\,(x\rightarrow\bbnum 0+x)\\
\text{use Eq.~(\ref{eq:identity-law-of-liftOpt})}:\quad & =\text{id}\quad.
\end{align*}

\end_inset

This completes the proof.
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $x^{:A}\rightarrow\bbnum 0+x$
\end_inset

 plays the role of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type, if we view 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[_]
\end_layout

\end_inset

 as a pointed functor (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Pointed-functors-motivation-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Denote that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method for brevity by 
\begin_inset Formula $\text{pu}_{\text{Opt}}$
\end_inset

:
\begin_inset Formula 
\[
\text{pu}_{\text{Opt}}^{:A\rightarrow\bbnum 1+A}\triangleq x^{:A}\rightarrow\bbnum 0+x\quad.
\]

\end_inset

Then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

's 
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
liftOpt
\end_layout

\end_inset

identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is written more concisely as:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{F}(\text{pu}_{\text{Opt}})=\text{id}\quad.\label{eq:identity-law-liftOpt-via-pure-puOpt}
\end{equation}

\end_inset

We can combine Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-liftOpt-via-pure-puOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into a single law if we compose the identity law with a lifted arbitrary
 function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\[
f^{\uparrow F}\bef\text{liftOpt}_{F}(\text{pu}_{\text{Opt}})=\text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})\quad.
\]

\end_inset

So the 
\begin_inset Quotes eld
\end_inset

combined
\begin_inset Quotes erd
\end_inset

 
\series bold
naturality-identity law
\series default
 of
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!combined with identity law
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 is:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{F}(f^{:A\rightarrow B}\bef\text{pu}_{\text{Opt}}^{B})=f^{\uparrow F}\quad.\label{eq:combined-naturality-identity-law-of-liftOpt}
\end{equation}

\end_inset


\end_layout

\begin_layout Paragraph
Composition law
\end_layout

\begin_layout Standard
Next, we translate Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into a corresponding law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
 That law needs to combine two predicates 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

 into a new predicate 
\begin_inset Formula $p(x)\triangleq p_{1}(x)\wedge p_{2}(x)$
\end_inset

.
 As Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:filter-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 uses a predicate 
\begin_inset Formula $p$
\end_inset

 only through the function 
\begin_inset Formula $\psi_{p}$
\end_inset

.
 So, we will derive the composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 if we somehow express 
\begin_inset Formula $\psi_{p}$
\end_inset

 as a combination of 
\begin_inset Formula $\psi_{p_{1}}$
\end_inset

 and 
\begin_inset Formula $\psi_{p_{2}}$
\end_inset

.
 Begin by writing:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

psi(p) == { x => Some(x).filter(p) } == { x => Some(x).filter(p1).filter(p2)
 }
\end_layout

\end_inset


\begin_inset Formula 
\[
\psi_{p}=x^{:A}\rightarrow(\bbnum 0+x)\triangleright\text{filt}_{\text{Opt}}(p)=x^{:A}\rightarrow(\bbnum 0+x)\triangleright\text{filt}_{\text{Opt}}(p_{1})\triangleright\text{filt}_{\text{Opt}}(p_{2})\quad.
\]

\end_inset

We need to transform this code into some sort of combination of the functions
 
\begin_inset Formula $\psi_{p_{1}}$
\end_inset

 and 
\begin_inset Formula $\psi_{p_{2}}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

psi(p1) == { x => Some(x).filter(p1) }
\end_layout

\begin_layout Plain Layout

psi(p2) == { x => Some(x).filter(p2) }
\end_layout

\end_inset

Since the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x).filter(p1)
\end_layout

\end_inset

 is still of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

, we may apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map(psi(p2))
\end_layout

\end_inset

 to that value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x => Some(x).filter(p1).map(y => Some(y).filter(p2)) // Type is Option[Option[A]].
\end_layout

\end_inset

Except for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[A]]
\end_layout

\end_inset

, the result is correct: a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 will be present within the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[A]]
\end_layout

\end_inset

 wrapper only if 
\emph on
both
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1(x)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2(x)
\end_layout

\end_inset

 return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 To convert the result to the required type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

, we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

psi(p) == x => Some(x).filter(p1).map { y => Some(y).filter(p2) }.flatten  
  // Use flatMap instead.
\end_layout

\begin_layout Plain Layout

       == x => Some(x).filter(p1).flatMap { y => Some(y).filter(p2) }
\end_layout

\begin_layout Plain Layout

       == psi(p1) andThen (_.flatMap(psi(p2)))     // Using standard flatten
 and flatMap for Option.
\end_layout

\end_inset

Denote this combination of the functions 
\begin_inset Formula $\psi_{p_{1}}$
\end_inset

 and 
\begin_inset Formula $\psi_{p_{2}}$
\end_inset

 by the symbol 
\begin_inset Formula $\diamond_{_{\text{Opt}}}$
\end_inset

, so that we may write:
\begin_inset Formula 
\[
\psi_{p}=\psi_{p_{1}}\diamond_{_{\text{Opt}}}\psi_{p_{2}}\triangleq x^{:A}\rightarrow x\triangleright\psi_{p_{1}}\triangleright\text{flm}_{\text{Opt}}(\psi_{p_{2}})=\psi_{p_{1}}\bef(y\rightarrow y\triangleright\text{flm}_{\text{Opt}}(\psi_{p_{2}}))\quad.
\]

\end_inset

We use the symbol 
\begin_inset Formula $\text{flm}_{\text{Opt}}$
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

; the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.flatMap(f)
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $x\triangleright\text{flm}_{\text{Opt}}(f)$
\end_inset

 if we view 
\begin_inset Formula $\text{flm}_{\text{Opt}}$
\end_inset

 as a curried function with the type signature:
\begin_inset Formula 
\[
\text{flm}_{\text{Opt}}:(A\rightarrow\text{Opt}^{B})\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad.
\]

\end_inset

The operation 
\begin_inset Formula $\diamond_{_{\text{Opt}}}$
\end_inset

 is a special kind of composition called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli composition!for 
\family typewriter
Option
\end_layout

\end_inset


\series bold
Kleisli
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
The
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli!prononciation of the name
\end_layout

\end_inset

 Swiss-German name Kleisli is pronounced 
\begin_inset Quotes eld
\end_inset

cli-slee
\begin_inset Quotes erd
\end_inset

 (
\begin_inset Quotes eld
\end_inset

cli
\begin_inset Quotes erd
\end_inset

 as in 
\begin_inset Quotes eld
\end_inset

climb
\begin_inset Quotes erd
\end_inset

).
\end_layout

\end_inset


\series bold
 composition
\series default
.
\begin_inset CommandInset label
LatexCommand label
name "kleisli-composition"

\end_inset

 It applies to functions such as 
\begin_inset Formula $\psi_{p}$
\end_inset

 that have type 
\begin_inset Formula $A\rightarrow\bbnum 1+A$
\end_inset

; such functions cannot be composed with the ordinary function composition
 (
\begin_inset Formula $\psi_{p_{1}}\bef\psi_{p_{2}}$
\end_inset

 does not type-check).
 It is straightforward to extend the operation 
\begin_inset Formula $\diamond_{_{\text{Opt}}}$
\end_inset

 from functions of type 
\begin_inset Formula $A\rightarrow\bbnum 1+A$
\end_inset

 to functions with more general types, 
\begin_inset Formula $A\rightarrow\bbnum 1+B$
\end_inset

 and 
\begin_inset Formula $B\rightarrow\bbnum 1+C$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def kleisliOpt[A, B](f: A => Option[B], g: B => Option[C]): A => Option[C]
 =
\end_layout

\begin_layout Plain Layout

  { x: A => f(x).flatMap(g) }      // Using the standard flatMap for Option.
\end_layout

\end_inset


\begin_inset Formula 
\[
f^{:A\rightarrow\bbnum 1+B}\diamond_{_{\text{Opt}}}g^{:B\rightarrow\bbnum 1+C}\triangleq x^{:A}\rightarrow f(x)\triangleright\text{flm}_{\text{Opt}}(g)\quad.
\]

\end_inset

The Kleisli composition 
\begin_inset Formula $f\diamond_{_{\text{Opt}}}g$
\end_inset

 yields a function of type 
\begin_inset Formula $A\rightarrow\bbnum 1+C$
\end_inset

 and is similar to the ordinary composition 
\begin_inset Formula $f\bef g$
\end_inset

 except for using 
\begin_inset Quotes eld
\end_inset

twisted
\begin_inset Quotes erd
\end_inset

 types, e.g., 
\begin_inset Formula $A\rightarrow\text{Opt}^{B}$
\end_inset

 instead of 
\begin_inset Formula $A\rightarrow B$
\end_inset

.
 (The 
\begin_inset Quotes eld
\end_inset

twisted
\begin_inset Quotes erd
\end_inset

 functions cannot be composed as 
\begin_inset Formula $f\bef g$
\end_inset

 because their types do not match.)
\end_layout

\begin_layout Standard
We can now derive the composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 starting from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{filt}\,(p_{1})\bef\text{filt}\,(p_{2})=\text{liftOpt}\,(\psi_{p_{1}})\bef\text{liftOpt}\,(\psi_{p_{2}})\quad.\\
\text{right-hand side}:\quad & \text{filt}\,(p)=\text{liftOpt}\,(\psi_{p})=\text{liftOpt}\,(\psi_{p_{1}}\diamond_{_{\text{Opt}}}\psi_{p_{2}})\quad.
\end{align*}

\end_inset

If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

's composition law holds, we obtain (without any additional assumptions)
 the equation:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}\,(\psi_{p_{1}})\bef\text{liftOpt}\,(\psi_{p_{2}})=\text{liftOpt}\,(\psi_{p_{1}}\diamond_{_{\text{Opt}}}\psi_{p_{2}})\quad.\label{eq:restricted-composition-law-for-liftOpt}
\end{equation}

\end_inset

This looks like a law typical for a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

: the composition of lifted functions is equal to the lifted Kleisli composition.
 So, it appears useful to formulate the composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 in a more general way by allowing arbitrary 
\begin_inset Formula $f^{:A\rightarrow\bbnum 1+B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow\bbnum 1+C}$
\end_inset

 instead of specific functions 
\begin_inset Formula $\psi_{p_{1}}$
\end_inset

 and 
\begin_inset Formula $\psi_{p_{2}}$
\end_inset

.
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{1.8pc} & F^{B}\ar[rd]\sp(0.55){\ \text{liftOpt}\,(g)}\\
F^{A}\ar[ru]\sp(0.45){\text{liftOpt}\,(f)\ }\ar[rr]\sb(0.5){\text{liftOpt}\,(f\diamond_{_{\text{Opt}}}g)} &  & F^{C}
}
\]

\end_inset

The composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 is then written as:
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of 
\family typewriter
liftOpt
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\bef\text{liftOpt}_{F}(g^{:B\rightarrow\bbnum 1+C})=\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.\label{eq:composition-law-of-liftOpt}
\end{equation}

\end_inset

Because this law holds for 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 involving arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, it is stronger than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

's composition law.
 We will now show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

's naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and hence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

's naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be derived from Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) if we choose 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 in a special way, such that one of 
\begin_inset Formula $f$
\end_inset

 or 
\begin_inset Formula $g$
\end_inset

 always returns a non-empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Option
\end_layout

\end_inset

 value:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-2-laws-of-liftOpt-entail-other-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-2-laws-of-liftOpt-entail-other-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 follows from Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) follows from Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Choose functions 
\begin_inset Formula $f^{:A\rightarrow\bbnum 1+B}$
\end_inset

 to be of the form:
\begin_inset Formula 
\begin{align*}
 & f^{:A\rightarrow\bbnum 1+B}\triangleq h^{:A\rightarrow B}\bef\text{pu}_{\text{Opt}}^{:B\rightarrow\bbnum 1+B}\\
\text{or, written out in more detail}:\quad & =h^{:A\rightarrow B}\bef(x^{:B}\rightarrow\bbnum 0+x)=x^{:A}\rightarrow\bbnum 0+h(x)\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $h^{:A\rightarrow B}$
\end_inset

 is an arbitrary function, and use those 
\begin_inset Formula $f$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{liftOpt}\,(f\diamond_{_{\text{Opt}}}g)=\gunderline{\text{liftOpt}\,(h\bef\text{pu}_{\text{Opt}})}\bef\text{liftOpt}\,(g)\\
\text{use Eq.~(\ref{eq:combined-naturality-identity-law-of-liftOpt})}:\quad & =h^{\uparrow F}\bef\text{liftOpt}\,(g)\quad.
\end{align*}

\end_inset

To simplify this formula, we need to compute 
\begin_inset Formula $f\diamond_{_{\text{Opt}}}g$
\end_inset

.
 The Kleisli composition 
\begin_inset Formula $\diamond_{_{\text{Opt}}}$
\end_inset

 is defined via the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type.
 With the notation 
\begin_inset Formula $\text{flm}_{\text{Opt}}$
\end_inset

 for the curried 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 function, the definition of  
\begin_inset Formula $\diamond_{_{\text{Opt}}}$
\end_inset

 is simplified to:
\begin_inset Formula 
\begin{equation}
f^{:A\rightarrow\bbnum 1+B}\diamond_{_{\text{Opt}}}g^{:B\rightarrow\bbnum 1+C}\triangleq f\bef\text{flm}_{\text{Opt}}(g)\quad.\label{eq:def-of-Kleisli-product}
\end{equation}

\end_inset

Then we compute 
\begin_inset Formula $f\diamond_{_{\text{Opt}}}g$
\end_inset

 using this definition of 
\begin_inset Formula $\diamond_{_{\text{Opt}}}$
\end_inset

 as:
\begin_inset Formula 
\begin{align*}
\text{definition of }f:\quad & \gunderline f\diamond_{_{\text{Opt}}}g=(h\bef\text{pu}_{\text{Opt}})\,\gunderline{\diamond_{_{\text{Opt}}}}\,g=h\bef\gunderline{\text{pu}_{\text{Opt}}\bef\text{flm}_{\text{Opt}}}(g)\\
\text{compute composition (see below)}:\quad & =h\bef g\quad.
\end{align*}

\end_inset

The result of composing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 is not obvious, but it turns out that 
\begin_inset Formula $\text{pu}_{\text{Opt}}$
\end_inset

 followed by 
\begin_inset Formula $\text{flm}_{\text{Opt}}(g)$
\end_inset

 is equal to just 
\begin_inset Formula $g$
\end_inset

.
 To verify that, let us first use the syntax of Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pure(x) == Some(x)             // By definition of `pure` for `Option`.
\end_layout

\begin_layout Plain Layout

p.flatMap(g) == p match {      // By definition of `flatMap` for `Option`.
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(x)   => g(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

pure(x).flatMap(g) == Some(x).flatMap(g) == g(x)
\end_layout

\end_inset

The same symbolic computation is written in the code notation like this:
\begin_inset Formula 
\begin{align}
\text{pu}_{\text{Opt}}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline A & \bbnum 0 & \text{id}
\end{array}\quad,\quad\quad & \text{flm}_{\text{Opt}}(g^{:A\rightarrow\bbnum 1+B})=\,\begin{array}{|c||c|}
 & \bbnum 1+B\\
\hline \bbnum 1 & 1\rightarrow1+\bbnum 0^{:B}\\
A & g
\end{array}\quad,\label{eq:def-of-puOpt-and-flmOpt}\\
 & \text{pu}_{\text{Opt}}\bef\text{flm}_{\text{Opt}}(g)=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline A & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & \bbnum 1+B\\
\hline \bbnum 1 & 1\rightarrow1+\bbnum 0^{:B}\\
A & g
\end{array}\nonumber \\
\text{matrix composition}:\quad & \quad=\,\begin{array}{|c||c|}
 & \bbnum 1+B\\
\hline A & \gunderline{\text{id}\bef g}
\end{array}\,=g\quad.\label{eq:simplify-puOpt-flmOpt}
\end{align}

\end_inset

Since we have now shown that 
\begin_inset Formula $f\diamond_{_{\text{Opt}}}g=h\bef g$
\end_inset

, the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) follows: 
\begin_inset Formula 
\[
\text{liftOpt}\,(f\diamond_{_{\text{Opt}}}g)=\text{liftOpt}\,(h\bef g)=h^{\uparrow F}\bef\text{liftOpt}\,(g)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
This derivation is possible because the function 
\begin_inset Formula $f$
\end_inset

 always returns a non-empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, which corresponds to filtering with a predicate that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 This reduces filtering to an identity function, which simplifies the compositio
n law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by eliminating one of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 functions.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We keep 
\begin_inset Formula $f^{:A\rightarrow\bbnum 1+B}$
\end_inset

 arbitrary but choose 
\begin_inset Formula $g^{:B\rightarrow\bbnum 1+C}$
\end_inset

 to be of the form:
\begin_inset Formula 
\[
g^{:B\rightarrow\bbnum 1+C}\triangleq h^{:B\rightarrow C}\bef\text{pu}_{\text{Opt}}^{C}\quad,
\]

\end_inset

where 
\begin_inset Formula $h^{:B\rightarrow C}$
\end_inset

 is an arbitrary function, and substitute into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

's composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{liftOpt}\,(f\diamond_{_{\text{Opt}}}g)=\text{liftOpt}\,(f)\bef\text{liftOpt}\,(h\bef\text{pu}_{\text{Opt}})\\
\text{use Eq.~(\ref{eq:combined-naturality-identity-law-of-liftOpt})}:\quad & \quad=\text{liftOpt}\,(f)\bef h^{\uparrow F}\quad.
\end{align*}

\end_inset

To proceed, we need to compute the Kleisli composition 
\begin_inset Formula $f\diamond_{_{\text{Opt}}}g$
\end_inset

 for the chosen form of 
\begin_inset Formula $g$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & f\diamond_{_{\text{Opt}}}\gunderline g=f\diamond_{_{\text{Opt}}}(h\bef\text{pu}_{\text{Opt}})\\
\text{definition~(\ref{eq:def-of-Kleisli-product}) of }\diamond_{_{\text{Opt}}}:\quad & =f\bef\text{flm}_{\text{Opt}}(h\bef\gunderline{\text{pu}_{\text{Opt}}})=f\bef\text{flm}_{\text{Opt}}(y\rightarrow\bbnum 0+h(y))\\
\text{definition~(\ref{eq:def-of-puOpt-and-flmOpt}) of }\text{flm}_{\text{Opt}}:\quad & =f\bef\,\begin{array}{|c||c|}
 & \bbnum 1+C\\
\hline \bbnum 1 & 1\rightarrow1+\bbnum 0^{:C}\\
B & y\rightarrow\bbnum 0+h(y)
\end{array}\\
\text{split matrix into 2 columns}:\quad & =\,f\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & C\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
B & \bbnum 0 & h
\end{array}\\
\text{definition of lifting, }^{\uparrow\text{Opt}}:\quad & =f\bef h^{\uparrow\text{Opt}}\quad.
\end{align*}

\end_inset

This yields the 
\series bold
right naturality
\series default
 law
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
liftOpt
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{4.5pc}F^{A}\ar[d]\sb(0.5){\text{liftOpt}\,(f)}\ar[rd]\sp(0.5){~~~\text{ liftOpt}\,(f\bef h^{\uparrow\text{Opt}})}\\
F^{B}\ar[r]\sp(0.42){h^{\uparrow F}} & F^{C}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\bef h^{\uparrow F}=\text{liftOpt}_{F}(f\bef h^{\uparrow\text{Opt}})\quad.\label{eq:right-naturality-law-of-liftOpt}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Assuming that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-deflate-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we express the two sides of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

's naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side of Eq.~(\ref{eq:naturality-law-of-deflate})}:\quad & \text{deflate}\bef f^{\uparrow F}=\text{liftOpt}\left(\text{id}\right)\bef f^{\uparrow F}\\
\text{use Eq.~(\ref{eq:right-naturality-law-of-liftOpt})}:\quad & \quad=\text{liftOpt}\,(f^{\uparrow\text{Opt}})\quad.\\
\text{right-hand side of Eq.~(\ref{eq:naturality-law-of-deflate})}:\quad & f^{\uparrow\text{Opt}\uparrow F}\bef\text{deflate}=f^{\uparrow\text{Opt}\uparrow F}\bef\text{liftOpt}\left(\text{id}\right)\\
\text{naturality law~(\ref{eq:left-naturality-law-of-liftOpt})}:\quad & \quad=\text{liftOpt}\,(\gunderline{f^{\uparrow\text{Opt}}\bef\text{id}})=\text{liftOpt}\,(f^{\uparrow\text{Opt}})\quad.
\end{align*}

\end_inset

We are justified to use the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) because we proved in part 
\series bold
(a)
\series default
 that it holds.
\end_layout

\begin_layout Standard
If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 obeys the naturality law then so does 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

, and vice versa (Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-naturality-law-of-deflate-from-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-naturality-for-deflate-entails-naturality-for-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
To summarize, we have proved that if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 and the two laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 then all four laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 will hold.
\end_layout

\begin_layout Standard
The converse statement also holds: if we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-liftOpt-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the four laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 will imply the two laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-decompose-Kleisli-opt-function"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-decompose-Kleisli-opt-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Show that any function 
\begin_inset Formula $f^{:A\rightarrow\bbnum 1+B}$
\end_inset

 can be expressed as 
\begin_inset Formula $f=\psi_{p}\bef h_{|p}^{\uparrow\text{Opt}}$
\end_inset

 with a suitable choice of a predicate 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

 and a partial function 
\begin_inset Formula $h_{|p}^{:A\rightarrow B}$
\end_inset

.
 Derive explicit formulas for 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

 in terms of 
\begin_inset Formula $f$
\end_inset

 and implement them in Scala.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-derive-composition-law-for-liftOpt-from-filter-laws-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-derive-composition-law-for-liftOpt-from-filter-laws-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Show that the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-liftOpt-via-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Hint: first derive the two naturality laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

; then use Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-decompose-Kleisli-opt-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to extend the restricted composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:restricted-composition-law-for-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to the full law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Constructions of filterable functors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Constructions-of-filterable-functors"

\end_inset


\end_layout

\begin_layout Standard
How can we recognize a filterable functor 
\begin_inset Formula $F^{A}$
\end_inset

 by its type expression, without having to prove laws? One intuition is
 that the type 
\begin_inset Formula $F^{A}$
\end_inset

 must be able to accommodate replacing values of 
\begin_inset Formula $A$
\end_inset

 by unit values; this replacement is performed by the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

.
 To make this intuition more precise, it helps to perform structural analysis
 that systematically looks for type constructions creating new filterable
 functors out of existing ones while preserving the laws.
 
\end_layout

\begin_layout Standard
To begin, we note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[_]
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[L, _]
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[_]
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[_]
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, _]
\end_layout

\end_inset

 are filterable.
 Let us now go through all constructions available for exponential-polynomial
 types.
 To check whether a functor is filterable, it is convenient to use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 function and its two laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Type parameters
\end_layout

\begin_layout Standard
There are three constructions that work solely by manipulating type parameters:
 the identity functor 
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

, the constant functor 
\begin_inset Formula $\text{Const}^{Z,A}\triangleq Z$
\end_inset

 (where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type), and the functor composition, 
\begin_inset Formula $F^{A}\triangleq G^{H^{A}}$
\end_inset

.
\end_layout

\begin_layout Standard
The identity functor is 
\emph on
not
\emph default
 filterable because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 of type 
\begin_inset Formula $\bbnum 1+A\rightarrow A$
\end_inset

 cannot be implemented.
\end_layout

\begin_layout Standard
The constant functor 
\begin_inset Formula $\text{Const}^{Z,A}\triangleq Z$
\end_inset

 can be viewed as a 
\begin_inset Quotes eld
\end_inset

wrapper
\begin_inset Quotes erd
\end_inset

 that never wraps any values of type 
\begin_inset Formula $A$
\end_inset

.
 This functor is filterable because we can define 
\begin_inset Formula $\text{liftOpt}\,(\_)\triangleq\text{id}^{:Z\rightarrow Z}$
\end_inset

 (filtering is a no-op for a 
\begin_inset Quotes eld
\end_inset

wrapper
\begin_inset Quotes erd
\end_inset

 that is always empty).
 All laws usually hold for an identity function.
 To verify the laws, note that the lifting to the 
\begin_inset Formula $\text{Const}$
\end_inset

 functor is also an identity function: 
\begin_inset Formula $f^{\uparrow\text{Const}}=\text{id}^{:Z\rightarrow Z}$
\end_inset

 for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
\begin_inset Formula 
\begin{align*}
\text{check law~(\ref{eq:combined-naturality-identity-law-of-liftOpt})}:\quad & \text{liftOpt}_{\text{Const}}(f\bef\text{pu}_{\text{Opt}})=\text{id}=f^{\uparrow\text{Const}}\quad,\\
\text{check law~(\ref{eq:composition-law-of-liftOpt})}:\quad & \text{liftOpt}_{\text{Const}}(f)\bef\text{liftOpt}_{\text{Const}}(g)=\text{id}\bef\text{id}=\text{id}=\text{liftOpt}_{\text{Const}}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The functor composition 
\begin_inset Formula $F^{A}\triangleq G^{H^{A}}$
\end_inset

 requires only 
\begin_inset Formula $H$
\end_inset

 to be a filterable functor:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filterable-composition-functors"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-composition-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functor 
\begin_inset Formula $F^{A}\triangleq G^{H^{A}}$
\end_inset

 is filterable when 
\begin_inset Formula $H^{A}$
\end_inset

 is filterable and 
\begin_inset Formula $G^{A}$
\end_inset

 is 
\emph on
any
\emph default
 functor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $\text{liftOpt}_{H}$
\end_inset

 is available and lawful, we define 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B]): G[H[A]] => G[H[B]] =
\end_layout

\begin_layout Plain Layout

  { g: G[H[A]] => g.map(liftOpt_H(f)) }
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{liftOpt}_{F}(f)\triangleq\big(\text{liftOpt}_{H}(f)\big)^{\uparrow G}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the identity-naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt_F
\end_layout

\end_inset

, note that 
\begin_inset Formula $f^{\uparrow F}=f^{\uparrow H\uparrow G}$
\end_inset

 by definition of 
\begin_inset Formula $F$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\uparrow F}:\quad & \text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})=\big(\text{liftOpt}_{H}(f\bef\text{pu}_{\text{Opt}})\big)^{\uparrow G}\\
\text{law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) of }\text{liftOpt}_{H}:\quad & \quad=\big(f^{\uparrow H}\big)^{\uparrow G}=f^{\uparrow F}\quad.
\end{align*}

\end_inset

To verify the composition law of 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

, compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}f^{\prime}):\quad & \text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(f^{\prime})=\big(\text{liftOpt}_{H}(f)\bef\text{liftOpt}_{H}(f^{\prime})\big)^{\uparrow G}\\
\text{composition law of }\text{liftOpt}_{H}:\quad & =\big(\text{liftOpt}_{H}(f\diamond_{_{\text{Opt}}}f^{\prime})\big)^{\uparrow G}=\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}f^{\prime})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
To show that the product of two filterable functors is filterable, we will
 use a definition of 
\begin_inset Formula $\text{liftOpt}_{G^{\bullet}\times H^{\bullet}}$
\end_inset

 and a proof quite similar to what we did for the product of functors (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor product
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filterable-functor-product"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functor 
\begin_inset Formula $F^{A}\triangleq G^{A}\times H^{A}$
\end_inset

 is filterable if 
\begin_inset Formula $G^{\bullet}$
\end_inset

 and 
\begin_inset Formula $H^{\bullet}$
\end_inset

 are filterable functors.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
To define 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

, we use the pair product operation 
\begin_inset Formula $\boxtimes$
\end_inset

 similarly to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-functor-product-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{liftOpt}_{F}(p)\triangleq\text{liftOpt}_{G}(p)\boxtimes\text{liftOpt}_{H}(p)\quad.
\]

\end_inset

The lifting to 
\begin_inset Formula $F$
\end_inset

 is defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-functor-product-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as 
\begin_inset Formula $f^{\uparrow F}=f^{\uparrow G}\boxtimes f^{\uparrow H}$
\end_inset

.
 To verify the naturality-identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\uparrow F}:\quad & \text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})=\text{liftOpt}_{G}(f\bef\text{pu}_{\text{Opt}})\boxtimes\text{liftOpt}_{H}(f\bef\text{pu}_{\text{Opt}})\\
\text{law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) for }G\text{ and }H:\quad & =f^{\uparrow G}\boxtimes f^{\uparrow H}=f^{\uparrow F}\quad.
\end{align*}

\end_inset

 To verify the composition law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g):\quad & \text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)\\
\text{definition of }\text{liftOpt}_{F}:\quad & =\big(\text{liftOpt}_{G}(f)\boxtimes\text{liftOpt}_{H}(f)\big)\bef\big(\text{liftOpt}_{G}(g)\boxtimes\text{liftOpt}_{H}(g)\big)\\
\text{composition property~(\ref{eq:function-product-distributive-property-over-composition})}:\quad & =\big(\text{liftOpt}_{G}(f)\bef\text{liftOpt}_{G}(g)\big)\boxtimes\big(\text{liftOpt}_{H}(f)\bef\text{liftOpt}_{H}(g)\big)\\
\text{composition laws of }G\text{ and }H:\quad & =\text{liftOpt}_{G}(f\diamond_{_{\text{Opt}}}g)\boxtimes\text{liftOpt}_{H}(f\diamond_{_{\text{Opt}}}g)\\
\text{definition of }\text{liftOpt}_{F}:\quad & =\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset

In this calculation, we used the composition property 
\begin_inset Formula 
\begin{equation}
(f\boxtimes g)\bef(p\boxtimes q)=(f\bef p)\boxtimes(g\bef q)\quad,\label{eq:function-product-distributive-property-over-composition}
\end{equation}

\end_inset

which follows from the definition of the pair product operation 
\begin_inset Formula $\boxtimes$
\end_inset

,
\begin_inset Formula 
\begin{align*}
 & (f\boxtimes g)\bef(p\boxtimes q)=\big(a\times b\rightarrow f(a)\times g(b)\big)\bef\big(c\times d\rightarrow p(c)\times q(d)\big)\\
\text{compute composition}:\quad & =\big(a\times b\rightarrow p(f(a))\times q(g(b))\big)\\
\text{definition of }\boxtimes:\quad & =\big(a\rightarrow p(f(a))\big)\boxtimes\big(b\rightarrow q(g(b))\big)\\
\text{definition of the }\bef\text{ operation}:\quad & =(f\bef p)\boxtimes(g\bef q)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
There are two constructions that produce new filterable functors involving
 disjunctive types (co-product types).
 The first construction is the filterable co-product 
\begin_inset Formula $F^{A}\triangleq G^{A}+H^{A}$
\end_inset

, where 
\begin_inset Formula $G^{\bullet}$
\end_inset

 and 
\begin_inset Formula $H^{\bullet}$
\end_inset

 are filterable functors.
 This is similar to the functor co-product (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The second construction is 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times G^{A}$
\end_inset

 where 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is a filterable functor.
 This cannot be reduced to the first construction because 
\begin_inset Formula $A\times G^{A}$
\end_inset

 is not filterable.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filterable-coproduct"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functor 
\begin_inset Formula $F^{A}\triangleq G^{A}+H^{A}$
\end_inset

 is filterable if 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are filterable functors.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $\text{liftOpt}_{G}$
\end_inset

 and 
\begin_inset Formula $\text{liftOpt}_{H}$
\end_inset

 are available, we define 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B]): Either[G[A], H[A]] => Either[G[B],
 H[B]] = {
\end_layout

\begin_layout Plain Layout

  case Left(ga)    => liftOpt_G(f)(ga)
\end_layout

\begin_layout Plain Layout

  case Right(ha)   => liftOpt_H(f)(ha)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\triangleq\begin{array}{|c||cc|}
 & G^{A} & H^{A}\\
\hline G^{A} & \text{liftOpt}_{G}(f) & \bbnum 0\\
H^{A} & \bbnum 0 & \text{liftOpt}_{H}(f)
\end{array}\quad.
\]

\end_inset

Lifting to the functor 
\begin_inset Formula $F^{A}$
\end_inset

 is defined as in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
f^{\uparrow F}\triangleq\begin{array}{|c||cc|}
 & G^{A} & H^{A}\\
\hline G^{A} & f^{\uparrow G} & \bbnum 0\\
H^{A} & \bbnum 0 & f^{\uparrow H}
\end{array}\quad.
\]

\end_inset

Our matrix calculations will always have the rows and columns of type 
\begin_inset Formula $G^{A}+H^{A}$
\end_inset

, so we will omit the type annotations for brevity.
 To verify the naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\uparrow F}:\quad & \text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})=\,\begin{array}{||cc|}
\text{liftOpt}_{G}(f\bef\text{pu}_{\text{Opt}}) & \bbnum 0\\
\bbnum 0 & \text{liftOpt}_{H}(f\bef\text{pu}_{\text{Opt}})
\end{array}\\
\text{law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) for }G\text{ and }H:\quad & =\,\begin{array}{||cc|}
f^{\uparrow G} & \bbnum 0\\
\bbnum 0 & f^{\uparrow H}
\end{array}\,=f^{\uparrow F}\quad.
\end{align*}

\end_inset

To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g):\quad & \text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)\\
\text{definition of }\text{liftOpt}_{F}:\quad & =\,\begin{array}{||cc|}
\text{liftOpt}_{G}(f) & \bbnum 0\\
\bbnum 0 & \text{liftOpt}_{H}(f)
\end{array}\,\bef\,\begin{array}{||cc|}
\text{liftOpt}_{G}(g) & \bbnum 0\\
\bbnum 0 & \text{liftOpt}_{H}(g)
\end{array}\\
\text{matrix composition}:\quad & =\,\,\begin{array}{||cc|}
\text{liftOpt}_{G}(f)\bef\text{liftOpt}_{G}(g) & \bbnum 0\\
\bbnum 0 & \text{liftOpt}_{H}(f)\bef\text{liftOpt}_{H}(g)
\end{array}\\
\text{law~(\ref{eq:composition-law-of-liftOpt}) for }G\text{ and }H:\quad & =\,\begin{array}{||cc|}
\text{liftOpt}_{G}(f\diamond_{_{\text{Opt}}}g) & \bbnum 0\\
\bbnum 0 & \text{liftOpt}_{H}(f\diamond_{_{\text{Opt}}}g)
\end{array}\\
\text{definition of }\text{liftOpt}_{F}:\quad & =\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filterable-coproduct-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functor 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times G^{A}$
\end_inset

 is filterable if 
\begin_inset Formula $G$
\end_inset

 is a filterable functor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $\text{liftOpt}_{G}$
\end_inset

 is available, we define 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B]): Option[(A, G[A])] => Option[(B,
 G[B])] = {
\end_layout

\begin_layout Plain Layout

  case None            => None                    // An empty wrapper remains
 empty.
\end_layout

\begin_layout Plain Layout

  case Some((a, ga))   => f(a) match {            // Does `a` satisfy the
 predicate?
\end_layout

\begin_layout Plain Layout

     case None    => None                         // No.
 Drop all data, return an empty wrapper.
\end_layout

\begin_layout Plain Layout

     case Some(b) => Some((b, liftOpt_G(f)(ga)))  // Yes.
 Keep `b` and filter `ga` using `liftOpt_G`.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{liftOpt}_{F}(f)\triangleq\,\begin{array}{|c||c|}
 & \bbnum 1+B\times G^{B}\\
\hline \bbnum 1 & 1\rightarrow1+\bbnum 0^{:B\times G^{B}}\\
A\times G^{A} & a\times g\rightarrow a\triangleright f\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & B\times G\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
B & \bbnum 0 & b\rightarrow b\times\text{liftOpt}_{G}(f)(g)
\end{array}
\end{array}\quad.
\]

\end_inset

The matrix for 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 has a non-split output column (representing the disjunctive type 
\begin_inset Formula $\bbnum 1+B\times G^{B}$
\end_inset

).
 This is  because the code must pattern-match on 
\begin_inset Formula $f\left(a\right)$
\end_inset

 in order to determine whether the result is of type 
\begin_inset Formula $\bbnum 1$
\end_inset

 or of type 
\begin_inset Formula $B\times G^{B}$
\end_inset

.
 It is inconvenient to use such matrices in calculations since the conventions
 of matrix products do not work unless all parts of a disjunctive type are
 represented by separate columns.
 To be able to do symbolic calculations, we need to rewrite the code in
 a different way.
\end_layout

\begin_layout Standard
Note that the code pattern when destructuring an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 value looks like this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[A, B, C](q: A => Option[B], r: B => C): Option[A] => Option[C] = {
\end_layout

\begin_layout Plain Layout

  case None    => None
\end_layout

\begin_layout Plain Layout

  case Some(a) => q(a) match {   // Destructure the result of applying the
 function `q`.
\end_layout

\begin_layout Plain Layout

    case None      => None
\end_layout

\begin_layout Plain Layout

    case Some(b)   => Some(r(b)) // Apply a final transformation `r`.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 can be rewritten using the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[A, B, C](q: A => Option[B], r: B => C): Option[A] => Option[C] = _.flatMap
 { a => q(a).map(r) }
\end_layout

\end_inset

So we may write the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt_F
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B]): Option[(A, G[A])] => Option[(B,
 G[B])] = _.flatMap {
\end_layout

\begin_layout Plain Layout

     case (a, ga)   => f(a).map { b => (b, liftOpt_G(f)(ga)) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{F}(f)\triangleq\text{flm}_{\text{Opt}}\big(a^{:A}\times g^{:G^{A}}\rightarrow a\triangleright f\bef(b\rightarrow b\times\text{liftOpt}_{G}(f)(g))^{\uparrow\text{Opt}}\big)\quad.\label{eq:liftOpt-flm-opt-derivation1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
To verify the laws, we first need to define the lifting to the functor 
\begin_inset Formula $F$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_F[A, B](f: A => B): Option[(A, G[A])] => Option[(B, G[B])] = {
\end_layout

\begin_layout Plain Layout

  case None            => None
\end_layout

\begin_layout Plain Layout

  case Some((a, ga))   => Some((f(a), ga.map(f)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Again, it is convenient to rewrite the code using the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_F[A, B](f: A => B): Option[(A, G[A])] => Option[(B, G[B])] = _.map
 {
\end_layout

\begin_layout Plain Layout

  case (a, ga) => (f(a), ga.map(f))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
f^{\uparrow F}=\big(a^{:A}\times g^{:G^{A}}\rightarrow f(a)\times(g\triangleright f^{\uparrow G})\big)^{\uparrow\text{Opt}}=\big(f\boxtimes f^{\uparrow G}\big)^{\uparrow\text{Opt}}\quad.
\]

\end_inset

For brevity, we omit type annotations.
 The naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $F$
\end_inset

 is verified by
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\uparrow F}:\quad & \text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})\\
\text{definition of }\text{liftOpt}_{F}:\quad & =\text{flm}_{\text{Opt}}\big(a\times g\rightarrow a\triangleright f\bef\text{pu}_{\text{Opt}}\bef\big(b\rightarrow b\times\gunderline{\text{liftOpt}_{G}(f\bef\text{pu}_{\text{Opt}})}(g)\big)^{\uparrow\text{Opt}}\big)\\
\text{law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) for }G:\quad & =\text{flm}_{\text{Opt}}\big(a\times g\rightarrow a\triangleright f\bef\gunderline{\text{pu}_{\text{Opt}}\bef\big(b\rightarrow b\times f^{\uparrow G}(g)\big)^{\uparrow\text{Opt}}}\big)\\
\text{naturality~(\ref{eq:naturality-law-of-pure}) of }\text{pu}_{\text{Opt}}:\quad & =\text{flm}_{\text{Opt}}\big(a\times g\rightarrow\gunderline{a\triangleright f\bef\big(b\rightarrow b\times f^{\uparrow G}(g)\big)}\bef\text{pu}_{\text{Opt}}\big)\\
\text{function composition}:\quad & =\text{flm}_{\text{Opt}}\big(\gunderline{a\times g\rightarrow\big(f(a)\times f^{\uparrow G}(g)\big)\,\triangleright}\,\text{pu}_{\text{Opt}}\big)=\gunderline{\text{flm}_{\text{Opt}}\big(}(f\boxtimes f^{\uparrow G})\bef\gunderline{\text{pu}_{\text{Opt}}}\big)\\
\text{use Eq.~(\ref{eq:flatmap-pure-law-for-Option})}:\quad & =\big(f\boxtimes f^{\uparrow G}\big)^{\uparrow\text{Opt}}=f^{\uparrow F}\quad.
\end{align*}

\end_inset

Here we used a property that applies to a composition of any 
\begin_inset Formula $q^{:A\rightarrow B}$
\end_inset

 with 
\begin_inset Formula $\text{pu}_{\text{Opt}}$
\end_inset

 under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{flm}_{\text{Opt}}(q^{:A\rightarrow B}\bef\text{pu}_{\text{Opt}}^{:B\rightarrow\bbnum 1+B})=q^{\uparrow\text{Opt}}\quad.\label{eq:flatmap-pure-law-for-Option}
\end{equation}

\end_inset

This property is derived by applying the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to suitable values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

None.flatMap(x => Some(q(x))) == None             None.map(q) == None    
   // pure_Opt(x) == Some(x)
\end_layout

\begin_layout Plain Layout

Some(x).flatMap(x => Some(q(x))) == Some(q(x))    Some(x).map(q) == Some(q(x))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Additional work is necessary to check 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

's composition law:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(f^{\prime})=\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}f^{\prime})\quad.\label{eq:liftOpt-composition-law-derivation1}
\end{equation}

\end_inset

Since 
\begin_inset Formula $\text{liftOpt}_{F}(f)$
\end_inset

 is equal to 
\begin_inset Formula $\text{flm}_{\text{Opt}}(...)$
\end_inset

, so we need somehow to transform 
\begin_inset Formula $\text{flm}_{\text{Opt}}(...)\bef\text{flm}_{\text{Opt}}(...)$
\end_inset

 into an expression of the form 
\begin_inset Formula $\text{flm}_{\text{Opt}}(...)$
\end_inset

.
 To obtain such a transformation, we use a trick: consider the composition
 law for the 
\begin_inset Formula $\text{liftOpt}_{\text{Opt}}$
\end_inset

 operation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 functor (not the 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 of the functor 
\begin_inset Formula $F$
\end_inset

).
 Since we already know that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 is filterable, the composition law must hold for 
\begin_inset Formula $\text{liftOpt}_{\text{Opt}}$
\end_inset

:
\begin_inset Formula 
\[
\text{liftOpt}_{\text{Opt}}(f^{:A\rightarrow\text{Opt}^{B}})\bef\text{liftOpt}_{\text{Opt}}(g^{:B\rightarrow\text{Opt}^{C}})=\text{liftOpt}_{\text{Opt}}(f\diamond_{_{\text{Opt}}}g)\quad.
\]

\end_inset

To express 
\begin_inset Formula $\text{liftOpt}_{\text{Opt}}$
\end_inset

 through known functions, recall that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 function, with the type signature 
\begin_inset Formula $\text{Opt}^{\text{Opt}^{A}}\rightarrow\text{Opt}^{A}$
\end_inset

, is equal to the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\text{ftn}_{\text{Opt}}$
\end_inset

 for brevity):
\begin_inset Formula 
\[
\text{liftOpt}_{\text{Opt}}(f)=f^{\uparrow\text{Opt}}\bef\text{deflate}_{\text{Opt}}=f^{\uparrow\text{Opt}}\bef\text{ftn}_{\text{Opt}}=\text{flm}_{\text{Opt}}(f)\quad.
\]

\end_inset

So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method equals 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 and obeys a law similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

's composition law:
\begin_inset Formula 
\begin{equation}
\text{flm}_{\text{Opt}}(f)\bef\text{flm}_{\text{Opt}}(f^{\prime})=\text{flm}_{\text{Opt}}(f\diamond_{_{\text{Opt}}}f^{\prime})=\text{flm}_{\text{Opt}}\big(f\bef\text{flm}_{\text{Opt}}(f^{\prime})\big)\quad.\label{eq:associativity-law-of-flatMap-for-Option}
\end{equation}

\end_inset

We call Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-of-flatMap-for-Option"
plural "false"
caps "false"
noprefix "false"

\end_inset

) the 
\series bold
associativity law
\series default
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of 
\family typewriter
flatMap
\family default
 for 
\family typewriter
Option
\end_layout

\end_inset

 for reasons explained in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-Kleisli-Option-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below.
\end_layout

\begin_layout Standard
To make the calculation quicker, denote by 
\begin_inset Formula $r_{f,g}$
\end_inset

 a sub-expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:liftOpt-flm-opt-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), so that we can write:
\begin_inset Formula 
\begin{equation}
r_{f,g}\triangleq b\rightarrow b\times\text{liftOpt}_{G}(f)(g)\quad,\quad\quad\text{liftOpt}_{F}(f)=\text{flm}_{\text{Opt}}(a\times g\rightarrow a\triangleright f\bef r_{f,g}^{\uparrow\text{Opt}})\quad.\label{eq:liftOpt-short-flatmap-opt-derivation1}
\end{equation}

\end_inset

We can now start with the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:liftOpt-composition-law-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
 & \text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(f^{\prime})\nonumber \\
\text{use Eq.~(\ref{eq:liftOpt-short-flatmap-opt-derivation1})}:\quad & =\text{flm}_{\text{Opt}}\big(a\times g\rightarrow a\triangleright f\bef r_{f,g}^{\uparrow\text{Opt}}\big)\bef\text{flm}_{\text{Opt}}\big(a^{\prime}\times g^{\prime}\rightarrow a^{\prime}\triangleright f^{\prime}\bef r_{f^{\prime},g^{\prime}}^{\uparrow\text{Opt}}\big)\nonumber \\
\text{use Eq.~(\ref{eq:associativity-law-of-flatMap-for-Option})}:\quad & =\text{flm}_{\text{Opt}}\big(\gunderline{\big(}a\times g\rightarrow a\triangleright f\triangleright r_{f,g}^{\uparrow\text{Opt}}\gunderline{\big)\bef}\,\text{flm}_{\text{Opt}}\big(a^{\prime}\times g^{\prime}\rightarrow a^{\prime}\triangleright f^{\prime}\bef r_{f^{\prime},g^{\prime}}^{\uparrow\text{Opt}}\big)\big)\nonumber \\
\triangleright\text{-notation}:\quad & =\text{flm}_{\text{Opt}}\big(a\times g\rightarrow a\triangleright f\bef r_{f,g}^{\uparrow\text{Opt}}\bef\text{flm}_{\text{Opt}}\big(a^{\prime}\times g^{\prime}\rightarrow a^{\prime}\triangleright f^{\prime}\bef r_{f^{\prime},g^{\prime}}^{\uparrow\text{Opt}}\big)\big)\quad.\label{eq:composition-lhs-derivation1}
\end{align}

\end_inset

Here we used a convenient 
\begin_inset Quotes eld
\end_inset

parenthesis-canceling
\begin_inset Quotes erd
\end_inset

 property of the 
\begin_inset Formula $\triangleright$
\end_inset

-notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\left(x\rightarrow x\triangleright f\right)\bef g=(x\rightarrow\gunderline{g(f(x)})=(x\rightarrow x\triangleright\gunderline{f\triangleright g})=\left(x\rightarrow x\triangleright f\bef g\right)\quad.
\]

\end_inset

It is not immediately clear how to proceed, so let us transform the right-hand
 side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:liftOpt-composition-law-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
 & \text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}f^{\prime})\nonumber \\
\text{definition~(\ref{eq:def-of-Kleisli-product}) of }\diamond_{_{\text{Opt}}}:\quad & =\text{liftOpt}_{F}(f\bef\text{flm}_{\text{Opt}}(f^{\prime}))\nonumber \\
\text{use Eq.~(\ref{eq:liftOpt-short-flatmap-opt-derivation1})}:\quad & =\text{flm}_{\text{Opt}}\big(a\times g\rightarrow a\triangleright f\bef\text{flm}_{\text{Opt}}(f^{\prime})\bef r_{f\bef\text{flm}_{\text{Opt}}(f^{\prime}),g}^{\uparrow\text{Opt}}\big)\quad.\label{eq:composition-rhs-derivation1}
\end{align}

\end_inset

How can we show that the last expressions in Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-lhs-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-rhs-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are equal? To find a way forward, let us compare these two equations and
 find the sub-expressions that remain different:
\begin_inset Formula 
\begin{align}
\text{sub-expression from the left-hand side}:\quad & r_{f,g}^{\uparrow\text{Opt}}\bef\text{flm}_{\text{Opt}}\big(a^{\prime}\times g^{\prime}\rightarrow a^{\prime}\triangleright f^{\prime}\bef r_{f^{\prime},g^{\prime}}^{\uparrow\text{Opt}}\big)\label{eq:composition-law-lhs-remaining-derivation1}\\
\text{we would like that to become equal to}:\quad & \text{flm}_{\text{Opt}}(f^{\prime})\bef r_{f\bef\text{flm}_{\text{Opt}}(f^{\prime}),g}^{\uparrow\text{Opt}}\quad.\label{eq:composition-law-rhs-remaining-derivation1}
\end{align}

\end_inset

The difference is in the lifted functions to the left and to the right of
 
\begin_inset Formula $\text{flm}_{\text{Opt}}$
\end_inset

.
 If we somehow bring those functions inside 
\begin_inset Formula $\text{flm}_{\text{Opt}}(...)$
\end_inset

, we may be able to simplify them further.
 So, we look for properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 that should have the form:
\begin_inset Formula 
\begin{align*}
 & (p^{:A\rightarrow B})^{\uparrow\text{Opt}}\bef\text{flm}_{\text{Opt}}(q^{:B\rightarrow\text{Opt}^{C}})=\text{flm}_{\text{Opt}}(\text{???}^{:A\rightarrow\text{Opt}^{C}})\quad,\\
 & \text{flm}_{\text{Opt}}(p^{:A\rightarrow\text{Opt}^{B}})\bef(q^{:B\rightarrow C})^{\uparrow\text{Opt}}=\text{flm}_{\text{Opt}}(\text{???}^{:A\rightarrow\text{Opt}^{C}})\quad.
\end{align*}

\end_inset

The typed holes must be filled using the only available data (the functions
 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

):
\begin_inset Formula 
\begin{align}
 & (p^{:A\rightarrow B})^{\uparrow\text{Opt}}\bef\text{flm}_{\text{Opt}}(q^{:B\rightarrow\text{Opt}^{C}})=\text{flm}_{\text{Opt}}(p\bef q)\quad,\label{eq:left-naturality-flatmap-option}\\
 & \text{flm}_{\text{Opt}}(p^{:A\rightarrow\text{Opt}^{B}})\bef(q^{:B\rightarrow C})^{\uparrow\text{Opt}}=\text{flm}_{\text{Opt}}(p\bef q^{\uparrow\text{Opt}})\quad.\label{eq:right-naturality-flatmap-option}
\end{align}

\end_inset

We omit the proofs for these 
\series bold
naturality laws
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
flatMap
\family default
 for 
\family typewriter
Option
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 With them, we transform Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-lhs-remaining-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-rhs-remaining-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

): 
\begin_inset Formula 
\begin{align*}
 & \gunderline{r_{f,g}^{\uparrow\text{Opt}}\bef}\,\text{flm}_{\text{Opt}}\big(a^{\prime}\times g^{\prime}\rightarrow a^{\prime}\triangleright f^{\prime}\bef r_{f^{\prime},g^{\prime}}^{\uparrow\text{Opt}}\big)\\
\text{use Eq.~(\ref{eq:left-naturality-flatmap-option})}:\quad & =\text{flm}_{\text{Opt}}\big(\gunderline{r_{f,g}}\bef\big(a^{\prime}\times g^{\prime}\rightarrow a^{\prime}\triangleright f^{\prime}\bef r_{f^{\prime},g^{\prime}}^{\uparrow\text{Opt}}\big)\big)\\
\text{expand }r_{f,g}:\quad & =\text{flm}_{\text{Opt}}\big((a\rightarrow a\times\text{liftOpt}_{G}(f)(g))\bef\big(a^{\prime}\times g^{\prime}\rightarrow a^{\prime}\triangleright f^{\prime}\bef r_{f^{\prime},g^{\prime}}^{\uparrow\text{Opt}}\big)\big)\\
\text{compute composition}:\quad & =\text{flm}_{\text{Opt}}\big(a\rightarrow a\triangleright f^{\prime}\bef r_{f^{\prime},\text{liftOpt}_{G}(f)(g)}^{\uparrow\text{Opt}}\big)\quad,
\end{align*}

\end_inset

and:
\begin_inset Formula 
\begin{align*}
 & \text{flm}_{\text{Opt}}(f^{\prime})\,\gunderline{\bef r_{f\bef\text{flm}_{\text{Opt}}(f^{\prime}),g}^{\uparrow\text{Opt}}}=\text{flm}_{\text{Opt}}\big(\gunderline{f^{\prime}}\bef r_{f\bef\text{flm}_{\text{Opt}}(f^{\prime}),g}^{\uparrow\text{Opt}}\big)\\
\text{expand function }f^{\prime}:\quad & =\text{flm}_{\text{Opt}}\big(a\rightarrow a\triangleright f^{\prime}\bef r_{f\bef\text{flm}_{\text{Opt}}(f^{\prime}),g}^{\uparrow\text{Opt}}\big)\quad.
\end{align*}

\end_inset

The difference between sub-expressions has become smaller; it just remains
 to show the following:
\begin_inset Formula 
\[
r_{f^{\prime},\text{liftOpt}_{G}(f)(g)}\overset{?}{=}r_{f\bef\text{flm}_{\text{Opt}}(f^{\prime}),g}\quad.
\]

\end_inset

Expand the definition of 
\begin_inset Formula $r_{f,g}$
\end_inset

 in both sides:
\begin_inset Formula 
\[
b\rightarrow b\times\gunderline{\text{liftOpt}_{G}(f^{\prime})\big(\text{liftOpt}_{G}(f)(g)\big)}\overset{?}{=}b\rightarrow b\times\gunderline{\text{liftOpt}_{G}\big(f\bef\text{flm}_{\text{Opt}}(f^{\prime})\big)(g)}\quad.
\]

\end_inset

Omitting the common sub-expressions, we find the remaining difference:
\begin_inset Formula 
\[
\text{liftOpt}_{G}(f^{\prime})\big(\text{liftOpt}_{G}(f)(g)\big)\overset{?}{=}\text{liftOpt}_{G}\big(f\bef\text{flm}_{\text{Opt}}(f^{\prime})\big)(g)\quad.
\]

\end_inset

This is equivalent to 
\begin_inset Formula $\text{liftOpt}_{G}$
\end_inset

's composition law  applied to the function 
\begin_inset Formula $g$
\end_inset

:
\begin_inset Formula 
\[
g\triangleright\text{liftOpt}_{G}(f)\bef\text{liftOpt}_{G}(f^{\prime})=g\triangleright\text{liftOpt}_{G}(\gunderline{f\diamond_{_{\text{Opt}}}f^{\prime}})=g\triangleright\text{liftOpt}_{G}\big(f\bef\text{flm}_{\text{Opt}}(f^{\prime})\big)\quad.
\]

\end_inset

Since the composition law of 
\begin_inset Formula $\text{liftOpt}_{G}$
\end_inset

 is assumed to hold, we have finished the proof of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:liftOpt-composition-law-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The construction in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 implements a special kind of filtering where the value 
\begin_inset Formula $a^{:A}$
\end_inset

 in the pair of type 
\begin_inset Formula $A\times G^{A}$
\end_inset

 needs to pass the filter for any data to remain in the functor after filtering.
 We can use the same construction repeatedly with 
\begin_inset Formula $G^{\bullet}\triangleq\bbnum 1$
\end_inset

 and obtain the type:
\begin_inset Formula 
\[
L_{n}^{A}\triangleq\underbrace{\bbnum 1+A\times\left(\bbnum 1+A\times\left(\bbnum 1+...\times(\bbnum 1+A\times\bbnum 1)\right)\right)}_{\text{parameter }A\text{ is used }n\text{ times}}\quad,
\]

\end_inset

which is equivalent to a list of up to 
\begin_inset Formula $n$
\end_inset

 elements.
 The construction defines a filtering operation for 
\begin_inset Formula $L_{n}^{\bullet}$
\end_inset

 that will delete any data beyond the first value of type 
\begin_inset Formula $A$
\end_inset

 that does fails the predicate.
 It is clear that this filtering operation implements the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 method defined on sequences.
\begin_inset Index idx
status open

\begin_layout Plain Layout
filterable!defined via 
\family typewriter
takeWhile
\end_layout

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "proof-that-takeWhile-is-a-lawful-filter"

\end_inset

So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 is a lawful filtering operation (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 where it was used).
\end_layout

\begin_layout Standard
We can also generalize the construction of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to the functor:
\begin_inset Formula 
\[
F^{A}\triangleq\bbnum 1+\underbrace{A\times A\times...\times A}_{n\text{ times}}\times\,G^{A}\quad.
\]

\end_inset

We implement the filtering operation with the requirement that 
\emph on
all
\emph default
 
\begin_inset Formula $n$
\end_inset

 values of type 
\begin_inset Formula $A$
\end_inset

 in the tuple 
\begin_inset Formula $A\times A\times...\times A\times G^{A}$
\end_inset

 must pass the filtering predicate, or else 
\begin_inset Formula $F^{A}$
\end_inset

 becomes empty.
 Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how such filtering operations may be used in practice.
\end_layout

\begin_layout Paragraph
Function types
\end_layout

\begin_layout Standard
As we have seen in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

), functors involving a function type, such as 
\begin_inset Formula $F^{A}\triangleq G^{A}\rightarrow H^{A}$
\end_inset

, require 
\begin_inset Formula $G^{\bullet}$
\end_inset

 to be a 
\emph on
contrafunctor
\emph default
 rather than a functor.
 It turns out that the functor 
\begin_inset Formula $G^{A}\rightarrow H^{A}$
\end_inset

 is filterable only if the contrafunctor 
\begin_inset Formula $G^{\bullet}$
\end_inset

 has certain properties (Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-identity-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) below) similar to properties of filterable functors.
 We will call such contrafunctors 
\series bold
filterable
\series default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
filterable!contrafunctor
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To motivate the definition of filterable contrafunctors, consider the operation
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 for 
\begin_inset Formula $F$
\end_inset

:
\begin_inset Formula 
\[
\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B}):(G^{A}\rightarrow H^{A})\rightarrow G^{B}\rightarrow H^{B}\quad,\quad\quad\text{liftOpt}_{F}(f)=p^{:G^{A}\rightarrow H^{A}}\rightarrow g^{:G^{B}}\rightarrow\text{???}^{:H^{B}}\quad.
\]

\end_inset

Assume that 
\begin_inset Formula $H$
\end_inset

 is filterable, so that we have the function 
\begin_inset Formula $\text{liftOpt}_{H}(f):H^{A}\rightarrow H^{B}$
\end_inset

.
 We will fill the typed hole 
\begin_inset Formula $\text{???}^{:H^{B}}$
\end_inset

 if we somehow get a value of type 
\begin_inset Formula $H^{A}$
\end_inset

; that is only possible if we apply 
\begin_inset Formula $p^{:G^{A}\rightarrow H^{A}}$
\end_inset

,
\begin_inset Formula 
\[
\text{liftOpt}_{F}(f)=p^{:G^{A}\rightarrow H^{A}}\rightarrow g^{:G^{B}}\rightarrow\text{liftOpt}_{H}(f)(p(\text{???}^{:G^{A}}))\quad.
\]

\end_inset

The only way to proceed is to have a function 
\begin_inset Formula $G^{B}\rightarrow G^{A}$
\end_inset

.
 We cannot obtain such a function by lifting 
\begin_inset Formula $f$
\end_inset

 to the contrafunctor 
\begin_inset Formula $G$
\end_inset

: that gives 
\begin_inset Formula $f^{\downarrow G}:G^{\bbnum 1+B}\rightarrow G^{A}$
\end_inset

.
 So, we need to require having a function:
\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{G}(f^{:A\rightarrow\bbnum 1+B}):G^{B}\rightarrow G^{A}\quad.\label{eq:type-signature-liftOpt-contrafunctors}
\end{equation}

\end_inset

This function is analogous to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 for functors, except for the reverse direction of transformation (
\begin_inset Formula $G^{B}\rightarrow G^{A}$
\end_inset

 instead of 
\begin_inset Formula $G^{A}\rightarrow G^{B}$
\end_inset

).
 We can now complete the implementation of 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\triangleq p^{:G^{A}\rightarrow H^{A}}\rightarrow g^{:G^{B}}\rightarrow\gunderline{\text{liftOpt}_{H}(f)\big(p(\text{\text{liftOpt}}_{G}(f)(g))\big)}\nonumber \\
\triangleright\text{-notation}:\quad & =p^{:G^{A}\rightarrow H^{A}}\rightarrow\gunderline{g^{:G^{B}}\rightarrow g\,\triangleright}\,\text{\text{liftOpt}}_{G}(f)\triangleright p\triangleright\text{liftOpt}_{H}(f)\nonumber \\
\text{omit }(g\rightarrow g\,\triangleright):\quad & =p\rightarrow\text{\text{liftOpt}}_{G}(f)\bef p\bef\text{liftOpt}_{H}(f)\quad.\label{eq:def-of-liftopt-function-type}
\end{align}

\end_inset

Note that the last line is similar to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-functor-exponential-def-of-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) but with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow F}=p^{:G^{A}\rightarrow H^{A}}\rightarrow f^{\downarrow G}\bef p\bef f^{\uparrow F}=p\rightarrow\text{cmap}_{G}(f)\bef p\bef\text{fmap}_{F}(f)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The laws for filterable contrafunctors are chosen such that 
\begin_inset Formula $F^{A}\triangleq G^{A}\rightarrow H^{A}$
\end_inset

 can be shown to obey filtering laws when 
\begin_inset Formula $H^{\bullet}$
\end_inset

 is a filterable functor and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is a filterable contrafunctor.
 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filterable-function-type"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-function-type"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume that 
\begin_inset Formula $H^{\bullet}$
\end_inset

 is a lawful filterable functor and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is a contrafunctor with a function 
\begin_inset Formula $\text{liftOpt}_{G}$
\end_inset

 having type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:type-signature-liftOpt-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and obeying the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-identity-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shown below.
 Then the functor 
\begin_inset Formula $F^{A}\triangleq G^{A}\rightarrow H^{A}$
\end_inset

 is filterable.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We will arrive at the required laws for 
\begin_inset Formula $G$
\end_inset

 by trying to prove the laws for 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Standard
Because of the function type of 
\begin_inset Formula $F^{\bullet}$
\end_inset

, it is convenient for derivations to apply both sides of the laws to an
 arbitrary value 
\begin_inset Formula $p^{:G^{A}\rightarrow H^{A}}$
\end_inset

.
 Consider the naturality-identity law of 
\begin_inset Formula $F$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p\triangleright f^{\uparrow F}=f^{\downarrow G}\bef p\bef f^{\uparrow H}:\quad & p\triangleright\text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})\\
\text{definition~(\ref{eq:def-of-liftopt-function-type}) of }\text{liftOpt}_{F}:\quad & =\text{\text{liftOpt}}_{G}(f\bef\text{pu}_{\text{Opt}})\bef p\bef\gunderline{\text{liftOpt}_{H}(f\bef\text{pu}_{\text{Opt}})}\\
\text{naturality-identity law of }\text{liftOpt}_{H}:\quad & =\text{\text{liftOpt}}_{G}(f\bef\text{pu}_{\text{Opt}})\bef p\bef\gunderline{f^{\uparrow H}}\quad.
\end{align*}

\end_inset

The only sub-expression that remains different is 
\begin_inset Formula $\text{\text{liftOpt}}_{G}(f\bef\text{pu}_{\text{Opt}})$
\end_inset

, and the derivation will be finished if we assume the 
\series bold
naturality-identity law
\series default
 of filterable contrafunctors
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of filterable contrafunctors
\end_layout

\end_inset

 to be:
\begin_inset Formula 
\begin{equation}
\text{\text{liftOpt}}_{G}(f\bef\text{pu}_{\text{Opt}})=f^{\downarrow G}\quad.\label{eq:naturality-identity-law-filterable-contrafunctor}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The composition law of 
\begin_inset Formula $F$
\end_inset

 applied to a value to a value 
\begin_inset Formula $p^{:G^{A}\rightarrow H^{A}}$
\end_inset

 is:
\begin_inset Formula 
\begin{align*}
\text{left-hand side of Eq.~(\ref{eq:composition-law-of-liftOpt}) for }F:\quad & p\triangleright\text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)=\gunderline{p\triangleright\text{liftOpt}_{F}(f)}\triangleright\text{liftOpt}_{F}(g)\\
\text{definition~(\ref{eq:def-of-liftopt-function-type}) of }\text{liftOpt}_{F}:\quad & =\big(\text{\text{liftOpt}}_{G}(f)\bef p\bef\text{liftOpt}_{H}(f)\big)\,\gunderline{\triangleright\text{liftOpt}_{F}(g)}\\
\text{definition~(\ref{eq:def-of-liftopt-function-type})}:\quad & =\text{\text{liftOpt}}_{G}(g)\bef\big(\text{\text{liftOpt}}_{G}(f)\bef p\bef\gunderline{\text{liftOpt}_{H}(f)\big)\bef\text{liftOpt}_{H}(g)}\\
\text{composition law~(\ref{eq:composition-law-of-liftOpt}) of }\text{liftOpt}_{H}:\quad & =\text{\text{liftOpt}}_{G}(g)\bef\text{\text{liftOpt}}_{G}(f)\bef p\bef\text{liftOpt}_{H}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset

The right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $F$
\end_inset

 is:
\begin_inset Formula 
\[
p\triangleright\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)=\text{liftOpt}_{G}(f\diamond_{_{\text{Opt}}}g)\bef p\bef\text{liftOpt}_{H}(f\diamond_{_{\text{Opt}}}g)\quad.
\]

\end_inset

Clearly, we need to require the 
\series bold
composition law
\series default
 of filterable
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of filterable contrafunctor
\end_layout

\end_inset

 contrafunctor 
\begin_inset Formula $G$
\end_inset

 to be:
\begin_inset Formula 
\begin{equation}
\text{\text{liftOpt}}_{G}(g)\bef\text{\text{liftOpt}}_{G}(f)=\text{liftOpt}_{G}(f\diamond_{_{\text{Opt}}}g)\quad.\label{eq:composition-law-filterable-contrafunctor}
\end{equation}

\end_inset

Assuming that 
\begin_inset Formula $\text{liftOpt}_{G}$
\end_inset

 satisfies this law, we obtain Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $F$
\end_inset

 and so conclude the proof.
\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
How to generalize the filtering operation from sequences to other recursive
 types? For motivation, we look at two examples: the filterable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor defined by:
\begin_inset Formula 
\[
\text{List}^{A}\triangleq\bbnum 1+A\times\text{List}^{A}\quad,
\]

\end_inset

and the recursive construction for ordinary functors (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-recursive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that requires a bifunctor 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filterable-recursive-type"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-recursive-type"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is a filterable functor, the recursive functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 defined by:
\begin_inset Formula 
\[
F^{A}\triangleq G^{A}+A\times F^{A}
\]

\end_inset

is filterable.
 With 
\begin_inset Formula $G^{A}\triangleq\bbnum 1$
\end_inset

, this construction reproduces the standard filtering operation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We first need to implement the type constructor 
\begin_inset Formula $F$
\end_inset

 and the function 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]                               // Assume that the functor
 G was defined previously.
\end_layout

\begin_layout Plain Layout

final case class FG[A](g: G[A]) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class FAF[A](a: A, rf: F[A]) extends F[A]
\end_layout

\begin_layout Plain Layout

                                         // Assume that liftOpt_G is available
 and define liftOpt_F:
\end_layout

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B]): F[A] => F[B] = {
\end_layout

\begin_layout Plain Layout

   case FG(g)       => FG(liftOpt_G(f)(g))
\end_layout

\begin_layout Plain Layout

   case FAF(a, rf)  => f(a) match {                      // Does `a` pass
 the filtering predicate?
\end_layout

\begin_layout Plain Layout

      case None        => liftOpt_F(f)(rf)              // No.
 Drop `a` and filter `rf` recursively.
\end_layout

\begin_layout Plain Layout

      case Some(b)     => FAF[B](b, liftOpt_F(f)(rf))  // Yes.
 Keep `b` and filter `rf` recursively.
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\triangleq\,\begin{array}{|c||c|}
 & F^{B}\\
\hline G^{A} & g^{:G^{A}}\rightarrow\text{liftOpt}_{G}(f)(g)+\bbnum 0^{:B\times F^{B}}\\
A\times F^{A} & a^{:A}\times r^{:F^{A}}\rightarrow f(a)\triangleright\begin{array}{|c||c|}
 & F^{B}\\
\hline \bbnum 1 & 1\rightarrow\overline{\text{liftOpt}_{F}}(f)(r)\\
B & b^{:B}\rightarrow\bbnum 0^{:G^{B}}+b\times\overline{\text{liftOpt}_{F}}(f)(r)
\end{array}
\end{array}\quad.
\]

\end_inset

The overline denotes recursive uses of 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 within its definition.
\end_layout

\begin_layout Standard
With this definition of 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

, it is inconvenient to use matrix composition because the matrix shown
 above has a single column instead of columns split by the disjunctive type
 
\begin_inset Formula $F^{A}=G^{A}+A\times F^{A}$
\end_inset

.
 We have seen a similar problem in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where we rewrote the code via 
\begin_inset Formula $\text{flm}_{\text{Opt}}$
\end_inset

 and avoided using matrices with non-split columns.
 But it is not clear how to rewrite the code for 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 in that way.
 Instead, we use a more straightforward approach: apply both sides of the
 laws to an arbitrary value of type 
\begin_inset Formula $F^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
The disjunctive type 
\begin_inset Formula $F^{A}$
\end_inset

 has two cases, 
\begin_inset Formula $G^{A}+\bbnum 0^{:A\times F^{A}}$
\end_inset

 and 
\begin_inset Formula $\bbnum 0^{:G^{A}}+A\times F^{A}$
\end_inset

.
 When applied to a value 
\begin_inset Formula $g^{:G^{A}}+\bbnum 0$
\end_inset

, the function 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 is exactly the same as 
\begin_inset Formula $\text{liftOpt}_{G}$
\end_inset

, so both laws are satisfied since 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is a lawful filterable functor.
 It remains to verify the laws when applied to a value 
\begin_inset Formula $\bbnum 0^{:G^{A}}+a^{:A}\times r^{:F^{A}}$
\end_inset

.
\end_layout

\begin_layout Standard
To prepare for the calculations, write the result of applying 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 to a value 
\begin_inset Formula $\bbnum 0+a\times r$
\end_inset

:
\begin_inset Formula 
\begin{equation}
(\bbnum 0^{:G^{A}}+a^{:A}\times r^{:F^{A}})\triangleright\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})=f(a)\triangleright\,\begin{array}{|c||c|}
 & F^{B}\\
\hline \bbnum 1 & 1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f)\\
B & b^{:B}\rightarrow\bbnum 0^{:G^{B}}+\left(b\times r\right)\triangleright\overline{\text{liftOpt}_{F}}(f)
\end{array}\quad.\label{eq:expression-liftOpt-derivation2}
\end{equation}

\end_inset

To check the naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

, begin with the left-hand side:
\begin_inset Formula 
\begin{align*}
 & (\bbnum 0+a\times r)\triangleright\text{liftOpt}_{F}(\gunderline{f\bef\text{pu}_{\text{Opt}}})=(\bbnum 0+a\times r)\triangleright\text{liftOpt}_{F}(x\rightarrow\bbnum 0+f(x))\\
\text{use Eq.~(\ref{eq:expression-liftOpt-derivation2})}:\quad & =\gunderline{a\triangleright(f\bef\text{pu}_{\text{Opt}})}\bef\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})(r)\\
b^{:B}\rightarrow\bbnum 0+\left(b\times r\right)\triangleright\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})
\end{array}\\
\text{evaluate function of }a:\quad & =\big(\bbnum 0+f(a)\big)\triangleright\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})\\
b^{:B}\rightarrow\bbnum 0+\left(b\times r\right)\triangleright\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})
\end{array}\\
\text{substitute into matrix}:\quad & =\bbnum 0+\left(f(a)\times r\right)\triangleright\gunderline{\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})}\\
\text{inductive assumption}:\quad & =\bbnum 0+\left(f(a)\times r\right)\triangleright\gunderline{f^{\uparrow F}}\quad.
\end{align*}

\end_inset

 The same expression is found by applying the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $\bbnum 0+a\times r$
\end_inset

:
\begin_inset Formula 
\[
(\bbnum 0^{:G^{A}}+a^{:A}\times r^{:F^{A}})\triangleright(f^{:A\rightarrow B})^{\uparrow F}=\bbnum 0^{:G^{A}}+f(a)\times f^{\uparrow F}(r)=\bbnum 0+f(a)\times r\triangleright f^{\uparrow F}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), apply its left-hand side to 
\begin_inset Formula $\bbnum 0+a\times r$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (\bbnum 0+a\times r)\triangleright\text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)\\
\text{use Eq.~(\ref{eq:expression-liftOpt-derivation2})}:\quad & =f(a)\triangleright\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f)\\
b^{:B}\rightarrow\bbnum 0+\left(b\times r\right)\triangleright\overline{\text{liftOpt}_{F}}(f)
\end{array}\,\,\gunderline{\triangleright\,\text{liftOpt}_{F}(g)}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align}
\text{apply }\text{liftOpt}_{F}(g):\quad & =f(a)\triangleright\,\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f)\,\triangleright\,\text{liftOpt}_{F}(g)\\
b^{:B}\rightarrow\big(\bbnum 0+\left(b\times r\right)\triangleright\overline{\text{liftOpt}_{F}}(f)\big)\triangleright\text{liftOpt}_{F}(g)
\end{array}\nonumber \\
\text{use Eq.~(\ref{eq:expression-liftOpt-derivation2})}:\quad & =f(a)\triangleright\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f)\bef\text{liftOpt}_{F}(g)\\
b^{:B}\rightarrow g(b)\triangleright\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f)\bef\overline{\text{liftOpt}_{F}}(g)\\
c^{:C}\rightarrow\bbnum 0+\left(c\times r\right)\triangleright\overline{\text{liftOpt}_{F}}(f)\bef\overline{\text{liftOpt}_{F}}(g)
\end{array}
\end{array}\\
\text{inductive assumption}:\quad & =a\triangleright f\bef\,\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f\diamond_{_{\text{Opt}}}g)\\
b^{:B}\rightarrow g(b)\triangleright\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f\diamond_{_{\text{Opt}}}g)\\
c^{:C}\rightarrow\bbnum 0+\left(c\times r\right)\triangleright\overline{\text{liftOpt}_{F}}(f\diamond_{_{\text{Opt}}}g)
\end{array}
\end{array}\quad.\label{eq:lhs-comp-law-liftOpt-derivation2}
\end{align}

\end_inset

We are justified in using the inductive assumption on the composition 
\begin_inset Formula $\overline{\text{liftOpt}_{F}}(f)\bef\text{liftOpt}_{F}(g)$
\end_inset

 even though 
\begin_inset Formula $\text{liftOpt}_{F}(g)$
\end_inset

 is not a recursive call.
 It is sufficient that at least one term in the function composition is
 a recursive call to 
\begin_inset Formula $\overline{\text{liftOpt}_{F}}$
\end_inset

.
\end_layout

\begin_layout Standard
The right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) applied to 
\begin_inset Formula $\bbnum 0+a\times r$
\end_inset

 gives:
\begin_inset Formula 
\begin{align*}
 & (\bbnum 0+a\times r)\triangleright\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\\
\text{use Eq.~(\ref{eq:expression-liftOpt-derivation2})}:\quad & =a\triangleright(f\diamond_{_{\text{Opt}}}g)\triangleright\,\begin{array}{||c|}
1\rightarrow r\triangleright\overline{\text{liftOpt}_{F}}(f\diamond_{_{\text{Opt}}}g)\\
c^{:C}\rightarrow\bbnum 0+\left(c\times r\right)\triangleright\overline{\text{liftOpt}_{F}}(f\diamond_{_{\text{Opt}}}g)
\end{array}\quad.
\end{align*}

\end_inset

The only remaining difference compared with the last expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:lhs-comp-law-liftOpt-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is:
\begin_inset Formula 
\begin{equation}
f\bef\,\begin{array}{||c|}
p\\
b^{:B}\rightarrow g(b)\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}
\end{array}\,\overset{?}{=}(f\diamond_{_{\text{Opt}}}g)\bef\,\begin{array}{||c|}
p\\
q
\end{array}\quad,\label{eq:comp-liftOpt-last-diff-derivation2}
\end{equation}

\end_inset

where 
\begin_inset Formula $p\triangleq1\rightarrow r\triangleright\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)$
\end_inset

 and 
\begin_inset Formula $q\triangleq c\rightarrow\bbnum 0+c\times r\triangleright\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)$
\end_inset

 are some fixed functions.
 We can show that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:comp-liftOpt-last-diff-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for arbitrary functions 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 Start from the right-hand side:
\begin_inset Formula 
\begin{align*}
\text{expect the l.h.s.~of Eq.~(\ref{eq:comp-liftOpt-last-diff-derivation2})}:\quad & (\gunderline{f\diamond_{_{\text{Opt}}}g})\bef\,\begin{array}{||c|}
p\\
q
\end{array}\,=f\bef\gunderline{\text{flm}_{\text{Opt}}(g)}\bef\,\begin{array}{||c|}
p\\
q
\end{array}\,=f\bef\,\begin{array}{||c|}
1\rightarrow1+\bbnum 0\\
b\rightarrow g(b)
\end{array}\,\bef\,\begin{array}{||c|}
p\\
q
\end{array}\\
{\color{green}\text{apply }\,\,\begin{array}{||c|}
p\\
q
\end{array}\,:}\quad & =f\bef\,\begin{array}{||c|}
1\rightarrow\gunderline{(1+\bbnum 0)\,\triangleright}\,\begin{array}{||c|}
p\\
q
\end{array}\\
b\rightarrow g(b)\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}
\end{array}\,=f\bef\,\begin{array}{||c|}
1\rightarrow p\\
b\rightarrow g(b)\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}
\end{array}\quad.
\end{align*}

\end_inset

This proves Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:comp-liftOpt-last-diff-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and concludes the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-recursive-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
This implementation preserves all values 
\begin_inset Formula $x^{:A}$
\end_inset

 except those that fail the filtering predicate (i.e., when 
\begin_inset Formula $f(x)=1+\bbnum 0$
\end_inset

).
 So, it has the same filtering logic as the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 method for sequences.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The next construction is for a functor defined via a filterable recursion
 scheme.
 The filtering logic is then different from that used in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-recursive-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filterable-recursive-type-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-recursive-type-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $S^{A,R}$
\end_inset

 is a bifunctor that is filterable with respect to 
\begin_inset Formula $A$
\end_inset

, the recursive functor 
\begin_inset Formula $F^{A}$
\end_inset

 defined by the recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 (type equation 
\begin_inset Formula $F^{A}\triangleq S^{A,F^{A}}$
\end_inset

) is filterable.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We follow the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-recursive"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Implement 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 recursively as:
\begin_inset Formula 
\[
\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\triangleq\text{liftOpt}_{S}(f)\bef\text{bimap}_{S}(\text{id})\big(\overline{\text{liftOpt}_{F}}(f)\big)=\text{liftOpt}_{S}(f)\bef\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{B,\bullet}}\quad.
\]

\end_inset

where 
\begin_inset Formula $\text{liftOpt}_{S}$
\end_inset

 is assumed to obey the laws.
 The lifting to 
\begin_inset Formula $F$
\end_inset

 is defined (also recursively) by:
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow F}\triangleq\text{bimap}_{S}(f)(\overline{f^{\uparrow F}})=f^{\uparrow S^{\bullet,R}}\bef\big(\overline{f^{\uparrow F}}\big)^{\uparrow S^{B,\bullet}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\uparrow F}:\quad & \text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})=\gunderline{\text{liftOpt}_{S}(f\bef\text{pu}_{\text{Opt}})}\bef\big(\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})\big)^{\uparrow S^{B,\bullet}}\\
\text{law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) of }\text{liftOpt}_{S}:\quad & =f^{\uparrow S^{\bullet,R}}\bef\big(\gunderline{\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})}\big)^{\uparrow S^{B,\bullet}}\\
\text{inductive assumption}:\quad & =f^{\uparrow S^{\bullet,R}}\bef\big(\overline{f^{\uparrow F}}\big)^{\uparrow S^{B,\bullet}}=f^{\uparrow F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), compute:
\begin_inset Formula 
\begin{align*}
 & \text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)\\
 & =\text{liftOpt}_{S}(f)\bef\gunderline{\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{B,\bullet}}\bef\text{liftOpt}_{S}(g)}\bef\big(\overline{\text{liftOpt}_{F}}(g)\big)^{\uparrow S^{C,\bullet}}\\
\text{naturality of }\text{liftOpt}_{S}:\quad & =\gunderline{\text{liftOpt}_{S}(f)\bef\text{liftOpt}_{S}(g)}\bef\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{C,\bullet}}\,\gunderline{\bef}\,\big(\overline{\text{liftOpt}_{F}}(g)\big)^{\uparrow S^{C,\bullet}}\\
\text{law~(\ref{eq:composition-law-of-liftOpt}) of }\text{liftOpt}_{S}:\quad & =\text{liftOpt}_{S}(f\diamond_{_{\text{Opt}}}g)\bef\big(\gunderline{\overline{\text{liftOpt}_{F}}(f)\bef\overline{\text{liftOpt}_{F}}(g)}\big)^{\uparrow S^{C,\bullet}}\\
\text{inductive assumption}:\quad & =\text{liftOpt}_{S}(f\diamond_{_{\text{Opt}}}g)\bef\overline{\text{liftOpt}_{F}}(f\diamond_{_{\text{Opt}}}g)=\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset

We have assumed a 
\series bold
naturality law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
liftOpt
\end_layout

\end_inset

 of 
\begin_inset Formula $\text{liftOpt}_{S}$
\end_inset

 with respect to the type parameter 
\begin_inset Formula $R$
\end_inset

 of 
\begin_inset Formula $S^{A,R}$
\end_inset

:
\begin_inset Formula 
\[
\big(p^{:R\rightarrow R^{\prime}}\big)^{\uparrow S^{B,\bullet}}\bef\text{liftOpt}_{S}(g^{:B\rightarrow\bbnum 1+C})=\text{liftOpt}_{S}(g^{:B\rightarrow\bbnum 1+C})\bef\big(p^{:R\rightarrow R^{\prime}}\big)^{\uparrow S^{C,\bullet}}\quad.
\]

\end_inset


\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{5.5pc}S^{B,R}\ar[r]\sp(0.5){~\text{liftOpt}_{S}(g^{:B\rightarrow\bbnum 1+C})}\ar[d]\sb(0.4){\big(p^{:R\rightarrow R^{\prime}}\big)^{\uparrow S^{B,\bullet}}} & S^{C,R}\ar[d]\sp(0.4){\big(p^{:R\rightarrow R^{\prime}}\big)^{\uparrow S^{C,\bullet}}}\\
S^{B,R^{\prime}}\ar[r]\sp(0.5){~\text{liftOpt}_{S}(g^{:B\rightarrow\bbnum 1+C})} & S^{C,R^{\prime}}
}
\]

\end_inset


\end_layout

\end_inset

This naturality law will hold automatically for any fully parametric implementat
ion of 
\begin_inset Formula $\text{liftOpt}_{S}$
\end_inset

 (see Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:Proofs-of-naturality-parametricity"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Filterable contrafunctors: motivation and examples
\end_layout

\begin_layout Standard
An intuitive view is that functors are 
\begin_inset Quotes eld
\end_inset

wrappers
\begin_inset Quotes erd
\end_inset

 of data, while contrafunctors 
\begin_inset Quotes eld
\end_inset

consume
\begin_inset Quotes erd
\end_inset

 data.
 Filterable functors permit us to exclude certain data from a wrapper; filterabl
e contrafunctors permit us to exclude certain data from being consumed.
 Let us now make this intuition precise.
\end_layout

\begin_layout Standard
A simple contrafunctor is 
\begin_inset Formula $C^{A}\triangleq A\rightarrow Z$
\end_inset

, where 
\begin_inset Formula $Z$
\end_inset

 is a constant type.
 This is a general form of an 
\begin_inset Quotes eld
\end_inset

extractor
\begin_inset Quotes erd
\end_inset

 — for example, a function that extracts logging information of type 
\begin_inset Formula $Z$
\end_inset

 from data of an arbitrary type 
\begin_inset Formula $A$
\end_inset

.
 It is sometimes necessary to exclude particular kinds of information (e.g.,
 private personal data) from logging.
 We can implement this by providing a predicate of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Boolean
\end_layout

\end_inset

 that decides, depending on the given value 
\begin_inset Formula $x^{:A}$
\end_inset

, whether 
\begin_inset Formula $x$
\end_inset

 should be passed to the extractor.
 That predicate will be attached to a given extractor 
\begin_inset Formula $c^{:C^{A}}$
\end_inset

 by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean): C[A] => C[A]
\end_layout

\begin_layout Plain Layout

val extractor: C[Payload] = ???           // Original code for extracting
 metadata from payloads.
\end_layout

\begin_layout Plain Layout

val noPrivateData: Payload => Boolean = ???  // Returns true only if payload
 has no private data.
\end_layout

\begin_layout Plain Layout

val filtered: C[Payload] = filter(noPrivateData)(extractor)     // Will
 not extract private data.
\end_layout

\end_inset

How could filtering work when the predicate returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

? Even if the data (of type 
\begin_inset Formula $A$
\end_inset

) is excluded from the filtered extractor, the function of type 
\begin_inset Formula $A\rightarrow Z$
\end_inset

 must still return a value of type 
\begin_inset Formula $Z$
\end_inset

.
 A solution is to have a 
\emph on
default value 
\emph default
of type 
\begin_inset Formula $Z$
\end_inset

 that the extractor will return when data is excluded from it.
\end_layout

\begin_layout Standard
There are two simple ways of implementing filtering for 
\begin_inset Formula $C^{A}=A\rightarrow Z$
\end_inset

 via a default value of type 
\begin_inset Formula $Z$
\end_inset

: First, by storing that default value in the type 
\begin_inset Formula $C^{A}$
\end_inset

 and considering the contrafunctor 
\begin_inset Formula $C^{A}\triangleq Z\times\left(A\rightarrow Z\right)$
\end_inset

 instead of 
\begin_inset Formula $A\rightarrow Z$
\end_inset

.
 Second, by using a type 
\begin_inset Formula $\bbnum 1+Z$
\end_inset

 instead of 
\begin_inset Formula $Z$
\end_inset

, since the type 
\begin_inset Formula $\bbnum 1+Z$
\end_inset

 has a default value 
\begin_inset Formula $1+\bbnum 0^{:Z}$
\end_inset

.
 The following two examples show how this works.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-first-filterable-contrafunctor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-first-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 for the contrafunctor 
\begin_inset Formula $C^{A}\triangleq A\rightarrow\bbnum 1+Z$
\end_inset

, where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
This contrafunctor 
\begin_inset Quotes eld
\end_inset

consumes
\begin_inset Quotes erd
\end_inset

 data of type 
\begin_inset Formula $A$
\end_inset

 and computes values of type 
\begin_inset Formula $\bbnum 1+Z$
\end_inset

.
 Given a value 
\begin_inset Formula $c$
\end_inset

 of type 
\begin_inset Formula $C^{A}$
\end_inset

, which is a function that we might write like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val c: A => Option[Z] = ???
\end_layout

\end_inset

we need somehow to impose a filter predicate 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

 ensuring that the function 
\begin_inset Formula $c$
\end_inset

 is applied only to values that pass the predicate.
 The result will be a new function 
\begin_inset Formula $d^{:A\rightarrow\bbnum 1+Z}$
\end_inset

 that will use its argument only if it passes the predicate.
 The function 
\begin_inset Formula $d$
\end_inset

 could return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 for all arguments, but that implementation would lose information.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(a) == true
\end_layout

\end_inset

, we may compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c(a)
\end_layout

\end_inset

, getting a value of type 
\begin_inset Formula $\bbnum 1+Z$
\end_inset

 that 
\begin_inset Formula $d$
\end_inset

 should return.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(a) == false
\end_layout

\end_inset

, the function 
\begin_inset Formula $d$
\end_inset

 must return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 So, the code of 
\begin_inset Formula $d$
\end_inset

 must be:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val d: A => Option[Z] = { a => if (p(a)) c(a) else None }
\end_layout

\end_inset

The transformation from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

d
\end_layout

\end_inset

 is a filtering operation for the contrafunctor 
\begin_inset Formula $C^{A}$
\end_inset

, implemented as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(c: A => Option[Z]): A => Option[Z] = { a
 => 
\end_layout

\begin_layout Plain Layout

  if (p(a)) c(a) else None
\end_layout

\begin_layout Plain Layout

}                        // Equivalent code is { a => Some(a).filter(p).flatMap(c)
 }
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{filt}_{C}(p^{:A\rightarrow\bbnum 2})\triangleq c^{:A\rightarrow\bbnum 1+Z}\rightarrow\text{pu}_{\text{Opt}}\bef\text{filt}_{\text{Opt}}(p)\bef\text{flm}_{\text{Opt}}(c)=c\rightarrow\psi_{p}\bef\text{flm}_{\text{Opt}}(c)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-first-filterable-contrafunctor-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-first-filterable-contrafunctor-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 for the contrafunctor 
\begin_inset Formula $C^{A}\triangleq Z\times\left(A\rightarrow Z\right)$
\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The code for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean): ((Z, A => Z)) => (Z, A => Z) = {
\end_layout

\begin_layout Plain Layout

  case (z, f) => (z, a => if (p(a)) f(a) else z)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{filt}_{C}(p^{:A\rightarrow\bbnum 2})\triangleq z^{:Z}\times f^{:A\rightarrow Z}\rightarrow z\times\bigg(a^{:A}\rightarrow p(a)\triangleright\,\begin{array}{|c||c|}
 & Z\\
\hline \bbnum 1\,(\text{false}) & z\\
\bbnum 1\,(\text{true}) & f(a)
\end{array}\,\bigg)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Note that the type 
\begin_inset Formula $Z\times\left(A\rightarrow Z\right)$
\end_inset

 is equivalent to 
\begin_inset Formula $\bbnum 1+A\rightarrow Z$
\end_inset

:
\begin_inset Formula 
\[
Z\times\left(A\rightarrow Z\right)\cong\left(\bbnum 1\rightarrow Z\right)\times\left(A\rightarrow Z\right)\cong\bbnum 1+A\rightarrow Z\quad.
\]

\end_inset

For the contrafunctor 
\begin_inset Formula $C^{A}\triangleq\bbnum 1+A\rightarrow Z$
\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function is implemented by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(c: Option[A] => Z): Option[A] => Z = {
\end_layout

\begin_layout Plain Layout

  case Some(a) if p(a)   => c(Some(a))          // Only apply `c` to `a`
 if `p(a) == true`.
\end_layout

\begin_layout Plain Layout

  case _                 => c(None)       // Return c(None) otherwise, or
 for empty Option.
\end_layout

\begin_layout Plain Layout

}                                   // Equivalent code is _.filter(p).pipe(c)
 (Scala 2.13).
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{filt}_{C}(p^{:A\rightarrow\bbnum 2}) & \triangleq c^{:\bbnum 1+A\rightarrow Z}\rightarrow\gunderline{x^{:\bbnum 1+A}\rightarrow x}\triangleright\text{filt}_{\text{Opt}}(p)\triangleright c\\
 & =c^{:\bbnum 1+A\rightarrow Z}\rightarrow\text{filt}_{\text{Opt}}(p)\bef c\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Another motivation for filterable contrafunctors comes from the construction
 
\begin_inset Formula $F^{A}\triangleq G^{A}\rightarrow H^{A}$
\end_inset

 (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-function-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

): In order to assure the properties of a filterable functor for 
\begin_inset Formula $F^{\bullet}$
\end_inset

, the contrafunctor 
\begin_inset Formula $G^{\bullet}$
\end_inset

 must have the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 function as shown in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:type-signature-liftOpt-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The existence of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 function for a contrafunctor turns out to be equivalent to the existence
 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function, as long as suitable laws hold.
 To verify that equivalence, begin by defining the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

, whose role is similar to that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 for filterable functors.
 The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{inflate}_{C}:C^{A}\rightarrow C^{\bbnum 1+A}\quad.
\]

\end_inset

We can relate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 by the following equations (to be derived below):
\begin_inset Formula 
\begin{align}
\text{filt}_{C}(p)=\text{inflate}_{C}\bef(\psi_{p}^{:A\rightarrow\bbnum 1+A})^{\downarrow C}\quad, & \quad\quad\text{inflate}_{C}=\big(\text{get}^{:\bbnum 1+A\rightarrow A}\big)^{\downarrow C}\bef\text{filt}_{C}(\text{nonEmpty})\quad,\label{eq:express-filter-via-inflate-for-contrafunctor}\\
\text{inflate}_{C}=\text{liftOpt}_{C}(\text{id}^{:\bbnum 1+A\rightarrow\bbnum 1+A})\quad, & \quad\quad\text{liftOpt}_{C}(f^{:A\rightarrow\bbnum 1+B})=\text{inflate}_{C}\bef f^{\downarrow C}\quad.\label{eq:express-liftOpt-via-inflate-for-contrafunctors}
\end{align}

\end_inset


\begin_inset Formula 
\[
\xymatrix{C^{\bbnum 1+A}\ar[rd]\sb(0.4){\text{filt}_{C}^{\bbnum 1+A}(\text{nonEmpty}^{:\bbnum 1+A\rightarrow\bbnum 2})~~~~~~~} & C^{A}\ar[l]\sb(0.4){\text{get}^{\downarrow C}}\ar[d]\sp(0.4){\text{inflate}_{C}}\ar[r]\sp(0.5){\text{filt}_{C}^{A}(p^{:A\rightarrow\bbnum 2})} & C^{A} & C^{B}\ar[r]\sp(0.5){\text{inflate}_{C}}\ar[rd]\sb(0.4){\text{liftOpt}_{C}(f)\triangleq~~~} & C^{\bbnum 1+B}\ar[d]\sp(0.45){(f^{:A\rightarrow\bbnum 1+B})^{\downarrow C}}\\
\xyScaleY{1.8pc}\xyScaleX{4.5pc} & C^{\bbnum 1+A}\ar[ru]\sb(0.6){\psi_{p}^{\downarrow C}} &  &  & C^{A}
}
\]

\end_inset

These functions have different but equivalent laws: 
\begin_inset Formula $\text{filt}_{C}$
\end_inset

 has 
\begin_inset Formula $4$
\end_inset

 laws, 
\begin_inset Formula $\text{inflate}_{C}$
\end_inset

 has 
\begin_inset Formula $3$
\end_inset

, and 
\begin_inset Formula $\text{liftOpt}_{C}$
\end_inset

 has just 
\begin_inset Formula $2$
\end_inset

 laws.
 So, 
\begin_inset Formula $\text{liftOpt}_{C}$
\end_inset

 is the most convenient function for proving laws, while 
\begin_inset Formula $\text{inflate}_{C}$
\end_inset

 is the easiest to implement in code (and to check whether a given contrafunctor
 is filterable).
 The laws
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
liftOpt
\family default
 for contrafunctors
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of 
\family typewriter
liftOpt
\family default
 for contrafunctors
\end_layout

\end_inset

 of 
\begin_inset Formula $\text{liftOpt}_{C}$
\end_inset

 are similar to the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 for filterable functors (we omit the derivations):
\begin_inset Formula 
\begin{align*}
\text{naturality law of }\text{liftOpt}_{C}:\quad & \text{liftOpt}_{C}(f^{:A\rightarrow B}\bef g^{:B\rightarrow\bbnum 1+E})=\text{liftOpt}_{C}(g)\bef f^{\downarrow C}\quad,\\
\text{naturality-identity law of }\text{liftOpt}_{C}:\quad & \text{liftOpt}_{C}(f^{:A\rightarrow B}\bef\text{pu}_{\text{Opt}}^{:B\rightarrow\bbnum 1+B})=f^{\downarrow C}\quad,\\
\text{composition law of }\text{liftOpt}_{C}:\quad & \text{liftOpt}_{C}(g^{:B\rightarrow\bbnum 1+E})\bef\text{liftOpt}_{C}(f^{:A\rightarrow\bbnum 1+B})=\text{liftOpt}_{C}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
As an illustration, let us implement these functions for the contrafunctor
 
\begin_inset Formula $C^{A}\triangleq A\rightarrow\bbnum 1+Z$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-solved-example-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 for 
\begin_inset Formula $C^{A}\triangleq A\rightarrow\bbnum 1+Z$
\end_inset

, and verify Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:express-filter-via-inflate-for-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution 
\end_layout

\begin_layout Standard
We implement the type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, preserving information:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def inflate[A](c: A => Option[Z]): Option[A] => Option[Z] = _.flatMap(c)
\end_layout

\begin_layout Plain Layout

def liftOpt[A, B](f: A => Option[B])(c: B => Option[Z]): A => Option[Z]
 = { a => f(a).flatMap(c) }
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{inflate}_{C}\triangleq c^{:A\rightarrow\bbnum 1+Z}\rightarrow\text{flm}_{\text{Opt}}(c)\quad,\quad\quad\text{liftOpt}_{C}(f^{:A\rightarrow\bbnum 1+B})\triangleq c^{:B\rightarrow\bbnum 1+Z}\rightarrow f\bef\text{flm}_{\text{Opt}}(c)=c\rightarrow f\diamond_{_{\text{Opt}}}c\quad.
\]

\end_inset

To verify Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:express-filter-via-inflate-for-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need the code for lifting a function 
\begin_inset Formula $g^{:A\rightarrow B}$
\end_inset

 to the contrafunctor 
\begin_inset Formula $C$
\end_inset

:
\begin_inset Formula 
\[
(g^{:A\rightarrow B})^{\downarrow C}=c^{:B\rightarrow\bbnum 1+Z}\rightarrow\gunderline{a^{:A}\rightarrow c(g(a))}=c^{:B\rightarrow\bbnum 1+Z}\rightarrow\gunderline{g\bef c}\quad.
\]

\end_inset

Now we use the code for 
\begin_inset Formula $\text{filt}_{C}$
\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-first-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and compute 
\begin_inset Formula $\text{get}^{\downarrow C}\bef\text{filt}_{C}(\text{nonEmpty})$
\end_inset

 as
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{inflate}_{C}:\quad & \text{get}^{\downarrow C}\bef\text{filt}_{C}(\text{nonEmpty})\\
\text{definitions of }^{\downarrow C}\text{ and }\text{filt}_{C}:\quad & =(c\rightarrow\text{get}\bef c)\bef(c\rightarrow\psi_{\text{nonEmpty}}\bef\text{flm}_{\text{Opt}}(c))\\
\text{compute composition}:\quad & =c\rightarrow\psi_{\text{nonEmpty}}\bef\text{flm}_{\text{Opt}}(\text{get}\bef c)\\
\text{use naturality law~(\ref{eq:left-naturality-flatmap-option}) of }\text{flm}_{\text{Opt}}:\quad & =c\rightarrow\gunderline{\psi_{\text{nonEmpty}}\bef\text{get}^{\uparrow\text{Opt}}}\bef\text{flm}_{\text{Opt}}(c)\\
\text{use Eq.~(\ref{eq:simplify-psi-nonEmpty-get-opt}) to simplify}:\quad & =c\rightarrow\text{flm}_{\text{Opt}}(c)=\text{inflate}_{C}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In the formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:express-filter-via-inflate-for-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the lifted partial function 
\begin_inset Formula $\text{get}^{\downarrow C}$
\end_inset

 is applied 
\emph on
before
\emph default
 the filtering operation (rather than after filtering, as would be the case
 for filterable functors).
 The derivation shows how the partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 is moved around due to the reverse order of contrafunctor-lifted function
 composition, until we find the expression 
\begin_inset Formula $\psi_{\text{nonEmpty}}\bef\text{get}^{\uparrow\text{Opt}}$
\end_inset

 where the partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 is applied 
\emph on
after
\emph default
 a filter 
\begin_inset Formula $\psi$
\end_inset

 (which makes it a total function due to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

's partial function law).
 For this reason, it is correct to apply lifted partial functions before
 filtering in contrafunctors.
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function law!reverse order in contrafunctors
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-solved-example-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:express-filter-via-inflate-for-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for an arbitrary filterable contrafunctor 
\begin_inset Formula $C^{\bullet}$
\end_inset

, assuming needed laws.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to check the two directions of the isomorphism in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:express-filter-via-inflate-for-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Starting from a given 
\begin_inset Formula $\text{filt}_{C}$
\end_inset

, we compute 
\begin_inset Formula $\text{inflate}_{C}$
\end_inset

 and then use that to define a new 
\begin_inset Formula $\text{filt}_{C}^{\prime}$
\end_inset

; we must show that 
\begin_inset Formula $\text{filt}_{C}=\text{filt}_{C}^{\prime}$
\end_inset

.
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{filt}_{C}(p):\quad & \text{filt}_{C}^{\prime}(p)=\text{inflate}_{C}\bef\psi_{p}^{\downarrow C}=\text{get}^{\downarrow C}\bef\text{filt}_{C}(\text{nonEmpty})\bef\psi_{p}^{\downarrow C}\quad.
\end{align*}

\end_inset

The computation gets stuck here: We could simplify the composition 
\begin_inset Formula $\psi_{p}\bef\text{get}$
\end_inset

 using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-of-psi-p-and-get-simplified"
plural "false"
caps "false"
noprefix "false"

\end_inset

), if only we could move these functions next to each other.
 It is clear that we need a law that exchanges the order of compositions
 of 
\begin_inset Formula $\text{filt}_{C}$
\end_inset

 with lifted functions.
 Typically, that is done by naturality laws.
 By analogy with Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and making sure types match, we write a 
\series bold
naturality law
\series default
 of
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
filter
\family default
 for contrafunctors
\end_layout

\end_inset

 
\begin_inset Formula $\text{filt}_{C}$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
\text{filt}_{C}(p^{:A\rightarrow\bbnum 2})\bef(f^{:B\rightarrow A})^{\downarrow C}=f^{\downarrow C}\bef\text{filt}_{C}(f\bef p)\quad.\label{eq:naturality-for-filter-for-contrafunctors}
\end{equation}

\end_inset

Assuming this law, we find that 
\begin_inset Formula $\text{filt}_{C}^{\prime}(p)=\text{filt}_{C}(p)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{use naturality law of }\text{filt}_{C}:\quad & \text{get}^{\downarrow C}\bef\gunderline{\text{filt}_{C}(\text{nonEmpty})\bef\psi_{p}^{\downarrow C}}=\gunderline{\text{get}^{\downarrow C}\bef\psi_{p}^{\downarrow C}}\bef\text{filt}_{C}(\gunderline{\psi_{p}\bef\text{nonEmpty}})\\
\text{use Eqs.~(\ref{eq:composition-of-psi-p-and-nonEmpty-simplified})--(\ref{eq:composition-of-psi-p-and-get-simplified})}:\quad & =(\gunderline{\psi_{p}\bef\text{get}})^{\downarrow C}\bef\text{filt}_{C}(p)=\gunderline{\text{id}_{|p}^{\downarrow C}}\bef\text{filt}_{C}(p)\\
\text{partial function law of }\text{filt}_{C}:\quad & =\text{id}^{\downarrow C}\bef\text{filt}_{C}(p)=\text{filt}_{C}(p)\quad.
\end{align*}

\end_inset

Here we assumed the partial function law in the form similar to that for
 functors:
\begin_inset Formula 
\[
f_{|p}^{\downarrow C}\bef\text{filt}_{C}(p)=f^{\downarrow C}\bef\text{filt}_{C}(p)\quad.
\]

\end_inset

The lifted partial function 
\begin_inset Formula $f_{|p}^{\downarrow C}$
\end_inset

 is applied 
\emph on
before
\emph default
 filtering, as appropriate for filterable contrafunctors.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Starting from a given 
\begin_inset Formula $\text{inflate}_{C}$
\end_inset

, we compute 
\begin_inset Formula $\text{filt}_{C}$
\end_inset

 and then use that to define a new 
\begin_inset Formula $\text{inflate}_{C}^{\prime}$
\end_inset

; we must show that 
\begin_inset Formula $\text{inflate}_{C}=\text{inflate}_{C}^{\prime}$
\end_inset

.
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{inflate}_{C}:\quad & \text{inflate}_{C}^{\prime}=\text{get}^{\downarrow C}\bef\text{filt}_{C}(\text{nonEmpty})=\text{get}^{\downarrow C}\bef\text{inflate}_{C}\bef\psi_{\text{nonEmpty}}^{\downarrow C}.
\end{align*}

\end_inset

The calculation cannot proceed unless we can exchange lifted functions around
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

.
 By analogy with Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and making changes suitable for contrafunctors, we obtain the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
inflate
\family default
 for contrafunctors
\end_layout

\end_inset


\series bold
naturality law
\series default
 for the function 
\begin_inset Formula $\text{inflate}_{C}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
(f^{:B\rightarrow A})^{\downarrow C}\bef\text{inflate}_{C}=\text{inflate}_{C}\bef f^{\uparrow\text{Opt}\downarrow C}\quad.\label{eq:naturality-law-of-inflate-for-filterable-contrafunctor}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{C^{A}\ar[r]\sp(0.5){\text{inflate}_{C}}\ar[d]\sb(0.45){(f^{:B\rightarrow A})^{\downarrow C}} & C^{\bbnum 1+A}\ar[d]\sp(0.45){(f^{:B\rightarrow A})^{\uparrow\text{Opt}\downarrow C}}\\
\xyScaleY{1.8pc}\xyScaleX{4.5pc}C^{B}\ar[r]\sp(0.5){\text{inflate}_{C}} & C^{\bbnum 1+B}
}
\]

\end_inset

With help of this law, we can finish the derivation:
\begin_inset Formula 
\begin{align*}
\text{use the naturality law}:\quad & \gunderline{\text{get}^{\downarrow C}\bef\text{inflate}_{C}}\bef\psi_{\text{nonEmpty}}^{\downarrow C}=\text{inflate}_{C}\bef\gunderline{\text{get}^{\uparrow\text{Opt}\downarrow C}\bef\psi_{\text{nonEmpty}}^{\downarrow C}}\\
\text{composition lifted to }C:\quad & =\text{inflate}_{C}\bef\big(\gunderline{\psi_{\text{nonEmpty}}\bef\text{get}^{\uparrow\text{Opt}}}\big)^{\downarrow C}\\
\text{use Eq.~(\ref{eq:simplify-psi-nonEmpty-get-opt})}:\quad & =\text{inflate}_{C}\,\gunderline{\bef\text{id}^{\downarrow C}}=\text{inflate}_{C}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-exercise-derive-inflate-liftopt-for-1+a-z"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-derive-inflate-liftopt-for-1+a-z"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 for the filterable contrafunctor 
\begin_inset Formula $C^{A}\triangleq\bbnum 1+A\rightarrow Z$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-exercise-derive-liftOpt-equivalence-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-derive-liftOpt-equivalence-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Verify Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:express-liftOpt-via-inflate-for-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for an arbitrary filterable contrafunctor 
\begin_inset Formula $C^{\bullet}$
\end_inset

, assuming needed laws.
\end_layout

\begin_layout Subsection
Constructions of filterable contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Constructions-of-filterable-contrafunctors"

\end_inset


\end_layout

\begin_layout Standard
How to build up a filterable contrafunctor from parts? Structural analysis
 produces a number of type constructions guaranteed to create lawful filterable
 contrafunctors.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 typeclass is inductive (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Inductive-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

) if formulated via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 or via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, because those methods return the type 
\begin_inset Formula $C^{A}$
\end_inset

 itself.
 So, we expect that the product, the exponential, and the recursive construction
s will apply to filterable contrafunctors (as they do to filterable functors).
\end_layout

\begin_layout Paragraph
Type parameters
\end_layout

\begin_layout Standard
Constant contrafunctors 
\begin_inset Formula $C^{A}\triangleq Z$
\end_inset

 are 
\begin_inset Quotes eld
\end_inset

trivially
\begin_inset Quotes erd
\end_inset

 filterable: all methods are identity functions, so all laws hold.
\end_layout

\begin_layout Standard
Further constructions that work with type parameters are functor compositions.
 The composition 
\begin_inset Formula $P\circ Q\triangleq P^{Q^{\bullet}}$
\end_inset

 is a contrafunctor when 
\begin_inset Formula $P$
\end_inset

 is a functor and 
\begin_inset Formula $Q$
\end_inset

 is a contrafunctor, or vice versa.
 The contrafunctor 
\begin_inset Formula $P^{Q^{\bullet}}$
\end_inset

 is filterable if 
\begin_inset Formula $Q^{\bullet}$
\end_inset

 (whether it is a functor or a contrafunctor) is filterable:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filterable-contrafunctor-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-contrafunctor-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If 
\begin_inset Formula $P^{\bullet}$
\end_inset

 is any contrafunctor and 
\begin_inset Formula $Q^{\bullet}$
\end_inset

 is a filterable functor then 
\begin_inset Formula $P^{Q^{\bullet}}$
\end_inset

 is filterable.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If 
\begin_inset Formula $P^{\bullet}$
\end_inset

 is any functor and 
\begin_inset Formula $Q^{\bullet}$
\end_inset

 is a filterable contrafunctor then 
\begin_inset Formula $P^{Q^{\bullet}}$
\end_inset

 is filterable.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We follow the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-composition-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with necessary modifications.
 
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 operation for 
\begin_inset Formula $P\circ Q$
\end_inset

 as 
\begin_inset Formula $\text{liftOpt}_{P\circ Q}(f^{:A\rightarrow\bbnum 1+B})\triangleq\big(\text{liftOpt}_{Q}(f)\big)^{\downarrow P}$
\end_inset

.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_PQ[A, B](f: A => Option[B]): P[Q[B]] => P[Q[A]] = _.contramap(liftOpt
_Q(f))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify the naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-identity-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\downarrow(P\circ Q)}:\quad & \text{liftOpt}_{P\circ Q}(f\bef\text{pu}_{\text{Opt}})=\big(\gunderline{\text{liftOpt}_{Q}(f\bef\text{pu}_{\text{Opt}})}\big)^{\downarrow P}\\
\text{naturality-identity law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) of }Q:\quad & =f^{\uparrow Q\downarrow P}=f^{\downarrow(P\circ Q)}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we show that its left-hand side equals 
\begin_inset Formula $\text{liftOpt}_{P\circ Q}(f\diamond_{_{\text{Opt}}}g)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{definition of }\text{liftOpt}_{P\circ Q}:\quad & \text{liftOpt}_{P\circ Q}(g)\bef\text{liftOpt}_{P\circ Q}(f)=\big(\text{liftOpt}_{Q}(g)\big)^{\downarrow P}\bef\big(\text{liftOpt}_{Q}(f)\big)^{\downarrow P}\\
\text{composition law of }P:\quad & =\big(\text{liftOpt}_{Q}(f)\bef\text{liftOpt}_{Q}(g)\big)^{\downarrow P}\\
\text{composition law~(\ref{eq:composition-law-of-liftOpt}) of }Q:\quad & =\big(\text{liftOpt}_{Q}(f\diamond_{_{\text{Opt}}}g)\big)^{\downarrow P}=\text{liftOpt}_{P\circ Q}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 operation for 
\begin_inset Formula $P\circ Q$
\end_inset

 as 
\begin_inset Formula $\text{liftOpt}_{P\circ Q}(f^{:A\rightarrow\bbnum 1+B})\triangleq\big(\text{liftOpt}_{Q}(f)\big)^{\uparrow P}$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_PQ[A, B](f: A => Option[B]): P[Q[B]] => P[Q[A]] = _.map(liftOpt_Q(f))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify the naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-identity-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\downarrow(P\circ Q)}:\quad & \text{liftOpt}_{P\circ Q}(f\bef\text{pu}_{\text{Opt}})=\big(\gunderline{\text{liftOpt}_{Q}(f\bef\text{pu}_{\text{Opt}})}\big)^{\uparrow P}\\
\text{naturality-identity law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) of }Q:\quad & =f^{\downarrow Q\uparrow P}=f^{\downarrow(P\circ Q)}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we show that its left-hand side equals 
\begin_inset Formula $\text{liftOpt}_{P\circ Q}(f\diamond_{_{\text{Opt}}}g)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{definition of }\text{liftOpt}_{P\circ Q}:\quad & \text{liftOpt}_{P\circ Q}(g)\bef\text{liftOpt}_{P\circ Q}(f)=\big(\text{liftOpt}_{Q}(g)\big)^{\uparrow P}\bef\big(\text{liftOpt}_{Q}(f)\big)^{\uparrow P}\\
\text{composition law of }P:\quad & =\big(\text{liftOpt}_{Q}(g)\bef\text{liftOpt}_{Q}(f)\big)^{\uparrow P}\\
\text{composition law~(\ref{eq:composition-law-filterable-contrafunctor}) of }Q:\quad & =\big(\text{liftOpt}_{Q}(f\diamond_{_{\text{Opt}}}g)\big)^{\uparrow P}=\text{liftOpt}_{P\circ Q}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Composition of two filterable contrafunctors is a filterable 
\emph on
functor
\emph default
 (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Paragraph
Products and co-products
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $G^{\bullet}$
\end_inset

 and 
\begin_inset Formula $H^{\bullet}$
\end_inset

 are filterable contrafunctors, the product 
\begin_inset Formula $G^{A}\times H^{A}$
\end_inset

 and the co-product 
\begin_inset Formula $G^{A}+H^{A}$
\end_inset

 will also be filterable contrafunctors.
 Proofs are analogous to the case of filterable functors and are delegated
 to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-6-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
We have a construction similar to that of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-function-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for filterable functors:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-function-type-exponential-filterable-contrafunctor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-function-type-exponential-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The contrafunctor 
\begin_inset Formula $F^{A}\triangleq G^{A}\rightarrow H^{A}$
\end_inset

 is filterable for any filterable functor 
\begin_inset Formula $G^{A}$
\end_inset

 and any filterable contrafunctor 
\begin_inset Formula $H^{A}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 operation for 
\begin_inset Formula $F$
\end_inset

 by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B])(p: G[B] => H[B]): G[A] => H[A] =
\end_layout

\begin_layout Plain Layout

  { ga => liftOpt_H(f)(p(liftOpt_G(f)(ga))) }
\end_layout

\end_inset

To obtain a clearer code formula, rewrite the Scala code using the 
\begin_inset Formula $\triangleright$
\end_inset

-notation and then simplify:
\begin_inset Formula 
\begin{align*}
 & \text{liftOpt}_{F}(f)\triangleq p^{:G^{B}\rightarrow H^{B}}\rightarrow\gunderline{g^{:G^{A}}\rightarrow g}\triangleright\text{liftOpt}_{G}(f)\triangleright p\triangleright\text{liftOpt}_{H}(f)\\
\text{simplify }(x\rightarrow x\triangleright y)=y:\quad & \quad=p^{:G^{B}\rightarrow H^{B}}\rightarrow\text{liftOpt}_{G}(f)\bef p\bef\text{liftOpt}_{H}(f)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-identity-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

), apply both its sides to an arbitrary 
\begin_inset Formula $p^{:G^{B}\rightarrow H^{B}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p\triangleright f^{\downarrow F}:\quad & p\triangleright\text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})=\text{liftOpt}_{G}(f\bef\text{pu}_{\text{Opt}})\bef p\bef\text{liftOpt}_{H}(f\bef\text{pu}_{\text{Opt}})\\
\text{use laws~(\ref{eq:naturality-identity-law-filterable-contrafunctor}) and~(\ref{eq:combined-naturality-identity-law-of-liftOpt})}:\quad & =f^{\uparrow G}\bef p\bef f^{\downarrow H}=p\triangleright f^{\downarrow F}\quad.
\end{align*}

\end_inset

To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

), show that its left-hand side equals 
\begin_inset Formula $p\triangleright\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\triangleright\text{-notation}:\quad & p\triangleright\text{liftOpt}_{F}(g)\,\gunderline{\bef}\,\text{liftOpt}_{F}(f)=\big(p\triangleright\text{liftOpt}_{F}(g)\big)\triangleright\gunderline{\text{liftOpt}_{F}(f)}\\
\text{definition of }\text{liftOpt}_{F}(f):\quad & =\text{liftOpt}_{G}(f)\bef\big(\gunderline{p\triangleright\text{liftOpt}_{F}(g)}\big)\bef\text{liftOpt}_{H}(f)\\
\text{definition of }\text{liftOpt}_{F}(g):\quad & =\gunderline{\text{liftOpt}_{G}(f)\bef\text{liftOpt}_{G}(g)}\bef p\bef\gunderline{\text{liftOpt}_{H}(g)\bef\text{liftOpt}_{H}(f)}\\
\text{composition laws of }G\text{ and }H:\quad & =\text{liftOpt}_{G}(f\diamond_{_{\text{Opt}}}g)\bef p\bef\text{liftOpt}_{H}(f\diamond_{_{\text{Opt}}}g)\\
\text{definition of }\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g):\quad & =p\triangleright\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-search-functor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-search-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (the search functor)
\end_layout

\begin_layout Standard
A non-trivial application of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-function-type-exponential-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the 
\series bold
search functor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
search functor
\end_layout

\end_inset

 
\begin_inset Formula $S_{Z}^{\bullet}$
\end_inset

 defined by 
\begin_inset Formula $S_{Z}^{A}\triangleq(A\rightarrow\bbnum 1+Z)\rightarrow\bbnum 1+A$
\end_inset

, where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
 This functor is filterable because it is a function from the filterable
 contrafunctor 
\begin_inset Formula $A\rightarrow\bbnum 1+Z$
\end_inset

 to the filterable functor 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 The simplest case of the search functor is found by setting 
\begin_inset Formula $Z\triangleq\bbnum 1$
\end_inset

, which gives the type constructor:
\begin_inset Formula 
\[
S_{\bbnum 1}^{A}\triangleq(A\rightarrow\bbnum 2)\rightarrow\bbnum 1+A\quad.
\]

\end_inset

Values of type 
\begin_inset Formula $S_{\bbnum 1}^{A}$
\end_inset

 may be viewed as 
\begin_inset Quotes eld
\end_inset

searchers
\begin_inset Quotes erd
\end_inset

 taking a predicate 
\begin_inset Formula $q^{:A\rightarrow\bbnum 2}$
\end_inset

 and looking for a value of type 
\begin_inset Formula $A$
\end_inset

 that satisfies the predicate.
 A searcher will return either a suitable value of type 
\begin_inset Formula $\bbnum 0+A$
\end_inset

, or an empty value 
\begin_inset Formula $1+\bbnum 0$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

not found
\begin_inset Quotes erd
\end_inset

).
 Applying a filter with an a predicate 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

 to a searcher will exclude values of type 
\begin_inset Formula $A$
\end_inset

 from the search unless they satisfy 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Standard
Another function-type construction is a generalization of the filterable
 contrafunctor 
\begin_inset Formula $A\rightarrow\bbnum 1+Z$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-function-a-to-1-+z-filterable-contrafunctor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-function-a-to-1-+z-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If a contrafunctor 
\begin_inset Formula $H^{\bullet}$
\end_inset

 is filterable, so is the contrafunctor 
\begin_inset Formula $F^{A}\triangleq A\rightarrow\bbnum 1+H^{A}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We extend the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B])(c: B => Option[H[B]]): A => Option[H[A]]
 =
\end_layout

\begin_layout Plain Layout

  { a => f(a).flatMap(c).map(liftOpt_H(f)) }
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\triangleq p^{:B\rightarrow\bbnum 1+H^{B}}\rightarrow\gunderline{a^{:A}\rightarrow a\,\triangleright}f\triangleright\text{flm}_{\text{Opt}}(p)\triangleright\big(\text{liftOpt}_{H}(f)\big)^{\uparrow\text{Opt}}\\
 & =p\rightarrow f\bef\text{flm}_{\text{Opt}}(p)\bef\big(\text{liftOpt}_{H}(f)\big)^{\uparrow\text{Opt}}\quad.
\end{align*}

\end_inset

To verify the naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-identity-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

), apply both sides to an arbitrary 
\begin_inset Formula $p^{:B\rightarrow\bbnum 1+H^{B}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p\triangleright f^{\downarrow F}:\quad & p\triangleright\text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})=f\bef\gunderline{\text{pu}_{\text{Opt}}\bef\text{flm}_{\text{Opt}}(p)}\bef\big(\text{liftOpt}_{H}(f\bef\text{pu}_{\text{Opt}})\big)^{\uparrow\text{Opt}}\\
\text{use Eq.~(\ref{eq:simplify-puOpt-flmOpt})}:\quad & =f\bef p\bef\big(\gunderline{\text{liftOpt}_{H}(f\bef\text{pu}_{\text{Opt}})}\big)^{\uparrow\text{Opt}}\\
\text{law~(\ref{eq:naturality-identity-law-filterable-contrafunctor}) of }H:\quad & =f\bef p\bef\big(f^{\downarrow H}\big)^{\uparrow\text{Opt}}=p\triangleright f^{\downarrow F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we apply its right-hand side to an arbitrary 
\begin_inset Formula $p^{:C\rightarrow\bbnum 1+H^{C}}$
\end_inset

 and transform the result until it is equal to 
\begin_inset Formula $p\triangleright\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\triangleright\text{-notation}:\quad & p\triangleright\text{liftOpt}_{F}(g)\,\gunderline{\bef}\,\text{liftOpt}_{F}(f)=\big(p\triangleright\text{liftOpt}_{F}(g)\big)\triangleright\gunderline{\text{liftOpt}_{F}(f)}\\
\text{definition of }\text{liftOpt}_{F}(f):\quad & =f\bef\text{flm}_{\text{Opt}}\big(\gunderline{p\triangleright\text{liftOpt}_{F}(g)}\big)\bef\big(\text{liftOpt}_{H}(f)\big)^{\uparrow\text{Opt}}\\
\text{definition of }\text{liftOpt}_{F}(g):\quad & =f\bef\text{flm}_{\text{Opt}}\gunderline{\big(g\bef\text{flm}_{\text{Opt}}(p)\bef(\text{liftOpt}_{H}(g))^{\uparrow\text{Opt}}\big)}\bef\big(\text{liftOpt}_{H}(f)\big)^{\uparrow\text{Opt}}\\
\text{Eqs.~(\ref{eq:associativity-law-of-flatMap-for-Option}) and~(\ref{eq:right-naturality-flatmap-option})}:\quad & \gunderline{f\bef\text{flm}_{\text{Opt}}(g)}\bef\text{flm}_{\text{Opt}}(p)\bef\big(\gunderline{\text{liftOpt}_{H}(g)\bef\text{liftOpt}_{H}(f)}\big)^{\uparrow\text{Opt}}\\
\text{definition~(\ref{eq:def-of-Kleisli-product}) of }f\diamond_{_{\text{Opt}}}g:\quad & =(f\diamond_{_{\text{Opt}}}g)\bef\text{flm}_{\text{Opt}}(p)\bef\big(\text{liftOpt}_{H}(f\diamond_{_{\text{Opt}}}g)\big)^{\uparrow\text{Opt}}\\
\text{definition of }\text{liftOpt}_{F}:\quad & =p\triangleright\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
To define a contrafunctor via type recursion, we need to use a recursion
 scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 that is contravariant in 
\begin_inset Formula $A$
\end_inset

 and covariant in 
\begin_inset Formula $R$
\end_inset

.
 In other words, the recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 must be a profunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
profunctor
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
recursion scheme!using a profunctor
\end_layout

\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the definition of a profunctor).
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-recursive-filterable-contrafunctor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-recursive-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $S^{A,R}$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

 and covariant in 
\begin_inset Formula $R$
\end_inset

, and additionally 
\begin_inset Formula $S^{\bullet,R}$
\end_inset

 is filterable (with the type parameter 
\begin_inset Formula $R$
\end_inset

 fixed), then the recursive contrafunctor 
\begin_inset Formula $F^{A}\triangleq S^{A,F^{A}}$
\end_inset

 is filterable.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The recursive contrafunctor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is implemented by wrapping 
\begin_inset Formula $S$
\end_inset

 in a case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = ...
\end_layout

\begin_layout Plain Layout

final case class F[A](s: S[A, F[A]])
\end_layout

\end_inset

The code of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 for 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is recursive and uses the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset

 method of the profunctor 
\begin_inset Formula $S$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def liftOpt_F[A, B](f: A => Option[B]): F[B] => F[A] = { case F(sbfb) =>
 F(
\end_layout

\begin_layout Plain Layout

  liftOpt_S(f)(sbfb).xmap_S(identity)(liftOpt_F(f))
\end_layout

\begin_layout Plain Layout

)}
\end_layout

\end_inset


\begin_inset Formula 
\[
\xymatrix{S^{B,F^{B}}\ar[r]\sp(0.525){\text{liftOpt}_{S}(f^{:A\rightarrow\bbnum 1+B})}\ar[rd]\sb(0.45){\text{liftOpt}_{F}(f)\triangleq~~~} & S^{A,F^{B}}\ar[d]\sp(0.45){\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{A,\bullet}}}\\
\xyScaleY{1.8pc}\xyScaleX{6pc} & S^{A,F^{A}}
}
\]

\end_inset

Note that 
\begin_inset Formula $F^{B}\cong S^{B,F^{B}}$
\end_inset

.
 As before, we use an overline to mark recursive calls to the same function:
\begin_inset Formula 
\begin{align*}
 & \text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\triangleq\text{liftOpt}_{S}(f)\bef\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{A,\bullet}}\\
 & =\text{liftOpt}_{S}(f)\bef\text{xmap}_{S}(\text{id})(\overline{\text{liftOpt}_{F}}(f))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the laws, we need the code for lifting to the contrafunctor 
\begin_inset Formula $F$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cmap_F[A, B](f: A => B): F[B] => F[A] = { case F(sbfb) => F( sbfb.xmap_S(f)(c
map_F(f)) ) }
\end_layout

\end_inset


\begin_inset Formula 
\[
f^{\downarrow F}\triangleq\text{xmap}_{S}(f)(\overline{f^{\downarrow F}})=f^{\downarrow S^{\bullet,F^{B}}}\bef\big(\overline{f^{\downarrow F}}\big)^{\uparrow S^{A,\bullet}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-identity-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is verified by:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\downarrow F}:\quad & \text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})=\gunderline{\text{liftOpt}_{S}(f\bef\text{pu}_{\text{Opt}})}\bef\big(\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})\big)^{\uparrow S^{A,\bullet}}\\
\text{law~(\ref{eq:naturality-identity-law-filterable-contrafunctor}) for }S^{\bullet,B}:\quad & =f^{\downarrow S^{\bullet,B}}\bef\gunderline{\big(\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}})\big)^{\uparrow S^{A,\bullet}}}\\
\text{inductive assumption}:\quad & =f^{\downarrow S^{\bullet,B}}\bef\big(\overline{f^{\downarrow F}}\big)^{\uparrow S^{A,\bullet}}=f^{\downarrow F}\quad.
\end{align*}

\end_inset

To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect }\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g):\quad & \text{liftOpt}_{F}(g^{:B\rightarrow\bbnum 1+C})\bef\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\\
\text{definition of }\text{liftOpt}_{F}:\quad & =\text{liftOpt}_{S}(g)\bef\big(\overline{\text{liftOpt}_{F}}(g)\big)^{\uparrow S^{B,\bullet}}\bef\text{liftOpt}_{S}(f)\bef\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{A,\bullet}}\\
\text{law~(\ref{eq:binaturality-law-of-filterable-profunctor}) of }\text{liftOpt}_{S}:\quad & =\gunderline{\text{liftOpt}_{S}(g)\bef\text{liftOpt}_{S}(f)}\bef\big(\overline{\text{liftOpt}_{F}}(g)\big)^{\uparrow S^{A,\bullet}}\bef\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{A,\bullet}}\\
\text{law~(\ref{eq:composition-law-filterable-contrafunctor}) of }\text{liftOpt}_{S}:\quad & =\text{liftOpt}_{S}(f\diamond_{_{\text{Opt}}}g)\bef\big(\gunderline{\overline{\text{liftOpt}_{F}}(g)\bef\overline{\text{liftOpt}_{F}}(f)}\big)^{\uparrow S^{A,\bullet}}\\
\text{inductive assumption}:\quad & =\text{liftOpt}_{S}(f\diamond_{_{\text{Opt}}}g)\bef\big(\overline{\text{liftOpt}_{F}}(f\diamond_{_{\text{Opt}}}g)\big)^{\uparrow S^{A,\bullet}}=\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset

In this derivation, we have used the naturality law of 
\begin_inset Formula $\text{liftOpt}_{S}$
\end_inset

 with respect to lifting in the type parameter 
\begin_inset Formula $A$
\end_inset

 of 
\begin_inset Formula $S^{A,R}$
\end_inset

:
\begin_inset Formula 
\[
\xymatrix{S^{B,R}\ar[r]\sp(0.5){\text{liftOpt}_{S}(f^{:A\rightarrow\bbnum 1+B})}\ar[d]\sp(0.4){(h^{:R\rightarrow R^{\prime}})^{\uparrow S^{B,\bullet}}} & S^{A,R}\ar[d]\sb(0.4){h^{\uparrow S^{A,\bullet}}}\\
\xyScaleY{1.8pc}\xyScaleX{6.0pc}S^{B,R^{\prime}}\ar[r]\sp(0.45){\text{liftOpt}_{S}(f)} & S^{A,R^{\prime}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{liftOpt}_{S}(f^{:A\rightarrow\bbnum 1+B})\bef(h^{:R\rightarrow R^{\prime}})^{\uparrow S^{A,\bullet}}=h^{\uparrow S^{B,\bullet}}\bef\text{liftOpt}_{S}(f)\quad.\label{eq:binaturality-law-of-filterable-profunctor}
\end{equation}

\end_inset

We expect this naturality law to hold for fully parametric functions, as
 discussed in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Bifunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What can we do with the techniques of this chapter?
\end_layout

\begin_layout Itemize
Use functor blocks to manipulate data wrapped in filterable functors.
\end_layout

\begin_layout Itemize
Decide whether a given filtering behavior satisfies the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Decide whether a given type constructor (functor or contrafunctor) is filterable.
 If so, implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 function that satisfies the appropriate laws.
\end_layout

\begin_layout Itemize
Use constructions to derive the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 without trial and error.
\end_layout

\begin_layout Standard
What 
\emph on
cannot
\emph default
 be done with these techniques?
\end_layout

\begin_layout Itemize
Given a filterable type constructor, generate the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 automatically.
\end_layout

\begin_layout Standard
This cannot be done because most non-trivial type constructors have many
 lawful but 
\emph on
inequivalent
\emph default
 implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
 When we say 
\begin_inset Quotes eld
\end_inset

a type constructor 
\begin_inset Formula $F$
\end_inset

 is filterable
\begin_inset Quotes erd
\end_inset

 we mean that there is at least one lawful implementation.
 It is not possible to choose a 
\begin_inset Quotes eld
\end_inset

preferred
\begin_inset Quotes erd
\end_inset

 implementation automatically, since different applications may need different
 filtering behavior.
 While in most cases the standard library provides generally useful implementati
ons of filtering (e.g., the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 methods on sequences), in some situations the programmer will need to write
 a custom implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 for a custom data type.
 The programmer must examine the given requirements and decide whether those
 requirements can be implemented as a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Subsection
Examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-filterable-laws-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-laws-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the functor 
\begin_inset Formula $F^{A}\triangleq G^{A}\rightarrow A$
\end_inset

 is not filterable (for any contrafunctor 
\begin_inset Formula $G^{A}$
\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Try to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $~:F^{\bbnum 1+A}\rightarrow F^{A}$
\end_inset

, writing out its full type signature:
\begin_inset Formula 
\[
\text{deflate}_{F}:(G^{\bbnum 1+A}\rightarrow\bbnum 1+A)\rightarrow G^{A}\rightarrow A\quad,\quad\quad\text{deflate}_{F}=p^{:G^{\bbnum 1+A}\rightarrow\bbnum 1+A}\rightarrow g^{:G^{A}}\rightarrow\text{???}^{:A}\quad.
\]

\end_inset

We cannot extract a value of type 
\begin_inset Formula $A$
\end_inset

 from 
\begin_inset Formula $g^{:G^{A}}$
\end_inset

 since the contrafunctor 
\begin_inset Formula $G^{A}$
\end_inset

 does not wrap any values of 
\begin_inset Formula $A$
\end_inset

.
 So, the only hope of filling the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

 is to apply the function 
\begin_inset Formula $p$
\end_inset

 to an argument of type 
\begin_inset Formula $G^{\bbnum 1+A}$
\end_inset

.
 Even if we are able to map 
\begin_inset Formula $G^{A}\rightarrow G^{\bbnum 1+A}$
\end_inset

 (e.g., if 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is filterable), the result of applying 
\begin_inset Formula $p$
\end_inset

 will be a value of type 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 We cannot compute a value of type 
\begin_inset Formula $A$
\end_inset

 out of that.
 So, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 for 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is not implementable.
 We conclude that 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is not filterable.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-filterable-laws-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-laws-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use known filterable constructions to show that:
\begin_inset Formula 
\[
F^{A}\triangleq\text{Int}\times\text{String}\rightarrow\bbnum 1+\text{Int}\times A+A\times\left(\bbnum 1+A\right)+(\text{Int}\rightarrow\bbnum 1+A+A\times A\times\text{String})
\]

\end_inset

is a filterable functor.
 (Using the constructions avoids the need for proofs.)
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to analyze the structure of the functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 to decide which constructions we may use.
 Define some auxiliary functors that represents sub-expressions in 
\begin_inset Formula $F^{A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
R_{1}^{A}\triangleq\text{Int}\times\text{String}\rightarrow A\quad, & \quad\quad R_{2}^{A}\triangleq\text{Int}\rightarrow A\quad,\\
G^{A}\triangleq\bbnum 1+\text{Int}\times A+A\times\left(\bbnum 1+A\right)\quad, & \quad\quad H^{A}\triangleq\bbnum 1+A+A\times A\times\text{String}\quad.
\end{align*}

\end_inset

Now we can rewrite the type 
\begin_inset Formula $F^{A}$
\end_inset

 as:
\begin_inset Formula 
\[
F^{A}=R_{1}^{L^{A}}\quad,\quad\quad L^{A}\triangleq G^{A}+R_{2}^{H^{A}}\quad.
\]

\end_inset

The type of 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is a co-product, so we need to check which of the two co-product constructions
 (Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

 or
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) might apply.
 The first of them does not apply because the functors 
\begin_inset Formula $\text{Int}\times A$
\end_inset

 and 
\begin_inset Formula $A\times\left(\bbnum 1+A\right)$
\end_inset

 are not filterable.
 But the second construction applies if we write 
\begin_inset Formula $G^{A}$
\end_inset

 in the form 
\begin_inset Formula $G^{A}=\bbnum 1+A\times K^{A}$
\end_inset

 where 
\begin_inset Formula $K^{A}\triangleq\bbnum 1+\text{Int}+A$
\end_inset

.
 Since 
\begin_inset Formula $K^{A}$
\end_inset

 is the co-product of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 functor and a constant functor (the fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

), 
\begin_inset Formula $K^{\bullet}$
\end_inset

 is filterable by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 So, 
\begin_inset Formula $G^{A}$
\end_inset

 is filterable.
\end_layout

\begin_layout Standard
Similarly, we find that 
\begin_inset Formula $H^{A}$
\end_inset

 is filterable by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 if we write 
\begin_inset Formula $H^{A}=\bbnum 1+A\times(\bbnum 1+A\times\text{String})$
\end_inset

, where the functor 
\begin_inset Formula $\bbnum 1+A\times\text{String}$
\end_inset

 is filterable by the same construction.
\end_layout

\begin_layout Standard
The functor 
\begin_inset Formula $R_{2}^{H^{\bullet}}$
\end_inset

 is filterable since it is a functor composition (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-composition-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and 
\begin_inset Formula $H^{\bullet}$
\end_inset

 is filterable.
 The co-product 
\begin_inset Formula $L^{A}\triangleq G^{A}+R_{2}^{H^{A}}$
\end_inset

 is filterable by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and 
\begin_inset Formula $R_{1}^{L^{A}}$
\end_inset

 by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-composition-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Each construction gives a specific code for the corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 function, and so we could derive the code for 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 that is guaranteed to obey the filter laws.
 However, keep in mind that there are several inequivalent ways of implementing
 a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 for this functor.
 For instance, the filtering operation for 
\begin_inset Formula $H^{\bullet}$
\end_inset

 could be defined similarly to that for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

JillsCoupons
\end_layout

\end_inset

 in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and not through a co-product construction.
 The constructions give one possibility out of many.
 The programmer needs to choose the implementation according to the business
 requirements at hand.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-identity-law-of-deflate"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-identity-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (identity law of 
\family typewriter
deflate
\family default
)
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
deflate
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $~:F^{\bbnum 1+A}\rightarrow F^{A}$
\end_inset

 is available only for filterable functors; but the function with the inverse
 type signature, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset


\begin_inset Formula $~:F^{A}\rightarrow F^{\bbnum 1+A}$
\end_inset

 , can be implemented for any functor 
\begin_inset Formula $F$
\end_inset

.
 (See definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Simplifying-the-filtering-laws-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

.) Assuming that a given functor 
\begin_inset Formula $F$
\end_inset

 is filterable, show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is a 
\series bold
left inverse
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
left inverse
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{inflate}_{F}\bef\text{deflate}_{F}=\text{id}\quad.\label{eq:identity-law-of-deflate}
\end{equation}

\end_inset

Also show that it is not a right inverse: 
\begin_inset Formula $\text{deflate}_{F}\bef\text{inflate}_{F}\ne\text{id}$
\end_inset

 for some functors 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We may assume that 
\begin_inset Formula $F$
\end_inset

 satisfies the filtering laws.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 can be equivalently written as:
\begin_inset Formula 
\[
\text{inflate}_{F}=(x^{:A}\rightarrow\bbnum 0+x)^{\uparrow F}=\text{pu}_{\text{Opt}}^{\uparrow F}=\big(\psi_{(\_\rightarrow\text{true})}\big)^{\uparrow F}\quad.
\]

\end_inset

Now we can use the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to derive:
\begin_inset Formula 
\[
\text{filt}_{F}(\_\rightarrow\text{true})=\psi_{(\_\rightarrow\text{true})}^{\uparrow F}\bef\text{deflate}_{F}=\text{inflate}_{F}\bef\text{deflate}_{F}\quad.
\]

\end_inset

Since the identity law says 
\begin_inset Formula $\text{filt}_{F}(\_\rightarrow\text{true})=\text{id}$
\end_inset

, we obtain 
\begin_inset Formula $\text{inflate}_{F}\bef\text{deflate}_{F}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To show that the inverse equation does not always hold, we need to find
 an explicit example: a specific functor 
\begin_inset Formula $F$
\end_inset

 and a value 
\begin_inset Formula $x^{:F^{\bbnum 1+A}}$
\end_inset

 such that 
\begin_inset Formula $x\triangleright\text{deflate}_{F}\bef\text{inflate}_{F}\neq x$
\end_inset

.
 Looking at the simplest filterable functors, we find that the constant
 functor 
\begin_inset Formula $F^{A}\triangleq Z$
\end_inset

 is not a suitable example because all its methods are identity functions.
 The next nontrivial example is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 functor, 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A=\text{Opt}^{A}$
\end_inset

.
 With the equivalence 
\begin_inset Formula $\text{Opt}^{\text{Opt}^{A}}\cong\bbnum 1+\bbnum 1+A$
\end_inset

, we write the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def inflate[A]: Option[A] => Option[Option[A]] = _.map(x => Some(x))
\end_layout

\begin_layout Plain Layout

def deflate[A]: Option[Option[A]] => Option[A] = _.flatten
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{inflate}_{\text{Opt}}\triangleq\text{pu}_{\text{Opt}}^{\uparrow\text{Opt}}=\,\begin{array}{|c||ccc|}
 & \bbnum 1 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\quad,\quad\quad\text{deflate}_{\text{Opt}}\triangleq\text{ftn}_{\text{Opt}}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \text{id}
\end{array}\quad.
\]

\end_inset

The composition 
\begin_inset Formula $\text{deflate}_{\text{Opt}}\bef\text{inflate}_{\text{Opt}}$
\end_inset

 is computed as:
\begin_inset Formula 
\begin{align*}
 & \text{deflate}_{\text{Opt}}\bef\text{inflate}_{\text{Opt}}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||ccc|}
 & \bbnum 1 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\\
\text{matrix composition}:\quad & =\,\begin{array}{|c||ccc|}
 & \bbnum 1 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\,\neq\text{id}=\,\begin{array}{|c||ccc|}
 & \bbnum 1 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 1 & \bbnum 0 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\quad.
\end{align*}

\end_inset

The result differs from an identity matrix in the second row.
 A value 
\begin_inset Formula $x^{:\bbnum 1+\bbnum 1+A}\triangleq\bbnum 0^{:\bbnum 1}+1+\bbnum 0^{:A}$
\end_inset

 will give a non-void result in the second row of the matrix, showing the
 difference:
\begin_inset Formula 
\[
(\bbnum 0+1+\bbnum 0)\triangleright\,\begin{array}{|c||ccc|}
 & \bbnum 1 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}=\,\begin{array}{|ccc|}
\bbnum 0 & 1 & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||ccc|}
\text{id} & \bbnum 0 & \bbnum 0\\
\text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 0 & \bbnum 0 & \text{id}
\end{array}\,=\,\begin{array}{|ccc|}
1 & \bbnum 0 & \bbnum 0\end{array}\,\neq\,\begin{array}{|ccc|}
\bbnum 0 & 1 & \bbnum 0\end{array}\quad.
\]

\end_inset

In Scala code, this value 
\begin_inset Formula $x$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(None)
\end_layout

\end_inset

, so the calculation corresponds to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

inflate(deflate(Some(None))) == None  // Would have been Some(None) if the
 function were an identity.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-filterable-property-1+K"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-property-1+K"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume that a given functor 
\begin_inset Formula $H^{A}\triangleq\bbnum 1+K^{A}$
\end_inset

 is filterable (but 
\begin_inset Formula $K^{\bullet}$
\end_inset

 is not necessarily filterable).
 The functor 
\begin_inset Formula $H^{\bullet}$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

data wrapper
\begin_inset Quotes erd
\end_inset

 with a fixed empty value, 
\begin_inset Formula $1+\bbnum 0^{:K^{A}}$
\end_inset

.
 Show that an empty wrapper remains empty after any filtering: the function
 
\begin_inset Formula $\text{filt}_{H}$
\end_inset

 satisfies, for any 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

,
\begin_inset Formula 
\begin{equation}
(1+\bbnum 0^{:K^{A}})\triangleright\text{filt}_{H}(p)=1+\bbnum 0^{:K^{A}}\quad.\label{eq:empty-filter-remains-empty-via-filt}
\end{equation}

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We know nothing about 
\begin_inset Formula $H^{\bullet}$
\end_inset

 and 
\begin_inset Formula $K^{\bullet}$
\end_inset

 other than the fact that 
\begin_inset Formula $\text{filt}_{H}$
\end_inset

 obeys the filtering laws.
 Rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:empty-filter-remains-empty-via-filt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) via the simpler function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

, which is  equivalent to 
\begin_inset Formula $\text{filt}_{H}$
\end_inset

:
\begin_inset Formula 
\[
(1+\bbnum 0^{:K^{A}})\triangleright\psi_{p}^{\uparrow H}\bef\text{deflate}_{H}\overset{?}{=}1+\bbnum 0^{:K^{A}}\quad.
\]

\end_inset

Any function lifted to 
\begin_inset Formula $H^{\bullet}$
\end_inset

 works separately for the two parts of the disjunctive type 
\begin_inset Formula $H^{A}=\bbnum 1+K^{A}$
\end_inset

.
 So:
\begin_inset Formula 
\[
(1+\bbnum 0^{:K^{A}})\triangleright f^{\uparrow H}=1+\bbnum 0^{:K^{B}}\quad,
\]

\end_inset

regardless of the choice of 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Setting 
\begin_inset Formula $f\triangleq\psi_{p}$
\end_inset

, we obtain:
\begin_inset Formula 
\begin{equation}
(1+\bbnum 0^{:K^{A}})\triangleright\psi_{p}^{\uparrow H}=1+\bbnum 0^{:K^{\bbnum 1+A}}\quad.\label{eq:emptyable-wrapper-psi-p-filter-derivation1}
\end{equation}

\end_inset

It remains to show that:
\begin_inset Formula 
\begin{equation}
(1+\bbnum 0^{:K^{\bbnum 1+A}})\triangleright\text{deflate}_{H}\overset{?}{=}1+\bbnum 0^{:K^{A}}\quad.\label{eq:emptyable-wrapper-deflate-derivation1}
\end{equation}

\end_inset

We can proceed only if we use some law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

; Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-identity-law-of-deflate"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows a suitable law.
 Since Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:emptyable-wrapper-psi-p-filter-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for all predicates 
\begin_inset Formula $p$
\end_inset

, we can choose the predicate 
\begin_inset Formula $p$
\end_inset

 to be identically 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 and get:
\begin_inset Formula 
\begin{equation}
(1+\bbnum 0^{:K^{A}})\triangleright\psi_{(\_\rightarrow\text{true})}^{\uparrow H}=(1+\bbnum 0^{:K^{A}})\triangleright\text{inflate}_{H}=1+\bbnum 0^{:K^{\bbnum 1+A}}\quad.\label{eq:emptyable-wrapper-inflate-derivation1}
\end{equation}

\end_inset

Substituting this into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:emptyable-wrapper-deflate-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we find:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }1+\bbnum 0^{:K^{A}}:\quad & (\gunderline{1+\bbnum 0^{:K^{\bbnum 1+A}}})\triangleright\text{deflate}_{H}\\
\text{use Eq.~(\ref{eq:emptyable-wrapper-inflate-derivation1})}:\quad & =(1+\bbnum 0^{:K^{A}})\triangleright\gunderline{\text{inflate}_{H}\bef\text{deflate}_{H}}\\
\text{identity law~(\ref{eq:identity-law-of-deflate}) of }\text{deflate}_{H}:\quad & =(1+\bbnum 0^{:K^{A}})\triangleright\gunderline{\text{id}}=1+\bbnum 0^{:K^{A}}\quad.
\end{align*}

\end_inset

This completes the proof of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:emptyable-wrapper-deflate-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and of the property
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:empty-filter-remains-empty-via-filt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The same property can be expressed in terms of 
\begin_inset Formula $\text{liftOpt}_{H}$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
(1+\bbnum 0^{:K^{B}})\triangleright\text{liftOpt}_{H}(f^{:A\rightarrow\bbnum 1+B})=1+\bbnum 0^{:K^{B}}\quad.\label{eq:empty-filter-remains-empty-via-liftOpt}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-filterable-laws-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-laws-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $G^{\bullet}$
\end_inset

 and 
\begin_inset Formula $H^{\bullet}$
\end_inset

 are filterable functors and 
\begin_inset Formula $H^{\bullet}$
\end_inset

 is of the form 
\begin_inset Formula $H^{A}\triangleq\bbnum 1+K^{A}$
\end_inset

 (where 
\begin_inset Formula $K^{\bullet}$
\end_inset

 is not necessarily filterable), prove that the functor 
\begin_inset Formula $F^{\bullet}\triangleq G^{K^{\bullet}}$
\end_inset

 is filterable.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to define 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 and verify its laws, assuming that 
\begin_inset Formula $\text{liftOpt}_{G}$
\end_inset

 and 
\begin_inset Formula $\text{liftOpt}_{H}$
\end_inset

 with types:
\begin_inset Formula 
\[
\text{liftOpt}_{G}(f^{:A\rightarrow\bbnum 1+B}):G^{A}\rightarrow G^{B}\quad,\quad\quad\text{liftOpt}_{H}(f^{:A\rightarrow\bbnum 1+B}):\bbnum 1+K^{A}\rightarrow\bbnum 1+K^{B}\quad,
\]

\end_inset

 are already available and obey the same laws.
 We need to implement the type signature:
\begin_inset Formula 
\[
\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B}):G^{K^{A}}\rightarrow G^{K^{B}}\quad.
\]

\end_inset

We can map 
\begin_inset Formula $G^{K^{A}}$
\end_inset

 to 
\begin_inset Formula $G^{K^{B}}$
\end_inset

 using 
\begin_inset Formula $\text{liftOpt}_{G}^{K^{A},K^{B}}(k)$
\end_inset

 if we supply 
\begin_inset Formula $k$
\end_inset

 of type 
\begin_inset Formula $K^{A}\rightarrow\bbnum 1+K^{B}$
\end_inset

 and use the type parameters 
\begin_inset Formula $K^{A}$
\end_inset

, 
\begin_inset Formula $K^{B}$
\end_inset

 instead of 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 We can compute the function 
\begin_inset Formula $k$
\end_inset

 as 
\begin_inset Formula $\text{liftOpt}_{H}(f^{:A\rightarrow\bbnum 1+B})$
\end_inset

 if we extend the argument to 
\begin_inset Formula $\bbnum 1+K^{A}$
\end_inset

 instead of 
\begin_inset Formula $K^{A}$
\end_inset

 using the function 
\begin_inset Formula $\text{pu}_{\text{Opt}}$
\end_inset

 with type parameter 
\begin_inset Formula $K^{A}$
\end_inset

:
\begin_inset Formula 
\[
\text{pu}_{\text{Opt}}^{K^{A}}:K^{A}\rightarrow\bbnum 1+K^{A}\quad,\quad\quad\text{pu}_{\text{Opt}}^{K^{A}}\bef\text{liftOpt}_{H}^{K^{B},K^{B}}(f^{:A\rightarrow\bbnum 1+B}):K^{A}\rightarrow\bbnum 1+K^{B}\quad.
\]

\end_inset

 Now we are ready to write the code for 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 as 
\begin_inset Formula 
\[
\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\triangleq\text{liftOpt}_{G}^{K^{A},K^{B}}\big(\text{pu}_{\text{Opt}}^{K^{A}}\bef\text{liftOpt}_{H}(f)\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
It remains to verify the laws.
 The naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\uparrow F}:\quad & \text{liftOpt}_{F}(f\bef\text{pu}_{\text{Opt}})=\text{liftOpt}_{G}^{K^{A},K^{B}}\big(\text{pu}_{\text{Opt}}^{K^{A}}\bef\gunderline{\text{liftOpt}_{H}(f\bef\text{pu}_{\text{Opt}})}\big)\\
\text{law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) of }\text{liftOpt}_{H}:\quad & =\text{liftOpt}_{G}^{K^{A},K^{B}}\big(\text{pu}_{\text{Opt}}^{K^{A}}\bef\gunderline{f^{\uparrow H}}\big)\\
\text{lifting }^{\uparrow H}\text{ expressed via }^{\uparrow K}:\quad & =\text{liftOpt}_{G}^{K^{A},K^{B}}\big(\gunderline{\text{pu}_{\text{Opt}}^{K^{A}}\bef f^{\uparrow K\uparrow\text{Opt}}}\big)\\
\text{naturality~(\ref{eq:naturality-law-of-pure}) of }\text{pu}_{\text{Opt}}:\quad & =\text{liftOpt}_{G}^{K^{A},K^{B}}(f^{\uparrow K}\bef\text{pu}_{\text{Opt}}^{K^{B}})\\
\text{law~(\ref{eq:combined-naturality-identity-law-of-liftOpt}) of }\text{liftOpt}_{G}:\quad & =\gunderline{(f^{\uparrow K})^{\uparrow G}}=f^{\uparrow F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g):\quad & \text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)\\
\text{definition of }\text{liftOpt}_{F}:\quad & =\gunderline{\text{liftOpt}_{G}\big(}\text{pu}_{\text{Opt}}\bef\text{liftOpt}_{H}(f)\gunderline{\big)\bef\text{liftOpt}_{G}\big(}\text{pu}_{\text{Opt}}\bef\text{liftOpt}_{H}(g)\gunderline{\big)}\\
\text{law~(\ref{eq:composition-law-of-liftOpt}) for }\text{liftOpt}_{G}:\quad & =\text{liftOpt}_{G}\big((\text{pu}_{\text{Opt}}\bef\text{liftOpt}_{H}(f))\,\gunderline{\diamond_{_{\text{Opt}}}(\text{pu}_{\text{Opt}}\bef\text{liftOpt}_{H}(g))}\big)\\
\text{simplify using Eq.~(\ref{eq:simplify-kleisli-opt-right-pure})}:\quad & =\text{liftOpt}_{G}\big(\text{pu}_{\text{Opt}}\bef\gunderline{\text{liftOpt}_{H}(f)\bef\text{liftOpt}_{H}(g)}\big)\\
\text{law~(\ref{eq:composition-law-of-liftOpt}) for }\text{liftOpt}_{H}:\quad & =\text{liftOpt}_{G}\big(\text{pu}_{\text{Opt}}\bef\text{liftOpt}_{H}(f\diamond_{_{\text{Opt}}}g)\big)=\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.
\end{align*}

\end_inset

In this derivation, we used a property that simplifies the Kleisli composition
 with 
\begin_inset Formula $\text{pu}_{\text{Opt}}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
f^{:K^{A}\rightarrow\bbnum 1+K^{B}}\diamond_{_{\text{Opt}}}\big(\text{pu}_{\text{Opt}}^{K^{B}}\bef\text{liftOpt}_{H}^{\bbnum 1+K^{B},\bbnum 1+K^{C}}(g^{:B\rightarrow\bbnum 1+C})\big)=f\bef\text{liftOpt}_{H}(g)\quad.\label{eq:simplify-kleisli-opt-right-pure}
\end{equation}

\end_inset

This simplification depends on the property
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:empty-filter-remains-empty-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $\text{liftOpt}_{H}$
\end_inset

 shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-property-1+K"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and does 
\emph on
not
\emph default
 work for arbitrary functions 
\begin_inset Formula $p$
\end_inset

, 
\begin_inset Formula $q$
\end_inset

 having the same type signatures as in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simplify-kleisli-opt-right-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
p^{:A\rightarrow\bbnum 1+B}\diamond_{_{\text{Opt}}}(\text{pu}_{\text{Opt}}^{:B\rightarrow\bbnum 1+B}\bef q^{:\bbnum 1+B\rightarrow\bbnum 1+C})\neq p\bef q\quad.
\]

\end_inset

To prove Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simplify-kleisli-opt-right-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

), use the code for 
\begin_inset Formula $\diamond_{_{\text{Opt}}}$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{\text{Opt}}$
\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-puOpt-and-flmOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side of Eq.~(\ref{eq:simplify-kleisli-opt-right-pure})}:\quad & f\gunderline{\diamond_{_{\text{Opt}}}}(\text{pu}_{\text{Opt}}^{K^{B}}\bef\text{liftOpt}_{H}(g))\\
\text{definition~(\ref{eq:def-of-Kleisli-product}) of }\diamond_{_{\text{Opt}}}:\quad & =f\bef\text{flm}_{\text{Opt}}(\gunderline{\text{pu}_{\text{Opt}}}^{K^{B}}\bef\text{liftOpt}_{H}(g))\\
\text{definition of }\text{pu}_{\text{Opt}}:\quad & =f\bef\gunderline{\text{flm}_{\text{Opt}}}(x^{:K^{B}}\rightarrow(\bbnum 0+x)\triangleright\text{liftOpt}_{H}(g))\\
\text{use Eq.~(\ref{eq:def-of-puOpt-and-flmOpt})}:\quad & =f^{:K^{A}\rightarrow\bbnum 1+K^{B}}\bef\,\begin{array}{|c||c|}
 & \bbnum 1+K^{C}\\
\hline \bbnum 1 & 1\rightarrow1+\bbnum 0^{:K^{C}}\\
K^{B} & x\rightarrow(\bbnum 0+x)\triangleright\text{liftOpt}_{H}(g)
\end{array}\quad.
\end{align*}

\end_inset

We expect the last expression to equal the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simplify-kleisli-opt-right-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which is 
\begin_inset Formula $f\bef\text{liftOpt}_{H}(g)$
\end_inset

.
 To be able to compare these expressions, we rewrite 
\begin_inset Formula $\text{liftOpt}_{H}(g)$
\end_inset

 equivalently as a matrix:
\begin_inset Formula 
\[
\text{liftOpt}_{H}(g^{:B\rightarrow\bbnum 1+C})=\,\begin{array}{|c||c|}
 & \bbnum 1+K^{C}\\
\hline \bbnum 1 & 1\rightarrow(1+\bbnum 0^{:K^{C}})\triangleright\text{liftOpt}_{H}(g)\\
K^{B} & x\rightarrow(\bbnum 0+x)\triangleright\text{liftOpt}_{H}(g)
\end{array}\quad.
\]

\end_inset

Usually, such an equivalent rewriting gives no advantages; but in this case,
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:empty-filter-remains-empty-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) simplifies the first row of the matrix to 
\begin_inset Formula $1\rightarrow1+\bbnum 0^{:K^{C}}$
\end_inset

.
 This makes both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:empty-filter-remains-empty-via-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) equal.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-filterable-laws-unrolling-trick"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-laws-unrolling-trick"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove that the recursive functor 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times A+A\times\left(\bbnum 1+A\right)\times F^{A}$
\end_inset

 is filterable.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Rather than proving the laws by hand (as we did in a similar case in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-recursive-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we will use a trick that will make calculations shorter.
 The trick is to 
\begin_inset Quotes eld
\end_inset

unroll
\begin_inset Quotes erd
\end_inset

 the recursive equation and to reduce 
\begin_inset Formula $F^{A}$
\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor, which has a standard filtering operation.
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
unrolling trick for recursive types
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive types!unrolling trick
\end_layout

\end_inset

unrolling trick gives, for any recursive definition of the form 
\begin_inset Formula $F^{A}\triangleq P^{A}+Q^{A}\times F^{A}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{if}\quad F^{A}\triangleq P^{A}+Q^{A}\times F^{A}\quad\text{then}\quad F^{A}\cong P^{A}\times\text{List}^{Q^{A}}\quad,\label{eq:def-recursive-functor-unrolling}
\end{equation}

\end_inset

where 
\begin_inset Formula $P^{\bullet}$
\end_inset

 and 
\begin_inset Formula $Q^{\bullet}$
\end_inset

 are arbitrary functors.
 The functor 
\begin_inset Formula $F^{A}$
\end_inset

 given in this example is of this form with the functors 
\begin_inset Formula $P^{A}\triangleq\bbnum 1+A\times A$
\end_inset

 and 
\begin_inset Formula $Q^{A}\triangleq A\times\left(\bbnum 1+A\right)$
\end_inset

.
 Comparing with the definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor,
\begin_inset Formula 
\begin{align*}
\text{List}^{A} & \triangleq\bbnum 1+A\times\text{List}^{A}\cong\bbnum 1+A\times(\bbnum 1+A\times(\bbnum 1+...(\bbnum 1+A\times\text{List}^{A})))\\
 & \cong\bbnum 1+A+A\times A+A\times A\times A+...+\underbrace{A\times...\times A}_{n\text{ times}}\times\,\text{List}^{A}\quad,
\end{align*}

\end_inset

we find that the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-recursive-functor-unrolling"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $F^{A}$
\end_inset

 can be 
\begin_inset Quotes eld
\end_inset

unrolled
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $n$
\end_inset

 times as:
\begin_inset Formula 
\begin{align*}
F^{A} & \triangleq P^{A}+Q^{A}\times F^{A}\cong P^{A}+Q^{A}\times(P^{A}+Q^{A}\times(P^{A}+...(P^{A}+Q^{A}\times F^{A})))\\
 & \cong P^{A}+Q^{A}\times P^{A}+Q^{A}\times Q^{A}\times P^{A}+...+\underbrace{Q^{A}\times...\times Q^{A}}_{n\text{ times}}\times\,F^{A}\\
 & \cong P^{A}\times\big(\bbnum 1+Q^{A}+Q^{A}\times Q^{A}+...\underbrace{Q^{A}\times...\times Q^{A}}_{n-1\text{ times}}\big)+\underbrace{Q^{A}\times...\times Q^{A}}_{n\text{ times}}\times\,F^{A}\quad.
\end{align*}

\end_inset

The type equivalence
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-recursive-functor-unrolling"
plural "false"
caps "false"
noprefix "false"

\end_inset

), 
\begin_inset Formula $F^{A}\cong P^{A}\times\text{List}^{Q^{A}}$
\end_inset

, follows by induction on the number of 
\begin_inset Quotes eld
\end_inset

unrolled
\begin_inset Quotes erd
\end_inset

 functors 
\begin_inset Formula $F$
\end_inset

.
 We can now use the functor product construction for 
\begin_inset Formula $F^{\bullet}$
\end_inset

 if we show that 
\begin_inset Formula $\text{List}^{Q^{\bullet}}$
\end_inset

 is filterable.
 This does not follow by functor composition because 
\begin_inset Formula $Q^{A}\triangleq A\times\left(\bbnum 1+A\right)$
\end_inset

 is 
\emph on
not
\emph default
 filterable (we saw that in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-non-filterable-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 However, we can derive from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-coproduct-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, setting 
\begin_inset Formula $G^{A}\triangleq\bbnum 1+A$
\end_inset

, that:
\begin_inset Formula 
\[
H^{A}\triangleq\bbnum 1+A\times\left(\bbnum 1+A\right)=\bbnum 1+Q^{A}
\]

\end_inset

is filterable.
 So, we can use the result of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-laws-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and conclude that 
\begin_inset Formula $\text{List}^{Q^{\bullet}}$
\end_inset

 is filterable.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-filterable-laws-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-laws-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the contrafunctor 
\begin_inset Formula $C^{A}\triangleq A\rightarrow Z$
\end_inset

 is not filterable (where the fixed type 
\begin_inset Formula $Z$
\end_inset

 does not have a known default value).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Try to implement the function 
\begin_inset Formula $\text{inflate}_{C}:C^{A}\rightarrow C^{\bbnum 1+A}$
\end_inset

 and write:
\begin_inset Formula 
\[
\text{inflate}_{C}:(A\rightarrow Z)\rightarrow\bbnum 1+A\rightarrow Z\quad,\quad\quad\text{inflate}_{C}=c^{:A\rightarrow Z}\rightarrow p^{:\bbnum 1+A}\rightarrow\text{???}^{:Z}\quad.
\]

\end_inset

The only way to fill the type hole 
\begin_inset Formula $\text{???}^{:Z}$
\end_inset

 is to apply 
\begin_inset Formula $c$
\end_inset

 to an argument of type 
\begin_inset Formula $A$
\end_inset

.
 However, we do not have values of type 
\begin_inset Formula $A$
\end_inset

; we only have 
\begin_inset Formula $p$
\end_inset

 of type 
\begin_inset Formula $\bbnum 1+A$
\end_inset

, and 
\begin_inset Formula $p$
\end_inset

 might be the 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 value, 
\begin_inset Formula $1+\bbnum 0$
\end_inset

.
 So, it is impossible to implement 
\begin_inset Formula $\text{inflate}_{C}$
\end_inset

, and we conclude that 
\begin_inset Formula $C$
\end_inset

 is not filterable.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-filterable-laws-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-laws-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a filterable functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

, show that the type 
\begin_inset Formula $F^{\bbnum 1}\rightarrow F^{\bbnum 0}$
\end_inset

 is 
\emph on
not
\emph default
 void.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
A filterable functor must have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 function with type signature 
\begin_inset Formula $F^{\bbnum 1+A}\rightarrow F^{A}$
\end_inset

.
 Set the type parameter 
\begin_inset Formula $A=\bbnum 0$
\end_inset

 in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 to obtain the code for a function of type 
\begin_inset Formula $F^{\bbnum 1}\rightarrow F^{\bbnum 0}$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 instance for the functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[T] = G[H[T]]
\end_layout

\end_inset

 assuming that the contrafunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

H[_]
\end_layout

\end_inset

 already has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 instance and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G[_]
\end_layout

\end_inset

 is an arbitrary contrafunctor.
 Verify the laws of filterable functor rigorously (by symbolic derivations,
 not tests).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 instance for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[T] = Option[Int => Option[(T, T)]]
\end_layout

\end_inset

.
 Show that the laws hold by using known constructions (avoiding explicit
 proofs or tests).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove rigorously (not by tests) that 
\begin_inset Formula $\text{flm}_{\text{Opt}}(\text{pu}_{\text{Opt}})=\text{id}^{:\bbnum 1+A\rightarrow\bbnum 1+A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that one can define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset


\begin_inset Formula $~:C^{\bbnum 1+A}\rightarrow C^{A}$
\end_inset

 for any contrafunctor 
\begin_inset Formula $C^{A}$
\end_inset

 (not necessarily filterable).
 Prove that 
\emph on
in case
\emph default
 
\begin_inset Formula $C^{\bullet}$
\end_inset

 is filterable, the 
\series bold
identity law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
inflate
\end_layout

\end_inset

 will hold:
\begin_inset Formula 
\[
\text{inflate}_{C}\bef\text{deflate}_{C}=\text{id}^{:C^{A}\rightarrow C^{A}}\quad.
\]

\end_inset

Show that the inverse equation does not hold in general: 
\begin_inset Formula $\text{deflate}_{C}\bef\text{inflate}_{C}\neq\text{id}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is a filterable functor, prove rigorously that the recursive functor 
\begin_inset Formula $F^{A}\triangleq G^{A}+\text{Int}\times A\times A\times A\times F^{A}$
\end_inset

 is filterable.
 Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 instance for 
\begin_inset Formula $F^{\bullet}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the functor 
\begin_inset Formula $F^{A}\triangleq A+\left(\text{Int}\rightarrow A\right)$
\end_inset

 is not filterable.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove that 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times G^{A}$
\end_inset

 is in general not filterable if 
\begin_inset Formula $G^{A}$
\end_inset

 is an arbitrary (non-filterable) functor; give an example of a suitable
 
\begin_inset Formula $G^{A}$
\end_inset

.
 Since 
\begin_inset Formula $F^{\bbnum 1}\rightarrow F^{\bbnum 0}\cong\bbnum 1+G^{\bbnum 1}\rightarrow\bbnum 1\cong\bbnum 1$
\end_inset

, this will demonstrate that Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-filterable-laws-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 gives a necessary but not a sufficient condition for a functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 to be filterable.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+G^{A}+H^{A}$
\end_inset

 is filterable if 
\begin_inset Formula $\bbnum 1+G^{A}$
\end_inset

 and 
\begin_inset Formula $\bbnum 1+H^{A}$
\end_inset

 are filterable (even when 
\begin_inset Formula $G^{\bullet}$
\end_inset

 and 
\begin_inset Formula $H^{\bullet}$
\end_inset

 are not filterable).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:filt-exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $C^{A}\triangleq A+A\times A\rightarrow\bbnum 1+Z$
\end_inset

 is a filterable contrafunctor (no law checking).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-6-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-6-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-flatmap-option"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:right-naturality-flatmap-option"
plural "false"
caps "false"
noprefix "false"

\end_inset

) in Scala syntax and in the code notation.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-6-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-6-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset

 are filterable contrafunctors, prove that the contrafunctors 
\begin_inset Formula $G^{A}\times H^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}+H^{A}$
\end_inset

 are also filterable.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the contrafunctor 
\begin_inset Formula $C^{A}\triangleq A\times F^{A}\rightarrow Z$
\end_inset

 is 
\emph on
not
\emph default
 filterable for any functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and any fixed type 
\begin_inset Formula $Z$
\end_inset

 that does not have a known default value.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-8-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-8-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that a 
\emph on
necessary
\emph default
 condition for a contrafunctor 
\begin_inset Formula $C^{\bullet}$
\end_inset

 to be filterable is that a function of type 
\begin_inset Formula $C^{\bbnum 0}\rightarrow C^{\bbnum 1}$
\end_inset

 can be implemented (i.e., the type 
\begin_inset Formula $C^{\bbnum 0}\rightarrow C^{\bbnum 1}$
\end_inset

 is not void).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-filterable-laws-8-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-8-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Show that a 
\emph on
polynomial
\emph default
 functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is filterable (in some way) if and only if the type 
\begin_inset Formula $F^{\bbnum 1}\rightarrow F^{\bbnum 0}$
\end_inset

 is not void.
 Find an example of a non-filterable polynomial functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 that violates the condition 
\begin_inset Formula $F^{\bbnum 1}\rightarrow F^{\bbnum 0}\not\cong\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Section
Further developments
\end_layout

\begin_layout Subsection
Naturality laws and natural transformations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Naturality-laws-and-natural-transformations"

\end_inset


\end_layout

\begin_layout Standard
While deriving various laws, we often need to interchange the order of compositi
ons that involve lifted functions.
 For instance, in the derivation of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-solved-example-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we needed to move 
\begin_inset Formula $\psi_{p}^{\downarrow C}$
\end_inset

 to the left of 
\begin_inset Formula $\text{filt}_{C}$
\end_inset

 in the expression 
\begin_inset Formula $\text{get}^{\downarrow C}\bef\text{filt}_{C}(\text{nonEmpty})\bef\psi_{p}^{\downarrow C}$
\end_inset

, or else we could make no progress with the calculations.
 The required interchange was possible due to the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-for-filter-for-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{filt}_{C}(p)\bef f^{\downarrow C}=f^{\downarrow C}\bef\text{filt}_{C}(f\bef p)\quad.
\]

\end_inset

In this and previous chapters, we discovered a number of laws of that form,
 e.g.:
\begin_inset Formula 
\begin{align*}
\text{Eq.~(\ref{eq:naturality-law-of-pure})}:\quad & \text{pu}_{F}\bef f^{\uparrow F}=f\bef\text{pu}_{F} &  & \text{for }\quad\text{pu}_{F}:A\rightarrow F^{A}\\
\text{Eq.~(\ref{eq:naturality-law-of-extract})}:\quad & \text{ex}_{F}\bef f=f^{\uparrow F}\bef\text{ex}_{F} &  & \text{for }\quad\text{ex}_{F}:F^{A}\rightarrow A\\
\text{Eq.~(\ref{eq:copointed-bifunctor-naturality-law})}:\quad & \text{ex}_{S}\bef f=\text{bimap}_{S}(f)(f)\bef\text{ex}_{S} &  & \text{for }\quad\text{ex}_{S}:S^{A,A}\rightarrow A\\
\text{Eq.~(\ref{eq:naturality-law-of-filter})}:\quad & f^{\uparrow F}\bef\text{filt}_{F}(p)=\text{filt}_{F}(f\bef p)\bef f^{\uparrow F} &  & \text{for }\quad\text{filt}_{F}:\left(A\rightarrow\bbnum 2\right)\rightarrow F^{A}\rightarrow F^{A}\\
\text{Eq.~(\ref{eq:naturality-law-of-deflate})}:\quad & \text{deflate}\bef f^{\uparrow F}=f^{\uparrow\text{Opt}\uparrow F}\bef\text{deflate} &  & \text{for }\quad\text{deflate}_{F}:F^{\bbnum 1+A}\rightarrow F^{A}\\
\text{Eq.~(\ref{eq:naturality-law-of-psi})}:\quad & f\bef\psi_{p}=\psi_{f\bef p}\bef f^{\uparrow\text{Opt}} &  & \text{for }\quad\psi:\left(A\rightarrow\bbnum 2\right)\rightarrow A\rightarrow\bbnum 1+A\\
\text{Eq.~(\ref{eq:left-naturality-law-of-liftOpt})}:\quad & h^{\uparrow F}\bef\text{liftOpt}_{F}(f)=\text{liftOpt}_{F}(h\bef f) &  & \text{for }\quad\text{liftOpt}_{F}:(A\rightarrow\text{Opt}^{B})\rightarrow F^{A}\rightarrow F^{B}\\
\text{Eq.~(\ref{eq:right-naturality-law-of-liftOpt})}:\quad & \text{liftOpt}_{F}(f)\bef h^{\uparrow F}=\text{liftOpt}_{F}(f\bef h^{\uparrow\text{Opt}}) &  & \text{for }\quad\text{liftOpt}_{F}:(A\rightarrow\text{Opt}^{B})\rightarrow F^{A}\rightarrow F^{B}\\
\text{Eq.~(\ref{eq:naturality-for-filter-for-contrafunctors})}:\quad & \text{filt}_{C}(p)\bef f^{\downarrow C}=f^{\downarrow C}\bef\text{filt}_{C}(f\bef p) &  & \text{for }\quad\text{filt}_{C}:\left(A\rightarrow\bbnum 2\right)\rightarrow C^{A}\rightarrow C^{A}\\
\text{Eq.~(\ref{eq:naturality-law-of-inflate-for-filterable-contrafunctor})}:\quad & f^{\downarrow C}\bef\text{inflate}_{C}=\text{inflate}_{C}\bef f^{\uparrow\text{Opt}\downarrow C} &  & \text{for }\quad\text{inflate}_{C}:C^{A}\rightarrow C^{\bbnum 1+A}
\end{align*}

\end_inset

We called all these laws 
\begin_inset Quotes eld
\end_inset

naturality laws
\begin_inset Quotes erd
\end_inset

, although they were derived from different premises and do not look similar
 at first sight.
 Is there a common pattern for these laws? For a given function, can we
 guess the form of its naturality law? 
\end_layout

\begin_layout Standard
Looking at the examples shown above, we find that each law follows one of
 the four patterns shown in the following table, where we use arbitrary
 functors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $H$
\end_inset

 and contrafunctors 
\begin_inset Formula $C$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Pattern
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type signature
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Naturality law
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2-transformation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $t^{A}:F^{A}\rightarrow G^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $(f^{:A\rightarrow B})^{\uparrow F}\bef t^{B}=t^{A}\bef f^{\uparrow G}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
3-transformation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $t^{A}:C^{A}\rightarrow F^{A}\rightarrow G^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f^{\uparrow F}\bef t^{B}(c)=t(c\triangleright f^{\downarrow C})\bef f^{\uparrow G}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A$
\end_inset

-lifting
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $t^{A,B}:(A\rightarrow G^{B})\rightarrow F^{A}\rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $(f^{:A\rightarrow B})^{\uparrow F}\bef t^{B,C}(p)=t^{A,C}(f\bef p)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $B$
\end_inset

-lifting
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $t^{A,B}:(A\rightarrow G^{B})\rightarrow F^{A}\rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $t^{A,B}(p)\bef(g^{:B\rightarrow C})^{\uparrow F}=t^{A,C}(p\bef g^{\uparrow G})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Let us now look at each of these patterns in detail.
\end_layout

\begin_layout Paragraph
\begin_inset Quotes eld
\end_inset

2-transformation
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This pattern covers functions with type signatures of the form 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 must be both functors or both contrafunctors.
 Functions of that kind, i.e., fully parametric functions with type signatures
 of the form 
\begin_inset Formula $t^{A}:F^{A}\rightarrow G^{A}$
\end_inset

, are called 
\series bold
natural transformations
\series default
 between 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
natural transformation
\end_layout

\end_inset

 Heuristically, we may view 
\begin_inset Formula $t^{A}$
\end_inset

 as a function that copies data of type 
\begin_inset Formula $A$
\end_inset

 from one 
\begin_inset Quotes eld
\end_inset

wrapper
\begin_inset Quotes erd
\end_inset

 to another and may rearrange that data in a way that does not depend on
 the type 
\begin_inset Formula $A$
\end_inset

.
 An example is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

 method defined in Scala on various sequence types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{headOpt}:\text{List}^{A}\rightarrow\text{Opt}^{A}\quad.
\]

\end_inset

We can write an equivalent Scala code for this function as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def headOption[A]: List[A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case List()   => None
\end_layout

\begin_layout Plain Layout

  case x :: _   => Some(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It is clear that this code works in the same way for all types 
\begin_inset Formula $A$
\end_inset

.
 This property is formulated mathematically as the requirement that we may
 first transform a list with a lifted function 
\begin_inset Formula $(f^{:A\rightarrow B})^{\uparrow\text{List}}$
\end_inset

 and then apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

; or we may first apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

 and then transform the data with a lifted function 
\begin_inset Formula $f$
\end_inset

 (and we will then need to lift 
\begin_inset Formula $f$
\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 functor rather than to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor); the results will be equal.
 We write this requirement as an equation called the 
\series bold
naturality law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
headOption
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\text{List}^{A}\ar[r]\sp(0.55){\text{headOpt}^{A}}\ar[d]\sp(0.4){(f^{:A\rightarrow B})^{\uparrow\text{List}}} & \text{Opt}^{A}\ar[d]\sb(0.4){f^{\uparrow\text{Opt}}}\\
\xyScaleY{1.6pc}\xyScaleX{4.5pc}\text{List}^{B}\ar[r]\sp(0.55){\text{headOpt}^{B}} & \text{Opt}^{B}
}
\]

\end_inset


\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow\text{List}}\bef\text{headOpt}^{B}=\text{headOpt}^{A}\bef f^{\uparrow\text{Opt}}\quad.
\]

\end_inset

It is important to keep in mind that this law does not depend on the fact
 that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

 extracts the 
\emph on
first
\emph default
 element of a list.
 The same naturality law will hold for any fully parametric function of
 type 
\begin_inset Formula $\text{List}^{A}\rightarrow\text{Opt}^{A}$
\end_inset

, e.g., the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.lastOption
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.drop(2).headOption
\end_layout

\end_inset

.
 The naturality law only expresses the property that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

 works in the same way for all types without examining any specific values
 in the list.
 
\end_layout

\begin_layout Standard
Other examples of natural transformations are the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inflate
\end_layout

\end_inset

, whose naturality laws we have already seen.
 All these naturality laws are captured by the 
\begin_inset Quotes eld
\end_inset

natural transformation
\begin_inset Quotes erd
\end_inset

 pattern, which we can formulate for arbitrary functors 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 as the following law:
\begin_inset Formula 
\[
\xymatrix{F^{A}\ar[r]\sp(0.55){t^{A}}\ar[d]\sp(0.4){(f^{:A\rightarrow B})^{\uparrow F}} & G^{A}\ar[d]\sp(0.4){f^{\uparrow G}}\\
\xyScaleY{1.7pc}\xyScaleX{3.5pc}F^{B}\ar[r]\sp(0.55){t^{B}} & G^{B}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
(f^{:A\rightarrow B})^{\uparrow F}\bef t^{:F^{B}\rightarrow G^{B}}=t^{:F^{A}\rightarrow G^{A}}\bef f^{\uparrow G}\quad.\label{eq:law-natural-transformation-of-functors}
\end{equation}

\end_inset

Once we recognize that a given function 
\begin_inset Formula $t^{A}:F^{A}\rightarrow G^{A}$
\end_inset

 has the type signature of a natural transformation, how can we remember
 its naturality law? A naturality law always involves an arbitrary function
 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 with two type parameters.
 Types will match only if the function 
\begin_inset Formula $f$
\end_inset

 is lifted to the functor 
\begin_inset Formula $F$
\end_inset

 when 
\begin_inset Formula $f$
\end_inset

 is applied before 
\begin_inset Formula $t$
\end_inset

, and to the functor 
\begin_inset Formula $G$
\end_inset

 when 
\begin_inset Formula $f$
\end_inset

 is applied after 
\begin_inset Formula $t$
\end_inset

.
 So, the naturality law is 
\begin_inset Formula $f^{\uparrow F}\bef t=t\bef f^{\uparrow G}$
\end_inset

 with appropriate type parameters.
\end_layout

\begin_layout Standard
The analogous naturality law for natural transformations 
\begin_inset Formula $t:C^{A}\rightarrow D^{A}$
\end_inset

 between contrafunctors 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

 has exactly the same form, but the order of type parameters must be swapped:
\begin_inset Formula 
\[
\xymatrix{C^{A}\ar[r]\sp(0.55){t^{A}}\ar[d]\sp(0.4){(f^{:B\rightarrow A})^{\downarrow C}} & D^{A}\ar[d]\sp(0.4){f^{\downarrow D}}\\
\xyScaleY{1.7pc}\xyScaleX{3.5pc}C^{B}\ar[r]\sp(0.55){t^{B}} & D^{B}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
(f^{:B\rightarrow A})^{\downarrow C}\bef t^{:C^{B}\rightarrow D^{B}}=t^{:C^{A}\rightarrow D^{A}}\bef f^{\downarrow D}\quad.\label{eq:law-natural-transformation-of-contrafunctors}
\end{equation}

\end_inset

Examples of this pattern are the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-pure-for-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $\text{pu}_{D}$
\end_inset

 (where we need to set 
\begin_inset Formula $C^{A}\triangleq\bbnum 1$
\end_inset

) and the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-inflate-for-filterable-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $\text{inflate}_{C}$
\end_inset

.
\end_layout

\begin_layout Paragraph
\begin_inset Quotes eld
\end_inset

3-transformation
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The second pattern, which we called 
\begin_inset Quotes eld
\end_inset

3-transformation
\begin_inset Quotes erd
\end_inset

, is a curried function that takes a first argument of type 
\begin_inset Formula $C^{A}$
\end_inset

 and returns a natural transformation of type 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

.
 This pattern is recognized by a type signature 
\begin_inset Formula $C^{A}\rightarrow F^{A}\rightarrow G^{A}$
\end_inset

 where 
\begin_inset Formula $C$
\end_inset

 is a contrafunctor while 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are functors (or vice versa, 
\begin_inset Formula $C$
\end_inset

 is a functor while 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are contrafunctors).
 Examples of such type signatures are the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

, defined in the Scala library for sequence-like type constructors (e.g.,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vector
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
For functions of this kind, naturality laws must modify the argument of
 type 
\begin_inset Formula $C^{A}$
\end_inset

 when changing the order of lifted functions.
 In order to formulate the naturality law for 
\begin_inset Formula $t^{A}:C^{A}\rightarrow F^{A}\rightarrow G^{A}$
\end_inset

, use an arbitrary function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and first transform the argument of type 
\begin_inset Formula $F^{A}$
\end_inset

 into 
\begin_inset Formula $F^{B}$
\end_inset

 using 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 before applying 
\begin_inset Formula $t^{B}(c)$
\end_inset

:
\begin_inset Formula 
\[
f^{\uparrow F}\bef t^{B}(c^{:C^{B}})=\text{???}^{:F^{A}\rightarrow G^{B}}\quad.
\]

\end_inset

It is clear that we must choose an arbitrary value 
\begin_inset Formula $c$
\end_inset

 of type 
\begin_inset Formula $C^{B}$
\end_inset

 (rather than 
\begin_inset Formula $C^{A}$
\end_inset

) for all types to match.
 It remains to fill the typed hole, which must be of the form 
\begin_inset Formula $t(...)\bef f^{\uparrow G}$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow F}\bef t^{B}(c^{:C^{B}})=t^{A}(\text{???}^{:C^{A}})\bef f^{\uparrow G}\quad.
\]

\end_inset

The argument of 
\begin_inset Formula $t$
\end_inset

 of type 
\begin_inset Formula $C^{A}$
\end_inset

 is obtained by applying 
\begin_inset Formula $f^{\downarrow C}$
\end_inset

 to 
\begin_inset Formula $c$
\end_inset

.
 So, the law is:
\begin_inset Formula 
\begin{equation}
f^{\uparrow F}\bef t(c)=t(c\triangleright f^{\downarrow C})\bef f^{\uparrow G}\quad.\label{eq:naturality-law-general-parameterized-transformation}
\end{equation}

\end_inset

A similar law can be derived for the case when 
\begin_inset Formula $C^{\bullet}$
\end_inset

 is a functor and 
\begin_inset Formula $F^{\bullet},G^{\bullet}$
\end_inset

 are contrafunctors.
\end_layout

\begin_layout Standard
Functions 
\begin_inset Formula $t:C^{A}\rightarrow F^{A}\rightarrow G^{A}$
\end_inset

 are reduced to natural transformations if we swap the order of curried
 arguments to 
\begin_inset Formula $F^{A}\rightarrow C^{A}\rightarrow G^{A}$
\end_inset

 and define the functor 
\begin_inset Formula $H^{A}\triangleq C^{A}\rightarrow G^{A}$
\end_inset

.
 Then 
\begin_inset Formula $F^{A}\rightarrow C^{A}\rightarrow G^{A}=F^{A}\rightarrow H^{A}$
\end_inset

, which is a type signature of a natural transformation.
 Denoting by 
\begin_inset Formula $\tilde{t}:F^{A}\rightarrow H^{A}$
\end_inset

 the function 
\begin_inset Formula $t$
\end_inset

 with its arguments swapped, we can write the naturality law of 
\begin_inset Formula $\tilde{t}$
\end_inset

 as:
\begin_inset Formula 
\[
f^{\uparrow F}\bef\tilde{t}=\tilde{t}\bef f^{\uparrow H}\quad,\quad\text{where}\quad\tilde{t}\triangleq p^{:F^{A}}\rightarrow c^{:C^{A}}\rightarrow p\triangleright t(c)\quad.
\]

\end_inset

To show that this law is equivalent to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-general-parameterized-transformation"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we use the definition of 
\begin_inset Formula $^{\uparrow H}$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow H}\triangleq h^{:H^{A}}\rightarrow c^{:C^{B}}\rightarrow c\triangleright f^{\downarrow C}\bef h\bef f^{\uparrow G}\quad.
\]

\end_inset

Substituting this into the naturality law of 
\begin_inset Formula $\tilde{t}$
\end_inset

, we obtain the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-general-parameterized-transformation"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side applied to }p^{:F^{A}}:\quad & p\triangleright f^{\uparrow F}\bef\gunderline{\tilde{t}}=\gunderline{p\triangleright f^{\uparrow F}}\bef\gunderline{\big(p}\rightarrow c\rightarrow\gunderline p\triangleright t(c)\big)\\
\text{apply function to }p\triangleright f^{\uparrow F}:\quad & \quad=c\rightarrow p\triangleright f^{\uparrow F}\triangleright t(c)=c\rightarrow p\triangleright f^{\uparrow F}\bef t(c)\quad,\\
\text{left-hand side applied to }p^{:F^{A}}:\quad & \gunderline{p\triangleright\big(p}\rightarrow c\rightarrow p\triangleright t(c)\big)\bef f^{\uparrow H}=\big(c\rightarrow p\triangleright t(c)\big)\triangleright\gunderline{f^{\uparrow H}}\\
\text{definition of }f^{\uparrow H}:\quad & \quad=c\rightarrow\gunderline{c\triangleright f^{\downarrow C}\bef}\,\big(c\rightarrow p\triangleright t(\gunderline c)\big)\bef f^{\uparrow G}\\
\text{apply function to }c\triangleright f^{\downarrow C}:\quad & \quad=c\rightarrow p\triangleright t(c\triangleright f^{\downarrow C})\bef f^{\uparrow G}\quad.
\end{align*}

\end_inset

So, we have reduced both sides of 
\begin_inset Formula $\tilde{t}$
\end_inset

's law to the two sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-general-parameterized-transformation"
plural "false"
caps "false"
noprefix "false"

\end_inset

) applied to an arbitrary 
\begin_inset Formula $p^{:F^{A}}$
\end_inset

and considered as functions of 
\begin_inset Formula $c^{:C^{B}}$
\end_inset

.
\end_layout

\begin_layout Standard
Reduction to natural transformations works similarly when 
\begin_inset Formula $C^{\bullet}$
\end_inset

 is a functor and 
\begin_inset Formula $F^{\bullet},G^{\bullet}$
\end_inset

 are contrafunctors.
 A naturality law of 
\begin_inset Formula $t:C^{A}\rightarrow F^{A}\rightarrow G^{A}$
\end_inset

 can then be derived from 
\begin_inset Formula $t$
\end_inset

's type signature.
\end_layout

\begin_layout Paragraph
\begin_inset Quotes eld
\end_inset

Liftings
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

lifted
\begin_inset Quotes erd
\end_inset

 function 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 is the result of applying a functor 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operation to a function 
\begin_inset Formula $f$
\end_inset

.
 The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 are similar to that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 except for using the function type 
\begin_inset Formula $A\rightarrow\text{Opt}^{B}$
\end_inset

 instead of 
\begin_inset Formula $A\rightarrow B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}_{F}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}\quad,\\
 & \text{flm}_{\text{Opt}}:(A\rightarrow\text{Opt}^{B})\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad,\\
 & \text{liftOpt}_{F}:(A\rightarrow\text{Opt}^{B})\rightarrow F^{A}\rightarrow F^{B}\quad.
\end{align*}

\end_inset

Replacing 
\begin_inset Formula $\text{Opt}$
\end_inset

 by an arbitrary functor 
\begin_inset Formula $G$
\end_inset

, we obtain the type signature of a 
\begin_inset Quotes eld
\end_inset

generalized lifting
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\text{lift}_{G,F}^{A,B}:(A\rightarrow G^{B})\rightarrow F^{A}\rightarrow F^{B}\quad,
\]

\end_inset

which we can view as a lifting of functions with a 
\begin_inset Quotes eld
\end_inset

twisted
\begin_inset Quotes erd
\end_inset

 type 
\begin_inset Formula $A\rightarrow G^{B}$
\end_inset

 (which we call 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli!functions
\end_layout

\end_inset


\series bold
Kleisli functions
\series default
) to functions of type 
\begin_inset Formula $F^{A}\rightarrow F^{B}$
\end_inset

.
 We will look at properties of generalized liftings in the next subsection.
 Here we focus on the naturality laws for generalized liftings.
\end_layout

\begin_layout Standard
A generalized lifting has two type parameters and two naturality laws.
 Looking at the two naturality laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:right-naturality-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 or at the two laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-naturality-flatmap-option"
plural "false"
caps "false"
noprefix "false"

\end_inset

), (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:right-naturality-flatmap-option"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $\text{flm}_{\text{Opt}}$
\end_inset

, we notice that each naturality law replaces one of the type parameters
 but keeps the other type parameter unchanged.
 This motivates us to fix one of the type parameters in the type signature
 of 
\begin_inset Formula $\text{lift}_{G,F}^{A,B}$
\end_inset

.
 For fixed 
\begin_inset Formula $A$
\end_inset

, the function 
\begin_inset Formula $\text{lift}_{G,F}^{A,B}$
\end_inset

 is a natural transformation between functors 
\begin_inset Formula $A\rightarrow G^{\bullet}$
\end_inset

 and 
\begin_inset Formula $F^{A}\rightarrow F^{\bullet}$
\end_inset

.
 With a fixed 
\begin_inset Formula $B$
\end_inset

, the function 
\begin_inset Formula $\text{lift}_{G,F}^{A,B}$
\end_inset

 is a natural transformation between contrafunctors 
\begin_inset Formula $\bullet\rightarrow G^{B}$
\end_inset

 and 
\begin_inset Formula $F^{\bullet}\rightarrow F^{B}$
\end_inset

.
 One can show that the corresponding naturality laws for these two natural
 transformations are equivalent to the two naturality laws of a generalized
 lifting.
\end_layout

\begin_layout Standard
We have reduced the four patterns of naturality laws to the laws of natural
 transformations, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:law-natural-transformation-of-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for functors and Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:law-natural-transformation-of-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for contrafunctors, which are easier to understand.
\end_layout

\begin_layout Paragraph
Parametricity theorem
\end_layout

\begin_layout Standard
It turns out that the naturality law of a natural transformation 
\begin_inset Formula $t:F^{A}\rightarrow G^{A}$
\end_inset

 will 
\emph on
always hold
\emph default
 if the code of the function 
\begin_inset Formula $t$
\end_inset

 is fully parametric.
 More precisely, naturality holds if the code of 
\begin_inset Formula $t$
\end_inset

 is a combination of the eight standard code constructions (shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

) together with recursion.
 This is a consequence of the 
\begin_inset Quotes eld
\end_inset

parametricity theorem
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
parametricity theorem
\end_layout

\end_inset

, which is beyond the scope of this chapter.
\begin_inset Foot
status open

\begin_layout Plain Layout
Formulations and proofs sufficient for the scope of this book are given
 in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:Proofs-of-naturality-parametricity"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 So, we do 
\emph on
not
\emph default
 need to verify naturality laws for functions whose code is known to be
 fully parametric.
 This saves a significant amount of work, since every method of every typeclass
 will have one naturality law per type parameter.
 Until now, we have been systematically deriving and checking all naturality
 laws; but we will not check those laws in the rest of the book.
\end_layout

\begin_layout Standard
Even if naturality laws hold automatically, it is important to be able to
 recognize their form and to use them in derivations where they are frequently
 needed.
 The mnemonic recipe for naturality laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:law-natural-transformation-of-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:law-natural-transformation-of-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is that an arbitrary function 
\begin_inset Formula $f$
\end_inset

 is lifted to the functor 
\begin_inset Formula $F$
\end_inset

 at the left side of 
\begin_inset Formula $t:F^{A}\rightarrow G^{A}$
\end_inset

 and to the functor 
\begin_inset Formula $G$
\end_inset

 at the right side of 
\begin_inset Formula $t$
\end_inset

, matching the two sides of the type signature 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
All methods of typeclasses considered in this book are covered by the natural
 transformation recipe.
 However, not all type signatures of fully parametric functions can be reduced
 to natural transformations.
 For example, 
\begin_inset Formula $t^{A}:(A\rightarrow A)\rightarrow A$
\end_inset

 is not of the form 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

 where 
\begin_inset Formula $F,G$
\end_inset

 are either functors or contrafunctors.
 The parametricity theorem will still produce naturality laws for such functions
; but we will not be able to write those laws via the natural transformation
 recipe.
 (A general procedure that works for all type signatures is given in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Naturality-laws-for-fully-parametric-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Subsection
Generalizing the laws of liftings.
 Kleisli functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Generalizing-the-laws-of-liftings-kleisli-functions"

\end_inset


\end_layout

\begin_layout Standard
As we have seen in this chapter, the laws of filtering may be formulated
 equivalently via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 methods.
 These methods and their laws are equivalent but play different roles: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is the most convenient to use in program code; 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is the easiest type signature to implement and to reason about, especially
 in order to demonstrate that a functor is not filterable; 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 has the fewest laws and is most convenient for proofs of general type construct
ions.
\end_layout

\begin_layout Standard
If we put the naturality laws aside, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 has the laws of identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and composition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It is notable how these two laws are similar to the functor laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-identity-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-composition-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{liftOpt}_{F}(\text{pu}_{F})=\text{id}\quad, & \quad\quad\text{liftOpt}_{F}(f^{:A\rightarrow\bbnum 1+B})\bef\text{liftOpt}_{F}(g^{:B\rightarrow\bbnum 1+C})=\text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)\quad.\\
\text{fmap}_{F}(\text{id})=\text{id}\quad, & \quad\quad\text{fmap}_{F}(f^{:A\rightarrow B})\bef\text{fmap}_{F}(g^{:B\rightarrow C})=\text{fmap}_{F}(f\bef g)\quad.
\end{align*}

\end_inset

The only difference between these laws is in replacing 
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

 by 
\begin_inset Formula $\text{pu}_{F}^{:A\rightarrow F^{A}}$
\end_inset

 and the function composition 
\begin_inset Formula $f\bef g$
\end_inset

 by the Kleisli composition 
\begin_inset Formula $f\diamond_{_{\text{Opt}}}g$
\end_inset

.
 We will now focus on the analogy between these laws, which goes far beyond
 the superficial similarity of form.
\end_layout

\begin_layout Standard
Kleisli functions 
\begin_inset Formula $f^{:A\rightarrow\bbnum 1+B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow\bbnum 1+C}$
\end_inset

 cannot be composed as 
\begin_inset Formula $f\bef g$
\end_inset

 with the ordinary function composition.
 If we instead use the Kleisli composition, 
\begin_inset Formula $f\diamond_{_{\text{Opt}}}g$
\end_inset

, the properties of Kleisli functions with respect to composition become
 completely analogous to the properties of the ordinary functions, except
 that the 
\begin_inset Formula $\text{pu}_{\text{Opt}}:A\rightarrow\bbnum 1+A$
\end_inset

 plays the role of the identity (
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

).
 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-Kleisli-Option-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-Kleisli-Option-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The Kleisli composition 
\begin_inset Formula $\diamond_{_{\text{Opt}}}$
\end_inset

 obeys the identity and the associativity laws:
\begin_inset Formula 
\begin{align*}
\text{identity laws}:\quad & \text{pu}_{\text{Opt}}^{:A\rightarrow\text{Opt}^{A}}\diamond_{_{\text{Opt}}}g^{:A\rightarrow\text{Opt}^{B}}=g\quad,\quad\quad f^{:A\rightarrow\text{Opt}^{B}}\diamond_{_{\text{Opt}}}\text{pu}_{\text{Opt}}^{:B\rightarrow\text{Opt}^{B}}\quad=f,\\
\text{associativity law}:\quad & \big(f^{:A\rightarrow\text{Opt}^{B}}\diamond_{_{\text{Opt}}}g^{:B\rightarrow\text{Opt}^{C}}\big)\diamond_{_{\text{Opt}}}h^{:C\rightarrow\text{Opt}^{D}}=f\diamond_{_{\text{Opt}}}\big(g\diamond_{_{\text{Opt}}}h\big)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Use the definitions
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-Kleisli-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simplify-puOpt-flmOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simplify-kleisli-opt-right-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

), (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-of-flatMap-for-Option"
plural "false"
caps "false"
noprefix "false"

\end_inset

) derived previously in this chapter:
\begin_inset Formula 
\begin{align*}
\text{use Eq.~(\ref{eq:simplify-puOpt-flmOpt})}:\quad & \text{pu}_{\text{Opt}}\diamond_{_{\text{Opt}}}g=\text{pu}_{\text{Opt}}\bef\text{flm}_{\text{Opt}}(g)=g\quad,\\
\text{use Exercise~\ref{subsec:Exercise-filterable-laws-2}}:\quad & f\diamond_{_{\text{Opt}}}\text{pu}_{\text{Opt}}=f\bef\gunderline{\text{flm}_{\text{Opt}}(\text{pu}_{\text{Opt}})}=f\bef\text{id}=f\quad,\\
\text{expect to equal }f\diamond_{_{\text{Opt}}}\big(g\diamond_{_{\text{Opt}}}h\big):\quad & \big(f\diamond_{_{\text{Opt}}}g\big)\diamond_{_{\text{Opt}}}h=f\bef\gunderline{\text{flm}_{\text{Opt}}(g)\bef\text{flm}_{\text{Opt}}(h)}\\
\text{use Eq.~(\ref{eq:associativity-law-of-flatMap-for-Option})}:\quad & \quad=f\bef\text{flm}_{\text{Opt}}(g\diamond_{_{\text{Opt}}}h)=f\diamond_{_{\text{Opt}}}\big(g\diamond_{_{\text{Opt}}}h\big)\quad.
\end{align*}

\end_inset

This calculation motivates the name 
\begin_inset Quotes eld
\end_inset

associativity law
\begin_inset Quotes erd
\end_inset

 for Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-of-flatMap-for-Option"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 can be viewed as a 
\begin_inset Quotes eld
\end_inset

generalized lifting
\begin_inset Quotes erd
\end_inset

 from Kleisli functions 
\begin_inset Formula $A\rightarrow\bbnum 1+B$
\end_inset

 to functions 
\begin_inset Formula $F^{A}\rightarrow F^{B}$
\end_inset

, just as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is a lifting from ordinary functions 
\begin_inset Formula $A\rightarrow B$
\end_inset

 to functions 
\begin_inset Formula $F^{A}\rightarrow F^{B}$
\end_inset

; the laws of composition and the laws of liftings are analogous.
 The close analogy between ordinary functions and Kleisli functions means
 that any proofs of properties of ordinary liftings can be mechanically
 translated into proofs of the corresponding properties of generalized liftings.
 Indeed, replacing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 and 
\begin_inset Formula $\text{id}$
\end_inset

 by 
\begin_inset Formula $\text{pu}_{\text{Opt}}$
\end_inset

 where appropriate, we can translate the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (functor product), written using the pair product operation 
\begin_inset Formula $\boxtimes$
\end_inset

, into the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filterable-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (filterable functor product).
 The same holds for the proofs of functor co-product and functor composition
 constructions.
\end_layout

\begin_layout Standard
The similarity between these proofs means, in the mathematical sense, that
 we have been proving essentially the same statements twice but did not
 look at the appropriate level of abstraction to see that.
 While programmers may accept the work of writing these proofs twice, a
 mathematician would prefer to define a 
\begin_inset Quotes eld
\end_inset

generalized lifting
\begin_inset Quotes erd
\end_inset

 that replaces 
\begin_inset Formula $\text{Opt}$
\end_inset

 by a functor 
\begin_inset Formula $M$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{lift}_{M,F}:(A\rightarrow M^{B})\rightarrow F^{A}\rightarrow F^{B}\quad,\\
 & \text{pu}_{M}:A\rightarrow M^{A}\quad,\quad\quad\diamond_{_{M}}:(A\rightarrow M^{B})\rightarrow(B\rightarrow M^{C})\rightarrow(A\rightarrow M^{C})\quad,
\end{align*}

\end_inset

and postulating the required properties as the set of identity, associativity,
 and composition laws:
\begin_inset Formula 
\begin{align*}
 & \text{lift}_{M,F}(\text{pu}_{M}^{:A\rightarrow M^{A}})=\text{id}^{:F^{A}\rightarrow F^{A}}\quad,\quad\quad\text{lift}_{M,F}(f)\bef\text{lift}_{M,F}(g)=\text{lift}_{M,F}(f\diamond_{_{M}}g)\quad,\\
 & \text{pu}_{M}\diamond_{_{M}}g=g\quad,\quad\quad f\diamond_{_{M}}\text{pu}_{M}=f\quad,\quad\quad\big(f\diamond_{_{M}}g\big)\diamond_{_{M}}h=f\diamond_{_{M}}\big(g\diamond_{_{M}}h\big)\quad.
\end{align*}

\end_inset

Now the two sets of proofs can be replaced by a single set of proofs formulated
 for an 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $M$
\end_inset


\series bold
-filterable
\series default

\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $M$
\end_inset

-filterable functor
\end_layout

\end_inset

 functor 
\begin_inset Formula $F$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 could be later set to the identity functor or the 
\begin_inset Formula $\text{Opt}$
\end_inset

 functor.
\end_layout

\begin_layout Standard
Not all functors 
\begin_inset Formula $M$
\end_inset

 support the Kleisli composition 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

 with the required laws.
 We will study such functors 
\begin_inset Formula $M$
\end_inset

, which are known as 
\series bold
monads
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monads
\end_layout

\end_inset

, in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Semimonads-and-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Motivation for using category theory
\begin_inset CommandInset label
LatexCommand label
name "subsec:Motivation-for-using-category-theory"

\end_inset


\end_layout

\begin_layout Standard
In this chapter, we have seen four examples of operations that have the
 form of a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{for functors }F:\quad & \text{fmap}_{F}:(A\rightarrow B)\rightarrow(F^{A}\rightarrow F^{B})\quad,\\
\text{for contrafunctors }C:\quad & \text{cmap}_{C}:(B\rightarrow A)\rightarrow(C^{A}\rightarrow C^{B})\quad,\\
\text{for }M\text{-filterable functors }F:\quad & \text{lift}_{M,F}:(A\rightarrow M^{B})\rightarrow(F^{A}\rightarrow F^{B})\quad,\\
\text{for }M\text{-filterable contrafunctors }C:\quad & \text{lift}_{M,F}:(B\rightarrow M^{A})\rightarrow(C^{A}\rightarrow C^{B})\quad.
\end{align*}

\end_inset

All these operations obey similar laws of naturality, identity, and composition
 but differ in the type of functions being lifted: the ordinary function
 
\begin_inset Formula $A\rightarrow B$
\end_inset

, the 
\begin_inset Quotes eld
\end_inset

reversed
\begin_inset Quotes erd
\end_inset

 type 
\begin_inset Formula $B\rightarrow A$
\end_inset

, the Kleisli function 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

, and the 
\begin_inset Quotes eld
\end_inset

reversed
\begin_inset Quotes erd
\end_inset

 Kleisli function 
\begin_inset Formula $B\rightarrow M^{A}$
\end_inset

.
 In turn, all these function types obey the laws of identity and composition.
 (For the types to match, composition of reversed functions needs to be
 performed in the reverse order.)
\end_layout

\begin_layout Standard
In order to avoid writing essentially the same proofs multiple times, we
 use a more abstract view of this situation: a new notion of a functor that
 can work with modified function types (e.g., 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 or 
\begin_inset Formula $F^{A}\rightarrow F^{B}$
\end_inset

) instead of the ordinary function types (
\begin_inset Formula $A\rightarrow B$
\end_inset

).
 This notion of functor is provided by
\begin_inset Index idx
status open

\begin_layout Plain Layout
category theory
\end_layout

\end_inset

 
\series bold
category theory
\series default
, which turns out to be a convenient language for describing various laws
 and types of operations in functional programming.
\end_layout

\begin_layout Standard
Category theory generalizes functions of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 to 
\series bold
morphisms
\series default
 
\begin_inset Formula $A\leadsto B$
\end_inset

, which
\begin_inset Index idx
status open

\begin_layout Plain Layout
morphism
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
category theory!morphism
\end_layout

\end_inset

 can be in any relation to 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 as long as the identity and composition laws hold.
 The morphism types, the 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
identity morphism
\end_layout

\end_inset

identity morphism
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset Formula $A\leadsto A$
\end_inset

, and the composition operation must be chosen appropriately.
 These choices, together with a definition of the admissible types 
\begin_inset Formula $A,B,...$
\end_inset

, define a 
\series bold
category
\series default
, e.g.:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Category
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Morphisms
\series default
\size default
 
\begin_inset Formula $f:A\leadsto B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Identity morphism
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Composition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset

plain
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f:A\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f\bef g$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset

reversed
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f:B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $g\bef f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $M$
\end_inset

-Kleisli
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f:A\rightarrow M^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{pu}_{M}:A\rightarrow M^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f\diamond_{_{M}}g$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset

reversed 
\begin_inset Formula $M$
\end_inset

-Kleisli
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f:B\rightarrow M^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{pu}_{M}:A\rightarrow M^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $g\diamond_{_{M}}f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

-lifted
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f:F^{A}\rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{id}^{:F^{A}\rightarrow F^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f\bef g$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition--(category)"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition--(category)"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (category)
\end_layout

\begin_layout Standard
A category
\begin_inset Index idx
status open

\begin_layout Plain Layout
category theory!category
\end_layout

\end_inset

 
\begin_inset Formula $\mathcal{C}$
\end_inset

 is a collection of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
category theory!object
\end_layout

\end_inset

 
\series bold
objects
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

 in category theory are 
\emph on
not
\emph default
 related to 
\begin_inset Quotes eld
\end_inset

object-oriented programming
\begin_inset Quotes erd
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
object-oriented programming
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset Formula $\left\{ A,B,...\right\} $
\end_inset

 and a collection of morphisms 
\begin_inset Formula $\left\{ f_{1},f_{2},...\right\} $
\end_inset

, where each morphism is labeled by two objects 
\begin_inset Formula $A,B$
\end_inset

 as 
\begin_inset Formula $f^{:A\leadsto B}$
\end_inset

 (the objects 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 do not need to be different).
 For any object 
\begin_inset Formula $A$
\end_inset

, the identity morphism 
\begin_inset Formula $\text{id}_{\mathcal{C}}^{:A\leadsto A}$
\end_inset

 must exist.
 For any two morphisms 
\begin_inset Formula $f^{:A\leadsto B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\leadsto C}$
\end_inset

, the composition 
\begin_inset Formula $f\bef_{_{\mathcal{C}}}g$
\end_inset

 must exist as a morphism labeled 
\begin_inset Formula $A\leadsto C$
\end_inset

.
 Additionally, the identity and the associativity laws must hold:
\begin_inset Formula 
\[
f\bef_{_{\mathcal{C}}}\text{id}_{\mathcal{C}}=f=f\bef_{_{\mathcal{C}}}\text{id}_{\mathcal{C}}\quad,\quad\quad\big(f\bef_{_{\mathcal{C}}}g\big)\bef_{_{\mathcal{C}}}h=f\bef_{_{\mathcal{C}}}\big(g\bef_{_{\mathcal{C}}}h\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The category laws clearly hold for the 
\begin_inset Quotes eld
\end_inset

plain
\begin_inset Quotes erd
\end_inset

 category whose objects are types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int]
\end_layout

\end_inset

, etc.) and morphisms are functions available in the programming language.
 The 
\begin_inset Formula $F$
\end_inset

-lifted category is a subset of the 
\begin_inset Quotes eld
\end_inset

plain
\begin_inset Quotes erd
\end_inset

 category where we only allow types of the form 
\begin_inset Formula $F^{A}$
\end_inset

; so the category laws also hold.
 Most applications of category theory to functional programming will use
 categories whose objects are types (or, sometimes, type constructors),
 and whose morphisms are functions of specific types, e.g., 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 or 
\begin_inset Formula $F^{A}\rightarrow F^{B}$
\end_inset

 as we have seen.
 However, the definition of category is general and does not require that
 morphisms be functions or that objects be types.
\end_layout

\begin_layout Standard
In functional programming, a 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

 is a type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 with a lawful lifting of functions 
\begin_inset Formula $A\rightarrow B$
\end_inset

 to functions 
\begin_inset Formula $F^{A}\rightarrow F^{B}$
\end_inset

.
 Category theory
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
category theory!functor|textit
\end_layout

\end_inset

 defines a functor more
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
functor!in category theory|textit
\end_layout

\end_inset

 generally — as a lawful lifting 
\emph on
from one category to another
\emph default
.
 We will use the phrase 
\begin_inset Quotes eld
\end_inset


\series bold
categorical functor
\series default

\begin_inset Quotes erd
\end_inset

 to distinguish the notion of functor in category theory from the programmer's
 notion (a type constructor with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
In category theory, programmer's functors are called 
\series bold
endofunctors
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
endofunctor
\end_layout

\end_inset

 — categorical functors from a category 
\begin_inset Formula $\mathcal{C}$
\end_inset

 to itself.
\end_layout

\end_inset

)
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition--(categorical-functor)"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition--(categorical-functor)"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (categorical functor)
\end_layout

\begin_layout Standard
Given two categories 
\begin_inset Formula ${\cal C}$
\end_inset

 and 
\begin_inset Formula ${\cal D}$
\end_inset

, a functor 
\begin_inset Formula $\mathcal{F}:{\cal C}\rightarrow{\cal D}$
\end_inset

 is a mapping of each type 
\begin_inset Formula $A$
\end_inset

 in 
\begin_inset Formula ${\cal C}$
\end_inset

 to the corresponding type 
\begin_inset Formula $\mathcal{F}(A)$
\end_inset

 in 
\begin_inset Formula $\mathcal{D}$
\end_inset

, as well as a mapping of each morphism 
\begin_inset Formula $f:A\leadsto_{_{\mathcal{C}}}B$
\end_inset

 from 
\begin_inset Formula $\mathcal{C}$
\end_inset

 to a corresponding morphism 
\begin_inset Formula $\mathcal{F}(f):\mathcal{F}(A)\leadsto_{_{\mathcal{D}}}\mathcal{F}(B)$
\end_inset

 in 
\emph on

\begin_inset Formula $\mathcal{D}$
\end_inset

.
 
\emph default
Additionally, the laws of identity and composition must hold according to
 the rules of each category.
 That is, identity morphisms 
\begin_inset Formula $\text{id}_{\mathcal{C}}$
\end_inset

 from the category 
\begin_inset Formula $\mathcal{C}$
\end_inset

 must be mapped to those of the category 
\begin_inset Formula $\mathcal{D}$
\end_inset

; and the composition (
\begin_inset Formula $\bef_{\mathcal{C}}$
\end_inset

) of any two morphisms in the category 
\begin_inset Formula $\mathcal{C}$
\end_inset

 must be mapped to the composition (
\begin_inset Formula $\bef_{\mathcal{D}}$
\end_inset

) of morphisms in the category 
\begin_inset Formula $\mathcal{D}$
\end_inset

.
\begin_inset Formula 
\begin{align*}
\text{identity law of categorical functor}:\quad & \mathcal{F}(\text{id}_{\mathcal{C}}^{:A\leadsto_{_{\mathcal{C}}}A})=\text{id}_{\mathcal{D}}^{:\mathcal{F}(A)\leadsto_{_{\mathcal{D}}}\mathcal{F}(A)}\quad,\\
\text{composition law of categorical functor}:\quad & \mathcal{F}(f^{:A\leadsto_{_{\mathcal{C}}}B})\bef_{_{\mathcal{D}}}\mathcal{F}(g^{:B\leadsto_{_{\mathcal{C}}}C})=\mathcal{F}(f\bef_{_{\mathcal{C}}}g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To clarify this definition, consider two examples: a contrafunctor 
\begin_inset Formula $C$
\end_inset

 and a filterable functor 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-category-definition-of-contrafunctor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-category-definition-of-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A contrafunctor 
\begin_inset Formula $C$
\end_inset

 is specified via a lawful function 
\begin_inset Formula $\text{cmap}:(B\rightarrow A)\rightarrow C^{A}\rightarrow C^{B}$
\end_inset

.
 To formulate this in category theory, we say that there must exist a categorica
l functor from the reversed category to the 
\begin_inset Formula $C$
\end_inset

-lifted category.
 To define that functor, we need to specify how types and morphisms are
 mapped from the first category to the second.
 Each type 
\begin_inset Formula $A$
\end_inset

 of the reversed category is mapped to the corresponding type 
\begin_inset Formula $C^{A}$
\end_inset

 of the 
\begin_inset Formula $C$
\end_inset

-lifted category.
 Each 
\begin_inset Formula $(A\leadsto B)$
\end_inset

-morphism 
\begin_inset Formula $f^{:B\rightarrow A}$
\end_inset

 of the reversed category is mapped to the morphism 
\begin_inset Formula $f^{\downarrow C}:C^{A}\rightarrow C^{B}$
\end_inset

 of the 
\begin_inset Formula $C$
\end_inset

-lifted category.
 
\end_layout

\begin_layout Standard
To formulate the laws of identity and composition for the (categorical)
 functor, we look up the definitions of the identity morphisms and the compositi
on operation in each category:
\begin_inset Formula 
\begin{align*}
\text{for the reversed category}:\quad & \text{id}^{:A\rightarrow A}\quad\text{and}\quad g\bef f\quad,\\
\text{for the }C\text{-lifted category}:\quad & \text{id}^{:C^{A}\rightarrow C^{A}}\quad\text{and}\quad f\bef g\quad.
\end{align*}

\end_inset

Now we require that the first category's identity morphism is mapped to
 the second category's identity morphism, and that a composition of any
 two morphisms (as defined in the first category) is mapped to a composition
 as defined in the second category:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \big(\text{id}^{:A\rightarrow A}\big)^{\downarrow C}=\text{id}^{:C^{A}\rightarrow C^{A}}\quad,\\
\text{composition law}:\quad & (g\bef f)^{\downarrow C}=f^{\downarrow C}\bef g^{\downarrow C}\quad.
\end{align*}

\end_inset

We derived these laws previously as the laws of contrafunctors.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-category-definition-of-filterable-functor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-category-definition-of-filterable-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A filterable functor 
\begin_inset Formula $F$
\end_inset

 is specified via a lawful function 
\begin_inset Formula $\text{liftOpt}_{F}:(A\rightarrow\text{Opt}^{B})\rightarrow F^{A}\rightarrow F^{B}$
\end_inset

.
 To formulate the categorical definition for this situation, we say that
 there must exist a functor from the 
\begin_inset Formula $\text{Opt}$
\end_inset

-Kleisli category to the 
\begin_inset Formula $F$
\end_inset

-lifted category.
\end_layout

\begin_layout Standard
To define that (categorical) functor, we need to specify how types and morphisms
 are mapped from the first category to the second.
 Each type 
\begin_inset Formula $A$
\end_inset

 of the 
\begin_inset Formula $\text{Opt}$
\end_inset

-Kleisli category is mapped to the corresponding type 
\begin_inset Formula $F^{A}$
\end_inset

 of the 
\begin_inset Formula $F$
\end_inset

-lifted category.
 Each 
\begin_inset Formula $(A\leadsto B)$
\end_inset

-morphism 
\begin_inset Formula $f^{:A\rightarrow\bbnum 1+B}$
\end_inset

 of the 
\begin_inset Formula $\text{Opt}$
\end_inset

-Kleisli category is mapped to the morphism 
\begin_inset Formula $\text{liftOpt}_{F}(f):F^{A}\rightarrow F^{B}$
\end_inset

 of the 
\begin_inset Formula $F$
\end_inset

-lifted category.
\end_layout

\begin_layout Standard
Formulate the laws of identity and composition for the (categorical) functor
 using the definitions of the identity morphisms and the composition operation
 in each category:
\begin_inset Formula 
\begin{align*}
\text{for the Opt-Kleisli category}:\quad & \text{pu}_{\text{Opt}}^{:A\rightarrow\bbnum 1+A}\quad\text{and}\quad f\diamond_{_{\text{Opt}}}g\quad,\\
\text{for the }F\text{-lifted category}:\quad & \text{id}^{:F^{A}\rightarrow F^{A}}\quad\text{and}\quad f\bef g\quad.
\end{align*}

\end_inset

Now we require that the first category's identity morphism is mapped to
 the second category's identity morphism, and that a composition of any
 two morphisms (as defined in the first category) is mapped to a composition
 as defined in the second category:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \text{liftOpt}_{F}\big(\text{pu}_{\text{Opt}}\big)=\text{id}^{:F^{A}\rightarrow F^{A}}\quad,\\
\text{composition law}:\quad & \text{liftOpt}_{F}(f\diamond_{_{\text{Opt}}}g)=\text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)\quad.
\end{align*}

\end_inset

We derived these laws previously as the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
In both examples, the laws of the suitably defined categorical functors
 turned out to be equivalent to the typeclass laws we derived previously.
 This gives us assurance that we have correctly guessed the relevant laws.
 The choice of typeclass laws is not self-evident.
 For example, Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Motivation-for-and-derivation-of-laws-of-filtering"
plural "false"
caps "false"
noprefix "false"

\end_inset

 derived the four laws of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function from heuristic ideas.
 The laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 have been formulated differently by different people, also starting from
 heuristic considerations.
\begin_inset Foot
status open

\begin_layout Plain Layout
E.g., with an additional 
\begin_inset Quotes eld
\end_inset

empty-value
\begin_inset Quotes erd
\end_inset

 law here: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/fantasyland/fantasy-land#filterable"

\end_inset


\end_layout

\end_inset

 It is not obvious whether we correctly guessed the relevant laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and did not assume more laws than necessary.
 In contrast, the two laws of the categorical functor are general and appear
 time and again in different areas of mathematics.
 This gives us confidence that these laws are correctly chosen and will
 be useful in a wide range of contexts.
 Proving that the four laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Motivation-for-and-derivation-of-laws-of-filtering"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are equivalent to the two laws of a categorical functor gives assurance
 that our choice of filtering laws is mathematically consistent and is likely
 to prove useful in applications.
\end_layout

\begin_layout Standard
Having looked at the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, we noticed that we can reduce the number of different proofs if we generalize
 the 
\begin_inset Formula $\text{Opt}$
\end_inset

-Kleisli category to an 
\begin_inset Formula $M$
\end_inset

-Kleisli category
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli!category
\end_layout

\end_inset

 with a suitable functor 
\begin_inset Formula $M$
\end_inset

.
 It turns out that one can prove general theorems about products, co-products,
 and composition of (categorical) functors that map between any categories.
 In this way, we can replace four theorems (say, for the product of functors,
 contrafunctors, filterable functors, and filterable contrafunctors) by
 a single but more abstract theorem about the product of (categorical) functors
 being a functor between suitably defined categories.
 We will not look at these proofs here; Chapters
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Filterable-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 already worked through a few almost identical proofs that show the required
 techniques.
\end_layout

\begin_layout Standard
The categorical view also shows us two directions for developing the theory
 further, hoping to find useful applications.
 First, we can look for functors 
\begin_inset Formula $M$
\end_inset

 (called 
\begin_inset Quotes eld
\end_inset

monads
\begin_inset Quotes erd
\end_inset

) that admit the Kleisli composition with the properties (the identity and
 the associativity laws) required by an 
\begin_inset Formula $M$
\end_inset

-Kleisli category.
 Second, having found some new monads 
\begin_inset Formula $M$
\end_inset

, we can look for 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $M$
\end_inset

-filterable
\begin_inset Quotes erd
\end_inset

 functors
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $M$
\end_inset

-filterable functor
\end_layout

\end_inset

 or contrafunctors 
\begin_inset Formula $F$
\end_inset

 that admit an operation 
\begin_inset Formula $\text{lift}_{M,F}$
\end_inset

 similar to 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 but adapted to the monad 
\begin_inset Formula $M$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

.
 We will see some examples of 
\begin_inset Formula $M$
\end_inset

-filterable contrafunctors
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $M$
\end_inset

-filterable contrafunctor
\end_layout

\end_inset

 later in this book.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
To summarize, using the category theory's notion of functor brings the following
 advantages:
\end_layout

\begin_layout Itemize
We are assured that we found a correct set of laws of a typeclass.
 We can derive the formulation of those laws from the standard laws of categorie
s and functors, without guessing.
\end_layout

\begin_layout Itemize
We may find some promising directions for obtaining more general type constructi
ons.
\end_layout

\begin_layout Itemize
Several proofs may be replaced by a single proof for properties of some
 (categorical) functors.
\end_layout

\begin_layout Itemize
We can formulate general constructions (e.g., functor product) that work in
 the same way for many different typeclasses.
\end_layout

\begin_layout Standard
In this way, we find that category theory is a useful tool for reasoning
 about abstract constructions that work with different typeclasses (functor,
 contrafunctor, filterable, etc.).
 Category theory views many typeclasses in a similar way and gives a systematic
 guidance for deriving the typeclass laws.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
What does category theory (CT) 
\emph on
not
\emph default
 do for functional programming
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
category theory!in functional programming
\end_layout

\end_inset

?
\end_layout

\begin_layout Itemize
CT defines many abstract constructions but does not say which of these construct
ions will have useful applications in practical programming.
\end_layout

\begin_layout Itemize
For verifying specific laws of specific functions (e.g., the laws of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 typeclass for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 function), CT gives neither proofs nor proof techniques that programmers
 could use.
\end_layout

\begin_layout Itemize
CT does not help determine whether a given type constructor (say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Option[(A, A)]
\end_layout

\end_inset

) will belong to a specific typeclass (e.g., a filterable functor, a pointed
 functor, or a monad).
\end_layout

\begin_layout Itemize
Even if we know that, say, a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 instance actually exists for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] = Option[(A, A)]
\end_layout

\end_inset

, CT does not help in writing correct code for that typeclass instance.
\end_layout

\begin_layout Itemize
CT does not say whether there exists a natural transformation between two
 given type constructors, or how to implement one if it exists and how to
 verify the suitable naturality laws.
\end_layout

\begin_layout Standard
Performing these tasks requires certain techniques of symbolic derivation
 adapted to 
\emph on
applied
\emph default
 (that is, practically relevant) functional programming.
 Developing such techniques and selecting the necessary theoretical material
 is one of the main themes of this book.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Chapter six of the functional programming tutorial it is about computations
 in the filterable factor consider this example this is a mathematical computati
on how would we express this computation in functional program we can write
 this Scala code now let us look a little bit more carefully about what
 this computation is doing for all integer X such that X is between 0 and
 100 we select those that have positive value of cosine X and then we compute
 square root of cosine X and sum over all those so we sum over only those
 that have cosine X greater than 0 those eggs and then if cosine X Radian
 is greater than 0 it is safe to compute the square root of cosine X so
 we compute that and we add together all those values of the square root
 of cosine X so in the Scala code this is represented by in this program
 because we take the sequence from zero to hundred we map with a cosine
 function we filter with the condition that the argument is greater than
 zero after the filter only those elements which are already transformed
 to the cosine values are left then it is safe to take the square root of
 those cosine values and add them up so this would be approximately the
 result now Scala has a different syntax for computations like this where
 you have a chain of map filter map and so on the syntax uses the key words
 for and the yield so it is sometimes called a for yield syntax I prefer
 to call it a Thunder block because this does not work unless you have some
 functor type around and you're using this only for computations in the
 factory type other names for the syntax are for comprehension now this
 comes from Python I believe and it does not add to my comprehension of
 what this code is doing so I will not call it a for comprehension I will
 call it a functor block because it's a block of code for something yield
 something and it has to be handled as a single expression so if I want
 to do anything with this expression I have to put it in parenthesis like
 this so it's a block that is except is an expression it yields a value
 so how does it work we can compare it side-by-side with the code of this
 program written a little bit more verbally where I wrote out all the arguments
 with names so here I say for example cosine of underscore and this is a
 Scala syntax for a function like this X goes to cosine of X so Scala allows
 you to have this function shorter just say cosine of underscore but let's
 write it out with names of variables and it will be map of X going to math
 dot cosine X then filter Y is going to wine greater than zero the map y
 is going to square root of y and then some the for yield syntax describes
 exactly the same computation and we can come compare line by line how the
 syntax is changing the for yield syntax is automatically transformed by
 the compiler into the form on the right so this is just syntax there is
 no special keyword or function that is called yield there's a keyword yield
 what healed itself is not a function it has syntax keyword so all of this
 is removed by the compiler and replaced by the code on the right the first
 line is equivalent to saying that whatever follows will have the value
 X going from 1 0 to 100 the first line in the for yield block must be this
 line with the left pointing arrow to the right of the left pointing arrow
 there must be a functor a functor value so this value is a sequence from
 zero to hundred and as we know sequences are factors to the left of the
 arrow is a variable or more generally a pattern with pattern variables
 in these examples we will only use simple variables to the left of the
 arrow but it can be a pattern match so the first line says take X to be
 any value in this sequence the second line says compute cosine of this
 value call it Y exactly similar to this is that we compute the cosine of
 X and in the next whatever comes filter or mat or whatever we call that
 why we're free to call that X here in fact aren't we it's a different scope
 it would be confusing however if we wrote X here X equals math dot cosine
 of X we can though it will be valid it will be just confusing so let's
 not do it but it would be exactly the same code if we renamed Y to X in
 what follows in this block just because it's translated into this kind
 of code and there we are free to call this variable by any name we want
 we can call it X Y or whatever the next line here says if y greater than
 zero now if is a keyword and this is an expression that should evaluate
 two boolean just like here this is an expression that should evaluate two
 boolean and this is under filter the last line is yield and after yield
 there can be some expression this expression is what comes here after we
 do the last map so actually yield is just as part of a block as as all
 this stuff it is not different we could put this computation inside the
 block for example we could have said Z equals a little Y and then say yield
 Z instead of this it will be exactly the same computation this would be
 here the last map after that we do the sum the sum cannot be done inside
 the filter block because it takes us out of the factor context as I say
 some transforms a functor value or sequence in the same in this case into
 a single number so every line in the functor block after the first line
 will be repeated for every X that belongs to this sequence however if some
 Y in in this computation isn't is non positive we will not compute the
 square root of Y so this value will be emitted from this resulting sequence
 just like it is here because it's the same code that's just written in
 a different syntax after we filter only values that pass the condition
 are left in the sequence so the same logic is a little more visual in the
 functor block syntax that anything after the if only is executed or is
 computed when it passes the condition so to summarize the block as a syntax
 for manipulating data within a container where this container in this case
 this was a sequence of integers it could be any container which is a functor
 which is any type constructor that has a map function such that the function
 laws hold as a result of computations in a functor block we manipulate
 data inside the factor or the container however the data changes it will
 still still remain within the same container so the value of this expression
 is a sequence it can be a sequence of double numbers level precision floating
 point numbers as a in this example so it changes type the data items inside
 the container can change their type of course the container does not change
 it is still a sequence we cannot change the type of the container in the
 functor block it must be within the same container so in Chapter four we
 have started with the container semantics looking at the map function and
 generalized from it to obtain the Kansai the concepts of a functor we will
 do the same in this tutorial to generalize the filter we will find what
 laws the filter must satisfy and what kind of containers will be such that
 you can define a filter method now more precisely in Scala there is a method
 called with filter if your functor has a method called with filter then
 you can use this function in a functor block with an if keyword otherwise
 it will fail to compile so we will call a functor filterable if it has
 a method called with filter that satisfies the appropriate laws that we
 will investigate later in this tutorial however for convenience many factors
 also define the filter method it is shorter to write it might be implemented
 differently for performance reasons in this tutorial we will not distinguish
 between filter and West filter we will consider them to be the same function
 their types are exactly the same and they are isomorphic in the sense that
 they yield maybe different implementations but these implementations are
 completely equivalent this is the type signature of the function with filter
 that needs to be implemented in order for us to be able to use the if syntax
 in a functor block with the factory F Scala syntax will be available no
 matter how you define this method with filter it must be that you are able
 to write F dot with filter it can be done using an implicit conversion
 typeclass or just defining a method West filter on your on your data type
 that does not matter you can use it in the functor block after that so
 the main questions that remains for this tutorial is what are the required
 laws that captured the intuition we have for these computations and once
 we found those laws what are the possible data types that are filterable
 the main intuition is that the filter call the function filter when you
 call it with some non-trivial condition may decrease the number of data
 items that a container holds it may not decrease it but it may also decrease
 the container therefore must be able to hold fewer or more data items it
 must be able to hold in some sense a different number of data items of
 course still of the same type t so here's an example that we are familiar
 with which is option the option type is written in the type in the short
 type notation as 1 plus T and here are some computations that we can do
 with an option using filter if an option is empty then whatever you filter
 it or whatever it still returns empty so that's not very interesting but
 you see if this number passes the condition and the number remains but
 if it does not pass the condition the option becomes empty also you can
 use width filter on an option that actually returns a different type not
 option but that type is isomorphic to option so it still has all the same
 methods as the option has it has map it also has filter and with filter
 and so on so it's isomorphic and it can be used if you wish but as I said
 in this tutorial it will be not important for us how this is implemented
 and what types are behind this operation in the standard library a standard
 library makes its choices which may change with time what's important is
 that the results of filtering can can be an empty option if the number
 inside the option does not pass the condition a second example familiar
 to us is lists so a list type can be visualized as this short notation
 so this is a disjunction of unit a single data item of type T two data
 items three data items and so on and if you apply filter to the list then
 only those elements that pass the condition remain in the list how does
 it work so for instance a list 10 20 30 is a disjunction of three elements
 which is this part of the disjunction after the filter only two elements
 remain twenty and thirty so after the filter we are in this part of the
 disjunction in the second example after the filter we go from this part
 of the disjunction to this one the empty list so what do we learn by looking
 at these examples it looks like the data type must be a disjunction of
 some sort or must contain a disjunction may be somewhere in this disjunction
 must have a different number of data items of type T so that when some
 data items do not pass the condition we take data from one part of the
 disjunction and put it into another part of the disjunction so for example
 here we had ten twenty thirty now this one did not pass the condition we
 still had these two so we put them into these two data items in this part
 of the disjunction so the data goes from one part of the disjunction to
 another as necessary according to whether the predicate P returns which
 is this this predicate P the function from a to Gulen or from in this case
 will be from T to boolean whether this predicate returns false on some
 T values of or true on the on the values that you actually have in your
 in your function another curious thing here we can notice is that when
 some data item does not pass the condition like this one in this example
 we we can see what's happening as if we replace this T with a unit with
 one unit type and the result would be 1 times T times T which is exactly
 is isomorphic to T times T so 1 times T times T is this part of the disjunction
 actually so this is a curious phenomenon that we noticed at the type level
 that certain items are replaced by a unit type and then the resulting type
 like this for example would be T times 1 times T it's equivalent to T times
 T and that's another part of the disjunction so we can accommodate replacing
 some items T by unit type that does not break the type it still remains
 within the same disjunction we will use this intuition later in second
 part of this tutorial and finally we notice that the container can actually
 become empty so all of these examples contain a disjunction part which
 is unit which represents an empty container now of course there are names
 for this in Scala so this is not the unit itself in this case it's a case
 object called none in this case it's a case object called nil I believe
 but that's just syntax this is a name for a unit type so Scala can have
 any number of named unit types the unit is the standard one but you can
 define any number of your own of course so these are these intuitions we
 we gather from these examples we would like to generalize this realize
 we need more examples so let's consider a business application where we
 have the following logic an order can be placed on Tuesday and or on Friday
 and under certain conditions an order is approved so separately on Tuesday
 and on Friday the order is considered for approval now this logic of approving
 or not approving is a function such as amount less than thousand or any
 other requirements we would like to abstract away the logic of approval
 from the logic of which orders are approved and that logic is the one that
 the filter function represents so therefore we will also abstract the type
 of order to a type parameter so we will consider a class or data type orders
 with type parameter a and it has two parts as a conjunction one is an option
 of a another is also an option away you're presenting that we can place
 an order on Tuesday or not and we can also place an order on Friday or
 not and then we define a filter function on this case class by simply calling
 the filter function on each option now this filter function option does
 what we just saw it does these things so that's going to represent exactly
 what we want when T is given some kind of approval condition we can apply
 this condition to the order placed on Tuesday if any order was placed on
 Tuesday and also we will apply it to an order placed on Friday if any the
 result of this definition is like this so suppose we placed an order for
 500 on Tuesday and for 2,000 on Friday but approval happens only when it's
 less than a thousand so then the Friday order will not be approved and
 the Tuesday order will be approved so the result will be this data so would
 have we achieved well we separated the logical which orders will be approved
 from the order of from the logic of how orders are approved and also from
 the specific data type that represents orders so this code only represents
 the logic of how orders will be removed from our container and that's what
 filter represents let's look at example code so this is this code I have
 written here orders 1 because we will have some variations on it shortly
 and here are some typical examples so if we filter with this condition
 then only this one survives now of course if no order was placed and it's
 still empty on Friday so condition is such that every order passes then
 both of the orders remain in the container and finally when now none of
 the orders pass the filter then a container becomes empty so we see that
 orders one is a container that can can represent empty or non empty sets
 of orders and that's the logic we want now in the short notation this functors
 type is written like this it's just a product of two option values and
 option is one plus a so it's one plus a times one plus a as in the other
 examples we see that the a is replaced by one or by the nun named unit
 when the value here does not pass the filter in this case filtering is
 applied independently to both parts of the product but we could consider
 other options for example both orders must be approved or else no orders
 can be placed at all that could be a business requirement another business
 requirement that one could come up with is that if at least one of the
 orders is approved then both orders can be placed so let's see how that
 works in code if we implement the rule a it means that both orders orders
 must be approved for them to be placed now if there's one order then this
 rule does not modify our previous behavior if there is only one order placed
 then we still apply a filter to it as as before but if there are two orders
 placed and then both of them must be approved so let's see how this logic
 can be implemented so first we find what will be the ordinary filtering
 procedure so the Tuesday orders after filtering is this new to use them
 and new Friday now the order the the ordinary filtering procedure would
 be applicable if both of them passed the test passed the predicate now
 this condition expresses that either the Tuesday is empty and for the empty
 option for all is always true well this is a mathematical convention that
 empty for all is true if this is not empty then predicate must hold for
 the value of the option so this condition therefore will be true either
 if both orders are present and pass the test or if one of the orders are
 both are empty and if not empty they pass the test so only in this situation
 we return something that could be non empty and that in other cases we
 return empty container so this expresses the business rule a so for example
 if we have 500 and 2000 and the filter is less than 1000 and one of them
 passes and the other one does not pass and then we return empty container
 so this is the new business requirement in all other cases we do exactly
 as before so for example here one of them passes the other didn't was not
 placed so that's fine all of the orders that were placed pass that's the
 business rule and that's the result then and finally when both pass then
 we return both non-empty so this is the new rule now the second business
 rule that we could consider in the business rule B is that both orders
 are approved if at least one of them is approved so both orders can be
 placed if at least one of them is approved so this is expressed by this
 condition exists on an option means that the option is not empty and its
 contents pass the test so P is a predicate exists on an option is this
 means that other exists a value inside the option and such that P on that
 value returns true so if at least one of them exists in other words is
 placed on order that was approved then we return this which is the the
 value of the container unmodified so we do not actually filter so even
 if some of them did not pass the filter so the first one did not pass the
 filter here's an example first one passed the second one did not pass the
 children but the result is still that we returned both orders so both orders
 can be placed if at least one of them was approved that's the new business
 rule now if one of the orders was empty still we applied the filter to
 the other one if both orders pass we'll return both others if none of the
 orders passed were returned empty container so in this way we have implemented
 these business requirements but now I would like to ask well I can come
 up with any number of other requirements of this kind which of them actually
 make sense in terms of filtering and this cannot be answered without some
 mathematical principles or laws that allow us to decide whether a certain
 function satisfies the laws and therefore it makes sense to be used as
 a filter otherwise we're just going to argue opinions and that is not productiv
e so what are these mathematical laws in order to arrive at them we need
 some more intuition and now we can generalize from examples we have seen
 the main intuition here is that computations in the funds our block should
 be reasonable they should make sense in other words here is a thunder block
 program this program should make sense you should look at it and reason
 about it in a way that is intuitively correct mathematically reasonable
 so let us now think about it and decide and derive what these mathematical
 requirements must be so here's a kind of schematic example of a functor
 block program the first line must be the line with a left arrow which let's
 say has some functor on the right hand side let's say list so then the
 entire block will be computations as we say lifted into the list functor
 or computation in the context of the list function which means that we
 have some data here when we're going to manipulate this data and the results
 are going to stay as a list container now let me go back a little bit and
 remind you that this is not modifying the container in place in any way
 these are mathematical computations are not modifications of anything these
 are values so from the point of view of the program this was one container
 and the result of this expression will be another container while this
 original container is left unmodified so this is just a mathematical kind
 of computation which no way to look at the mathematical equation like this
 we don't say oh was this X modified was this X modified when we did the
 cosine X was this X replaced by cosine X and then we know it wasn't mathematica
lly we never talked we never do this replacing value values our values we
 cannot replace y 100 by anything makes no sense and so let's not replace
 anything we just compute values so similarly here we just compute new values
 every time now imagine we have some kind of program like this we compute
 some functions we filter on some conditions we again compute some more
 functions again filter and some more conditions and finally we get some
 function of all these depending on all these values we computed and all
 these values computed here will be put into the final list and all the
 values that did not pass any of these tests will not be put into the final
 list so what do we expect to be true intuitively true about such programs
 for one thing for example here we have a condition depending on Y but Y
 is defined as f of X so if we put this f of X here instead of why we should
 be computing the same thing it's the same condition x goes over all elements
 in this list and Y is computed and then we check some condition we should
 be able to get the same result if we check this condition directly on f
 of X instead of Y and we should be able to do it first so the order should
 not matter them once we so once we write if p1 of f of X on this line instead
 of this and we write this on the next line instead of that's the way interchang
e these lines and replace Y by f of X it should be exactly the same thing
 because these are values that we computed and these are conditions we we
 evaluate if that were not true if somehow Scala compiled this to a different
 code it will be highly confusing you would not be able to simplify your
 program by substituting values into other places see it looks like Y is
 equal to f of X but then somehow you cannot substitute f of X here that
 will be highly confusing or you cannot first compute f of X in the condition
 and maybe you don't need Y then maybe the older rest doesn't really need
 Y you can simplify your program so you want to be able to do that to reason
 about your program like this here is my value let's substitute it in here
 instead maybe the program becomes simpler now it means we have this requirement
 for any program that has this kind of code must be equivalent to any program
 that that that has this kind of code notice the semicolons I put them here
 because Scala also allows you that syntax you can put this entire functor
 block on one line if you wish and separate the lines with semicolons but
 this might be harder to read it's up to up to you how to write the code
 with one line or with many lines the next requirement is found if we look
 at these two conditions intuitively first we check a 1 and we only pass
 those values that satisfy that first condition and we check the second
 condition only from those that pass the first condition we additionally
 take only those that pass the second condition so that should be equivalent
 to check in just one condition that is the conjunction of these two conditions
 that gives us the second requirement the third requirement is somewhat
 trivial if a predicate always returns true for all values of X for instance
 if this p1 were just identically true then we should remove we should be
 able to remove this check from the program because that should not affect
 at all what's happening if we remove it all the values will always pass
 to the next line and so that's the same as if this check wasn't there so
 that's our requirement 3 another final requirement quite important in fact
 is that remember what we had in our initial computation that the filter
 was for positive Y and then we took the square root of Y now if some Y
 were negative we shouldn't be doing square root of it so in other words
 we rely on the fact that only values that pass the filter will ever be
 used in further calculations after this if line just like we rely on this
 here with after the filter we relied on the fact that data that the node
 passed the filter will be emitted from any further calculation and so we
 formulate that as a requirement that when whenever a filter predicate P
 of X returns false for some value of X then that value of x will not be
 included in any computations performed after that line so that is our final
 condition so these are the four properties that functor block programs
 must satisfy let us now formulate these properties mathematically in fact
 it is very important that we can formulate these laws mathematically we
 it's not just talking about the program you know what you could change
 in the program without changing its result it's not just words we can actually
 write equations and check them to see that these conditions hold how do
 we do that for instance we write the first law like this we say whenever
 there is a function f and the filter condition P such as here the function
 f and the filter condition P then we look at how this part of the founder
 block program will be translated by skeleton pilot into the map and filter
 so this will be map F filter P and this will be filtered P of F map F in
 other words this will be compositions of the functions map F here is AF
 map because that's the right well type the flip map its argument is f so
 map F composed with filter P must be equal to filter of F composed with
 P which is this remind you that function composition works from left to
 right when you when you write it with this symbol F composed P but if you
 want to write specifically as code you must put the functions in the opposite
 order P of F because first YouTube f of X and then he applied P to the
 result and so that's first you took F and then the applied P and Scala
 there is an operation called and then on functions which does exactly this
 in Scala this code would be F and then P which is a nice and visual way
 of writing function composition notice here I did not write it here because
 this is actually going to be code but I could have written elsewhere and
 I will be writing this in the in the example code I'll be using and then
 so in other words the factor block program that has first a map step and
 then a filter step is equivalent to the factor block program that first
 has a filter step with this different condition as it is necessary as we
 were thinking here and then it has the map step now what does it mean to
 have one step of a functor block program remember how the functor block
 program is translated into maps and filters each line actually consists
 is replaced by a step so a function map or fill map with a function filter
 with a function and so on so instead of saying the functor block program
 remains the same when we do this and that with the line we say the map
 with this function would do the same with the functor value as a map with
 another function x filter with another function and so on so we actually
 say instead of saying the Thunderer block program remains the same when
 we change the number of lines or something we say the functor value itself
 the value of the sequence or the value of some other factor the factor
 value itself is transformed in the same way by a certain map and filter
 operation and that's what it is so f map f is a function that transforms
 the frontier value into another frontier value the filter p is a function
 that transforms a function value into another function value and so this
 law says that function values are transformed in the same way any function
 value whatever you want will be transformed in the same way by these two
 functions composed and also by these two functions composed if this is
 so then you can replace here this map filter with that filter map and for
 any functor value here and this could be actually a long funter program
 before that so this could be instead of just a simple sequence this could
 be sequence does map that map does filter those children map all inside
 this expression regardless of this the transformation by these two functions
 will be the same as the transformation by these two functions so it is
 in this way that we can stop talking about just replacing lines in code
 and start talking about mathematical functions and their equality that
 has a great advantage because first of all functions have types we can
 check the types are correct we can reason about functions with types much
 better second functions have values that we can check to be equal for all
 values of the argument this is what we have done before with the functor
 laws and we will do the same now with a filter laws so this was the first
 law the second law represents this condition the conjunction law by the
 way laws have names for convenience but actually there are just equations
 so the first law is called natural ality this comes from category theory
 and it's not important why it is called natural 'ti but basically whatever
 law you have that interchanges your interesting function with f map or
 map that's naturally G so typically that means you can map the contents
 of your container before your operation or you can map it after your operation
 and it's equivalent in some way so that's naturally naturality expresses
 the idea that you're manipulating data inside the factor in some way or
 inside a container and this manipulation preserves the data items it does
 not look into their details so when you map the data items from one type
 to another then your manipulation would be equivalent to some similar manipulat
ion followed by the transformation of the data items so for instance if
 the manipulation is to omit some elements and you can omit them before
 transformation or you can rip them sorry this is will be after you can
 read them before the transformation or you can omit them after the transformati
on if the condition is adjusted appropriately the result will be the same
 or this could be a transformation that somehow rearranges the order of
 elements or does some other such thing that does not actually look into
 the elements values themselves but just rearranges something about them
 it can emit them which can duplicate them and so on so all these transformation
s are called natural and so therefore this law of natural T is called let's
 look at the second law now the second law represents this requirement that
 if we have two conditions next to each other then we can replace them by
 a single condition that is the conjunction of these two mathematically
 we can say that the filter transformation so think about filter P as a
 single symbol just like F map F is a single value that transforms the functor
 values FA to FB so filter filter P transforms FA 2 FA so this is a transformati
on of theta FA composed with another transformation of FA 2 FA and they
 must be equivalent to a filter transformation again FA 2 FA when the predicate
 is equal to the conjunction of these two predicates so I have written down
 the mathematical conjunction but of course in Scala code there will be
 just the double ampersand boolean conjunction so that's the second law
 the third law is that if the condition is identically true it returns true
 for all X then the transformation that the filter on the functor is identity
 does not change the function value at all and if this is so then whenever
 you have a filter with identity function you know that whatever was before
 is going to be identically preserved by that kind of filter so you can
 just you delete that operation and that would correspond here to deleting
 this line if this were an identically true condition so in this way you
 see how mathematical laws actually represent a general way of manipulating
 code and the fourth law is a little more complicated to formulate so filter
 P and followed by some map that's we're trying to describe what it means
 that X will be excluded from computations performed after this if so we
 need to put some computation after this if let's call it let's say this
 is a computation that is transforming by F it could be a filter right so
 we have a filter or F map as possible computations but we already have
 a law for what happens when we have a filter followed by a filter so now
 we have a law about what happens when we have a filter followed by F map
 so this computation F should not see any values X for which PA will return
 false how do we express that but F should not see those memories a good
 way to express that is to use a partial function instead of F I denoted
 it like this so F barque is a partial function that is only defined for
 those X for which the condition P holds in Scala this could be written
 like this it's a case expression with the condition and if the condition
 is true we just return f of X so we don't change the function f but now
 if the condition is not true this partial function fails it will it will
 be a runtime exception if we apply this partial function to value X for
 which P of X does not hold so the filter guarantees however that all further
 computations will never see such X for which P of X does not hold and so
 therefore it should be safe for us to use that partial function here after
 the filter so the filter transforms FA to FA look at this type signature
 again filter P so we put the first argument and the result is a function
 from a fatal funny so filter will transform a fading in such a way that
 the values that are left in it will always pass the condition P and so
 it is safe to apply a partial function not only it is safe but it will
 give the same result because the partial function is made out of the function
 f unmodified so therefore we have this law that filter followed by MANET
 should be the same as filter followed by a partial function map and it
 should be safe and it should give the same result so that is well because
 it is safe mathematically we don't know how to express that we just say
 it needs to give the same result if it always gives the same result for
 any functor values that you put into this transformation then you are safe
 so here are the four laws and we can define a typeclass let's call it filterabl
e and the typeclass will have a method with filter which will be a partial
 type 2 value function and this function must satisfy these laws together
 with F map so we cannot really define filterable without also defining
 map for this type so this partial type 2 value function must be defined
 in such a way that it requires already the functor typeclass as a constraint
 so it is only defined for types 4 for type constructors that are functors
 and so then for those we already have F map with the correct laws so those
 are necessary for filter so filter is a further property of a functor so
 we can say it's a filterable functor so let us see if the laws hold for
 the functor example that we have the orders but with Tuesday and Friday
 we will also look at some examples of the filter block program notation
 so before we return to the orders example let's refresh the filter block
 notation so here are some examples we take integers from 1 to 10 we perform
 some calculation with them so there's this Y will be I computed for each
 of these axes then we impose the condition that y is negative and only
 for those Y's we continue so then Z is computed then we impose another
 condition of Z and then we can get something else but actually we don't
 use this P and that's fine and then we return a tuple we don't actually
 return a tuple we return a sequence of these tuples the yield is not the
 final result of this entire factor block the yield is the result of a single
 computation for a single data item inside the factor or if you wish the
 container of data so now I'm showing some transformations that you can
 make so for instance here instead of saying if Z is less than 100 on line
 86 I'm saying on line 96 if this entire expression is less than 100 and
 then I compute Z later and that gives the same result and also instead
 of doing P equals Z minus X which I'm not actually using so I could actually
 should actually delete this from the code I use P here and that's exactly
 the same so you can put more computations into the yield part of the block
 or fewer computations you can put some of them here it's entirely equivalent
 and the only consideration here is readability how easy it is to read the
 code and understand what it should do also I can mathematically express
 this condition as a condition on Y is that absolute value of y must be
 less than the square root of 100 minus six and together gives the same
 result so I can transform these conditions in any way I want and the results
 are the same and finally I merge these two conditions for y into one condition
 using the conjunction law and again the results are the same so this is
 the test not very far yet so this isn't this is the way that we expect
 the program to behave we expect to be able to simplify the program in certain
 ways so that for instance here we notice we compute this expression twice
 let's not do it let's compute it here first as Z and then use it that's
 a typical transformation of a program that the programmer would do so we
 see that the naturality law the first law of filter guarantees that this
 program transformation is valid it does not change the result what a surprise
 it would be if that were not true a programmer would look for a button
 for a very long time and this is because reasoning about the program has
 become broken if you break the laws of the filter so it becomes impossible
 to reason about the program by looking at the code we should avoid that
 at all costs breaking mathematical laws is something that has real costs
 that has real consequences makes our life much harder so now let's see
 if these laws hold for the orders example to do that we define the typeclass
 instance in the example code I have defined typeclass called filterable
 with filter I have not found a standard filterable typeclass in libraries
 either in the cats or in the Scala z library so I defined my own it's just
 a few lines of code to do that [Music] we'll see how that is defined it's
 using an abstract class with an implicit function value which means that
 you cannot create instances of this abstract class without having a functor
 instance for your type constructor f so in this way I enforce that filterable
 here must be already a factor and then it has this method which is in the
 way I implemented the partial type T value function so I define the partial
 type to type function and a partial type to value function the other typeclass
 is just called filterable not filter ball with filter and it does not define
 a function with filter it defines a function called flatten so this we'll
 be talking about in the second part of this tutorial so now we only look
 at filter and it's its properties in order to define typeclass instance
 for orders so that we you find a partial type 2 type function extending
 it to orders we need to define this and override the function with filter
 and also we need to have a functor instance for orders until we have that
 this wouldn't compile so we need to have the functor instance well a functor
 instance for orders is the straightforward thing orders is a simple conjunction
 type option times option so the cats library has an extension that derives
 such functor instances for case classes so I'm just going to use it very
 convenient very little typing when it works we'll see cases when it doesn't
 work so we first define a functor instance and then a filterable instance
 so how do we define the federal instance we just override the function
 with filter in the class and this is the exactly exactly the same code
 as we had in our first example we filter the first option we filter in
 the second option and notice that this is a standard library function on
 options so this is not the function I am defining this is not really recursive
 in any way this is a standard library function already defined on option
 and very easy one to implement so then I check the laws now I have implemented
 this law checking helper just as I did with factors so let's look at how
 it's implemented so it has a bunch of arbitrary values as at once and then
 for all these values I will check the laws so the first law is that map
 followed by filter is the same as filter followed by map the only thing
 is that the filter needs to have a different function type so this is a
 2 B this is B 2 boolean and this is a to be B to boolean so this entire
 thing is a tubulin so then it is filter of a and then a to B so first you
 map filter than you filter map and that should have equal values the conjunctio
n law is that we do a filter not filter and that's the same as filter with
 this function the identity law is that you do a filter with something that's
 identically true and that should be exactly the same as what you started
 with so in all these examples I have an arbitrary value of the function
 and I check that for an arbitrary value of the funder these transformations
 are equivalent give the same values so for this I need to be able to compare
 values of the factors so learn in this extra function compare for equality
 of the funder this is very similar to what I did in the factor that class
 they finalized the partial function law for which we savings the filter
 P and then map F and then we do a filter P and then we map using this partial
 function which is f except that it's only defined for those X for which
 P of X is true so here are the four laws naturality sometimes called permit
 Rissa t but let's avoid the mumbo-jumbo and not reality is not mumbo-jumbo
 because it's natural so conjunction law identity law and partial function
 law so this test passes so the laws hold for this order's functor with
 this type cons instance now notice in this test i define the functor instance
 outside the test but the filter will instance inside so that i can define
 different filterable instances in different tests and that's what I will
 do I will first vary for example 1 which is this straightforward filtering
 here's how it works so we can use it in the filter in the filter block
 notation data is this orders of some orders of 500 and 2,000 so X is compared
 with 1000 which is our approval criterion and then we transform to a string
 and the result is the orders of transformed and they're printed more nicely
 and this second order was not approved so the first order was approved
 the second example is the orders with business rule a and orders with business
 rule a is this more complicated code that we saw before again we check
 the laws and notice we define a different filterable instance and so this
 checking is with a different instance and exactly the same function block
 code returns now empty orders because for business rule a both orders need
 to be approved for any of them to be placed and so exactly the same function
 block code now gives a different result because we define the filterable
 instance differently and interestingly the example 2 B does not work that
 it breaks the function or sorry the filterable law it does not break the
 function but still factor it breaks the filter rule law and so this fails
 and actually there is specific data that shows it to fail and also it fails
 a partial function law and so we will look at it why why that happens for
 now let's look at this well actually that's what's finished with the orders
 why does the law break it's an interesting consideration so if we filter
 with one filter and then it was another filter that should be equal to
 the filtering with a conjunction now in this example I chose the two conditions
 so that their conjunction always returns folks so we should be having an
 empty container after this however in the data one of the orders is below
 and one is above thousand and so the business rule to be says that both
 orders can be placed if if at least one can be approved and so then after
 the first filter both orders are still placed and I laughter the second
 filter also both holders can be placed however if we filter with the condition
 that no orders pass then we get an empty order so that's not the same and
 also breaks the partial function law we filter with a condition and we
 use the function that is only defined when that condition holds and we
 have an exception at runtime so what happens here is that it's counterintuitive
 we thought we would limit computations to these eggs but actually we have
 not limited them to that to the next mm is still there so reasoning about
 a program that uses this filter implementation would break our intuition
 about what the filter should do and that's why this is not a good filterable
 implementation so business rule to be is not filterable [Music] so now
 consider the example of this factor it is a disjunction that has either
 no data items or two data items so it's a product or nothing how can we
 implement it as a filterable so I call this a collapsible product for reasons
 we'll we'll see momentarily well we first derive a functor for it so the
 type isn't just an option of tuple a a which is this type now how do we
 define filter for it well let's write this function so we have F a of type
 option to pull a a and we have a filter function so now option to call
 a a has two cases in the disjunction first as its non-empty with some values
 X and one now what can we do we must apply the filter to both of them because
 if we don't go fail some of the laws as we just saw with the business rule
 to be example when we don't apply the filter to some of the values then
 partial functions will fail and conjunctions may also feel so now if we
 apply to X and we also applied to Y what if one of them passes and the
 other does not what we can we have to exclude the one that did not pass
 but our type has a disjunction that has only two parts one must have two
 and the other is empty so if X passes and why does not pass we cannot retain
 Y we could retain X if we had any way of retaining X but we need a we need
 a two value so we cannot just put X here we need another value we could
 put X twice I'm not sure that would be a good idea though it doesn't feel
 right it probably will violate some law if you do that it feels wrong but
 you duplicate values it will be I have not checked it so you're welcome
 to check if the laws hold with that implementation but the most reasonable
 implementation is that if none of them if if only one of them passes we
 need to remove both so we get the empty container so that's how it's implemente
d so only if both x and y passes the test the container is unchanged I just
 write FA just to save typing sum of X Y again and it's faster otherwise
 we return empty container so laws hold I checked the laws with different
 types just to be sure now as a reminder this function takes type parameters
 so that it cannot just check laws with all types at once it's impossible
 you have to give specific types on which you would check the laws so transform
 from int to strain to something that need to be specified so let's look
 now at examples of functors that are not filterable so we have seen that
 orders with business you'll be or break laws it actually breaks law for
 as well now another example of a function that is not filterable is a function
 that defines filter in a special way for certain types for example for
 into type it defines the filter function in one way and for all other types
 in a different way so that is not natural the filter should not look at
 types it should manipulate data without regard of its type so this type
 a should be unknown type and should not check that it is integer or something
 else so it actually breaks slower so let's look at how that works so here
 is this factor a zero which is just an option and I'm going to define a
 filterable instance where I define a filter not in the way that usual option
 is defined in the filter I will first check if the type is integer if the
 type is integer then I'm going to check the condition if the condition
 passes I do whatever what was before I return the same value if the condition
 does not pass then I return zero so this is actually zero so I especially
 prepared this so if the type is integer and the filter fails I replace
 the integer by zero that's a special rule that's only used for integer
 for all other types i do the standard thing and filter on an option in
 the standard way so this kind of thing is an incorrect implementation of
 filter because it is not natural in the type it is using some information
 about the type that is not parametric and what happens is that as long
 as you don't try to use the integer type then you are in this second case
 and it's all right it's it's it's correct but once you start using the
 integer type then naturality law fails and if you uncomment this test and
 run it it won't tell you that it failed in the natural tool and here's
 a counter example that breaks naturality law we say this data is some zero
 subtract one and check that it is greater than zero and another way is
 to check first that X minus 1 is greater than zero which is the same right
 y is equal to X minus 1 so I could put this X minus 1 in here which I did
 and put the condition first and that should be the same it doesn't matter
 if I first check the condition and then compute X minus 1 or if I first
 come to the X minus 1 and then check the same condition but the results
 are not the same so actually the first result is not equal to the second
 one the second result is not empty the first result is empty so that is
 a clear violation of the naturality law so this is this shows you that
 we are trying to reason about the program and we refactored the program
 in some way and the results changed this kind of bug would be very hard
 to find you refactor your program and results change example is this factor
 1 plus a where the filter is defined so that it always returns 1 plus 0
 now 1 plus 0 is my short notation for this part of the disjunction so it's
 only the unit so 1 plus a is option of a and 1 plus 0 would mean none so
 you always return none part of the disjunction now if you do that here
 is our implementation so the filter always returns none that breaks the
 identity law if filter with true and it's not the same because it always
 returns none so if you did not have none to begin with you get none and
 that's regardless of what you filter so even if you filter with the true
 that's still none so that breaks like the identity oh yeah there were 3
 so these are so far wrong implementations of filter this is the notion
 type as we know it has a good implementation of photo so now the last two
 examples are functors that cannot have an implementation of filter they
 are not filterable so let's see how that works the first is the identity
 function it's not filterable identity factor needs to implement filter
 but how can we implement filter well we get a value a and we need to return
 let me let me just you bring then use two penny for clarity we get the
 value of type a and we need to filter now if the condition does not pass
 there is nothing for us to do except still to return the same value so
 we cannot actually apply the filter there's nothing we could do if the
 filter were to return false there's nothing we can do we must return the
 value of type a and so we return the identity so basically this is a filter
 that always returns identity does not ever filter out anything and that
 breaks the partial function law because it does not filter out anything
 and so we rely on filtering out certain values and that expectation is
 broken so here's an example we have some data with a negative number we
 filter by positive we take square roots and we expect that everything is
 fine but actually the result is this not a number because square root of
 a negative number is not a number and so our expectation is broken and
 the second example is this factor is a product of a and 1 plus a now one
 plus a is option a is the identity factor so it's a product of two factors
 one of them is not filter what we just saw the other is filterable it turns
 out that the product is still not filterable so why is that well a very
 similar reason we have a value of type T and the value of type option T
 if this value does not pass the we need to remove it somehow from the container
 but we can't the container always must have a value here it's a product
 so it requires both parts and so it always must have a value of type T
 here we can not remove it so let's suppose this were some value and this
 were an empty option so this one none the only way we could filter this
 is to retain this value X and that's the same problem as we had with the
 identity function if we do not filter out values that don't pass the test
 when we violate the partial function law so this is exactly the same test
 as before we violate the partial function law so to summarize this these
 laws one to four these are equation laws with in other words these are
 equations for functions there are not just some kind of vague descriptions
 of what we do with the code these are actually mathematical equations for
 functions that can be proved to hold or not to hold and these equations
 rigorously specify what it means to filter data in the container so we
 have derived these four equations from our intuitions about what a filter
 should do now we will only use these equations we will not need to do any
 more intuitive reasoning we're now on solid ground and we will derive there
 is functors filter ball or not filterable in these worked examples in the
 first example john has up to three coupons and Jill after two coupons all
 the John's coupons must be valid but each of jewels coupons is going to
 be checked independently why is this even described by a functor we need
 to abstract the problem from details and see how we can represent this
 as a functor and then we will see what is the filterable factor first of
 all to represent this as a factor we need to have a tight constructor so
 what is a type parameter more clearly the type of coupons the factor is
 going to be the container with all the coupons the type of the data that
 coupons represent is going to be a parameter so we are going to abstract
 away a specific type of the coupon data so then we have a container that
 has two parts so it's a conjunction one part is John's coupons and other
 part is juice coupons and the first part will be itself a disjunction because
 it can have zero one two or three coupons the second part zero one or two
 so once we reformulate the situation in this way it is clear that it is
 represented by a factor and then the conditions of coupon being valid is
 an arbitrary condition which is a predicate a function from coupon type
 to believe and we are going to filter our container using that condition
 and the result will be a container having all valid coupons according to
 the logic defined here so the first thing I would do is to write the type
 in a short notation then I can have a bird's-eye view of the data so the
 type is a conjunction of two parts Jones coupons is a disjunction of unit
 one coupon two coupons three coupons and each group one is represented
 by a data item of type a joke just coupons is a disjunction of 0 coupons
 one coupon and two coupons so now we can implement this in a standard way
 using sealed trades and case closes so for convenience we first implement
 the left part of the disjunction and the right part of the disjunction
 ah sorry of the conjunction and so at the end we'll have the functor coupons
 which is the conjunction of jones coupons and jones coupons as before we
 need to define the factory instance so we use automatic derivation for
 functor instance now it remains to implement in a filterable so the logic
 is that first of all jones coupons and jost coupons are validated independently
 so jones are independent from Jules for John there is one kind of logic
 and for Jo there's another kind of logic so what is it for Jones well if
 there is any number of coupons there could be none and then we don't have
 to filter anything there is any number of coupons then all of them must
 be valid by the filter condition and then we retain them otherwise we discard
 them so logic is that if John has no coupons then we return again in no
 coupon situation if there's one coupon and the condition is valid then
 the coupon is retained otherwise we return the empty situation if there
 are two coupons then both must be valid and then we retain both of them
 otherwise we return the empty situation again similarly for three coupons
 so that's the logic for John's coupons and for dos 2.0 logic has just examined
 each coupon separately so there's one we keep one if there are two we see
 which one returns true so we use this matching on pair so we compute a
 pair of two boolean values corresponding to whether the filter results
 are true or false for c1 and c2 which are the two coupons of jill's and
 then we match at the same time on both values of the pair so that it makes
 the code a little more clear and readable so we have just four situations
 and way you turn one coupon or two coupons or zero coupons so finally having
 computed the new filtered John's coupons and filtered jos coupons we put
 them into the coupons let's class into the conjunction and that's our result
 so now here is some test data there are two coupons each for John and Jill
 but the condition is that the value must be above 150 and so for John one
 of them is below and so none of his coupons are valid for Jill one of the
 coupons is valid and then this Thunder block will transform the coupon
 value into a string and so we see that John's coupons are all gone they're
 not valid because one of them is not valid but Jill's coupons have been
 filtered differently so the valid coupon is retained and there is a Jill
 one disjunction part so that's how we can implement the situation and this
 is indeed a filterable factor which we can check automatically by a helper
 function that checks the laws the second example is that we imagine that
 there is the server that receives a sequence of requests and each request
 must be authenticated now there's a special logic that once an own authenticate
d request is found the server accepts no further requests how shall we describe
 this with a functor and how shall we make that function filterable if possible
 so the server is representing a sequence of requests so let's first of
 all generalize the request type to R so we have done a sequence of our
 as requests we make the functor instance for the server and that doesn't
 seem to work with automatic generation so we just do the met by hand this
 is not a lot of code the server is just a sequence wrapped in a case class
 so we just need to call me up on the sequence so how do we implement filterable
 so we need to take requests one by one until we find a request that is
 not not authenticated so we abstract the condition for being authenticated
 as a predicate that goes from a to boolean and then we use the function
 take while which is the standard library function defined on sequences
 and this will take the initial part of the sequence until while the predicate
 is true on the well on elements of the sequence until we find an element
 that fails the predicate or until the sequence is over so we compute that
 sequence and though so we have the resulting instance testing this we do
 using this test data so let's say the condition for acceptance would be
 that the square of the number is less than 1000 and so then only the first
 three numbers satisfy now I could actually put a zero here and it still
 would just be the first three because after this the take wire will stop
 taking illness once one element was found to fail the condition and so
 this logic is now encapsulated by this code you see in this code I do not
 mention this logic that the server should take sequence and so on it looks
 like I am just processing elements one by one for each X in the container
 compute this and check this condition and then compute this so this code
 describes what I compute and the logic about how elements are retained
 or emitted from the container is encapsulated in the filterable in instance
 that we defined over there and as usual we check the laws of the filterable
 the other examples already start with a tight data type in the first two
 examples I showed how you can stake a real world situation and convert
 it into a factor with a filterable instance so this should help us to learn
 to recognize such situations in real life and make code so that the logic
 of filtering is separate from the logic of checking data data for conditions
 well so the filter by instance helps us separate such situations in three
 parts first part is the data type privet which is completely freed data
 it's a type parameter so we can we will separate all knowledge about the
 data type into a different part of the code second is the predicates in
 which we filter so the specific logic for checking valid coupons or authenticat
ing requests so that's a function from this data type to boolean so again
 this is implemented in a different part of the code and the third part
 into which we split the code is the filtering logic which is which elements
 are retained and which elements are emitted under what condition so the
 condition is already given but then for instance for John all coupons must
 be must be valid for Jill they're all independent and for the server the
 initial subsequence must be all valid and so on so that logic is what the
 filter will instance implements so by recognizing these situations and
 structuring the code in this way we separate concerns and so in the following
 examples we assume that the first two logical steps have been made and
 we already have a data type and it only remains to see if that data type
 is filterable and if so to implement the filterable instance the first
 example is this case class which is written here so the first step for
 me would be to write this in a short notation because then I can see much
 more clearly how to implement anything with it so the short notation would
 be this so there's an option and conjunction or product with an optional
 tuple so now I'm this type that I see it's a product so I can filter this
 because this is an option and I can filter this because we just had this
 example this was the collapsing product example I can filter both of them
 so most likely I can easily filter the product by just filtering the two
 parts so let's see how that works by actually declaring separately the
 filter both instances for the two parts of the product and then combining
 them so the first type would be optionally in a second would be option
 of two point a so that's the first type the first the part of the conjunction
 and the second part in the conjunction so they functor value needs a functor
 instance needs to be defined so we use a giraffe for that and the filter
 will instance needs three defines our we define these functions in the
 usual way so that i just wrote out here the code which would be exactly
 the same as a filter clean but just for clarity and to illustrate what
 exactly is doing this is the code so the option is standard filter instance
 for option f is non-empty we need to check the condition for for the value
 that's in it and if the condition holds then we return the non-empty option
 as it was so unchanged in all other cases either it was empty or it is
 not empty but the predicate does not hold we return empty option the second
 factor is the option of a tuple and here we did what we did before if both
 conditions are valid we return unchanged otherwise return none so either
 we had an empty option here or we had a non empty option but one of these
 conditions failed so then we return empty ocean so now we have defined
 two filterable instances for the two parts of the conjunction let's now
 define the total instance for [Music] the conjunction itself so as of this
 class p that is defined here and all we need to do so again we derive the
 function automatically all we need to do really is to take the two parts
 of the conjunction and filter them separately now just to note this detail
 of the syntax of dot filter is available because of this typeclass so the
 first is of type F one of a so it's some kind of function second a subtype
 of two away it's another kind of function that we defined these factors
 do not by themselves automatically get a dot filter method so this method
 as a syntax appears once you define the class at the typeclass of filter
 ball and then in the imports at the top of this test file you look at the
 imports I have imports filterable so the filterable is the object filterable
 underscore so the filterable is the object that contains all the syntax
 for the factory and sorry for the filter multi class so this is the way
 that it is defined which we already saw in the previous tutorial so let
 me just go very quickly over it the filter syntax is defined when we have
 already with filter then we defined also a filter isn't an alias to with
 filter and we also define other functions which I will talk about later
 but this is this implicit class that converts your factor into something
 that has this syntax this is a pure syntax extension which does not change
 the code we could have used the different syntax we could have said yet
 the evidence value for this partial function and the evidence value contains
 the filter call that so that will be just less readable using that syntax
 we have this more readable style of dot something dot something does something
 which is easier to read so now we can check the laws for the P using these
 definitions so you see it's very easy to derive filter instances if from
 parts that already have filter instances and we will look at it in more
 detail later the next example is this type now if you look at this type
 its int + int here and also in so each part of the disjunction has an int
 so we could factorize it out like in ordinary algebra with types and we
 have int times 1 plus a plus a na plus a a in we could have done this like
 that and then we already have a filterable instance for this cut type because
 this is John's coupons in their previous examples we already have an implementa
tion of this type so we could just leave the integer unchanged under filter
 filter this and we're done now the other implementation is possible and
 valid there's another implementation that's perhaps more interesting because
 it keeps information about what filters what items were filtered out and
 it gives you no trivial information in these integer values yet it's still
 consistent with the laws so let's see what we want to do well so let's
 look at this type what we're given suppose that we are in this part of
 the disjunction so we are given a value which is in this part of the disjunctio
n then we filter something and we have one of the data items not passing
 the test so two of them are left well clearly we have an int we have two
 data items so we should be in this part of a disjunction so we will move
 data over here and in this way we implement that's how we did in the Jones
 example Jones good but we can also add one to the integer value here to
 show that we have emitted one data item so more generally this type allows
 us to implement a filter in such a way that whenever we emit some data
 items we can add the number of these items to the integer value and in
 this way we will in some sense keep track of how much we have lost so how
 many have been filtered out this could have been this could be an interesting
 implementation for certain cases maybe so let's see how it works so we
 implement first of all this type as a sealed trait with four case classes
 sorts of disjunction with four parts so this part will be just the integer
 this part has one item two items three items implemented functor instance
 now we implement the filtering so how we do this well actually this is
 a bit complicated because of all the different cases that can help so in
 order to simplify the code I implemented the ad function from list that
 converts a list of a into this leader structure and a list of a should
 be at most a length three so this function takes an integer and takes a
 list away and then it implements it finds out how many elements are in
 the list and notice this thing it adds to the integer the number corresponding
 to how many elements were not in the list so now I'm using this function
 and implement the filter so if I have zero elements I returns in your elements
 nothing to filter if I have one element I check the condition and if it
 passes I return unchanged otherwise I return the zero elements but I increment
 the end showing that I have emitted one element and similarly for all the
 other cases I filter but then I put the new integer into the data items
 in other words that's what I implemented so here's here's an example so
 I have it initially three elements with integer equal to zero and I have
 a condition that the string has length less than for only two elements
 sorry only one element passes that test and so this code will give me a
 list of one a one with a value Firefox and the integer value too so that
 was here so L plus two and plus two in other words I know that after filtering
 this is the result of Firefox went to items were filtered out so in this
 way I can implement more interesting logic and and keeping track of how
 many items were deleted because I have the integer value in the types so
 that's an integer that's so interesting presentation of the filter and
 I can of course check I should check that laws hold in fact if I changed
 anything here if I put n plus three here for example instead of n plus
 one the laws would not hold why is that because for example we have a conjuncti
on law or the filter by one condition and then filter by another condition
 the result must be equal to the filtering by and junction of the conditions
 so the keeping track of how many elements were deleted must be consistent
 it must actually keep track of the number of elements deleted because only
 that will satisfy the conjunction law if you first delete one element then
 you delete two more elements then it should be the same as if you deleted
 three elements and right away and so the integer must reflect that so if
 the integer does not reflect that you will violate one of the laws the
 next example is the functor which is non empty list it's a recursive function
 defined like this so it's type F is defined as a disjunction of a or a
 times F so it can be a or it can be a times a or it can be any times a
 times a and so on so it's a list that has always at least one element is
 just like a list except it does not have the unit it cannot be empty so
 actually this cannot be filtered law the intuitive reason for this is that
 the empty container cannot be represented so this disjunction [Music] as
 this form a plus a times a plus a times a times a and so on and all the
 parts of the disjunction have at least one item of type a and so if let's
 say the filter condition were identically false we should have excluded
 all data items but we cannot because there is no part of a disjunction
 that represent in all data items there must be at least one somewhere so
 if we had a functor like this you'll find recursively like this or in some
 other way with a 1 plus something so if we had the unit as one part of
 the disjunction then we would be able to represent the empty container
 using that part of the disjunction but now we we can't so let's see how
 that works so we can certainly write down the factor a functor instance
 is fine and we can try dividing a filterable instance but we will fail
 the laws and the reason is when we do this case so how do we define the
 recursive first of all how do we define recursive filter for instance we
 use this function with filtering recursively so there are two cases for
 the disjunction one case is the one in this case we just have no choice
 except to return the same value because there's no way to represent anything
 else we cannot represent empty now the recursive case with tail we again
 we don't do anything with the hell because well we we could actually they
 wouldn't help us by we could we couldn't actually filter the hill it's
 not true there's no way to point a filter at your hand let's apply it I'll
 still fail of course because if this one is wrong we should have used the
 filter here as well we can't there's no way to present absence the absence
 of data but let's try as hard as we can so what do we do with the head
 well we need to check whether the predicate is true on the head if if so
 then we can return this otherwise what if the predicate is wrong is false
 only head well we don't have this a so we omit it we still have FFA we
 can filter F of n notice we are returning this part after filter so we
 can omit that and we return F of a which is the tail which is off of the
 same type non-empty list already and that's fine because it's recursive
 type so this type is the same as the entire type it's recursively the same
 so we can return a value of this type of a way taking as a tail so we can
 return tail organ return filter detail it will be of the right type so
 this is the best we can do to implement filter law but that actually won't
 help us if we are we see what happens here well I'm just ingest all the
 tests so we could filter on this so how would that work this is an instance
 of the non-empty list with two elements both negative and we want to filter
 with a positive condition and then we take a square root so according to
 the logic of what the filter should do let's reveal an empty container
 because none of that one should pass the test so we should never can compute
 any square roots in this calculation but this is not what happens because
 the filter is wrong so the first one is filtered so we were here P hat
 is false so we're in this case so we return the filter on recursive so
 this is a recursive invocation of the seen function with the filter we
 returned the recursive invocation on this then we are in this case where
 we must return the same thing since there's no other way to do anything
 there's nothing else that we can return so as a result the square root
 will be applied to minus 100 so this would be emitted but this would not
 be emitted so in other words this filter fails to filter out some of the
 data and that's why it's wrong it's not going to satisfy laws and it's
 not filterable so in fact it is impossible to implement the filter function
 correctly it's not just that we didn't manage it's actually impossible
 in this second part of the tutorial we will see why the next example is
 this factor which has two type parameters but we are interested in the
 type parameter a so there's a Z or there is an integer Z a and a so how
 do we filter that I certainly it's a functor its covariant in a but how
 do we filter so in order to understand how we will filter this I look at
 the type in this notation and I imagine well it would be if one of these
 failed the filter well if if no element fails the filter I know what to
 do I just return the same continue so the only question is what happens
 when some elements fail the filter condition and so then let's say this
 one fails and let's say this one passes so I have to exclude this one but
 and what can I return like I must return one of these two parts of the
 disjunction I cannot return this part well I could I could duplicate this
 value it's probably not very interesting but I might want to do this in
 some cases I shall return this perhaps well it's more logical right you
 have fewer data items after filtering if you duplicate then you don't represent
 the fact that you have fewer data items and maybe it is better to try to
 represent that fact if you can and here we can so we can actually return
 Z we had a Z already we can just return it we don't need to change it in
 any way we just return it and so in this way we will be representing a
 collapsible filter collapsible product so if at least one of them fails
 then both will be filtered out and will have this value which will we will
 use to represent an empty container now this value is not going to be just
 one value like a unit if it's some type Z and we don't know what that type
 is but having that part of the disjunction will represent an empty container
 doesn't have any ace in it it has a Z in it but that's not what we were
 filtering we're filtering AIDS so this is totally fine to represent an
 empty container and notice we can only return the Z because we already
 had a Z in this part of the disjunction so in this part we already had
 a Z if we didn't for instance if we had this type then there's no way for
 us to return a Z when these two fail all the tests we have an int we have
 an A but we need to return a Z we can't and so this factor is not filterable
 with respect to a so just to show you that it's important that in this
 function there is a Z here and the Z here all right let's implement so
 we will just write it short without we don't need to have sealed traits
 here just right on either of Z and this conjunction or the product or the
 tuple the same thing so either of Z and tuple these things is the type
 now we have a type constructor with two parameters and we only are interested
 in a factor with respect to one parameter so we need to use the type lambda
 or anonymous type function which is written like this I'm using that projector
 plug in the kind projector plug-in so this syntax means take this type
 constructor fix Z consider the second type parameter as unknown and the
 result is a type constructor which still waits for a type parameter to
 be given and that's our type constructor so that's the syntax equivalent
 syntax is let's say we could say lambda X going to f of Z X so the capital
 lambda introduces a type function and so the type function is taking the
 type X and returning this type so this type function is an anonymous type
 expression that is unnamed type expression it represents a type function
 a functional type level takes one type argument and returns a type so just
 like our anonymous functions are called lambdas anonymous type functions
 are called type lambdas what the type lambda represents would be something
 like this if we could write it with which we can note for example Q of
 x equals F of G of X now if Z were not a type parameter but a type that
 is already fixed somewhere we could write this and then Q would be a type
 function that we want but in this situation we cannot write that because
 Z is not a fixed type C is a type parameter so we must put Z here which
 defeats the purpose we want a type constructor with a single type parameter
 we want to fix the Z type parameter in F and we want the result to be type
 constructor with a single undetermined type parameter so that's what type
 lambda does so this syntax does not work an alternative faster syntax for
 this is that so this is a tentative syntax that works and let me just for
 reference show what it would be in ordinary functions so we had an ordinary
 function let's say f of X we want to define a function that fixes the value
 of Z and only considers X as an argument so we want a function with one
 argument which is f of X but we don't have a Z to do that Z is not available
 in this scope so we cannot do that so instead we write an anonymous function
 such as X going to f of Z X so in an expression where Z is which is known
 this this can be done so we don't need a name Q for this function it's
 an anonymous function so this is exactly equivalent and the Scala syntax
 for this can be shorter we might list and so see the syntax of the kind
 projector podían was designed to resemble the ordinary Scala syntax for
 anonymous functions were lambdas to give you an honest type functions for
 type lambdas so this wasn't aggression just explain what is it going to
 have a type London so we need to use the type lambdas unfortunately the
 cats derive library does not work with type lambdas and so that doesn't
 compile our no matter we implemented by hand so we write a functor instance
 by hand then we can use the carry Harvard library to implement the actual
 map function and that works here so anyway we can save typing we should
 now the filterable instance needs to be implemented and so let's go back
 to our type so we have a disjunction we have two parts of the disjunction
 if the if we are in this part there is nothing to filter because we don't
 have any age if we end in this part we need to see if both of them pass
 the filter and only in that case we return in the container unchanged otherwise
 we return to Z which was this one this is e so let's implement this logic
 if we're in the left we just returned the container and changed if we're
 in the right we have an N Z X and y if both of them can pass the test both
 of the x and y chat x and y are tied a z is of type Z and n is integer
 we don't use the integer we discard it if we're in the case that at least
 one of them fails if we're on the kit in the case that both of them passed
 and we return FA which is the original value unchanged so actually we could
 replace these unused variables you see now unused intellij underlines them
 within gray you can replace them with underscores which is a shorthand
 for saying that this is a pattern that we don't need to name it should
 just match and whatever is there we don't need that's usual way of doing
 this so then we check the filterable laws with this factor and that works
 so we can put a type lambda as a type parameter that works however we need
 to put specific types in terms of bullying or integer or string or something
 otherwise there's no way to run any code actually if your types are not
 specified the next example is this functor which is a disjunction of several
 parts and one of them includes a list so for the list we're just going
 to use the standard filter instance so a filter function on the list I'm
 not going to reinvent that or implement that in any other way we're just
 interested in finding out how we could implement filter on this kind of
 thing we're interested in these parts what a list is already standard we
 know how to filter list although of course there are more than one way
 of filtering lists but that's not the point of this exercise so here's
 this factor we define it as the sealed trade with three is Junction cases
 so empty have Z and have list there's standard way in which we implement
 these junctions in Scala now unfortunately we cannot implement functor
 automatically because cats derive doesn't work with type lambdas and carry
 Hubbard's implement does not work with list being a fun tree doesn't know
 how to do function list and cannot derive it either because it's a recursive
 type that is not yet supported by this library so we need to implement
 for instance ourselves which is which is not a lot of work if it's empty
 then it's empty and we just whatever should be mapped whatever part is
 mapped is mapped so as we have seen in Chapter four hunters are relatively
 straightforward to implement so if you build a functor out of parts then
 if you know how to implement functor for the parts then you're easily implement
ed for the entire type and that's what we have here so how do we implement
 filterable well we have again got to look at the type if we're in this
 disjunction part or in this part there is nothing to filter no ace and
 so we just return them unchanged always a good idea to return unchanged
 if there's nothing to filter in this way and we could always return one
 of course the unit but then we would lose information so if we are in this
 part of the disjunction we don't want to lose that information when we're
 filtered so we shouldn't in return one actually that would violate the
 identity law if we're filtering with a predicate that's identically true
 we should not change the value and so if we're in here there's nothing
 to filter and that's exactly the same as if we're filtering with something
 that's identically true and so we should not change the value so that means
 in all other cases except the case of have lists we should just return
 the unchanged value now if we are in the have list case which is that we're
 in this case then obviously in truth stay unchanged now we need to check
 if this a is passing the test and we also need to use filter on this so
 we filter this we will get another list that's fine but what if this a
 does not pass well we cannot then return this part of the disjunction because
 we don't have an a to put in this part this list could be empty so this
 there could be no ace in there in any case we can't find given a out of
 there always and so there's no other choice except to return one of these
 two parts of the disjunction but which one or we can't really return Z
 because we don't have a value of Z Z is a type parameter so we don't know
 where to get such a value but we can return one the unit well in this case
 it's a named unit it has a named empty but since it's a unit you can always
 return it and so that's what we do if that condition holds we return [Music]
 the heaviest case with filtered list here otherwise we return empty case
 there's no other choice and that works lost pass so all the tests here
 are run and they'd all pass the laws are always checked the last example
 is a little advanced because it introduces a new concept filterable control
 factor now it seems the what to introduce a new concept in an example but
 it's an easy step right now we'll talk a bit more about filterable control
 factors in the second part of this tutorial recall that the control factor
 is a tight constructor that has a control map function that is like map
 except that the arrow is going in the other direction if functor represents
 a container that is something that holds values a data of some type and
 contrivance represents something that consumes values of the type it's
 not a container it's actually doesn't have any values of that type it consumes
 them it needs them so it will consume them we've given given and so a filterabl
e control factor means a container that can consume less it can filter what
 it consumes and if they're consumed items do not pass a test it will not
 consume them it can consume fewer items so here's an example of a filter
 Concha functor will not check laws at this point but we will check them
 later once once we find more about filterable hunters it will be quite
 easy to understand what the filterable contract you must be so at this
 point we will not check laws for contractors from filterable country hunters
 so here it is I just put co-variants adaptations for illustrative purposes
 for no particular use in the code that follows I'm not using subtyping
 but just to illustrate and this is a cultural factor control factors cannot
 be able to medically derived by in a cat's library which is a shame because
 they're just as easy to generate as hunters are but they don't exist there
 so let's use the Curie Harvard library to implement the country hunter
 instance so the country hunter is a called contravariant in the cats library
 and it has the country map function with this signature so so it's C of
 A to C or B but the function is literally not a to b so i just implement
 automatically and by the way just to check that cats cannot derive anything
 with exponential types anything with function types but cannot derive so
 cannot this is a very easy factor but cannot derive so not support it well
 just for our information the cat's derive can do case classes polynomial
 types only products and sums but no Exponential's so the contra filter
 is the function [Music] sorry the the control control factor instance which
 I just called control filter now is implemented as a function with filter
 it has exactly the same signature as for filters so it takes the predicate
 from a to boolean it takes old value of the function returns a new oh sorry
 contra funky and it turns a new value of the control factor so how do we
 filter the control factor quite easily in fact you need to return a function
 so C is a function from a to option Z so we need to return a function from
 a to options if so that's that is the that is the function return it takes
 an X of tightly and it checks whether X passes the test if so it lets our
 country function cancion X otherwise it does not let it consume X and instead
 it returns none none is the possible value that it can return so that's
 important that in the case that our argument does not pass the test we
 have to return something and we're not allowed to let the country hunter
 consume that value and that's similar to the partial function law if for
 fun tips if value does not pass the test we're not allowing the factor
 to transform this value any further so any further processing should not
 happen for that value and so for the country functor this happens right
 here contra fighters conceal values and so the are they should be guaranteed
 not to need to consume values that don't pass the filter that's the main
 intuition behind filtering the Contra factors and so here we define a specific
 type constructor example eight which is C of L Z with Z equals string we
 can do that with specific type without it we the only thing we have to
 do is at I clamp the C of question mark Z so so that's the only thing we
 have to do it here we can if we are willing to constrain the parameter
 Z to be a fixed type then we can do it and we are doing this here because
 we're about to run tests and for tests in any case we need specific types
 so just to run the test I need to define the Equality function that will
 compare two different values of contra factor and since they're functions
 it's not immediately easy to compare them we need to do it for all and
 run the functions on some arguments and so I also have contra filterable
 laws implemented but this is just for later logo we discussed these laws
 right now so now here are some exercises for you which they are based on
 what we just have covered [Music] they're very similar to the works examples
 I just gave and after you do these exercises we will go on to the second
 part of the tutorial where we will discuss the laws of functors in more
 detail and in more depth we will discover why the laws are like this however
 they can be simplified and how we can reason about filterable factors in
 a much simpler
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this is part 2 of chapter 6 of the functional programming tutorial in part
 1 we considered filterable functions starting from examples we considered
 the syntax of the functor block starting from the intuitive requirements
 that the if operation search should satisfy we derived the filter laws
 and then we considered what types could be filterable or not filter belong
 examples in the second part we will look at the laws in more in-depth and
 one motivation is that there are four laws it's a lot of laws to remember
 each of them seems to be describing a difference side of the filter function
 in different property but doesn't seem to be any obvious connection between
 these laws but actually there is we will find by looking at what the filtering
 function does with a bit of intuition we can actually reduce the number
 of laws to two and we can find why these laws must be as they are to begin
 consider our intuition from the first part of the tutorial which is that
 we considered filterable type like this more like this and we noticed that
 when a data item does not pass the filter condition then the remaining
 data items are moved into a different part of the disjunction but algebraically
 is a similar to replacing this type with one so whatever data items do
 not pass the filter condition are going to be replaced with one with the
 unit type and if you replace this with a unit type what is left is a type
 1 times T times T which is isomorphic to this so let us see if we can make
 this intuition more precise what does it mean that we replace a data item
 of type a by a unit type if we're given a factor such as a freeway how
 can we replace this data item by one without breaking the type because
 the replacing cannot be just happening blindly that would be changing the
 type of F of a and we are not allowed to change it the filter operation
 should keep the type unchanged so the first question is how to replace
 this data item by one can we make that more precise and second maybe we
 replace it by different type so then how do we transform that time back
 to halfway so let us try to do this and first of all note that we could
 replace data items by unit if instead of the type F of a we had the type
 F of one plus a in other words F of option away and that type means that
 every time that the function f contains a data item type of type A instead
 now it contains disjunction either it will be a data item of type A or
 it will be one the unit value if we had this kind of type then we could
 easily implement the step one every time we look at a data item of this
 type we see whether this is you know whether this is one or a o if it is
 one then it remains one if it is a and it does not pass the filter condition
 we replace that by one and this replacement replacement does not break
 the type because this disjunction contains both the type a and the unit
 type so but how do we get this type out of this one we can use a function
 actually very easily called inflate I'll just call this function inflate
 it transforms any factor into the factor type of option a and it works
 by lifting this function into the function so this function which is in
 Scala the son type constructor it takes a value of type a and returns a
 value of type option a just takes this value a and puts it into the right
 part of the disjunction so this function exists obviously for any type
 a and when we lift this function into the filter using the F map we get
 a function from f of A to F of 1 plus a so that's the function we want
 that's inflate so that always exists from any function and after that we
 filter so we perform the filtering operation by taking each element of
 type 1 plus a and filtering it and that is just a filtering operation on
 an option that operation is defined in the standard library it is obviously
 easy to define we have done it in first part of the tutorial we just filter
 the option with the given radical P so if the option I was empty it remains
 empty if the option was non empty and the predicate holds on that value
 X then it remains non-empty on changed otherwise it becomes empty now so
 far we have gotten this type but we need FFA how do we get from a family
 of FFA from F of 1 plus a 2 F of 8 so that's step 2 so actually if filter
 does not so somehow this function must be available so I call this function
 deflate somehow for the filterable factor this function must be available
 otherwise the filter couldn't work like this so this intuition tells us
 that perhaps we should be able to define the function deflate for the function
 f if the filter is in filterable and notice that the standard Scala library
 already has a function called flatten which works like this of this type
 it takes a sequence of option and we can return the sequence so this is
 exactly the same type signature as deflate except for specific functor
 seek for the sequence so sequence is filterable as we know so this suggests
 that actually being able to define deflate is necessary if a factor is
 filterable so let's look at this diagram again to see how this works so
 that we expect that the filter function applied to a predicate P and a
 founder of a functor value if a first works by inflating to f11 plus a
 then we filter the option inside the function so we lift the filtering
 operation on the option to the factor using F map we get again everyone
 plus a then we deflate that into FA and so then we get a function from
 FA to F if that's the type signature of filter of P just to remind you
 that filter of PE is a function that is taking a fail and with returning
 a fee so let's try to express more formally filter through different now
 there is a car composition here in flight and this F map inflate itself
 is defined as f map so we have f map of some composed with f map of filter
 so that's f map of the composition of these two functions by the property
 of death note now the composition of these two functions can be simplified
 with I call this Bob boolean option boolean to option so we take filter
 P which is a condition from a to boolean and we get a function from a to
 one plus a it from a to option A so we kind of lift the boolean predicate
 P into a function from a to option A and this function works by checking
 that the predicate holds if it does we just return some of that X otherwise
 we return none so this is defined by this color code now notice here we
 use a standard filter on an option which is a very simple function so we
 aren't really using this filter on some arbitrary function f we're using
 a very specific function which is called filter on an option we do not
 have to write the word filter here we could have implemented this by hand
 it's very easy so this function Bob boolean to option lifting will be very
 convenient for us in what follows so make sure you understand what it does
 and how its defined it transforms a predicate from a function a to boolean
 to a function from a to optional so then we see that this function is basically
 a composition of this and this so therefore we can simplify an Express
 filter through deflate by saying this composition is equal to composition
 of the first two is equal to f map of the Bob and the second one is deflate
 and so basically we have a composition of F map Bob and deflate and that's
 how we would have expressed further if we had the function deflate so the
 flight is assumed of this type signature from F M a1 plus a2 F F just a
 short digression about notation here sometimes I write functions with parenthes
es and sometimes without parentheses now this is similar to mathematical
 notation like cosine of X where we do not write parentheses when this expressio
n is very short but we do right parentheses when it's longer for clarity
 for example cosine of a plus B or some larger expression we would write
 of course parentheses the parentheses but if the expression is very short
 we do not write parentheses so similarly I would use this notation we would
 write both p4f map f filter P without parentheses so to summarize this
 in the function type diagram filter P is defined through the flight as
 a composition of F map Bob which sub Bob is Bob T so already applies to
 the filter condition P is a function from a to one plus a so we lifted
 to the vomiter we get a function from get a function from FA to f1 plus
 a and then we deflate so as another reminder my notation is that the compositio
n works from left to right so we apply first the function on the left and
 then we apply the function on the right to the result so just so that it
 is easier to read easier to reason about and easier to write on the diagram
 so far we have expressed a filter through the flight assuming that defy
 it existed so actually we can also express the flight through filter and
 when we do that it will be interesting to note we assume we will assume
 that law for holes so here's how we can express deflate through a filter
 what's very easy the idea of deflate is that we have a factor of 1 plus
 a sum of these 1 plus A's are empty some of them are non empty we just
 want to filter out those that are empty only the non empty ones need have
 to be remaining and then we will get a function get those that are non
 empty we will extract the value a value type made out of them and that
 will give us F of a so how do we do that well we can write code like this
 so F of a is a value of type F of optionally we can first filter on the
 condition that the option is non empty and then can map with the gate function
 on the option now the get one method is a partial function that takes only
 the right part of the disjunction and returns the X but it is undefined
 on the left part of the disjunction so the gate is undefined on 1 plus
 0 so it's a partial function but it is safe to use this partial function
 after filter that's our fourth law we have filtered to the condition that
 all the option values that pass are non empty and so it is safe to use
 the partial function now in Scala code if this were a sequence I would
 have used the collect function and written the code like this the collect
 function is functionally equivalent to this consequences but for arbitrary
 function f not necessarily having the collect method we can just use the
 partial function it's safe because of the filter property for so if law
 for holds then we can define the flight through filter so we have defined
 filter thread of flight and we have defined the flight through filter this
 means they are computationally equivalent this is a very important idea
 these two functions are actually doing the same thing if we have one of
 them you can have the other and these are equations these are not just
 mappings so to speak from one to another these are actually equations so
 one function is equal to some combination of the other function with stuff
 and the other function is also equal to some combination with the first
 function Wisla so basically it means we have one you have the other and
 they carry the same amount of information the same amount of power so if
 you are able to define filter for some function for functor you can also
 define deflate and vice versa we have seen that some function some factors
 are not filterable so you cannot define filter therefore you also are unable
 to define deflate for them so we could actually say that filterable factors
 are those that have deflate and we could specify them by implementing deflate
 and then we could derive the implementation of filter from the given implementa
tion of the flight by a standard library function so we could actually define
 a typeclass of filter about 3d flights rather than through filter it would
 be equivalent as we have shown we can express one through the other provided
 that the laws hold of course but they must be formulated for the flight
 in that case and then we need to check the de haut so the flight is actually
 there useful because its type signature is so simple it's a function from
 functor of option A to function and because its type signature is so simple
 we can easily verify that some functors are certainly not filterable here
 are some examples consider this factor if I wanted to check if that this
 function is filterable then in principle I could try to implement filter
 for it and check the laws that would take me while perhaps so let me see
 if I can write a deflate function the deflate function would have mapped
 F 1 plus a 2 F a what is F 1 plus a it is this type now mapping F of 1
 plus a 2 FA means I'm mapping this type to this type so I have a function
 from this type to this type this function cannot be implemented because
 the argument contains the unit part of the disjunction if the argument
 is unit if I need to produce a value of this type but I don't have any
 ace all I have is a unit type if I am if I'm in any of these parts on the
 disjunction maybe I can produce value of type a but if I'm in this part
 of the disjunction I don't have any values available in order to define
 a function from this type to this type I'm required to define what happens
 with every element of the disjunction when it is given as an argument and
 so I'm not able to map one to a and I'm also not able to map one to a times
 a being able to map this is equivalent to having a selected element of
 type a but I don't have that I don't know what the type a is if the type
 a were pointed then I would have a selected element and I would have implemente
d this function by returning that selected element when I'm given the unit
 so it's an example of a pointed type is option event the point in value
 the selected value is not the empty option but in this example is a type
 parameter we do not have any more information about a so we do not know
 whether it is pointed therefore we cannot implement this function 1 to
 a and therefore we cannot implement this function since we cannot implement
 the flight we could not possibly implement filter either because as we
 know filter is expressed through deflate like this another example is this
 functor this functor is not filterable how do we see that if we wanted
 to implement deflate then we would have to map f a 1 plus a 2 FA every
 one plus a is this so we need to have a function of this type how can we
 implement this function well we have an int and we have this we need an
 a well we can put an end here and we can get one plus a but we need to
 produce a value of type a and we only have one plus a so this function
 cannot be implemented for an arbitrary type a for the same reason what
 if its argument is the empty option the the part of the disjunction that
 is unit then we would have to produce some value of type a but we don't
 have one therefore it is not filterable so the function deflate is easier
 to implement than filter and easier to reason about that non filter is
 very quick to see that you cannot map this to this and therefore it is
 not filterable or it is also easy to see when you can so let us continue
 to analyze the the laws of filterable and we noticed that we were able
 to define the flight out of filter only by assuming that law for homes
 for filter the interesting thing that and that we find we will find now
 is that if we define filter from deflate law for will be satisfied automaticall
y for filter in other words deflate only has three laws this is a very interesti
ng observation and perhaps unexpected let me now show how this is derived
 we will now derive and mathematically prove that one filter is defined
 through deflate law for four filter is satisfied automatically for convenience
 we will be using this function a lot so what can denote this with sy p
 sy p is a function that already is applied to the condition p and its type
 is this so this function already encapsulate the filtering functionality
 if this value does not pass the condition and then it will be replaced
 by 1 if it does pass the condition it will remain here we can then write
 filter like this much shorter let us now write law for in this notation
 expressing filter through deflate law for looks like this it is the partial
 function law so if we first filter which is this composition and then we
 apply a map with some function it's the same as wave first filter and uh
 apply the partial function map where the partial function is defined as
 the same function as f except it's only legal to pass values that satisfy
 the condition P let us use this type diagram the fact that the function
 type diagram as I call them to visualize this law in the vertices of this
 diagram are types and each edge of the diagram is labeled with the function
 that makes the transformation from this type to this type so then it is
 easier to read this law this law means that first we take the type of a
 notice that here in this law there is no space really to write the types
 of everything so this law is convenient like this if we don't already know
 the types when we just need to manipulate things but if we need to first
 understand the types and this notation is too short it's better to use
 a diagram notation and on the diagram intention we just write the same
 things except we put all the types intermediate and final initial and so
 on types of everything so we start with a value of type of a the left-hand
 side of the equation transforms in the upper part on the diagram first
 transfer strobe side P and then we get F of 1 plus I because side P has
 this type signature then we deflate we get FA and then we map with function
 f F maps a to be F map F maps FA to FB and the lower part of the diagram
 similarly first of psi P we get F 1 + I and we deflate we get F a then
 we have map with the partial of F we got FB and the law says says that
 if you take a value here you go to the upper way or you go the lower way
 you get to the same value here always connects this equality again a little
 remark about notation so I'm writing F map F without parenthesis here the
 type signature of F map is curried so it has a first argument F and then
 there is a second argument which is FA and so f map applied to F is a function
 from a fatal FB and I do not write parentheses here for clarity so think
 about this notation is again similar to mathematical function like cosine
 X or sine X without parentheses so then think of this is one value one
 expression like cosine X all right so we have formulated the law in terms
 of deflect how do we show that this law holds now we are supposed to show
 this with no further assumptions perhaps about deflate well actually that
 is not true we cannot do this unless we know something about deflate so
 one thing we know this is that this law is supposed to tell me that it
 is safe to map with a partial function it will be the same as if I mapped
 with the total function because I have filtered so I filtered out the possibly
 illegal values for this partial function but the filtering happens right
 here far from Earth map so there's this deflate step in the middle I have
 filtered here than I deflate and the ninetieth map maybe I will be able
 to reason about it better if this F map were close to beside P because
 this beside P contains the predicate P this also contains the predicate
 P so maybe I can reason about this eclair together site is by the way its
 itself enough map of something so if I put this F map next to this side
 P somehow if I transform this expression into an expression where I have
 a composition of site P and F map of something then perhaps I can easily
 reason about it because that will be F map composition with F map and then
 I can simplify everything and look at these functions and maybe get what
 I want how do we interchange the flight and F map in the two sides of this
 equation well remember that we have a law law one which interchanges f
 map and filter so filter now is expressed through deflate so maybe if we
 put it right here instead of filter but we'll have a law that interchanges
 earth map and deflate such a law is called usually natural reality law
 so let's express the old law one the filters go one through the flight
 we get this equation which is now more difficult to understand without
 the type diagram so I write a function time diagram here it starts with
 F a it first maps with a function a to b 2f b then we apply the filtering
 function we get we get F 1 plus B and we deflate that to f b now this deflate
 is parametrized by big f and b so it's a deflate for F 1 plus B 2 F be
 the right hand side is the lower part of the diagram which first maps with
 psy of composition F in P now P goes from B to Bui so composition F and
 P goes from A to B the boolean so from A to B and shy of that goes from
 a to 1 plus a I'm sorry from FA to F 1 plus F so first we get this and
 this already incorporates filtering then we deflate we get FA and then
 we map if FA to FB using the same function f as we used here so here the
 filtering worker is first on the Left map here the filtering occurs after
 of milk that's the law that we can interchange filtering and F map now
 we would like to transform this so that we can have a law that interchanges
 deflate and F map we almost have that except we have this I in the way
 so can we simplify this perhaps somehow let's write it down f map F composition
 with psy which is f map of both P is by the ethnic composition law it is
 this so can we simplify this expression we can actually there is a property
 which the Bob function has which looks like we can interchange Bob with
 some functions so it's like a natural Adil except it isn't because Bob
 is not if a function that works with functors only those functions can
 have natural tools so it's kind of a similar law not interchanges the order
 of Bob and some functions here's the function type diagram for it we start
 with some type a we first map F A to B we get a B and we map with Bob we
 get big on plus B some Bob maps from Vito and plus B it and takes the boolean
 predicate makes it an option kind of predicate option valued predicate
 the second way the right hand side is a lower part of the equation is first
 we do the book filtering we get one plus a and then we map the function
 f so we have to map 1 plus a 2 1 plus B using F F goes from A to B so obviously
 we just lift F to the option factor so we get a function 1 plus a 2 1 plus
 B so this is denoted like I denote it like this is f map for the option
 factor I right opt for gravity instead of option I need to spend less faint
 less less space in my equations so how can we verify that this property
 holds well I have code actually I have both symbolic derivation of this
 and the code that checks so let's look at the code so here's the definition
 of filter from the flight and here's the definition from the flight from
 filter and let me see where my book property is Bob yes it's here so let
 me first look at the Bob property perhaps since we're talking about this
 so Bob is defined like this and I also defined it as composition of apply
 and filter just like we did in the slide it's a composition of this and
 filter so I can write it down if I want explicitly has a composition we
 can check that this is the same function actually I have a helper function
 that checks function equality which I could have used here but functional
 equality means checking that for all arguments X and for all arguments
 P it has two arguments so both of px is equal to BA first composition P
 X so now the law of natural T is that this must hold so f is of type let's
 site T to a and this is a to boolean so this composition is of type so
 this composition is of type T to boolean and this can this is composition
 is of type T - 1 plus a and that should be equal to that function from
 T to 1 plus a so therefore we take T to string just to check it a is int
 and so then we write that F composition with hope of P so I'm just writing
 it straightforwardly here composition and Scala is and then so F is applied
 and then this is applied so book of P is a function so book is already
 applied to P and the result is again a function which is of this type that
 should equal book of composition F and P like this and then so composition
 with map of F on the option then I applied both of these functions to some
 X so that I can check that the results are the same and also I can check
 this law symbolically now of course the test passes but it checks the law
 for certain values maybe 400 randomly chosen this is perhaps if enough
 of any assurance but this is correct but it is nice to be able to have
 rigorous derivation not just a numerical test so how do we have a sim how
 do we find a symbolic rigorous derivation we transform the Scala code so
 the easy way of doing this is to first replace these mathematical notations
 with specific Scala code that corresponds to them for instance F composition
 F and then both P means first we apply F to some X and then we apply both
 painter the result when we put in a definition of both P which is some
 dot filter of people then we expand what filter means filter means if P
 of f of X then some f of X is known so that is the left-hand side let's
 call this expression 1 and the right-hand side is that this applies to
 some X in Scala that would be dot map of F and then we do the same thing
 so we expand the book into its definition we expand the definition of filter
 which is nice for option then we put the map inside so if this condition
 is true then this dot map else this dot map then we simplify this because
 we can obviously see this as a non-empty option so mapping it over F means
 we just put F inside so that is the result of the right-hand side of the
 law and this is expression 2 obviously expression 1 and 2 are identical
 so in this way we have proved this property both using a test numerically
 so to speak and mathematically rigorous them using this property we can
 now rewrite law one which was this by interchanging this F and book into
 so f composition book F and then what is pop and then as map f so we put
 that in note here that we have now F map of Bob and then F map of F map
 depth of of F now this F map is with respect to the option factor and this
 F map is with respect to the F factor that's why I use this sub sub superscript
 opt to make sure we don't get lost different types so this is a lifting
 of F into the option factor so this is of type option a to option B and
 then we F map that over to function to functor F and then we get this part
 of the diagram F of option A to F of option D through F map of F map F
 so now we rewrite this left hand side like this and we write the right-hand
 side of that already contained the F map of this book of composition which
 was here F map because I is f map of Bob so this is f map of both composition
 this is this so now the left hand side and the right hand side contains
 common prefix and we can remove it because our goal is to show that they're
 equal we do not assume that they are equal we need to show them they're
 equal so if we show that they're equal without this prefix then they will
 be equal with this so we can remove this prefix now we need to show this
 codes and that exactly looks like a law for a deflate that we want this
 is low one for deflate now we will also want to show that this law is [Music]
 equivalent to the law one for filtering then we would have to show it in
 the other direction and then we have to reason about why we can remove
 this prefix but let's just keep it aside this prefix by the way is the
 only one that contains the filter condition P and so this prefix should
 it contains the arbitrary filter condition P and so that's how it would
 prove equivalence and the laws but at this point we're not so interested
 in the equivalence of the laws for the flight because deflate actually
 will not be so important in terms of checking its laws for us but we could
 give derive the laws for the flight there will be two three laws from the
 first three laws the filter would follow the three laws of the flight and
 so at this point we have derived in natural G law for the flight which
 was ours so on the diagram it looks like this we first map F 1 plus I 2
 F 1 plus B then we deflate with respect to B or we first deflate with respectiv
e a and then we map a to b and that should be the same that's the natural
 reality law and having the naturality law for a function between factors
 means that it's a natural transformation that's basically the definition
 of natural transformation it is a transformation of one factor into another
 such that the natural T law holds that you can f map before the transformation
 or you can F map after the transformation and that's the same so here's
 an example of implementing deflate so suppose we take this factor then
 we look at the type of f of 1 plus a which will be this just substituting
 1 plus a here when we expand brackets just like in school algebra we expand
 brackets and we are allowed to do this because of isomorphisms in the polynomia
l types so then we have this type this disjunction and then we say well
 we need to map with deflate this into this so let's see which parts of
 the disjunction we could map into which parts obviously this well the unit
 we can happen to unit and into nothing else this we should probably map
 into this and these things could be mapped into unit all of them so all
 of these could be mapped into unit and that's fine that's natural transformatio
n and that would have defined the collapsing filter that we considered in
 the first part on this tutorial the filter that retains the two values
 only when both of them passed the filter when even one of them doesn't
 pass the filter both of them are removed and we get the empty the empty
 container so this would be an example of implementing deflate for this
 factor so it is quite easy the function has a very simple type signature
 and this illustrates what natural transformations do so in general natural
 transformation would map some container GA into some container age and
 what it does it rearranges the data it is not allowed to modify the values
 unless we know something about these types but generally we don't and so
 this is an arbitrary type were not allowed to change its value were allowed
 to rearrange the order of values or the disjunction part in which these
 values are held and well of course able to remove values or duplicate them
 also very loud but we're not allowed to inspect the type and do something
 type specific or and so on so same considerations as for a good implementation
 of functor that we just look at the type and try to see how we can produce
 a new type with no changes to the values exactly the same considerations
 apply here a natural transformation will not modify any values it will
 just rearrange data in a container so if you have a natural transformation
 between two containers which you don't always have but if you do have it
 it means that data in this container can be somehow naturally rearranged
 with no changes to the data just some erasing maybe some duplicating in
 some order changing it can be rearranged and you get this type is this
 container so if these two containers are in some sense sufficiently similar
 that this can be done this rearrangement of data then you have a natural
 transformation between these two factors so we have found the law for deflate
 which is this which interchanges F map and deflate now let's use this to
 show that law for poles what is love for expressed while deflated is this
 I'm repeating the type diagram from the slide before now we can use a natural
 T law which is this to interchange the flatten map in both sides of this
 equation so when we do this we get this equation so we just interchanged
 and now this F is next to the sign in both parts of the equation so we
 can now admit this common suffix the common part of the two equations because
 we're interested in showing that this is true so we show that this is true
 without the composition will deflate then it will also be true with that
 composition and so then we expand the PSI back into its definition which
 was here it's just the definition for brevity and we get F map of this
 equal to f map of this now this is quite simple to check that this is true
 let's write out the Scala code for the left hand side on the right hand
 side we see these two pieces of Scala code I've corrected the Scala code
 here so this function is partial function will be always safe because we
 are applying it after filtering on the condition P and so any values X
 that this partial function will receive will be guaranteed to satisfy the
 condition P this is because this is the law for for the option functor
 and we need to verify that it holds for the optional function when we define
 this filter according to the usual the usual way of defining the filter
 going to the way we we have assumed that we define it so let me show the
 code and that demonstrates this unit so easily but this law holds so let
 me just write it down so why does it hold for option or we have son of
 X filter P f map map is X P of X goes to X or half of X so what is some
 X filter P it is if P of X some X else none so how do we map this well
 if it is none then it is not so we put them F map we put a map in here
 so this is equal to that so this this code is evaluated like this to this
 expression so now how do we do a map on the Sun well we have a non empty
 option here so we just put this X in there now clearly this P of X holds
 so the sum will be evaluated only if P of X holds so then we don't need
 this condition this condition will be satisfied by by the way that if is
 compiled so then we don't need to to do all this we just do f of X and
 that is precisely sum of F of f of X filtered P of X so if you'll repeat
 so this is lawful for option that we can map with function if so this is
 some of X P so therefore some of X filter PMF so therefore these two are
 equivalent and so what do we find we find that law for holds this was the
 last equation that we needed to show and we showed that this is the same
 code that is evaluated in the same way for all arguments therefore this
 holds therefore law for holds so we find that the law for for filter hold
 automatically if we define filter through deflate so let me show you an
 example code that was there before where I defined filters through deflate
 and deflate through a filter so I actually used functions to define that
 so I define a function which is called filter from the flight which is
 paralyzed on a factor and this function takes an argument which is a deflate
 function which is a function of this type and it returns so this this takes
 the deflate as an argument and returns filter as an argument as a value
 so it returns as a value a function with the type necessary for filter
 so you see this is the this is part of the power of functional program
 we can transform code one function into another by writing a function it
 transforms code what we don't actually transform source code we transform
 expressions algebraically or using other functions but the point is that
 we define a function that performs this work so that can be done with no
 restrictions so this could be any type signature pretty much [Music] as
 long as all the type parameters are defined up front in here one limitation
 is that we cannot have further type parameters inside of this argument
 so this limitation is sometimes quite serious but often not so so this
 is our definition of filter from the flight is the F map of Bop and then
 deflate since exactly how we defined filter from the flight I've mapped
 Bob and then deflate and we also define a function that takes a filter
 and returns a deflate now instead of taking a filter function I just wanted
 to save myself some typing and I assume that the founder F was from the
 filter with filter typeclass so that has a filter function and then I do
 so how do these functions work well they I'm supposed to return this function
 so I take P which is this and then I'm supposed to return this function
 so this is the F map book and then deflate all I need to do is to prepare
 this map properly I need to do F map on an option so I use the implicit
 evidence value foot which is this implicitly funder F it has a map function
 which has this type signature but has the first argument which is function
 f of a and the second argument which is function f but I need these arguments
 in the opposite order I need first F F because I want F map I want a flipped
 map functions I want to interchange these two arguments so for this I use
 the flip function which is defined in my common code like this it takes
 a function from A to B to C returns a function from B to A to C in its
 code I leave for automatic instrumentation so this is this flip function
 and then I get the F map for the types that I need then I just write more
 or less than mathematical notation and here also I prepare an implicit
 function instance sorry implicit function evidence and then once I get
 that evidence into the implicit scope I can use the syntax F way dot filter
 dot map if I don't have this then dot map would not compile on an F for
 because F Way is a filter but with filter all we know about it is that
 it's filterable with filter but that actually includes functor and that's
 not automatic as it includes filter and so we need to prepare this evidence
 other than that this is the definition we had in the slides we deflate
 is first we filter non empty options and then we get the values from the
 option so this is a partial function but it is safe here because it's after
 the filter and as an example we do the orders example from the first part
 of the tutorial and then we just deflate from filter actually takes no
 arguments and filter from the flight takes arguments so then I first obtain
 the flight from the filter then I obtain filter from that D flight and
 then I check that that filter is the same as the previous one so that's
 what is checked here so that the filter is the same function as the filter
 obtained from the flight that was obtained from Philips alone it's showing
 me that it's really equivalent functions all right well that is so good
 but still we have a bit of complication because the flight seems to have
 a lot of laws three laws and notice we always have this deflate composed
 with psi with this F map of something always deflate is with F map of something
 in front of it so maybe this F map of something or this I and then deflate
 maybe this composition is actually easier to handle let's look at the type
 signature of this composition the type signature is actually interesting
 it is going from F a then we get this F map si which is going from some
 a to some 1 plus B so let's say this is a function we get f1 plus B and
 we deflate that we get FB so actually the composition of F map and deflate
 is a function from FA to FB that consumes this function f from 8 to 1 plus
 B so let's call this F map option or F map opt for short now the type signature
 of Asmat opt is that it takes an argument of type from a to one plus B
 and note this argument already expresses filtering and mapping at the same
 time so this function from a to one plus B expresses first that we check
 some condition on a and for some edge rate return every option and for
 some is very turned on empty and then we also map a to some be in some
 way so so this F combines combines filtering and mapping and the result
 is a map from FA to FB so deflation is already incorporated so F may up
 F composed with deflate that is the definition of F may opt here's the
 type diagram for it so from FA 12 be either directly through F map opt
 and this is how we define it it's a composition of F map F and deflate
 now it's important to note that F map opt and deflate are equivalent functions
 because we can also define the flight through F map opt to do that it's
 very easy we just make this arrow identity we said let this a be actually
 the same as 1 plus B so let's say this is actually 1 plus a and this is
 also 1 plus a we can do this because a and B are arbitrary so we can set
 a equals 1 plus B if we want to then this will be identity so this is an
 identity function and then obviously deflate is equal to f map opt applied
 to that identity function because these two will then become equal so since
 we can express one function through another and the second really first
 they are equivalent these are equalities so these are not some kind of
 mappings so these functions are actually equal on all values so now it's
 interesting to express the laws in terms of F map opt now law 4 is already
 taken care of so it's already automatically satisfied we can express filter
 through F map opt this is actually quite short because we have incorporated
 this F map and deflate into one function so I'm writing out all the type
 arguments here for clarity so this F map opt has actually three type arguments
 to F and the types a and B so no filter is this kind of thing so now how
 do we show that the laws hold well we will show it now actually well we
 cannot show that the law school we need to derive what the laws are for
 F map opt we need to serve its press filter through F map opt and substitute
 into the laws so for example let's look at the at this law well in this
 law it's probably easy we just have some morality this law looks interesting
 so there is some boolean conjunction here so how are we how will we deal
 with it or we need a book of this to be able to do so we need to know what
 happens when Bob is applied to the conjunction of two predicates how is
 that expressed through a both of the two predicates alone through Bob of
 p1 and whoop of p2 well it so happens that for the option this is the code
 so we need to take Bob p1 applied it to X to X and then to do a flat map
 on the resulting option with Bob p2 so that is maybe unexpected let's look
 at the code that shows yeah so here's by the way deflate from map option
 and map option from the flight and again the check in that they are equivalent
 when we will take one from the other so let me explain this a little later
 but let's look at the boolean some property of Bob the conjunction property
 so we can check this property by a numerical test or we can check it symbolical
ly so numerical test is that for any X a bob of this applied to X is the
 same as that formula drop of P 1 of X flat map book Peter why is that well
 so we can write out the code the Bob is defined as some dot filter so we
 have this code some dot filter means that since this is already non-empty
 option if P 1 of X and P 2 of X then it's sum of X else is known so that
 is the left-hand side let's call this expression 1 the right-hand side
 of the law is that we have what P 1 of X flat mat book Peter now book T
 1 X is this which is this expression so now we need to flat map this with
 something how do we flat map well if the option is none then the result
 is none now if it's not known when we need to check if P 2 applies and
 then we still have a son otherwise we have known so we have this code if
 P 1 then if B 2 then some else none else now so obviously with only return
 sum of X when both conditions hold so that is equivalent to this which
 is expression 2 and expression 1 and expression 2 are identical so we see
 that flat map actually expresses the boolean conjunction in some strange
 way so this was the property that we needed and actually this is very important
 we will be using this a lot in this this formula so let's have a notation
 for it so this is kind of a composition of Bob Irwin and Bob - Bob p1 and
 don't be - let's go let's call them Q so Q actually is a function from
 a to 1 plus B and Q 2 is a function from B to 1 plus C and we can write
 this formula like this q one of X will be option of B we can flatmap this
 with q2 and get an option of C and so the result is a function from a to
 option C so this is a kind of composition but the types of the functions
 are kind of twisted so the usual composition would be if the types were
 a to B B to C and the result is of type A to C but here instead of a to
 B we have into one plus B so option B here we have B to one plus C and
 here we have a to 1 plus C so every time the type of the function is twisted
 there is something added to it on the right hand side but it's the same
 thing that's added every time so it's that it's some functor that is put
 on top of that so this is called nicely composition in the general case
 of the closely composition is for some functor m where you have a function
 from M to M a - M B from B to MC and you can post these two functions and
 you get a function from A to M C so you twist the type on the right hand
 side of the function by applying some function m in our case the function
 M is the option factor so we just applied 1 + 8 so we twist with 1 plus
 a at the right hand side so in this tutorial we'll only be using this closely
 composition with this function or as I said twisting the notation for that
 will be closely opt and I would use a diamond opt diamond with subscript
 opt to remind ourselves that we are only using this specific case we're
 not going to be you in the general case in this tutorial but the general
 case is extremely useful nevertheless so that's why I wanted to mention
 it so this is called the Kleiss lis composition so we're using the Chrysler
 composition for the specific case of option so this is the closely opted
 composition and interestingly this composition has an identity element
 which is a function of this type that returns the non empty option this
 function is an identity for this composition so if you take this function
 and compose it with this operation with any other function you get that
 function and so we will show now that the classic composition operation
 is associative and respects the closely identity just as a normal compositional
 would so this is very interesting because it is a full analog of a normal
 composition of functions with identity function and associativity of compositio
n however the types are twisted so how can we can even do that so the reason
 is that are twisted in this way so this is a special kind of twisting that
 allows you to to work the option is a very special factor and that's why
 it works and let us now look at the code that shows how this all works
 so we define a closely opt composition which is a function from a to option
 B from beta option C into a two options the code of this function is left
 for automatic implementation we also define an implicit class for syntax
 so that we can say this we can use this symbol to compose using the class
 Li opt composition law so we just refer to that function we define the
 identity which is a function from a to option a again this is left for
 automatic implementation but this is basically some dot apply so X goes
 to some of X just so that we know what it is but that's what it is I'm
 going to be implemented and then we check the laws so we say well I have
 this now func function equation utility and it checks that functions are
 equal just for from brevity so this is exactly like the associativity of
 composition except I replace the composition symbol in the little circle
 with this strange symbol but that's the only difference so this is the
 closely composition and that is associative and also the identity so identity
 on the Left composed with F is equal to F and identity on the right composed
 with F is also equal to F and I check that with various types but also
 I can derive the symbolically deriving and symbolically is again a matter
 of writing out Scala code and transforming it as if you are evaluating
 so I will leave this for you to look at I will just go through the first
 few steps that are necessary the important thing to make it easier that
 you can just do it brute force you can just write out this code and check
 everything but it's much easier and more visual if you decompose the function
 of this type into a pair of functions one is the filter function and the
 other is the transformation function so remember that this function represents
 at once filtering and transformation but it is easier to reason about it
 if you decompose them into filtering separately than transformation separately
 so let me do that here is how I can define F is if I have P and Q here's
 a how I define P and Q is if I have F so they are equivalent so I can define
 one through the other and the others would have the first one so then I
 note that the composition the closely opt composition expresses boolean
 conjunction we have seen as before but now I'd like to see this more explicitly
 in fact so what is the class the composition of the two functions and while
 I transform the code in the same way I did before I expand then there's
 an if when I put the flat map inside the F and so on and I find that the
 P and Q component of the composition is expressed like this so T composition
 the filter is the boolean conjunction of the two filters except that the
 second filter has to be applied to the transformed value of x because it
 could be a different type and the queue functions are simply composed the
 transformations that are inside here are actually composed in the usual
 way but the filter is composed using the boolean conjunction and so this
 is why the walls hold obviously a laws will hold for Q because the ordinary
 composition is associative and respects the identity and by the way the
 identity function is mapped into a filter that is identically true and
 a transformation that is identity and so obviously then the filter will
 be identity element for this because this will be identically true and
 something that will be equal to that something whether it's only right-hand
 side or in the left hand side and identity and in these logical so it is
 for this reason that the laws hold you're welcome to check in more detail
 all these calculations and I would like to wrap up the previous topic the
 transformation from one function to another and just illustrate a Scala
 trick here so I want to define a deflate function from this map option
 and I want to deflate to define map option from the flight however I have
 a little trouble here during this and the trouble is I want to define a
 function deflate from map option which takes an argument that is map option
 characterized by a and parameterize by D but a and B must be special you'll
 be chosen so remember how I define it here the flight is defined through
 map option when I set one of the parameters to one plus a another to a
 well I could I could write B here instead of a so it will be B baby baby
 so I could say I say I sat in the D flight I'm sorry uncertain the F map
 opt I said a to be equal to one plus B so a must be optional D but how
 do i express this in a function map option is a function with this signature
 but I need to set somehow the type a equal to the type option B so that
 this is actually the same type and I can put identity in there how do I
 do that so I use produce the cats library which contains a useful utility
 called is so this is is a type constructor which is parameterize by two
 types the Scala syntax allows me to write is in between a and option B
 but you can see that is is defined just as a type constructor with two
 type parameters and is a the class that holds evidence that this type is
 equal to that type what does it mean to hold that evidence it means you
 could in using this value you could transform this type to this type or
 backward with no computation we just map identically so this evidence would
 not compile because you don't have the implicit value if these types are
 not equal when you actually call this function so when you define the code
 of this function you don't know what a and B are and you say they must
 be equal so you have evidence that they are equal but what when you actually
 call this function which will do the you needs to write the types correctly
 so that actually they are equal and then it will compile these implicit
 evidence will be found so once you have this implicit evidence so then
 you return this you have a for example an X of type a but a is option B
 so how do you get an option B out of it well you use the squares function
 which takes an a returns not should be in this case this function is automatica
lly defined but only because you have the evidence that a is option B and
 here's the substitute function that will transform F of option B into F
 of a now a is the same as option B so this transformation actually doesn't
 do anything it doesn't perform computations very convenient and flip means
 that you you do it in the other direction so substitute will do FA from
 F function B to F a but without flip it will go from F a to F optionally
 so with this evidence you can easily coerce one type into another or the
 second at first and also with any functions you have functor and we do
 have a functor here so we need actually to check the types and make sure
 that we are given we're given fo B which is a type F of option B but we
 actually need F of a to call the function and that's what we do here so
 we substitute which is a function defined for his in the cat's library
 that's very convenient it's a bit of writing to get all these types correct
 and actually all this performs no computation at all because this is just
 identical equality of types of X is just of this type or that type it can
 pile time at the run time is actually the same value because when you call
 this function you must use the same types so there's no or very little
 overhead and calling these functions they don't actually perform computation
 so if you have a big data structure here and this is immediate this is
 very quick to do that there's no computation so how do we call that so
 here's how we call that we specify the types option B and B and then this
 is a type a right so this is a type parameter a in that function and we
 specified directly as option B and that's why here as well yeah we directly
 specify that and that's why it compiles so that's how we implement what's
 in the slide here we call F map opt with option B & B as type parameters
 here is option a and a or Justin and we check that the deflate obtained
 by direct definition was equal to deflate that obtained through the map
 option which itself was obtained from the flight and just rename this for
 consistency so these computations illustrate the equivalence between F
 map option D flight and the properties of the class like composition so
 let us look at the type signature of F my opt once again it takes a function
 from a to one plus B and it returns a function from FA to LV in other words
 we can imagine that we have this set of Kleiss Li functions which are functions
 with this type which is kind of twisted so these are the nicely opted functions
 or in the language of category theory this is a function that belongs to
 the class like category with opt functor now for us this is not particularly
 helpful right now we are actually coming from another direction we found
 that these functions were helpful and we are studying their properties
 and we discovered that they have this product the composition of functions
 of this type which is very similar to the usual function composition and
 this function f map opt is very similar to a usual F map because it lifts
 the function of this type into the functor except for this twist so it
 lifts a function from a to one plus B into a function f A to F be not f1
 plus B but F B so this is a twisted kind of lift but it's very similar
 to a usual F map it lifts a function from A to B into a function from F
 A to F be in other words it lifts a computation into a functor context
 it makes those computations occur on values that are held within a functor
 so this is a very similar kind of lifting although it's with a twist as
 twist is of course highly non-trivial we have a lot of work to do to deal
 with this but once we have done this work with C and that this formulation
 is actually very intriguing it's very similar to just lifting a function
 into a functor context so in fact [Music] only two laws are necessary for
 this F map opt namely this law that if you take identity function then
 the lifting of that into the functor context gives you identity function
 on the functor in the container and second law is the composition law which
 is that if you take the composition of two lifted functions that's the
 same as the lifting of the closely composition of these two functions so
 let's look at the type diagram for the composition we have F a FB and FC
 so let's say F goes from 801 plus B G goes from B to 1 plus C then the
 closely composition of F and G goes from a to 1 plus C and F map opt would
 lift each of them but this lifting is consistent so this way gives you
 the same value as this way and that's the left-hand side gives you the
 same value as the right-hand side so the two laws for F mapped are very
 similar to the two function laws if two functor laws were that lifting
 an identity gives you identity and lifting a function and composing it
 with a rather lifted function is the same as lifting of the composition
 so they're very similar here except that the types are more complicated
 they're twisted and as I said and the composition here isn't nicely composition
 so this is a kind some kind of twisted composition and your more complicated
 types then the the functor laws but conceptually they're simpler actually
 they're also more complicated than the filter laws conceptually they're
 simpler they're fewer and easier to understand this is just some kind of
 twisted lifting from from one kind of set of functions to another and [Music]
 from functions of this type to functions on the container and the lifting
 of course must respect the usual laws it must lift identity to identity
 must live composition to composition so that's kind of natural and there
 are no more laws so there are only the natural laws for for the factor
 just twist it so let us show that this is indeed so mean I just claimed
 so fine didn't really show yet and that's only two loans are actually necessary
 let me see how that is proved so let's start with the law 3 which is the
 filter with a identically true function now that function after you pop
 it it gives you this and so this composition is the F map opt of the clearly
 identity because actually the book of this filter function is exactly the
 function that is the closely identity business this function doesn't let
 me highlight correctly this function so therefore if the filter law is
 true then this is an identity and so then the F map opt of identity must
 be identity and if this is true and the filter must be identity so old
 law 3 is actually equivalent to the identity law both of them imply each
 other because of this equal votes are equal science everywhere so that's
 very strong identity done isomorphism now we need to derive the laws 1
 & 2 obviously we have only one law the composition law left and somehow
 this one law should cover two old laws at once how can that be so let's
 see we know that the conjunction responds to the classical position let's
 so the way that we can take one law and get two out of it is to use different
 type parameters in this law you see this law has three type parameters
 a B and C we can choose them to whatever we want and you choosing them
 in different ways can give us different perhaps specific laws and that's
 what we shall do now so let's consider nicely functions only of types it
 goes to one plus a no other types so we're choosing the type parameter
 in the class Lee in this way and then actually we can see that the filter
 composition is equal to this so Q I'm just defining for gravity that Q
 is Bob of P so all Q's are of this type and then the filter is equal to
 f map opt of Bob right so in other words F map opt of dope of p1 which
 is Q 1 in position with F map opt Q 2 that's the composition of two filters
 now by the composition law we have this and then we know that the composition
 of the class ly responds to the Bob of the boolean conjunction we have
 already derived that so this derives the law to law one is a little longer
 to derive because it's a natural to know it has more stuff in it it says
 that F map can be interchanged with F map opt so notice that here we have
 specialized two functions of this type of the class Lee functions of this
 type here will always also specify a specialized namely specialized two
 functions that are filled that are ordinary functions transformed into
 a closely opt kind of function which we will denote by K F so K F is a
 function of a twisted type that corresponds to some function f of an ordinary
 type by always returning the non empty option so we just take a we'll apply
 F to it and always return a non empty option never return empty option
 so that is basically a composition of F with the identity in the class
 Lee and because of this we have the property that F map opt of K F is is
 by definition is this we can then decompose the F map because K F is the
 composition so we can decompose that into F map lesson F map of it and
 F map edan on the flight is identity because you can you can check that
 and so yeah let's let me think why I did not say anything here about why
 this is identity so if you F map the identity in the closely means you
 map F of a into F of one plus a but in that F of one plus a there are not
 there no empty options because the identity never produces an empty option
 so then when you deflate that there aren't any empty options and so that
 it returns you the original container but in principle this actually oh
 that isn't actually easier by definition this is f map opt of it opt because
 this is F map and then the flight is the same as f map opt by definition
 and so by the identity law this is equal to identity so therefore this
 is equal to F map F so f map opt of this transformed function is actually
 the same as I've met Beth therefore we can just rewrite this law using
 F map opt of K F instead of F map F when we do that we can use the fly
 sleep composition and so then for example we will get this using the closely
 composition of K F and Bob P which we can then simplify because we know
 that the KF times what P we can just you can just expand we know that that
 Bob P has this has this law sorry it has the law that we derived before
 this one we know that both P has this law and so therefore we can transform
 this into that the only thing we need to do is to see that if we if you
 do a closely composition like this and actually this is an ordinary composition
 with F so all of this hinges on the fact that K was defined from an ordinary
 function f so K is not an arbitrary clastic function it's a class a function
 that never returns empty option and so it's much simpler to compose anything
 with it you just compose normally like this and then finally you substitute
 that in there and you find that this is equal to that they are under F
 map oops and so therefore the one holds I encourage you to go through this
 may be slower but all the steps are written here we start with this when
 we write we define an arbitrary function f then we define K out of that
 F and we show that we need we can rewrite star as this equation then we
 show that what is under F map opt is the same by transforming the left
 hand side into F and then book P the right hand side into Bob FP and them
 F may opt so we just used set of Q here and we use this instead of Q here
 we use this and we obtain this property which we already showed previously
 so let me summarize what we have found filterable functors can be defined
 in different ways we can define them using a filter function using a deflate
 function or using F mapped all these three methods are equivalent expressed
 identically through and so if you have one of them you can define to others
 but these methods have different roles for us in the program code in the
 funster blocks we use the if operation the easiest reason about in the
 code is that operation which corresponds to a filter or with filter a type
 signature that is the simplest is that of deflate that is the easiest goes
 to implement and to reason about conceptually however the F map opt has
 the simplest laws it has a just two laws which are functor laws with a
 twist now let me talk a little about category theory so the to function
 laws with a twist are accommodated by category theory as just some kind
 of generalized functor laws or other words in other words as ordinary functor
 laws for some kind of a twisted functor and the twisted functor has twisted
 function types and so if we for example look at type signatures of f map
 contrived map and f may poped compare them you see this is an ordinary
 of map type signature this is the contra of map type signature and this
 is the F myope type signature so they all look like some kind of lifting
 of functions from here into a functor context or container on a Content
 context but this lifting is ordinary and this lifting is from reversed
 functions and this lifting is from these twisted closely opt functions
 otherwise it's very similar the laws are the same identity law and composition
 law now here of course we have contract on position so composition here
 goes in the into the other direction that's natural because we have twisted
 the composition because we have twist the type here the composition has
 a class like composition we have to twist it so cutting category theory
 says let's consider all of them as actually functors but on the left hand
 side you have something twisted so you have a twisted founder here that's
 how category theory generalizes all of this into lifting so it's always
 lifting from one kind of arrow to another kind of function arrow to another
 kind of functional arrow with twisted types now category theory gives us
 intuitions about how better laws could be derived and two of these intuitions
 we have seen is one is that it's probably helpful and useful if we look
 for type signatures that look like lifting if we find a function like f
 map opt whose type signature looks like lifting then it's probably very
 useful because then you can expect that you just need to twist the composition
 here somehow of these strange twisted functions other than that you have
 standard functor laws just the two laws and they're standard very easy
 to understand identity and composition so at the price of twisting the
 type here and here and using a different composition because the types
 are twisted second hint is look for natural transformations and use a natural
 T law to interchange F map and whatever you need so you can do that and
 that allows you to reason about the laws and derive one law from another
 so that's kind of intuition that natural transformations are useful because
 they have this natural reality where you can flip F map across them and
 that is useful for deriving the laws so notice how we have arrived at this
 point we have started with filter we derived a large number of laws of
 four okay twice as many as now a number of laws for filter and then we
 were looking for a better type signature basically a smaller more kind
 of reasonable type signature deflate had a great type signature but F map
 opt has fantastic excuse me fantastic type signature because it's it's
 a lifting and it's laws are very easy however category theory does not
 directly provide any derivations from these laws so I don't think you will
 find these laws from any category theory look filter and deflate are not
 usually found there or the laws from them category tier is too abstract
 for that it gives hints about what you could do but it doesn't give you
 laws or equations for these functions or specific types doesn't also doesn't
 tell you that this should have been the type that is at the root of being
 able to filter not actually somehow you need to look for class Li and use
 the option to twist the class Li category theory doesn't tell you that
 you start with filter and you think you're doing something very down-to-earth
 filtering values out of sequences and actually at the root of this there
 is this twisted Kleiss Li opt category of functions but category Theory
 doesn't tell you that you have to derive it yourself it does not also it
 doesn't help you derive that either just gives you hints about how you
 might be able to do it in particular look for a lifting like type signature
 but we were lucky to find it there's no easy way of deriving this so what
 are the further directions that category Theory hints about I can give
 you two examples so now that we have seen this pattern let's investigate
 other kinds of liftings for example well if here I have some and a 1 plus
 a 2 B or something instead of this what if I here here have F of a to be
 instead of A to B well if I have 8 a 2 F of B with the same F as this will
 I have something else would have I can try to investigate different kinds
 of liftings and see if they're interesting or useful but this actually
 so this is one kind of abstract direction we could go now I'm not going
 to go into that direction I'll explain why um another thing you can do
 is to replace the option in this construction by another function so not
 F but let's say some m and then let's see what happen is then we'll have
 some different twisted thing and let's try to interpret it so why I don't
 want to go into this direction is because first of all there's no end to
 different functions or types that you can write down there's no end to
 twisting and generalizing and putting more functors here you know F of
 F of B of F of something there is no obvious limit or obvious direction
 where to go so infinitely many possibilities are open and you can spend
 a very long time studying all of those possibilities with not much of a
 practical use it takes a very long time to discover which are practical
 things that you can use and which are just theoretical things that don't
 necessarily give you a lot of practical value so one approach is that I
 start with examples we start with practical value that we obviously see
 in code and then I generalize so I generalize a certain to a certain extent
 to a certain degree and then stop so certainly where to stop is a judgment
 call there's no obvious decision to make and you need to understand have
 some intuition about how much generalization is useful and how much is
 just I don't play you could you could go very far here in generalizing
 and category theory especially encourages you to generalize with very little
 regard for practical use and I don't think that's the direction I want
 to go so having said all this let us look at the practical question what
 are the filterable factors if I give you some type how do you know that
 this is a filterable factor so let's eat to answer that question let's
 use intuition from our deflate type signature so we reshuffle data in a
 container by replacing some values of type a by unit and reshuffling means
 we just reuse a different part of disjunction usually not always so therefore
 we can try to reason about it and say look at the type and try to substitute
 one plus a instead of a in the type and see if you can reshuffle the results
 to get what to get FA again if you cannot it means you cannot in and deflate
 I showed you examples of that some simple ones and then it's not filterable
 but if you can then you can look further how you want to make it filterable
 and especially for your particular requirements of your application and
 to get some intuition about this let us consider how we can build up filterable
 factors from parts this is very similar to what we did with ordinary factors
 so we will now list some constructions certainly not all possible constructions
 but some sufficiently large number of constructions and give you new filterable
 functors given old ones and let's see how that works so first of all a
 constant function meaning that for all types aids it's a constant the same
 fixed type Z and for that functor we define F map opt as identity so whatever
 type you have here you can transform it from A to B but Z stays the same
 just identity so filtering does nothing and filter is identical constant
 I'm sorry add an identical transformation and Z is some fixed type so that
 is filter book note that this is not floatable the identity function for
 the reason that you cannot transform one plus a into a unless a is a pointed
 type but this needs to be for all types so it is not filterable the typical
 constructions that we have for functors are that you have a product of
 two functions and that's a function same for filterable sum of two functions
 is a function same for filterable composition of any factor and the filterable
 factor is filterable now this is not necessarily Tolcher well this has
 to be so if you compose them then it's filterable this is a construction
 that's specific to fill troubles and this is a functor that needs to be
 filter ball already and then you can do this and you again get a filterable
 factor so notice we can replace this one with a pointed type so we can
 do this a pointed type is basically something that's that has an element
 that's selected somehow so we could imagine that this is isomorphic to
 a disjunction of either you have that selected element which is represented
 by this part of the disjunction or you do not or your value is not that
 selected value and then your in this part of the disjunction so all the
 values that are not selected are in this type Z somehow defined and the
 selected value is represented by this unit so this is an isomorphism that
 you could imagine not necessarily very useful as a morphism but you can
 imagine that this is one plus Z and then this is one plus something so
 one plus something as a as a rule is filterable similarly you could do
 mini-mini so how do you how do you filter this if a passes then you filter
 this and you are still in the same part of the disjunction if it does not
 pass your return unit you ignore that you just drop from those now so a
 recursive filter will functor we had an example where this was I believe
 a unit or something but if G is filterable then you can add this and this
 is a recursive function that looks like a list a little bit except that
 the empty list is not empty but this G and then you have a and then again
 a and then again a and and some G so this is a list like functor and it
 is filterable in the same way that lists are and the final construction
 is that you take some country factor which has to be filterable as well
 and that function gives you a filterable factor here's an example of something
 that's not filterable again if you have them even if this is filter rule
 this is not filterable and so this entire thing is not filtered back so
 let us look at some of these constructions in detail and see how the laws
 can be satisfied so take the construction of product if the laws hold for
 the two factors so they are both vulnerable then let's do F map opt how
 do we define F map opt for the product factor so we have F map opt for
 the F and F map opt for the G we have them and now we need to define a
 map opt for F G so we define that by taking the product of the two values
 one was type F a another of type Q and G a and we do F map opt on both
 of them separately obviously that's an easy way of doing it the identity
 law calls because it holds for the two as my box F and G and therefore
 we have a product of identity of P and identity of key as being composition
 law holds because the composition acts separately on P and Q and so we
 have composition of 2f map opts F and tulip earth map opens G separately
 so these are we are not mixing up P and Q so let me pop F only X on P and
 F map up G only X and Q so when you're mixing it up and so the composition
 act separately on the two parts of the conjunction on the product and therefore
 the lowest hold now we can transform each composition using its own law
 this must be again diamond opt I forgot the subscript here and finally
 we get what the law for the product function notice this is exactly the
 same proof as for the functor property if you look at the chapter four
 we we have the same construction for product of two factors being a factor
 and the proof for the two laws of factor is exactly the same except for
 the diamonds and these other notation F map opt instead of F map otherwise
 it's exactly the same computation one-to-one why is this it's because in
 category theory F map opt response to this generalized functor between
 a twisted class three category nicely opt category which is kind of twisted
 and the functions on the container and so because it is a fun treat has
 exactly the same properties of any factor once we define it that way all
 the proofs remain literally the same except for notation new proofs therefore
 are necessary only when using non filterable functors when we cannot represent
 all the factors in our construction as filterable which is constructions
 four to six in constructions four to six son functor is not filterable
 like this one and this one and in this construction France and they're
 both filterable and so in the category Theory formulation that would be
 just functor so that would be exactly the same proof as that this is a
 functor if this is a country furniture and this as a function so we don't
 really want to repeat the same proofs and just putting in some new diamonds
 and so on we want to look at proofs for new interesting properties here's
 the property that lost hold for this type if they hold for GF so how do
 we define the map opt F map opt act on this disjunction if the argument
 is in the right part of the disjunction of this form then we return the
 right part and or if there are if not only if the argument is in the right
 part in the disjunction but also if the function f acting on a is in the
 right part of its disjunction so this is there are these two conditions
 if these two conditions hold then we'll return the right part of the disjunctio
n which is we return this B that was transformed from a and we transform
 the Q in using its own F map opt otherwise we return the left part of the
 disjunction so that is how we define the F map opt I remind you F map opt
 takes a function that transforms and filters at the same so this function
 could give you a left the left part of the disjunction the empty option
 or it could give you a newbie new value so if it gives you a new value
 then on only then will return the right part of the junction with this
 new value because we're it's supposed to return FB so we need to return
 one plus B times G B and so we return b times the f map opt and the g filter
 will factor now we check that identity law holds is straightforward we
 take F in this definition to be the identity in the closely I hoped category
 so then I'm saying category just to get familiar with that terminology
 all I mean here is that this is a function of type a to one plus a and
 mean nothing else and we know that functions of type a to 1 plus B have
 the property of this twisted composition and they have this twisted identity
 and that's what we that's all we know but that's what it means when I say
 it's class like adding or it's these functions of these funny types that
 have this funny composition so taking F here to be the flyest identity
 we find that F of a is f of a is by definition 0 plus a by definition of
 this and so f map of the graph is identity by the identity law in the G
 not supposed to hold and if we put it in then 1 goes to 1 and a times Q
 goes into a times Q so that gives you identity composition law we only
 need to check that if the argument is of this type and only when all the
 functions return the right hand side because if if even one of the arguments
 in the composition returns less inside anywhere then the entire thing was
 going to return left-hand side and then all laws will hold because there
 will be none it was none in all laws so the only non-trivial case that
 needs to be checked is that everything is in the right side of the disjunctions
 in that case the conjunction also is in the right side and then we need
 to check what happens with this thing and of course that's that's really
 easy because everything is just working on this right-hand side F map opt
 of this is by definition that and we again apply F math opt and we again
 have some C which we assume this everything then we'll the right hand side
 then we have composition of F math opts in the GE filter we'll factor that
 has its own law so we transform it like this and finally we get the F map
 opt for F from the composition of the functions on the right side of the
 disjunction so the interpretation of this filter is that it's kind of greedy
 if if a does not pass the test and all the data here is deleted even if
 they all pass the test the a is kind of very very special and if that only
 if the a passes the test and we filter this and see if any of those pass
 the test but if a it does not pass we return one so this is kind of a Brady
 filter so now I've shown that its laws hold let me actually look at some
 code see if I have oh yeah it's nicely up category and we have seen this
 and [Music] yeah this is in implementing filterable typeclass using the
 flatten instead of instead of a filter and this is just the check letitia's
 satisfying the wall so let me go to my worked examples for this chapter
 so these examples show you that sums and products and all filter balls
 are filterable so here I have an implicit def that produces an evidence
 for functor given the two factors F and G so that is done using a type
 lambda here and then I'll just do the laps on the factors in the usual
 way the Sun is the either and I say that if I have F and G functors and
 I have a functor instance for either FG so that's trivial the fermentation
 here and I do very similar very trivial implementation using deflate very
 easy to do because of its type signature and I show that if F and G are
 filterable and if there are factors at the same time says syntax in Scala
 is like this : filter book : function and I have both evidence values then
 I produce a filterable for this type constructor which is a type lambda
 which is a product of F and G and I do the same with yourself so the implementa
tion of deflate is particularly easy I'm given a tuple of F option AG option
 a I'm supposed to return a tuple of f AG and that's easy I just deflate
 both of them separately similarly with the either and given to an either
 of a function AG option a I'm supposed to return either of FNG a and I
 just match and deflate separately and I can wear this red did I change
 maybe maybe I need to refresh this because the tests tests passed I check
 the laws I have some data and I use the borders now the orders to is the
 tuple of two orders and orders easy either of two orders so I use the orders
 and then the filterable instance for orders is already defined and then
 I have already filterable for orders to in order Z and here is the code
 for the construction of functor construction v where I have a functor Jeep
 which is filterable so first I say that the function f that I define like
 this so F of a equals one was a G okay first of all I need to show this
 has a functor instance given that G has one so that is straightforward
 I need to do this option map and so on and I do the same with deflate so
 if G has a filterable and functor instance then I produce a new evidence
 for filterable instance for the type lambda which is this and the code
 is simple kind because of the signature of that option of optional a G
 of option a and I'm supposed to return an option of a G of a so I just
 met on the option and flattened and I'm sorry deflate cannot swallow here
 I have to deflate as deflate is an arbitrary function G and then I use
 flat map on the option because this is an option type so I use the standard
 flat map on it so that's basically it and see what was was changed not
 sure what was changed now let's check it after this recording just to make
 sure everything compiles if I find anything I'll make a patch and upload
 it the next example is the recursive construction where you define a new
 factor with Perceval using an already existing filterable factor G and
 you're adding a new data item and again an instance of recursive function
 so this is like a list except in the list this would be a unit and now
 here we put a unit is filterable trivially now we put an arbitrary filterable
 here so an interesting thing about deriving this law is that the proof
 must be inductive because the type is recursive so given a function f from
 a to it 1 plus B we have the F map opt for the filterable function G so
 we have that and also we have F map opt for F which is the inductive assumption
 so I use it I use the prime here to show that this F map opt is not the
 one we are going to define but it's the one that we already assumed to
 exist and to satisfy the laws in the previous inductive step so this is
 the inductive assumption that's how we're going to derive the laws we're
 going to say if this F map opt is already satisfying the laws and we will
 only use it when we call the recursive F map opt in the definition of this
 function filterable functor and so when we use the recursive code we're
 allowed to use this recursive definition which already is assumed to satisfy
 all laws but then we prove that the definition of the next step satisfies
 the laws so here's the definition we define f map opt by first of all looking
 at f of a so first of all if we're in the queue then we just return if
 we're in the left side of this disjunction we just return the F map of
 G applied to this so there's not much to do if we are in this part of the
 disjunction then we need to check whether F of a is in the left or in the
 right if it's in the left then actually we do an interesting thing so if
 this does not pass the filter then we we can't return this because we don't
 have a value of Q of type G we return this filtered so so we descend into
 the recursive instance we discard this a this a with this card and we return
 this filtered this P filtered using the recursive instance of F map opt
 so we call ourselves we call this function that will derive defining now
 on this P and we return the result why is this valid it's because the type
 is recursive so when we return that that will be of type FB and that's
 exactly what we are supposed to return because this type is the same as
 this entire type this entire disjunction is the same as this so we are
 allowed to return it in there in the core otherwise we so if F of a is
 some be in the right side then we return this B times again the recursive
 filter result of this so we can return the right-hand side of this disjunction
 which is fine we can return the left-hand side of this disjunction if we
 have a Q or we can return only this piece after filtering because the type
 of this piece is the same as the entire type by the recursive definition
 so this is a definition of F nap opt of F let me show you the code to perhaps
 make it more clear how the recursive thing works so here is a definition
 of this construction using the type constructor c6 it's paralyzed by filterable
 function G and type a so then you have this disjunction so this is this
 disjunction the left side has a G a on the right side has a product of
 a and FA which is itself of the same type c6 so this defines this construction
 so now we have a convenient place to put all the implicit for this type
 and Scala allows you to have a object with the same name as a type constructor
 and if you put implicit into that object then whenever you use the type
 constructor these implicit are visible you don't have to include them yourself
 or import them yourself that's very convenient but saves you typing and
 looking for where these employees must be and so here we put a functor
 instance assuming that G is a factor and the filterable instance assuming
 that G is both filterable and fund although the filterable typeclass requires
 function so we could have just gotten the functor evidence out of filterable
 evidence but it's just for convenience to have both and now let's look
 at the code the both the functor instance and the filterable instance must
 be recursive because it's at a corrosive type so the map function takes
 a c6 of GA so a function from A to B and returns a c6 of GB so there are
 two cases the base case you just map a GA which should be fun to play assumptio
n and note that this dot map syntax is available because cats library allows
 you to do this with simple input which I believe is just import cats syntax
 functor dot underscore so I can just use this syntax easily anything that's
 declared as a factor and the step I have two values X and s x fa the recursive
 value of c6 so I apply F to X and I map which is the same map here and
 map recursively and the function f over this thing same thing I have to
 do with the flight I have to probably have a base I can do flight that
 if there is a step that means I have two values here both of them are type
 option and I need to deflate the first of all and the second so the first
 if the first is not empty it means that in this type this a passed the
 test so note that in the slide I had F map opt define but here I have flat
 undefined because it's easier but it's the same thing I need to decide
 what to do when this passes the test or doesn't if it passes the test I
 return that thing deflated and I deflate the other part this part recursively
 so this is the recursive call of this to the same function and if the pay
 is not passing the test if this option is empty then I need to deflate
 this recursive value and return its it deflated alone so that has the same
 type as the entire functor and that's why I - return the 20s so just to
 make a correspondence between what I have in the slides and what I have
 here in the code it is easier to implement flatten sorry deflate it's easier
 to implement deflate then it is to implement F map opt or map option or
 anything like that but it is equivalent so all the decisions we make when
 we implement f na opt are made here exactly the same way we need to flatten
 sorry to deflate G of option A plus option a times F of option and so every
 option needs to give us a decision how to flat deflate it into a non option
 type so in our FF definition we had exactly the same exactly the same question
 how to define the result of F map opt when this is given or when this is
 given and the result of F is in the left and some one so then we check
 identity law and the composition law so identity law it's easy to check
 because the identity function never returns an empty option so we're never
 in this case and therefore either we are here and we return the flattened
 queue the deflated queue which is just the same for identity or we on the
 right and then we have a times P and then we just return the same because
 a recursive instance of if map opt already satisfies the identity law and
 so when we when we apply that to P we get P identity so in this way we
 use induction plane mathematical induction to show that laws hold the compositi
on law holds in the same way so we need to show this holds now if the arguments
 are in the left then it's just about a loss for DNA which are holding by
 assumption if the arguments are in the right in here then we need to look
 at what's happening so we have F 1 and F 2 and there are four cases so
 well either if both of them returned in all empty then the previous proof
 will go through this one it's exactly the same so we need to consider the
 cases when one of them returns non-empty if the first one returns empty
 then we are returning the recursive instance so there is nothing more to
 show the second one will never be cold so we need we need actually two
 more cases only the first returns empty and the first returns non empty
 but the second returns empty so just remember to remind you decomposition
 alloys assuming two arbitrary nicely functions so a - 1 + B beta 1 plus
 C and we need to show that F map opt gives you the composition so if the
 first function returns an empty option then this also returns an empty
 option because the class decomposition is the boolean conjunction of the
 two filters so if one of them returns emptied in both conjunction also
 returns empty so then it which it remains to show so we collapse this equation
 because this is now 1 + 0 so we can use that face fruit for the right-hand
 side we need to show this and that is just the inductive assumption for
 left my post prime so if we are always in during inductive case we don't
 want to prove any further it remains to show this case again the composition
 is empty so it remains to show that the F map opt applied to this and is
 equal to F map opt prime because we are in the case of + 1 + 0 so there
 is nothing else to do and we rewrite this and we again get just the inductive
 assumption so this being equal to list so this filter is really lists like
 if this is empty we we go into the nested data structure so if you expand
 this recursive type it looks like GA plus 8 times open parenthesis GA plus
 8 times opening other parenthesis and so on so it's it's then expanded
 into GA plus 8 times J plus a times a times G a and so on so if 1a is empty
 you can always delete it and you are still in the disjunction it just recurse
 into the nested fa and they were still in in the disjunction so this is
 exactly like filter on the list the final marked example is is this one
 this is a bit interesting so here's what we have we have a big type expression
 how can we show that this is filter or order that is not it looks a lot
 of like lot of work you have to write a lot of code and then check laws
 and what if you implement it and then laws don't hold where did you make
 a mistake oh that is a lot of work so instead of trying to do that we will
 analyze the structure of this data type and use these constructions constructio
ns that are listed here and try to see if we can decompose this type expression
 into these constructions so let's look at it first of all we have this
 int time string going to this big thing okay let's denote in time string
 going to able to denote this by r1 a and also we have this int going to
 big expression so let's call this R to a inte going to a then we have one
 plus int of a instance a plus int times 1 plus 6 there's this big piece
 and after that big piece is this function type so the function type contains
 that so now we can rewrite it like that so it's r1 applied to the type
 GA plus r2 applied to AJ so that's great ga is filterable by so what is
 Jia is this it is filterable because it has type 1 plus a times something
 right we can make this a we can put it outside brackets and then you have
 1 plus a times int plus 1 plus a so n plus 1 plus a is let's call it K
 and that is filterable because it's of the form 1 plus a plus constant
 and that gives us filter rule by constructions 1 and 3 is a constant is
 construction 1 and the construction of 3 is the sum of 2 filter balls so
 constant is filterable and 1 plus a is option filterable of course so therefore
 K is filter mo therefore this is federal H is filter ball by the same construct
ion v again because 1 plus a time string is filterable by constructions
 5 and 1 so we can see this is constant so it's filterable then it's 1 plus
 a times filter which is construction v this is again construction v so
 H is filterable DS filterable and then we have so r2 of H a is a composition
 of two functions with the compositional factor r2 which is this and filterable
 so that's filterable then we have a sum of filterable and filter book therefore
 this is filterable and then we have a composition of a factor doesn't have
 to be full turbo in that construction and the filter wall so that's that's
 all we just looked at the types and we use this see in this construction
 the factor does not have to be filterable outside so this doesn't have
 to be filtered this doesn't have to be filterable these functions are just
 whatever functions we want this is filter ball and this is filterable and
 we're done so we have shown and also of course each construction comes
 with specific code that you can use to implement the filter walls and so
 you don't have to worry about it anymore you can just follow these these
 constructions you can write general library that will implement all of
 these constructions as implicit and you just call the functions from this
 line but you want something you get it and implicit will be found automatically
 so one important comment at this point is that first of all these constructions
 are not the only ones available and second there are more than one ways
 there's more than one way of implementing the filterable certainly this
 is one a valid way but there are alternatives and certain applications
 might require different alternatives so if you remember the examples from
 the previous the part 1 of this tutorial there are different business requireme
nts that might lead you to different in implementations of the filterable
 and so you can probably add more rules more constructions to this list
 but in in any case it shows you a large number of possible factors that
 can have filter ball behavior and a large number of different filterable
 behaviors such as greedy or collapsible or list like filter behavior so
 you can combine them in any way you want using these constructions here
 are some exercises for you to follow what we did and we worked examples
 and finally some bonus about filterable control factors so until now we
 were dealing only with filterable functions but actually filterable control
 factors also are interesting and could be useful and let me just conclude
 this tutorial with a discussion of filterable control factors and the discussio
n will be again modeled after the way we did we dealt with filterable factors
 first of all what are the definitions and laws how do you define filterable
 control factors so the filter functions have the same signature for country
 functions and for fun clips the there is instead of deflator than there
 is inflate which goes the opposite way and instead of F map upstairs contra
 F map opt which also goes in the opposite way so again this is a kind of
 a twisted function type it has first of all it it has reversed direction
 so B to a and here's a to b as appropriate for a control factor but also
 it has this twist with the klystron opt category just like the content
 ma opt all these functions are computation like we want you can express
 each of them through any other so for example filter through inflate contra
 F map is standard for contra factor so if you have country factor you can
 express filter through inflate inflate through filter control app opted
 to inflate inflate through contrast map opt in very much the same way as
 we expressed and for all four factors they have different laws for laws
 for filter 3los translate to laws for contract map opt and as before contract
 map opt is just kind of a twisted lifting what are examples of filterable
 country factors so here some from a 2 1 plus Z where Z is a fixed constant
 type from 1 plus a 2 Z or again C is any constant type what is a non filterable
 country function for example this where F is whatever you cannot implement
 inflate for it because what to implement inflate you have to transform
 this into a sea of 1 plus a which means the function that consumes UCC
 a is a function that consumes a and other stuff C 1 plus a is a function
 that consumes 1 plus a and other stuff to construct that function it means
 that you should be able to consume 1 that is a unit and go on and other
 stuff and go on but you don't have that you only have a function that consumes
 a and other stuff so you're required to consume a we cannot implement inflate
 so this gives us some intuition about what filterable country functors
 do first of all let's recall the main visual image of what frontiers and
 country functions do factors hold data a fonder F away in some sense it
 holds data of type a and allows you to manipulate that data a contra functor
 CA in some sense it consumes data of type a it does not actually have any
 data of type a inside it consumes it like these examples it is a function
 that consumes data of type a or some other type related to a so a contra
 functor wants you to give it one or more items of type a and then it will
 consume them and give you something else which is not a a filterable country
 functor is able to consume fewer data items of type a if you filter a country
 functor by a condition it means you prevent it from consuming some data
 that does not pass a test in other words let's say it's such a consumer
 that it is able to consume less it is able to refrain from consuming certain
 items a function of this type let's take a simpler example a twosie with
 this arbitrary factor being just unit a to Z is a function that requires
 you to give it an A it cannot refrain from consuming an a there's no way
 for it to not consume an A this function on the other hand can do it if
 you don't give it an A there is this part of the disjunction and the function
 can take that and produce a Z so this contra factor is able to refrain
 from consuming certain values and still give you the result but this functor
 is not able to do that and so it this contra factor is not filterable for
 this reason so this is the interpretation that it can consume fewer data
 items if necessary by filtering them out and the easiest function again
 is inflate so consider that function and try to implement it here are some
 constructions some analogous to filter both under constructions first of
 all a constant control factor with identity filter then the functor constructio
ns which are exactly analogous to functor you don't need to check any laws
 therefore really if g and h AR filter will control factors then the product
 is filterable control factor their sum and the composition like this is
 a filterable control enter and here you have different combinations you
 can have a functor of a control function you could have a contra functor
 of a function or you could have control factor of contra factor the result
 will be a factor again filterable you can do this of course if they're
 both filterable this is a factor this is a control function and contravariance
 is here on the left sorry covariance is on the left of the arrow so it
 becomes contravariant and so this is a contra factor if they're both filter
 button this is also filterable that is quite easy to show all of this it's
 just analogous because the laws are the functor laws it's just a twist
 and the twist is irrelevant for these constructions the twist just remains
 the same in all computations so whatever twist you have on the type the
 proofs remain the same for the factor construction now there are special
 constructions where you have to deal with the twisted type I will not go
 through the proofs of these but just to mention two of them so if you have
 this type then you can filter because you can refrain from consuming this
 a because you have the unit you can consume unit and here you cannot refrain
 from consuming any but if there are no a is given you can return one you
 can always return one how do you filter a control function well you just
 give it before you give it the data you filter it out so you give it less
 data and the Contra factors should be able to handle that if it is filterable
 it should be able to consume less data so that's the intuition behind it
 and I'm not going to go a lot into detail for but for country functions
 because so far haven't seen a lot of obvious applications for them but
 certainly there might be some this concludes chapter 6 or the functional
 programming tutorial 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
