#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[What I learned about FP]{What I learned about functional programming}
\subtitle{while writing a book about it}
\author{Sergei Winitzki}
\date{2021-10-28}
\institute[SBTB]{Scale by the Bay 2021}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\usepackage[nocenter]{qtree}
\usepackage{relsize}
\renewcommand\arraystretch{1.4}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why I wrote a book about functional programming.
 I
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
My background: theoretical physics
\end_layout

\begin_layout Itemize
I used to write academic publications looking like this:
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Winitzki - physics paper - sample page.png
	lyxscale 40
	width 40col%

\end_inset


\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Itemize
Repented and turned to software engineering in 2010
\end_layout

\begin_layout Standard
I have been studying FP since 2008 (OCaml, Haskell, Scala)
\end_layout

\begin_layout Itemize
Learning from papers, online tutorials, and books
\end_layout

\begin_layout Itemize
Attending the SBTB conference since 2014
\end_layout

\begin_layout Itemize
Using Scala at my day job since 2015
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why I wrote a book about functional programming.
 II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
I found the FP community to be unlike other programmers' communities
\end_layout

\begin_layout Itemize
Others are focused on a chosen programming language (Java, Python, JavaScript,
 etc.), and on designing and using libraries and frameworks
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
\begin_inset Quotes eld
\end_inset

setup this YAML config, override this method, use this annotation
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The FP community talks in a very different way
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
\begin_inset Quotes eld
\end_inset

referential transparency, algebraic data types, monoid laws, parametric
 polymorphism, free applicative functors, monad transformers, Yoneda lemma,
 Curry-Howard isomorphism, profunctor lenses, catamorphisms
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "A glossary of FP terminology"
target "https://degoes.net/articles/fp-glossary"
literal "false"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
From SBTB 2018: 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "The Functor,  Applicative,  Monad talk"
target "https://www.youtube.com/watch?v=L0aYcq1tqMo"
literal "false"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
By 2018, everyone expects to hear these concepts mentioned
\end_layout

\end_deeper
\begin_layout Itemize
An 
\begin_inset CommandInset href
LatexCommand href
name "actual Scala error message"
target "https://stackoverflow.com/questions/36002541/mysterious-gadt-skolem-what-type-is-trying-to-escape-its-scope"
literal "false"

\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

found   : Seq[Some[V]]
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

required: Seq[Option[?V8]] where type ?V8 <: V (this is a GADT skolem)
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why I wrote a book about functional programming.
 III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Main questions:
\end_layout

\begin_layout Itemize
Which theoretical knowledge will actually help write Scala code?
\end_layout

\begin_layout Itemize
Where can one learn about this, with definitions and examples?
\end_layout

\begin_layout Standard
What I did 
\emph on
not
\emph default
 want to see:
\end_layout

\begin_layout Itemize
Theory for the sake of theory, with no applications
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Monad is just a monoid in the category of endofunctors"
target "https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Lawvere theories"
target "https://bartoszmilewski.com/2017/08/26/lawvere-theories/"
literal "false"

\end_inset

 as an alternative to monads
\end_layout

\begin_layout Itemize

\emph on
\begin_inset CommandInset href
LatexCommand href
name "The Book of Monads"
target "https://www.amazon.com/Book-Monads-Alejandro-Serrano-Mena/dp/0578405296"
literal "false"

\end_inset


\emph default
: 
\begin_inset Quotes eld
\end_inset

monads from adjunctions
\begin_inset Quotes erd
\end_inset

 are never used
\end_layout

\end_deeper
\begin_layout Itemize
Heuristic explanations without proofs
\end_layout

\begin_deeper
\begin_layout Itemize
Most FP books have no proofs and few rigorous definitions
\end_layout

\begin_layout Itemize
A couple of books (
\emph on

\begin_inset CommandInset href
LatexCommand href
name "Introduction to functional programming using Haskell"
target "https://www.amazon.co.uk/Introduction-Functional-Programming-Prentice-Hall-Paperback/dp/B00OVNLJTS/"
literal "false"

\end_inset


\emph default
 and 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "Functional programming in Scala"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset


\emph default
) include only a few simplest proofs
\end_layout

\begin_layout Itemize
Even 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "The Book of Monads"
target "https://www.amazon.com/Book-Monads-Alejandro-Serrano-Mena/dp/0578405296"
literal "false"

\end_inset


\emph default
 does not prove the laws for any monads!
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why I wrote a book about functional programming.
 IV
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Reading various materials has given me more questions than answers
\end_layout

\begin_layout Itemize
Monads
\end_layout

\begin_deeper
\begin_layout Itemize
P.
\begin_inset space ~
\end_inset

Wadler, 
\begin_inset Quotes eld
\end_inset


\emph on

\begin_inset CommandInset href
LatexCommand href
name "Monads for functional programming"
target "https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf"
literal "false"

\end_inset


\emph default

\begin_inset Quotes erd
\end_inset

 (1995)
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename wadler-excerpt.png
	lyxscale 40
	width 60col%

\end_inset


\begin_inset VSpace -40baselineskip%
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia"
target "https://en.wikipedia.org/wiki/Monad_(functional_programming)"
literal "false"

\end_inset

: 
\emph on
In functional programming, a monad is an abstraction that allows structuring
 programs generically.
 ...
 Category theory also provides a few formal requirements, known as the monad
 laws, which should be satisfied by any monad and can be used to verify
 monadic code.
\end_layout

\end_deeper
\begin_layout Standard
Cannot understand this
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why I wrote a book about functional programming.
 V
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Reading various materials has given me more questions than answers
\end_layout

\begin_layout Itemize
Applicative functors
\end_layout

\begin_deeper
\begin_layout Itemize
P.
\begin_inset space ~
\end_inset

Chuisano and R.
\begin_inset space ~
\end_inset

Bjarnason,
\emph on
 
\begin_inset CommandInset href
LatexCommand href
name "Functional programming in Scala"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename fpis-excerpt.png
	lyxscale 40
	width 45col%

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia"
target "https://en.wikipedia.org/wiki/Applicative_functor"
literal "false"

\end_inset

: 
\emph on
In functional programming, an applicative functor ...
 is an intermediate structure between functors and monads.
 ...
 Applicative functors are the programming equivalent of lax monoidal functors
 with tensorial strength in category theory.

\emph default
 
\end_layout

\end_deeper
\begin_layout Standard
Cannot understand this
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why I wrote a book about functional programming.
 VI
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Reading various materials has given me more questions than answers
\end_layout

\begin_layout Itemize
Free monads
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
\begin_inset CommandInset href
LatexCommand href
name "Functional programming in Scala"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset


\emph default
: 
\emph on
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Return
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FlatMap
\end_layout

\end_inset

 constructors witness that this data type is a monad for any choice of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

, and since they’re exactly the operations required to generate a monad,
 we say that it’s a free monad.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia"
target "https://en.wikipedia.org/wiki/Monad_(functional_programming)#Free_monads"
literal "false"

\end_inset

: 
\emph on
Sometimes, the general outline of a monad may be useful, but no simple pattern
 recommends one monad or another.
 This is where a free monad comes in; as a free object in the category of
 monads, it can represent monadic structure without any specific constraints
 beyond the monad laws themselves.
 ...
 For example, by working entirely through the Just and Nothing markers,
 the Maybe monad is in fact a free monad.
\end_layout

\begin_layout Itemize
Three different implementations of the free monad: a 
\begin_inset CommandInset href
LatexCommand href
name "blog post"
target "http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html"
literal "false"

\end_inset

 by Gabriel Gonzalez (2012), a 
\begin_inset CommandInset href
LatexCommand href
name "talk"
target "http://functionaltalks.org/2014/11/23/runar-oli-bjarnason-free-monad/"
literal "false"

\end_inset

 given by Rúnar Bjarnason (2014), and a 
\begin_inset CommandInset href
LatexCommand href
name "talk"
target "https://www.slideshare.net/KelleyRobinson1/why-the-free-monad-isnt-free-61836547"
literal "false"

\end_inset

 given by Kelley Robinson (2016) — but no rigorous definitions
\end_layout

\begin_layout Standard
Cannot understand this
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why I wrote a book about functional programming.
 VII
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Most resources for modern FP are either too academic or too limited to questions
 of practical usage
\end_layout

\begin_layout Itemize
But see 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Haskell Wikibooks"
target "https://en.wikibooks.org/wiki/Haskell"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Functional Programming in Scala"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
After several years of study, I found 
\emph on
systematic
\emph default
 ways of:
\end_layout

\begin_layout Itemize
finding the practice-relevant parts of FP theory
\end_layout

\begin_layout Itemize
organizing the required knowledge
\end_layout

\begin_layout Itemize
verifying theoretical statements through mathematical derivations
\end_layout

\begin_layout Standard
Then I wrote a new book to answer all my FP questions
\end_layout

\begin_layout Standard

\size small
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "78col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -40baselineskip%
\end_inset

The book explains (with code examples and exercises):
\end_layout

\begin_layout Itemize
theory and applications of major design patterns of FP
\end_layout

\begin_layout Itemize
techniques for deriving and verifying properties of types and code (typeclass
 laws, equivalence of types)
\end_layout

\begin_layout Itemize
practical motivations for (and applications of) these techniques
\end_layout

\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "27col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename book-draft-cover.png
	lyxscale 20
	width 2.5cm

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 I.
 Questions that have rigorous answers
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
In FP, a programmer encounters certain questions about code that can be
 answered rigorously 
\end_layout

\begin_layout Itemize
The answers are 
\emph on
not
\emph default
 a matter of opinion or experience
\end_layout

\begin_layout Itemize
The answers are found via mathematical derivations and reasoning
\end_layout

\begin_layout Itemize
The answers will help the programmer in designing the code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of reasoning tasks.
 I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{0}
\end_layout

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Are the types 
\family typewriter
\size footnotesize
\color blue
Either[Z, R => A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
R => Either[Z, A]
\family default
\size default
\color inherit
 equivalent? Can we compute a value of type 
\family typewriter
\size footnotesize
\color blue
Either[Z, R => A]
\family default
\size default
\color inherit
 given a value of type 
\family typewriter
\size footnotesize
\color blue
R => Either[Z, A]
\family default
\size default
\color inherit
 and conversely? (
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
R
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 are type parameters.)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f[Z, R, A](r: R => Either[Z, A]): Either[Z, R => A] = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def g[Z, R, A](e: Either[Z, R => A]): R => Either[Z, A] = ???
\end_layout

\begin_layout Itemize
It turns out that 
\family typewriter
\size footnotesize
\color blue
f
\family default
\size default
\color inherit
 
\emph on
cannot
\emph default
 be implemented, while 
\family typewriter
\size footnotesize
\color blue
g
\family default
\size default
\color inherit
 can be:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def g[Z, R, A](e: Either[Z, R => A]): R => Either[Z, A] =
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  r => e.map(f => f(r))       // 
\family default
\color inherit
Scala 2.12
\end_layout

\begin_layout Itemize
Programmers need to develop intuition about why this is so
\end_layout

\begin_layout Itemize
These results are rigorous (programmers do not need to write tests)
\end_layout

\begin_deeper
\begin_layout Itemize
The Curry-Howard isomorphism and the LJT algorithm
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of reasoning tasks.
 II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{1}
\end_layout

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
How to use 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
 with 
\family typewriter
\size footnotesize
\color blue
Either[Z, A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Future[A]
\family default
\size default
\color inherit
 together?
\end_layout

\begin_layout LyX-Code

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\family typewriter
\color blue
val result = for { // This code will not compile; we want to have...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  a <- Future(...) // ...
 a computation that is run asynchronously,
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  b <- Either(...) // a computation whose result may be unavailable,
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  c <- Future(...) // a computation that is run asynchronously.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield ??? // Continue computations when results are available.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space \hspace*{}
\length 1.8mm
\end_inset

Should 
\family typewriter
\size footnotesize
\color blue
result
\family default
\size default
\color inherit
 have type 
\family typewriter
\size footnotesize
\color blue
Either[Z, Future[A]]
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
Future[Either[Z,A]]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space \hspace*{}
\length 1.8mm
\end_inset

How to combine 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 with 
\family typewriter
\size footnotesize
\color blue
Future 
\family default
\size default
\color inherit
so that we can use 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Itemize
It turns out that 
\family typewriter
\size footnotesize
\color blue
Either[Z, Future[A]]
\family default
\size default
\color inherit
 is wrong (cannot implement 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 correctly).
 The correct solution is 
\family typewriter
\size footnotesize
\color blue
Future[Either[Z, A]]
\end_layout

\begin_layout Itemize
Programmers need to develop intuition about why this is so
\end_layout

\begin_layout Itemize
This is a rigorous result (programmers do not need to test it)
\end_layout

\begin_deeper
\begin_layout Itemize
The theory of monad transformers and their laws
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of reasoning tasks.
 III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{2}
\end_layout

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Can we implement 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 for the type constructor 
\family typewriter
\size footnotesize
\color blue
Option[(A, A, A)]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def flatMap[A, B](fa: Option[(A, A, A)])(f: A => Option[(B, B, B)])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   : Option[(B, B, B)] = ???
\end_layout

\begin_layout Itemize
It turns out that 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 
\emph on
can
\emph default
 be implemented but fails the monad laws
\end_layout

\begin_layout Itemize
Programmers need to develop intuition about why this is so
\end_layout

\begin_deeper
\begin_layout Itemize
How should we modify 
\family typewriter
\size footnotesize
\color blue
Option[(A, A, A)]
\family default
\size default
\color inherit
 to make it into a monad?
\end_layout

\end_deeper
\begin_layout Itemize
This is a rigorous result (programmers do not need to test it)
\end_layout

\begin_deeper
\begin_layout Itemize
The theory of monads and their laws
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of reasoning tasks.
 IV
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{4}
\end_layout

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Different people define a 
\begin_inset Quotes eld
\end_inset

free monad
\begin_inset Quotes erd
\end_inset

 via different sets of case classes.
 Are these definitions equivalent? What is the difference?
\end_layout

\begin_layout Enumerate
How to define a free monad on a 
\family typewriter
\size footnotesize
\color blue
Pointed
\family default
\size default
\color inherit
 functor (i.e.,
\begin_inset space ~
\end_inset

when the functor already has the 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 method)?
\end_layout

\begin_layout Itemize
The free monad on a functor is less code than the free monad on a non-functor
\end_layout

\begin_layout Itemize
The free monad's encoding that assumes the monad laws is less code than
 an encoding without assumed laws
\end_layout

\begin_layout Itemize
Programmers need to develop intuition about how to implement them
\end_layout

\begin_layout Itemize
This is a rigorous result (programmers do not need to test it)
\end_layout

\begin_deeper
\begin_layout Itemize
The theory of 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 inductive typeclasses and their encodings
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 I.
 Questions that have rigorous answers
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
FP allows programmers to ask and rigorously answer questions like these
\emph on
 while writing code
\end_layout

\begin_layout Itemize
In this aspect of the programmer's work, it is 
\emph on
engineering
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 II.
 Software engineers and software artisans
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
FP is similar to engineering in a number of ways
\end_layout

\begin_deeper
\begin_layout Itemize
Mechanical, electrical, chemical engineering are based on calculus, classical
 and quantum mechanics, electrodynamics, thermodynamics
\end_layout

\begin_layout Itemize
FP is based on category theory, type theory, logic proof theory
\end_layout

\end_deeper
\begin_layout Itemize
Engineers use special terminology
\end_layout

\begin_deeper
\begin_layout Itemize
Examples from mechanical, electrical, chemical engineering: 
\begin_inset CommandInset href
LatexCommand href
name "rank-4 tensors"
target "https://serc.carleton.edu/NAGTWorkshops/mineralogy/mineral_physics/tensors.html"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Lagrangians with non-holonomic constraints"
target "https://arxiv.org/abs/math/0008147"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Fourier transform of the delta function"
target "https://www.youtube.com/watch?v=KAbqISZ6SHQ"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "inverse Z-transform"
target "https://ocw.mit.edu/resources/res-6-008-digital-signal-processing-spring-2011/video-lectures/lecture-6-the-inverse-z-transform/"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Gibbs free energy"
target "https://www.amazon.com/Introduction-Chemical-Engineering-Kinetics-Reactor/dp/1118368258"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
Examples from FP: 
\begin_inset CommandInset href
LatexCommand href
name "rank-$N$ types"
target "https://wiki.haskell.org/Rank-N_types"
literal "true"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "continuation-passing transformation"
target "https://www.cs.toronto.edu/~lczhang/324/ex/a2.pdf"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "polymorphic lambda functions"
target "https://stackoverflow.com/questions/20152939/what-is-a-polymorphic-lambda"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "free monads"
target "https://stackoverflow.com/questions/13352205/what-are-free-monads"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "hylomorphisms"
target "https://en.wikipedia.org/wiki/Hylomorphism_(computer_science)"
literal "false"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
As in engineering, the special terminology in FP is 
\emph on
not
\emph default
 self-explanatory
\end_layout

\begin_deeper
\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

lambda function
\begin_inset Quotes erd
\end_inset

? 
\end_layout

\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

free monad
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 II.
 Software engineers and software artisans
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Functional programming looks like engineering, while other approaches to
 software resemble 
\emph on
artisanship
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace -30baselineskip%
\end_inset

Books on mechanical, electrical, chemical engineering design:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Jazar. Theory of Applied Robotics 2nd edition - sample page.png
	lyxscale 20
	width 20col%

\end_inset


\begin_inset Graphics
	filename Schaum's outline of electric curcuits, 4th edition - sample page.png
	lyxscale 20
	width 20col%

\end_inset


\begin_inset Graphics
	filename Ellingson - Electromagnetics vol. 2, sample page.png
	lyxscale 20
	width 20col%

\end_inset


\begin_inset Graphics
	filename Sinnott, Tower. Chemical Engineering Design 5th edition - sample page.png
	lyxscale 20
	width 20col%

\end_inset


\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\align center
Books on software design and architecture:
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Solid software design architecture handbook - sample page.png
	lyxscale 20
	width 20col%

\end_inset


\begin_inset Graphics
	filename Clean architecture - sample page.png
	lyxscale 20
	width 16col%

\end_inset


\begin_inset Graphics
	filename Code Complete - sample page.png
	lyxscale 20
	width 14col%

\end_inset


\begin_inset Graphics
	filename Code Complete - another sample page.png
	lyxscale 20
	width 20col%

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 II.
 Software engineers and software artisans
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
Sample pages from 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "Program design by calculation"
target "https://www4.di.uminho.pt/~jno/ps/pdbc.pdf"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Standard
\align center
Sample pages from 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "The Science of Functional Programming"
target "https://leanpub.com/sofp"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 III.
 The science of 
\family typewriter
map
\family default
 / 
\family typewriter
filter
\family default
 / 
\family typewriter
reduce
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
reduce
\family default
\size default
\color inherit
 programming style — iteration without loops
\end_layout

\begin_layout Itemize
Compute the list of all integers 
\begin_inset Formula $n$
\end_inset

 between 1 and 100 that can be expressed as 
\begin_inset Formula $n=p*q$
\end_inset

 (with 
\begin_inset Formula $2\leq p\leq q$
\end_inset

) in exactly 
\begin_inset Formula $4$
\end_inset

 different ways 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> (1 to 100).filter { n =>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     |   (2 to n).count(x => n % x == 0 && x * x <= n) == 4
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     | }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
res0: IndexedSeq[Int] = Vector(36, 48, 80, 100)
\end_layout

\begin_layout Standard
The 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
reduce
\family default
\size default
\color inherit
 programming style is an FP success story
\end_layout

\begin_layout Itemize
Nameless functions (
\begin_inset Quotes eld
\end_inset

lambdas
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

closures
\begin_inset Quotes erd
\end_inset

) are widely used
\end_layout

\begin_deeper
\begin_layout Itemize
and have been added to most programming languages by now
\end_layout

\end_deeper
\begin_layout Itemize
Essential methods: 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\end_layout

\begin_layout Itemize
Similar techniques work with parallel and stream processing (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Spark
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
Similar techniques work with relational databases (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Slick
\end_layout

\end_inset

) 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 III.
 The science of 
\family typewriter
map
\family default
 / 
\family typewriter
filter
\family default
 / 
\family typewriter
reduce
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Essential methods: 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\end_layout

\begin_layout Itemize
What data types other than 
\family typewriter
\size footnotesize
\color blue
Seq[A]
\family default
\size default
\color inherit
 can support these methods?
\end_layout

\begin_deeper
\begin_layout Itemize
Algebraic data types?
\end_layout

\begin_layout Itemize
Trees and other recursive types? 
\end_layout

\begin_layout Itemize
Perfect-shaped trees? 
\begin_inset Preview

\begin_layout Standard

\size scriptsize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] [ [ [ $a_5$ ]
 [ $a_6$ ] ] [ [ $a_7$ ] [ $a_8$ ] ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Which methods can be defined for 
\family typewriter
\size footnotesize
\color blue
MyData[A]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type MyData[A] = String => Option[(String, A)]
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 III.
 The science of 
\family typewriter
map
\family default
 / 
\family typewriter
filter
\family default
 / 
\family typewriter
reduce
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A systematic approach to understanding 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
reduce
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
Determine the required laws of 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\end_layout

\begin_deeper
\begin_layout Itemize
The laws express the programmers' expectations about code behavior
\end_layout

\begin_layout Itemize
Define the corresponding typeclasses
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Functor
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Monad
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Applicative
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Traversable
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Find all type constructions that preserve the typeclass laws
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Q[A]
\family default
\size default
\color inherit
 are filterable functors then so is 
\family typewriter
\size footnotesize
\color blue
Either[P[A], Q[A]]
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 is a contravariant functor then 
\family typewriter
\size footnotesize
\color blue
P[A] => A
\family default
\size default
\color inherit
 is a monad
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 is a monad then so is 
\family typewriter
\size footnotesize
\color blue
Either[A, P[A]]
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Q[A]
\family default
\size default
\color inherit
 are applicative then so is 
\family typewriter
\size footnotesize
\color blue
Either[P[A], (A, Q[A])]
\end_layout

\begin_deeper
\begin_layout Itemize
I found many more type constructions of that sort
\end_layout

\end_deeper
\begin_layout Itemize
Sometimes it becomes necessary to define additional typeclasses
\end_layout

\begin_deeper
\begin_layout Itemize
Contravariant functor, contravariant filterable, contravariant applicative
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Develop intuition about implementing lawful typeclass methods 
\end_layout

\begin_layout Itemize
Develop intuition about data types that can have those methods
\end_layout

\begin_deeper
\begin_layout Itemize
...
 and about data types that 
\emph on
cannot
\emph default
 (and reasons why)
\end_layout

\end_deeper
\begin_layout Itemize
Develop proof techniques that save time when proving the laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 IV.
 The logic of types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Most of FP use cases are based on only six type constructions:
\end_layout

\begin_layout Itemize
Unit type — 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_layout Itemize
Type parameters — 
\family typewriter
\size footnotesize
\color blue
[A]
\end_layout

\begin_layout Itemize
Product types — 
\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\begin_layout Itemize
Co-product types (
\begin_inset Quotes eld
\end_inset

disjunctive union
\begin_inset Quotes erd
\end_inset

 types) — 
\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\begin_layout Itemize
Function types — 
\family typewriter
\size footnotesize
\color blue
A => B
\end_layout

\begin_layout Itemize
Recursive types — 
\family typewriter
\size footnotesize
\color blue
Fix[A, S]
\family default
\size default
\color inherit
 where 
\family typewriter
\size footnotesize
\color blue
S[_, _]
\family default
\size default
\color inherit
 is a 
\begin_inset Quotes eld
\end_inset

recursion scheme
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Fix[A, S[_, _]](unfix: S[A, Fix[A, S]])
\end_layout

\begin_layout Standard
Going through all possible type combinations, we can enumerate essentially
 all possible typeclass instances
\end_layout

\begin_layout Itemize
all possible functors, filterables, monads, applicatives, traversables,
 etc.
\end_layout

\begin_layout Itemize
in some cases, we can generate code automatically
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 IV.
 The logic of types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Unit, product, co-product, and function types correspond to logical propositions
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(true)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A and B)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A or B)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(if A then B)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Not all programming languages support all of these type constructions
\end_layout

\begin_deeper
\begin_layout Itemize
Then the logic of types is 
\emph on
incomplete
\emph default
 in those languages
\end_layout

\end_deeper
\begin_layout Itemize
Languages that do not support co-products will make you suffer
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
fileOpened, err := os.Open("filename.txt")     // go-lang has you
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
if err != nil { log.Fatal(err) }  // doomed to write this forever
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
My approach forced me to formulate and prove every statement
\end_layout

\begin_layout Itemize
Each chapter gave me at least one surprise
\end_layout

\begin_deeper
\begin_layout Itemize
What I believed and tried to prove turned out to be incorrect
\end_layout

\begin_layout Itemize
What seemed to be intuitively unexpected turned out to be true
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapters 1 to 3:
\end_layout

\begin_layout Itemize
Nameless functions are used in mathematics too, just hidden
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\sum_{n=1}^{100}n^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\color blue
(1 to 100).map { n => n * n }.sum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\int_{0}^{1}\sin\,(x^{3})\,dx$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\color blue
integrateNumerically(0, 1) { x => math.sin(x * x * x) }
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Variable shadowing and lexical scoping are the same in math usage
\end_layout

\begin_layout Itemize
Many algorithms require non-tail-recursive code (
\size footnotesize
\color blue
map
\size default
\color inherit
 for a tree)
\end_layout

\begin_layout Itemize
Perfect-shaped trees 
\emph on
can
\emph default
 be defined via recursive ADTs
\end_layout

\begin_layout Standard
\align center
\begin_inset Preview

\begin_layout Standard

\size scriptsize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] [ [ [ $a_5$ ]
 [ $a_6$ ] ] [ [ $a_7$ ] [ $a_8$ ] ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset VSpace -30baselineskip%
\end_inset

Chapters 4 and 5: a practical application of the Curry-Howard isomorphism
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Type inference
\begin_inset Quotes erd
\end_inset

 — determining type signature from given code
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Code inference
\begin_inset Quotes erd
\end_inset

 — determining code from given type signature
\end_layout

\begin_layout Itemize
The 
\family typewriter
\size footnotesize
\color blue
curryhoward
\family default
\size default
\color inherit
 library uses the LJT algorithm for code inference
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
import io.chymyst.ch._
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> def in[A, B](a: A, b: Option[B]): Option[(A, B)] = implement
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def in[A, B](a: A, b: Option[B]): Option[(A, B)]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> in(1.5, Some(true))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val res0: Option[(Double, Boolean)] = Some((1.5,true))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> def h[A, B]: ((((A => B) => A) => A) => B) => B  =  implement
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def h[A, B]: ((((A => B) => A) => A) => B) => B
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> println(h.lambdaTerm.prettyPrint)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
a ⇒ a (b ⇒ b (c ⇒ a (d ⇒ c))) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> def g[A, B]: ((((A => B) => B) => A) => B) => B  =  implement
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
error: type ((((A ⇒ B) ⇒ B) ⇒ A) ⇒ B) ⇒ B cannot be implemented
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapters 6 to 8:
\end_layout

\begin_layout Itemize
Subtypes / supertypes are not always the same as supersets / subsets
\end_layout

\begin_layout Itemize
Functions of type ADT => ADT can be manipulated via matrices
\end_layout

\begin_layout Standard

\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val p: Either[A, B] => Either[C, D] = {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    case Left(x)   => Right(f(x))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    case Right(y)  => Left(g(y))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\size scriptsize
\color inherit

\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size scriptsize
\begin_inset Formula 
\[
\quad\begin{array}{|c||cc|}
 & C & D\\
\hline A & \bbnum 0 & x\rightarrow f(x)\\
B & y\rightarrow g(y) & \bbnum 0
\end{array}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Typeclasses can be viewed as partial functions from types to values
\end_layout

\begin_layout Itemize
All non-parameterized types have a monoid structure
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapters 9 to 12:
\end_layout

\begin_layout Itemize
Filterable functors are a neglected typeclass with useful properties
\end_layout

\begin_layout Itemize
Data types 
\family typewriter
\size footnotesize
\color blue
Option[(A, A)]
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Option[(A, A, A)]
\family default
\size default
\color inherit
, etc., 
\emph on
cannot
\emph default
 be monads
\end_layout

\begin_layout Itemize
Monads need 
\begin_inset Quotes eld
\end_inset

runners
\begin_inset Quotes erd
\end_inset

 to be useful, but some monads' runners do not obey the laws or cannot exist
 (
\family typewriter
\size footnotesize
\color blue
State
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Continuation
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
Without some laws, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 is 
\emph on
not
\emph default
 equivalent to 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 with 
\family typewriter
\size footnotesize
\color blue
flatten
\end_layout

\begin_layout Itemize
Almost all monads are not commutative, but almost all applicative functors
 are commutative
\end_layout

\begin_layout Itemize
All contravariant functors are applicative (if defined using the six standard
 type constructions)
\end_layout

\begin_layout Itemize
One 
\emph on
can
\emph default
 define 
\family typewriter
\size footnotesize
\color blue
fold
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 for a breadth-first traversal of trees
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapters 13 and 14:
\end_layout

\begin_layout Itemize
Not all typeclasses have a 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 construction: there is free functor, free contrafunctor, free filterable,
 free monad, free applicative functor, but not free foldable or free traversable
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Tagless final
\begin_inset Quotes erd
\end_inset

 is just a Church encoding of the free monad
\end_layout

\begin_layout Itemize
A complete proof of the correctness of the Church encoding is 
\emph on
hard
\end_layout

\begin_deeper
\begin_layout Itemize
My proof uses relational parametricity together with some obscure results
 from 
\begin_inset CommandInset href
LatexCommand href
name "unpublished talk slides"
target "https://www.ioc.ee/~tarmo/tday-voore/vene-slides.pdf"
literal "false"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
...
 but programmers do not need to study those proofs
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Monad transformers likely exist for all explicitly definable monads, but
 there is no general method or scheme for defining the transformers
\end_layout

\begin_layout Itemize
Some monad transformers are incomplete and unusable for practical coding
 (
\family typewriter
\size footnotesize
\color blue
Continuation
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Codensity
\family default
\size default
\color inherit
)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Conclusions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Functional programming has a steep learning curve
\end_layout

\begin_deeper
\begin_layout Itemize
Programmers can already benefit from the simplest techniques
\end_layout

\begin_deeper
\begin_layout Itemize
...
 and mostly stop there (
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
fold
\family default
\size default
\color inherit
, ADTs, 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
)
\end_layout

\end_deeper
\begin_layout Itemize
Full 
\emph on
ab initio
\emph default
 derivations and proofs take 800 pages
\end_layout

\begin_layout Itemize
The difficulty is at the level of undergraduate calculus
\end_layout

\end_deeper
\begin_layout Itemize
Much of the theory is directly beneficial for coding
\end_layout

\begin_deeper
\begin_layout Itemize
Using FP techniques makes programmers' work closer to 
\emph on
engineering
\end_layout

\end_deeper
\begin_layout Itemize
Full details in the free book — 
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
