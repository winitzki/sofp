#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Nil,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\start_of_appendix
Notations
\begin_inset CommandInset label
LatexCommand label
name "chap:Appendix-Notations"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset

Certain notations and terms were chosen in this book differently from what
 the functional programming community currently uses.
 The proposed notation is well adapted to reasoning about types and code,
 and especially for designing data types and proving the laws of various
 typeclasses.
\end_layout

\begin_layout Section
Summary of notations for types and code
\end_layout

\begin_layout Description
\begin_inset Formula $F^{A}$
\end_inset

 type constructor 
\begin_inset Formula $F$
\end_inset

 with type argument 
\begin_inset Formula $A$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}$
\end_inset

 value 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\bbnum 1,\,1$
\end_inset

 the unit type and its value; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\bbnum 0$
\end_inset

 the void type.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A+B$
\end_inset

 a disjunctive type.
 In Scala, this type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 a value of a disjunctive type 
\begin_inset Formula $A+B$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A\times B$
\end_inset

 a product (tuple) type.
 In Scala, this type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $a^{:A}\times b^{:B}$
\end_inset

 value of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A\rightarrow B$
\end_inset

 the function type, mapping from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}\rightarrow f$
\end_inset

 a nameless function (as a value).
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x:A => f }
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\text{id}$
\end_inset

 the identity function; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\triangleq$
\end_inset

 
\begin_inset Quotes eld
\end_inset

is defined to be
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

is equal by definition
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\overset{!}{=}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

must be equal according to what we know
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\overset{?}{=}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

we ask — is it equal? — because we still need to prove that
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\square$
\end_inset

 
\begin_inset Quotes eld
\end_inset

this proof or this derivation is finished
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\cong$
\end_inset

 for types, a natural isomorphism between types; for values, 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

 values according to an already established isomorphism
\end_layout

\begin_layout Description
\begin_inset Formula $A^{:F^{B}}$
\end_inset

 special type annotation, used for defining unfunctors (GADTs)
\end_layout

\begin_layout Description
\begin_inset Formula $\wedge$
\end_inset

 logical conjunction; 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

both 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\vee$
\end_inset

 logical disjunction; 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

either 
\begin_inset Formula $\alpha$
\end_inset

 or 
\begin_inset Formula $\beta$
\end_inset

 or both are true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\Rightarrow$
\end_inset

 logical implication; 
\begin_inset Formula $\alpha\Rightarrow\beta$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\alpha$
\end_inset

 is true then 
\begin_inset Formula $\beta$
\end_inset

 is true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 of a functor 
\begin_inset Formula $F$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor[F].fmap
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\text{flm}_{F},\text{ftn}_{F},\text{pu}_{F}$
\end_inset

 the standard methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 of a monad 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $F^{\bullet}$
\end_inset

 the type constructor 
\begin_inset Formula $F$
\end_inset

 understood as a type-level function.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $F^{\bullet}\leadsto G^{\bullet}$
\end_inset

 or 
\begin_inset Formula $F\leadsto G$
\end_inset

 a natural transformation between functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F ~> G
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\forall A.P^{A}$
\end_inset

 a universally quantified type expression.
 In Scala 3, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[A] => P[A]
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\exists A.P^{A}$
\end_inset

 an existentially quantified type expression.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ type A; val x: P[A] }
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $\bef$
\end_inset

 the forward composition of functions: 
\begin_inset Formula $f\bef g$
\end_inset

 is 
\begin_inset Formula $x\rightarrow g(f(x))$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\circ$
\end_inset

 the backward composition of functions: 
\begin_inset Formula $f\circ g$
\end_inset

 is 
\begin_inset Formula $x\rightarrow f(g(x))$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f compose g
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\circ$
\end_inset

 the backward composition of type constructors: 
\begin_inset Formula $F\circ G$
\end_inset

 is 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[G[A]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $\triangleright$
\end_inset

 use a value as the argument of a function: 
\begin_inset Formula $x\triangleright f$
\end_inset

 is 
\begin_inset Formula $f(x)$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 a function 
\begin_inset Formula $f$
\end_inset

 raised to a functor 
\begin_inset Formula $G$
\end_inset

; same as 
\begin_inset Formula $\text{fmap}_{G}f$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $f^{\uparrow G\uparrow H}$
\end_inset

 a function raised first to 
\begin_inset Formula $G$
\end_inset

 and then to 
\begin_inset Formula $H$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.map(_.map(f))
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 a function 
\begin_inset Formula $f$
\end_inset

 raised to a contrafunctor 
\end_layout

\begin_layout Description
\begin_inset Formula $\diamond_{M}$
\end_inset

 the Kleisli product operation for the monad 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $L\varangle M$
\end_inset

 or equivalently 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 — the monad transformer of a monad 
\begin_inset Formula $L$
\end_inset

 applied to a monad 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\oplus$
\end_inset

 the binary operation of a monoid.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x |+| y
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\Delta$
\end_inset

 the 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function of type 
\begin_inset Formula $\forall A.\,A\rightarrow A\times A$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\pi_{1},\pi_{2},...$
\end_inset

 the projections from a tuple to its first, second, ..., parts
\end_layout

\begin_layout Description
\begin_inset Formula $\boxtimes$
\end_inset

 pair product of functions, 
\begin_inset Formula $(f\boxtimes g)(a\times b)\triangleq f(a)\times g(b)$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\left[a,b,c\right]$
\end_inset

 an ordered sequence of values.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(a, b, c)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\begin{array}{||cc|}
x\rightarrow x & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}$
\end_inset

 
\begin_inset space ~
\end_inset

a function that works with disjunctive types (a 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive functions
\end_layout

\end_inset

disjunctive function
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Section
Detailed explanations
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}$
\end_inset

 means a type constructor 
\begin_inset Formula $F$
\end_inset

 with a type parameter 
\begin_inset Formula $A$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

.
 Type constructors with multiple type parameters are denoted by 
\begin_inset Formula $F^{A,B,C}$
\end_inset

.
 Nested type parameters such as Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[G[A]]
\end_layout

\end_inset

 are denoted by 
\begin_inset Formula $F^{G^{A}}$
\end_inset

, meaning 
\begin_inset Formula $F^{(G^{A})}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}$
\end_inset

 means a value 
\begin_inset Formula $x$
\end_inset

 that has type 
\begin_inset Formula $A$
\end_inset

; this is a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
type annotation
\end_layout

\end_inset

type annotation
\series default
.
 In Scala, a type annotation is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 The colon symbol, 
\begin_inset Formula $:$
\end_inset

, in the superscript shows that 
\begin_inset Formula $A$
\end_inset

 is not a type argument (as it would be in a type constructor, 
\begin_inset Formula $F^{A}$
\end_inset

).
 The notation 
\begin_inset Formula $x:A$
\end_inset

 can be used as well, but 
\begin_inset Formula $x^{:A}$
\end_inset

 is easier to read when 
\begin_inset Formula $x$
\end_inset

 is inside a larger code expression.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\bbnum 1$
\end_inset

 means the unit type
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type
\end_layout

\end_inset

, and 
\begin_inset Formula $1$
\end_inset

 means the value of the unit type.
 In Scala, the unit type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, and its value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 Example of using the unit type is 
\begin_inset Formula $\bbnum 1+A$
\end_inset

, which corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 in Scala.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bbnum 0$
\end_inset

 means the void
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 type (the type with no values).
 In Scala, this is the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 Example of using the void type is to denote the empty part of a disjunction.
 For example, in the disjunction 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 the non-empty part is 
\begin_inset Formula $\bbnum 0+A$
\end_inset

, which in Scala corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

.
 The empty part 
\begin_inset Formula $\bbnum 1+\bbnum 0$
\end_inset

 corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 Similarly, 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 denotes the left part of the type 
\begin_inset Formula $A+B$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A]
\end_layout

\end_inset

), while 
\begin_inset Formula $\bbnum 0+B$
\end_inset

 denotes its right part (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right[A]
\end_layout

\end_inset

).
 Values of disjunctive types are denoted similarly.
 For instance, 
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 denotes a value of the left part of the type 
\begin_inset Formula $A+B$
\end_inset

; in Scala, this value is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A,B](x)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $A+B$
\end_inset

 means the disjunctive type made from types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 (or, a disjunction of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

).
 In Scala, this is the type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 denotes a value of a disjunctive type 
\begin_inset Formula $A+B$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 is the value of type 
\begin_inset Formula $A$
\end_inset

, which is the chosen case, and 
\begin_inset Formula $\bbnum 0$
\end_inset

 stands for other possible cases.
 For example, 
\begin_inset Formula $x^{:A}+\bbnum 0^{B}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A,B](x)
\end_layout

\end_inset

 in Scala.
 Type annotations 
\begin_inset Formula $^{:A}$
\end_inset

 and 
\begin_inset Formula $^{:B}$
\end_inset

 may be omitted if the types are unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $A\times B$
\end_inset

 means the product type made from types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 In Scala, this is the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $a^{:A}\times b^{:B}$
\end_inset

 means a value of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

; in Scala, this is the tuple value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

.
 Type annotations 
\begin_inset Formula $^{:A}$
\end_inset

 and 
\begin_inset Formula $^{:B}$
\end_inset

 may be omitted if the types are unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $A\rightarrow B$
\end_inset

 means a function type from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

.
 In Scala, this is the function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}\rightarrow y$
\end_inset

 means a nameless function with argument 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

 and function body 
\begin_inset Formula $y$
\end_inset

.
 (Usually, the body 
\begin_inset Formula $y$
\end_inset

 will be an expression that uses 
\begin_inset Formula $x$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x: A => y }
\end_layout

\end_inset

.
 Type annotation 
\begin_inset Formula $^{:A}$
\end_inset

 may be omitted if the type is unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{id}$
\end_inset

 means the identity function.
 The type of its argument should be either specified as 
\begin_inset Formula $\text{id}^{A}$
\end_inset

 or 
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

, or else should be unambiguous from the context.
 In Scala,  
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset

 corresponds to 
\begin_inset Formula $\text{id}^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\triangleq$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

equal by definition
\begin_inset Quotes erd
\end_inset

.
 A definition of a function 
\begin_inset Formula $f$
\end_inset

 is written as 
\begin_inset Formula $f\triangleq(x^{:\text{Int}}\rightarrow x+10)$
\end_inset

; in Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val f = { x: Int => x + 10 }
\end_layout

\end_inset

.
 A definition of a type constructor 
\begin_inset Formula $F$
\end_inset

 is written as 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

; in Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Option[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\cong$
\end_inset

 for types means an equivalence (an isomorphism) of types.
 For example, 
\begin_inset Formula $A+A\times B\cong A\times\left(\bbnum 1+B\right)$
\end_inset

.
 The same symbol 
\begin_inset Formula $\cong$
\end_inset

 for 
\emph on
values
\emph default
 means 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

 according to an equivalence relation that needs to be established in the
 text.
 For example, if we have established an equivalence that allows nested tuples
 to be reordered whenever needed, we can write 
\begin_inset Formula $\left(a\times b\right)\times c\cong a\times\left(b\times c\right)$
\end_inset

, meaning that these values are mapped to each other by the established
 isomorphism functions.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $A^{:F^{B}}$
\end_inset

 in type expressions means that the type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 assigns the type 
\begin_inset Formula $F^{B}$
\end_inset

 to the type expression 
\begin_inset Formula $A$
\end_inset

.
 This notation is used for defining unfunctors (GADTs).
 For example, the Scala code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

case class F1() extends F[Int]
\end_layout

\begin_layout Plain Layout

case class F2[A](a: A) extends F[(A, String)]
\end_layout

\end_inset

defines an unfunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
unfunctor
\end_layout

\end_inset

, which is denoted by 
\begin_inset Formula $F^{A}\triangleq\bbnum 1^{:F^{\text{Int}}}+A^{:F^{A\times\text{String}}}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\wedge$
\end_inset

 (conjunction), 
\begin_inset Formula $\vee$
\end_inset

 (disjunction), and 
\begin_inset Formula $\Rightarrow$
\end_inset

 (implication) are used in formulas of Boolean as well as constructive logic
 in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:5-Curry-Howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

, e.g., 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

, where Greek letters stand for logical propositions.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 means the standard method 
\begin_inset Formula $\text{fmap}$
\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass, implemented for the functor 
\begin_inset Formula $F$
\end_inset

.
 In Scala, this may be written as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor[F].fmap
\end_layout

\end_inset


\family default
.
 Since each functor 
\begin_inset Formula $F$
\end_inset

 has its own specific implementation of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

, the subscript 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 is not a type parameter of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

.
 The method 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 actually has 
\emph on
two
\emph default
 type parameters, which can be written out as 
\begin_inset Formula $\text{fmap}_{F}^{A,B}$
\end_inset

.
 Then the type signature of 
\begin_inset Formula $\text{fmap}$
\end_inset

 is written in full as 
\begin_inset Formula $\text{fmap}_{F}^{A,B}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}$
\end_inset

.
 For clarity, we may sometimes write out the type parameters 
\begin_inset Formula $A,B$
\end_inset

 in the expression 
\begin_inset Formula $\text{fmap}_{F}^{A,B}$
\end_inset

, but in most cases these type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 can be omitted without loss of clarity.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 denotes a monad 
\begin_inset Formula $F$
\end_inset

's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

.
 This function has type signature 
\begin_inset Formula $A\rightarrow F^{A}$
\end_inset

 that contains a type parameter 
\begin_inset Formula $A$
\end_inset

.
 In the code notation, the type parameter may be either omitted or denoted
 as 
\begin_inset Formula $\text{pu}_{F}^{A}$
\end_inset

.
 If we are using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method with a complicated type, e.g., 
\begin_inset Formula $\bbnum 1+P^{A}$
\end_inset

, instead of the type parameter 
\begin_inset Formula $A$
\end_inset

, we might want to write this type parameter for clarity and write 
\begin_inset Formula $\text{pu}_{F}^{\bbnum 1+P^{A}}$
\end_inset

.
 The type signature of that function is then 
\begin_inset Formula 
\[
\text{pu}_{F}^{1+P^{A}}:\bbnum 1+P^{A}\rightarrow F^{\bbnum 1+P^{A}}\quad.
\]

\end_inset

But in most cases we will not need to write out the type parameters.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{flm}_{F}$
\end_inset

 denotes the curried version of a monad 
\begin_inset Formula $F$
\end_inset

's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 The type signature of 
\begin_inset Formula $\text{flm}_{F}$
\end_inset

 is 
\begin_inset Formula $\text{flm}_{F}:(A\rightarrow F^{B})\rightarrow F^{A}\rightarrow F^{B}$
\end_inset

.
 Note that Scala's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 type signature is not curried.
 The curried method 
\begin_inset Formula $\text{flm}_{F}$
\end_inset

 is easier to use in calculations involving the monad's laws.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{ftn}_{F}$
\end_inset

 denotes a monad 
\begin_inset Formula $F$
\end_inset

's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 with the type signature 
\begin_inset Formula $\text{ftn}_{F}:F^{F^{A}}\rightarrow F^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{\bullet}$
\end_inset

 means the type constructor 
\begin_inset Formula $F$
\end_inset

 understood as a type-level function, — that is, with a type parameter unspecifi
ed.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

.
 The bullet symbol, 
\begin_inset Formula $\bullet$
\end_inset

, is used as a placeholder for the missing type parameter.
 When no type parameter is needed, 
\begin_inset Formula $F$
\end_inset

 means the same as 
\begin_inset Formula $F^{\bullet}$
\end_inset

.
 (For example, 
\begin_inset Quotes eld
\end_inset

a functor 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

a functor 
\begin_inset Formula $F^{\bullet}$
\end_inset


\begin_inset Quotes erd
\end_inset

 mean the same thing.) However, it is useful for clarity to be able to indicate
 the place where the type parameter would appear.
 For instance, functor composition is denoted as 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

; in Scala 2, this is 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Lambda[X => F[G[X]]]
\end_layout

\end_inset


\family default
 when using the 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
kind@
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 plugin
\end_layout

\end_inset

 plugin.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/typelevel/kind-projector"
target "https://github.com/typelevel/kind-projector"
literal "false"

\end_inset


\end_layout

\end_inset

 When the first type parameter of a bifunctor 
\begin_inset Formula $P^{A,B}$
\end_inset

 is fixed to 
\begin_inset Formula $Z$
\end_inset

, the resulting functor may be denoted by 
\begin_inset Formula $P^{Z,\bullet}$
\end_inset

.
 As another example, 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 denotes a monad transformer for the base monad 
\begin_inset Formula $L$
\end_inset

 and the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 The foreign monad 
\begin_inset Formula $M$
\end_inset

 is a type parameter in 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

, and so is the missing type parameter denoted by the placeholder symbol
 
\begin_inset Formula $\bullet$
\end_inset

.
 (However, the base monad 
\begin_inset Formula $L$
\end_inset

 is not a type parameter in 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 because the construction of the monad transformer depends sensitively on
 the internal details of 
\begin_inset Formula $L$
\end_inset

.)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{\bullet}\leadsto G^{\bullet}$
\end_inset

 or 
\begin_inset Formula $F\leadsto G$
\end_inset

 means a natural transformation between two functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

.
 In some Scala libraries, this is denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F ~> G
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\forall A.P^{A}$
\end_inset

 is a universally quantified type expression, in which 
\begin_inset Formula $A$
\end_inset

 is a bound type parameter.
\end_layout

\begin_layout Standard
\begin_inset Formula $\exists A.P^{A}$
\end_inset

 is an existentially quantified type expression, in which 
\begin_inset Formula $A$
\end_inset

 is a bound type parameter.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bef$
\end_inset

 means the forward composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
forward composition
\end_layout

\end_inset

 of functions: 
\begin_inset Formula $f\bef g$
\end_inset

 (reads 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset

 before 
\begin_inset Formula $g$
\end_inset


\begin_inset Quotes erd
\end_inset

) is the function defined as 
\begin_inset Formula $x\rightarrow g(f(x))$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\circ$
\end_inset

 means the backward composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
backward composition
\end_layout

\end_inset

 of functions: 
\begin_inset Formula $f\circ g$
\end_inset

 (reads 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset

 after 
\begin_inset Formula $g$
\end_inset


\begin_inset Quotes erd
\end_inset

) is the function defined as 
\begin_inset Formula $x\rightarrow f(g(x))$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\circ$
\end_inset

 with type constructors means their (backward) composition, for example
 
\begin_inset Formula $F\circ G$
\end_inset

 denotes the type constructor 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[G[A]]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $x\triangleright f$
\end_inset

 (the 
\series bold
pipe notation
\series default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
$@
\begin_inset Formula $\triangleright$
\end_inset

-notation!see 
\begin_inset Quotes eld
\end_inset

pipe notation
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 is a different syntax for 
\begin_inset Formula $f(x)$
\end_inset

.
 The value 
\begin_inset Formula $x$
\end_inset

 is passed as the argument to the function 
\begin_inset Formula $f$
\end_inset

.
 In Scala, the expression 
\begin_inset Formula $x\triangleright f$
\end_inset

 is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 or, if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is a method, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.f
\end_layout

\end_inset

.
 This syntax is used with many standard methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toSeq
\end_layout

\end_inset

.
 Because the argument 
\begin_inset Formula $x$
\end_inset

 is to the left of the function 
\begin_inset Formula $f$
\end_inset

 in this notation, forward compositions of functions such as 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

 are naturally grouped to the left as it is done in Scala code, for example
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.toSeq.sorted
\end_layout

\end_inset

.
 The operation 
\begin_inset Formula $\triangleright$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

pipe
\begin_inset Quotes erd
\end_inset

) groups weaker than the forward composition (
\begin_inset Formula $\bef$
\end_inset

), and so we have 
\begin_inset Formula $x\triangleright f\bef g=x\triangleright f\triangleright g$
\end_inset

 in this notation.
 Reasoning about code in the pipe notation uses the identities
\begin_inset Formula 
\begin{align*}
x\triangleright f=f(x)\quad,\quad\quad & \left(x\triangleright f\right)\triangleright g=x\triangleright f\triangleright g\quad,\\
x\triangleright f\bef g=x\triangleright\left(f\bef g\right)\quad,\quad\quad & x\triangleright f\triangleright g=x\triangleright f\bef g\quad.
\end{align*}

\end_inset

The pipe symbol groups stronger than the function arrow, so 
\begin_inset Formula $x\rightarrow y\triangleright f=x\rightarrow(y\triangleright f)$
\end_inset

.
 Here are some examples of reasoning with functions in the pipe notation:
\begin_inset Formula 
\begin{align*}
 & \left(a\rightarrow a\triangleright f\right)=\left(a\rightarrow f(a)\right)=f\quad,\\
 & f\triangleright\left(y\rightarrow a\triangleright y\right)=a\triangleright f=f(a)\quad,\\
 & f(y(x))=x\triangleright y\triangleright f\neq x\triangleright\left(y\triangleright f\right)=f(y)(x)\quad.
\end{align*}

\end_inset

The correspondence between the forward composition and the backward composition:
\begin_inset Formula 
\begin{align*}
 & f\bef g=g\circ f\quad,\\
 & x\triangleright(f\bef g)=x\triangleright f\bef g=x\triangleright f\triangleright g=g(f(x))=(g\circ f)(x)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 means a function 
\begin_inset Formula $f$
\end_inset

 lifted to a functor 
\begin_inset Formula $G$
\end_inset

.
 For a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, the application of 
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 to a value 
\begin_inset Formula $g^{:G^{A}}$
\end_inset

 is written as 
\begin_inset Formula $f^{\uparrow G}(g)$
\end_inset

 or as 
\begin_inset Formula $g\triangleright f^{\uparrow G}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g.map(f)
\end_layout

\end_inset

.
 Nested lifting (i.e., lifting to the functor composition 
\begin_inset Formula $H\circ G$
\end_inset

) can be written as 
\begin_inset Formula $f^{\uparrow G\uparrow H}$
\end_inset

, which means 
\begin_inset Formula $\left(f^{\uparrow G}\right)^{\uparrow H}$
\end_inset

 and produces a function of type 
\begin_inset Formula $H^{G^{A}}\rightarrow H^{G^{B}}$
\end_inset

.
 Applying a nested lifting to a value 
\begin_inset Formula $h$
\end_inset

 of type 
\begin_inset Formula $H^{G^{A}}$
\end_inset

 is written as 
\begin_inset Formula $f^{\uparrow G\uparrow H}h$
\end_inset

 or 
\begin_inset Formula $h\triangleright f^{\uparrow G\uparrow H}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.map(_.map(f))
\end_layout

\end_inset

.
 The functor composition law is written as
\begin_inset Formula 
\[
p^{\uparrow G}\bef q^{\uparrow G}=\left(p\bef q\right)^{\uparrow G}\quad.
\]

\end_inset

Note the similarity between Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(p).map(q)
\end_layout

\end_inset

 and the notation 
\begin_inset Formula $x\triangleright p^{\uparrow G}\triangleright q^{\uparrow G}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 means a function 
\begin_inset Formula $f$
\end_inset

 lifted to a contrafunctor 
\begin_inset Formula $H$
\end_inset

.
 For a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, the application of 
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 to a value 
\begin_inset Formula $h:H^{B}$
\end_inset

 is written as 
\begin_inset Formula $f^{\downarrow H}h$
\end_inset

 or 
\begin_inset Formula $h\triangleright f^{\downarrow H}$
\end_inset

, and yields a value of type 
\begin_inset Formula $H^{A}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.contramap(f)
\end_layout

\end_inset

.
 Nested lifting is denoted as 
\begin_inset Formula $f^{\downarrow H\uparrow G}\triangleq(f^{\downarrow H})^{\uparrow G}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\diamond_{M}$
\end_inset

 means the Kleisli product operation for a given monad 
\begin_inset Formula $M$
\end_inset

.
 This is a binary operation working on two Kleisli functions of types 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $B\rightarrow M^{C}$
\end_inset

 and yields a new function of type 
\begin_inset Formula $A\rightarrow M^{C}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\oplus$
\end_inset

 means the binary operation of a monoid, for example 
\begin_inset Formula $x\oplus y$
\end_inset

.
 The specific monoid type should be defined for this expression to make
 sense.
 For example, in Scala the monoidal operation is usually denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x |+| y
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\Delta$
\end_inset

 means the standard 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function of type 
\begin_inset Formula $\forall A.\,A\rightarrow A\times A$
\end_inset

, i.e., 
\begin_inset Formula $\Delta\triangleq a^{:A}\rightarrow a\times a$
\end_inset

 or, in Scala,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta[A](a: A): (A, A) = (a, a)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\pi_{1},\pi_{2},...$
\end_inset

 denote the functions extracting the first, second, ..., parts in a tuple.
 In Scala, 
\begin_inset Formula $\pi_{1}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_._1)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\boxtimes$
\end_inset

 means the pair product
\begin_inset Index idx
status open

\begin_layout Plain Layout
pair product of functions
\end_layout

\end_inset

 of functions, where the result is a pair of the values of the two functions:
 
\begin_inset Formula $(f\boxtimes g)(a\times b)=f(a)\times g(b)$
\end_inset

.
 In Scala, this operation can be defined by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pair_product[A,B,P,Q](f: A => P, g: B => Q): ((A, B)) => (P, Q) = {
\end_layout

\begin_layout Plain Layout

  case (a, b) => (f(a), g(b))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The operations 
\begin_inset Formula $\Delta$
\end_inset

, 
\begin_inset Formula $\pi_{i}$
\end_inset

 (where 
\begin_inset Formula $i=1,2,...$
\end_inset

), and 
\begin_inset Formula $\boxtimes$
\end_inset

 allow us to express any function operating on tuples.
 Useful properties for reasoning about code of such functions: 
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \Delta\bef\pi_{i}=\text{id}\quad,\\
\text{naturality law}:\quad & f\bef\Delta=\Delta\bef(f\boxtimes f)\quad,\\
\text{left projection law}:\quad & (f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f\quad,\\
\text{right projection law}:\quad & (f\boxtimes g)\bef\pi_{2}=\pi_{2}\bef g\quad,\\
\text{composition law}:\quad & (f\boxtimes g)\bef(p\boxtimes q)=(f\bef p)\boxtimes(g\bef q)\quad,
\end{align*}

\end_inset

as well as the functor lifting laws for 
\begin_inset Formula $\Delta$
\end_inset

 and 
\begin_inset Formula $\pi_{i}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow F}\bef\Delta=\Delta\bef f^{\uparrow(F\times F)}=\Delta\bef(f^{\uparrow F}\boxtimes f^{\uparrow F})\quad,\\
 & (f^{\uparrow F}\boxtimes f^{\uparrow G})\bef\pi_{1}=f^{\uparrow(F\times G)}\bef\pi_{1}=\pi_{1}\bef f^{\uparrow F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left[a,b,c\right]$
\end_inset

 means an ordered sequence of values, such as a list or an array.
 In Scala, this can be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(a, b, c)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vector(a, b, c)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array(a, b, c)
\end_layout

\end_inset

, or another collection type.
\end_layout

\begin_layout Standard
\begin_inset Formula $f^{:Z+A\rightarrow Z+A\times A}\triangleq\begin{array}{||cc|}
z\rightarrow z & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}\,$
\end_inset

 is the 
\series bold
matrix notation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
matrix notation
\end_layout

\end_inset

 for a function whose input and/or output type is a disjunctive type (
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive functions
\end_layout

\end_inset

a 
\series bold
disjunctive function
\series default
).
 In Scala, the function 
\begin_inset Formula $f$
\end_inset

 is implemented as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[Z, A]: Either[Z, A] => Either[Z, (A, A)] = {
\end_layout

\begin_layout Plain Layout

  case Left(z)   => Left(z) // Identity function on Z.
\end_layout

\begin_layout Plain Layout

  case Right(a)  => Right((a, a)) // Delta on A.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The rows of the matrix indicate the different 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

s in the function's code, corresponding to the different parts of the input
 disjunctive type.
 If the input type is not disjunctive, there will be only one row.
 The columns of the matrix indicate the parts of the output disjunctive
 type.
 If the output type is not disjunctive, there will be only one column.
\end_layout

\begin_layout Standard
A matrix may show all parts of the disjunctive types in separate 
\begin_inset Quotes eld
\end_inset

type row
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

type column
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{equation}
f^{:Z+A\Rightarrow Z+A\times A}\triangleq\begin{array}{|c||cc|}
 & Z & A\times A\\
\hline Z & \text{id} & \bbnum 0\\
A & \bbnum 0 & a\rightarrow a\times a
\end{array}\quad.
\end{equation}

\end_inset

This notation clearly indicates the input and the output types of the function
 and is useful at some stages of reasoning about the code.
 The vertical double line separates input types from the function code.
 In the code above, the 
\begin_inset Quotes eld
\end_inset

type column
\begin_inset Quotes erd
\end_inset

 shows the parts of the input disjunctive type 
\begin_inset Formula $Z+A$
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

type row
\begin_inset Quotes erd
\end_inset

 shows the parts of the output disjunctive type 
\begin_inset Formula $Z+A\times A$
\end_inset

.
\end_layout

\begin_layout Standard
The matrix notation is adapted to 
\emph on
forward
\emph default
 function composition 
\begin_inset Formula $f\bef g$
\end_inset

.
 Assume that 
\begin_inset Formula $A$
\end_inset

 is a monoid type, and consider the composition of the function 
\begin_inset Formula $f$
\end_inset

 shown above and the function 
\begin_inset Formula $g$
\end_inset

 defined as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g[Z, A: Monoid]: Either[Z, (A, A)] => A = {
\end_layout

\begin_layout Plain Layout

  case Left(_)          => Monoid[A].empty
\end_layout

\begin_layout Plain Layout

  case Right((a1, a2))  => a1 |+| a2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the matrix notation, the function 
\begin_inset Formula $g$
\end_inset

 is written (with and without types) as
\begin_inset Formula 
\[
g\triangleq\begin{array}{|c||c|}
 & A\\
\hline Z & \_\rightarrow e^{:A}\\
A\times A & a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\quad,\quad\quad g\triangleq\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\quad.
\]

\end_inset

The forward composition 
\begin_inset Formula $f\bef g$
\end_inset

 is computed by forward-composing the matrix elements using the rules of
 the ordinary matrix multiplication, omitting any terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f\bef g & =\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}\,\bef\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\\
 & =\,\begin{array}{||c|}
\text{id}\bef(\_\rightarrow e^{:A})\\
\left(a\rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}\right)
\end{array}=\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a\rightarrow a\oplus a
\end{array}\quad.
\end{align*}

\end_inset

Applying a function to a disjunctive value such as 
\begin_inset Formula $x^{:Z+A}$
\end_inset

 is computed by writing 
\begin_inset Formula $x$
\end_inset

 as a row vector:
\begin_inset Formula 
\[
x=z^{:Z}+\bbnum 0^{:A}=\begin{array}{|cc|}
z^{:Z} & \bbnum 0\end{array}\quad,
\]

\end_inset

and the computation 
\begin_inset Formula $x\triangleright f\bef g$
\end_inset

 again follows the rules of matrix multiplication:
\begin_inset Formula 
\[
x\triangleright f\bef g=\begin{array}{|cc|}
z^{:Z} & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a\rightarrow a\oplus a
\end{array}=z\triangleright(\_\rightarrow e)=e\quad.
\]

\end_inset

Since the standard rules of matrix multiplication are associative, the propertie
s of the 
\begin_inset Formula $\triangleright$
\end_inset

-notation such as 
\begin_inset Formula $x\triangleright(f\bef g)=(x\triangleright f)\triangleright g$
\end_inset

 are guaranteed to hold.
\end_layout

\begin_layout Standard
To use the matrix notation with 
\emph on
backward
\emph default
 compositions (
\begin_inset Formula $f\circ g$
\end_inset

), all function matrices need to be transposed.
 (A standard identity of matrix calculus is that the transposition reverses
 the order of composition, 
\begin_inset Formula $\left(AB\right)^{T}=B^{T}A^{T}$
\end_inset

.) The argument types will then appear in the top row and the result types
 in the left column; the double line is above the matrix since that is where
 the function inputs come from.
 The above calculations are then rewritten as
\begin_inset Formula 
\begin{align*}
g\circ f & =\begin{array}{|c|cc|}
 & Z & A\times A\\
\hline\hline A & \_\rightarrow e^{:A} & a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\,\circ\,\begin{array}{|c|cc|}
 & Z & A\\
\hline\hline Z & \text{id} & \bbnum 0\\
A\times A & \bbnum 0 & a\rightarrow a\times a
\end{array}\\
 & =\,\begin{array}{|cc|}
\hline\hline \text{id}\bef(\_\rightarrow e^{:A}) & \left(a\rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}\right)\end{array}=\begin{array}{|cc|}
\hline\hline \_\rightarrow e^{:A} & a\rightarrow a\oplus a\end{array}\quad.\\
(g\circ f)(x) & =\begin{array}{|cc|}
\hline\hline \_\rightarrow e^{:A} & a\rightarrow a\oplus a\end{array}\,\begin{array}{|c|}
z^{:Z}\\
\bbnum 0
\end{array}=(\_\rightarrow e^{:A})(z)=e\quad.
\end{align*}

\end_inset

The 
\emph on
forward
\emph default
 composition seems to be easier to read and to reason about in the matrix
 notation.
\end_layout

\begin_layout Chapter
Glossary of terms
\begin_inset CommandInset label
LatexCommand label
name "chap:Appendix-Glossary-of-terms"

\end_inset


\end_layout

\begin_layout Description
Code
\begin_inset space ~
\end_inset

notation 
\begin_inset Index idx
status open

\begin_layout Plain Layout
code notation
\end_layout

\end_inset

A mathematical notation developed in this book for deriving properties of
 code in functional programs.
 Variables have optional type annotations, such as 
\begin_inset Formula $x^{:A}$
\end_inset

 or 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Nameless functions are denoted by
\begin_inset Formula $x^{:A}\rightarrow f$
\end_inset

, products by 
\begin_inset Formula $a\times b$
\end_inset

, and values of a disjunctive type 
\begin_inset Formula $A+B$
\end_inset

 are written as 
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset

.
 Functions working with disjunctive types are denoted by matrices.
 Lifting of functions to functors, such as 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

, is denoted by 
\begin_inset Formula $f^{\uparrow L}$
\end_inset

; function compositions are denoted by 
\begin_inset Formula $f\bef g$
\end_inset

 (forward composition) and 
\begin_inset Formula $f\circ g$
\end_inset

 (backward composition); and function applications by 
\begin_inset Formula $f(x)$
\end_inset

 or equivalently 
\begin_inset Formula $x\triangleright f$
\end_inset

.
 See Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Appendix-Notations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
contrafunctor
\end_layout

\end_inset

Contrafunctor A type constructor having the properties of a contravariant
 functor
\begin_inset Index idx
status open

\begin_layout Plain Layout
contrafunctor
\end_layout

\end_inset

 with respect to a type parameter.
 Instead of 
\begin_inset Quotes eld
\end_inset

contravariant functor
\begin_inset Quotes erd
\end_inset

, this book uses the shorter name 
\begin_inset Quotes eld
\end_inset

contrafunctor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
Disjunctive
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type
\end_layout

\end_inset

A type representing one of several distinct possibilities.
 In Scala, this is usually implemented as a sealed trait extended by several
 case classes.
 The standard Scala disjunction types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

.
 Also known as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
sum type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\series bold
sum 
\series default
type, 
\series bold
tagged union
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
tagged union type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 type, 
\series bold
co-product
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
co-product type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 type, and variant type (in Object Pascal and in OCaml).
 The shortest name is 
\begin_inset Quotes eld
\end_inset

sum type,
\begin_inset Quotes erd
\end_inset

 but the English word 
\begin_inset Quotes eld
\end_inset

disjunctive
\begin_inset Quotes erd
\end_inset

 is less ambiguous to the ear than 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
Exponential-polynomial
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exponential-polynomial type
\end_layout

\end_inset

A type constructor built using products, disjunctions (sums or co-products),
 and function types (
\begin_inset Quotes eld
\end_inset

exponentials
\begin_inset Quotes erd
\end_inset

), as well as type parameters and fixed types.
 For example,  
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Either[(A,A), Int=>A]
\end_layout

\end_inset

 is an exponential-polynomial type constructor.
 Such type constructors are always profunctors and can also be functors
 or contrafunctors.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor block
\end_layout

\end_inset

Functor
\begin_inset space ~
\end_inset

block A short syntax for composing several 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operations applied to a functor-typed value.
 The type constructor corresponding to that value must be a functor and
 is fixed throughout the entire functor block.
 For example, the Scala code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for { x <- List(1,2,3); y <- List(10, x); if y > 2 }
\end_layout

\begin_layout Plain Layout

  yield 2 * y
\end_layout

\end_inset

is equivalent to the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(1, 2, 3).flatMap(x => List(10, x))
\end_layout

\begin_layout Plain Layout

  .filter(y => y > 1).map(y => 2 * y)
\end_layout

\end_inset

and computes the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(20, 20, 20, 6)
\end_layout

\end_inset

.
 This is a functor block that 
\begin_inset Quotes eld
\end_inset

raises
\begin_inset Quotes erd
\end_inset

 computations to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor.
 Similar syntax exists in a number of languages and is called a 
\series bold

\begin_inset Quotes eld
\end_inset

for-comprehension
\begin_inset Quotes erd
\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
for
\family default
-comprehensions (Python)
\end_layout

\end_inset

 or a 
\begin_inset Quotes eld
\end_inset

list comprehension
\begin_inset Quotes erd
\end_inset

 in Python, 
\series bold

\begin_inset Quotes eld
\end_inset

do-notation
\begin_inset Quotes erd
\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
do
\family default
-notation (Haskell)
\end_layout

\end_inset

 in Haskell, and 
\series bold

\begin_inset Quotes eld
\end_inset

computation expressions
\begin_inset Quotes erd
\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
computation expressions (F#)
\end_layout

\end_inset

 in F#.
 I use the name 
\begin_inset Quotes eld
\end_inset

functor block
\begin_inset Quotes erd
\end_inset

 in this book because it is shorter and more descriptive.
 (The type constructor used in a functor block needs to be at least a functor
 but does not have to be a monad.)
\end_layout

\begin_layout Description
Kleisli
\begin_inset space ~
\end_inset

function 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli!functions
\end_layout

\end_inset

 A function with type signature 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 for some fixed monad 
\begin_inset Formula $M$
\end_inset

.
 Also called a Kleisli morphism
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli!morphisms
\end_layout

\end_inset

 (a morphism in the Kleisli category corresponding to the monad 
\begin_inset Formula $M$
\end_inset

).
 The standard monadic method 
\begin_inset Formula $\text{pure}_{M}:A\rightarrow M^{A}$
\end_inset

 has the type signature of a Kleisli function.
 The Kleisli composition operation, 
\begin_inset Formula $\diamond_{M}$
\end_inset

, is a binary operation that combines two Kleisli functions (of types 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $B\rightarrow M^{C}$
\end_inset

) into a new Kleisli function (of type 
\begin_inset Formula $A\rightarrow M^{C}$
\end_inset

).
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
method
\end_layout

\end_inset

Method This word is used in two ways: 1) A method
\begin_inset Formula $_{1}$
\end_inset

 is a Scala function defined as a member of a typeclass.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 is a method defined in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

 typeclass.
 2) A method
\begin_inset Formula $_{2}$
\end_inset

 is a Scala function defined as a member of a data type declared as a Java-compa
tible 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

.
 Trait methods
\begin_inset Formula $_{2}$
\end_inset

 are necessary in Scala when implementing functions whose arguments have
 type parameters (because Scala function values defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 cannot have type parameters).
 So, many typeclasses such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, whose methods
\begin_inset Formula $_{1}$
\end_inset

 require type parameters, will use Scala 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traits
\end_layout

\end_inset

 with methods
\begin_inset Formula $_{2}$
\end_inset

 for their implementation.
 The same applies to type constructions with quantified types, such as the
 Church encoding.
 
\end_layout

\begin_layout Description
Nameless
\begin_inset space ~
\end_inset

function 
\begin_inset Index idx
status open

\begin_layout Plain Layout
nameless function
\end_layout

\end_inset

An expression of function type, representing a function.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: Int) => x * 2
\end_layout

\end_inset

.
 Also known as function expression, function literal, anonymous function,
\begin_inset Index idx
status open

\begin_layout Plain Layout
anonymous function!see 
\begin_inset Quotes eld
\end_inset

nameless functions
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 closure, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
lambda-function!see 
\begin_inset Quotes eld
\end_inset

nameless function
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

lambda-function, lambda-expression, or simply a 
\begin_inset Quotes eld
\end_inset

lambda
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
Partial
\begin_inset space ~
\end_inset

type-to-value
\begin_inset space ~
\end_inset

function
\begin_inset space ~
\end_inset

(PTVF) A function with a type parameter but defined only for a certain subset
 of types.
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial type-to-value function
\end_layout

\end_inset

 In Scala, PTVFs are implemented via a typeclass constraint:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def double[T: Semigroup](t: T): T = implicitly[Semigroup[T]].combine(t, t)
\end_layout

\end_inset

This PTVF is defined only for types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 for which a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 typeclass instance is available.
\end_layout

\begin_layout Description
Polynomial
\begin_inset space ~
\end_inset

functor 
\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial functor
\end_layout

\end_inset

A type constructor built using disjunctions (sums), products (tuples), type
 parameters and fixed types.
 For example, in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Either[(Int, A), A]
\end_layout

\end_inset

 is a polynomial functor with respect to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 is a fixed type (not a type parameter).
 Polynomial functors are also known as 
\series bold
algebraic data types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic data type
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
Product
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
product type
\end_layout

\end_inset

A type representing several values given at once.
 In Scala, product types are the tuple types, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

, and case classes.
 Also known as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples
\end_layout

\end_inset


\series bold
tuple
\series default
 type, 
\series bold
struct
\series default
 (in C and C++), and 
\series bold
record
\series default
.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
profunctor
\end_layout

\end_inset

Profunctor A type constructor whose type parameter occurs in both covariant
 and contravariant positions and satisfying the appropriate laws; see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Description
Type
\begin_inset space ~
\end_inset

notation 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation
\end_layout

\end_inset

A mathematical notation for type expressions developed in this book for
 easier reasoning about types in functional programs.
 Disjunctive types are denoted by 
\begin_inset Formula $+$
\end_inset

, product types by 
\begin_inset Formula $\times$
\end_inset

, and function types by 
\begin_inset Formula $\rightarrow$
\end_inset

.
 The unit type is denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

, and the void type by 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 The function arrow 
\begin_inset Formula $\rightarrow$
\end_inset

 groups weaker than 
\begin_inset Formula $+$
\end_inset

, which in turn groups weaker than 
\begin_inset Formula $\times$
\end_inset

.
 This means
\begin_inset Formula 
\[
Z+A\rightarrow Z+A\times A\quad\text{is the same as}\quad\left(Z+A\right)\rightarrow\left(Z+\left(A\times A\right)\right)\quad.
\]

\end_inset

 Type parameters are denoted by superscripts.
 As an example, the Scala definition
\family typewriter

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = Either[(A, A => Option[Int]), String => List[A]]
\end_layout

\end_inset


\family default
is written in the type notation as 
\begin_inset Formula 
\[
F^{A}\triangleq A\times\left(A\rightarrow\bbnum 1+\text{Int}\right)+(\text{String}\rightarrow\text{List}^{A})\quad.
\]

\end_inset


\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
unfunctor
\end_layout

\end_inset

Unfunctor A type constructor that cannot possibly be a functor, nor a contrafunc
tor, nor a profunctor.
 An example is a type constructor with explicitly indexed type parameters,
 such as 
\begin_inset Formula $F^{A}\triangleq\left(A\times A\right)^{:F^{\text{Int}}}+\left(\text{Int}\times A\right)^{:F^{\bbnum 1}}$
\end_inset

.
 The Scala code for this type constructor is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A](x: A, y: A)   extends F[Int]
\end_layout

\begin_layout Plain Layout

final case class F2[A](s: Int, t: A) extends F[Unit]
\end_layout

\end_inset

This can be seen as a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
GADT!see 
\begin_inset Quotes eld
\end_inset

unfunctor
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\series bold
GADT
\series default
 (generalized algebraic data type) that uses specific values of type parameters
 instead of the type parameter 
\begin_inset Formula $A$
\end_inset

 in at least some of its case classes.
\end_layout

\begin_layout Section
How the term 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 is used
\end_layout

\begin_layout Standard
This book avoids using the terms 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebra
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 because these terms are too ambiguous.
 The functional programming community uses the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 in at least 
\emph on
four
\emph default
 incompatible ways.
\end_layout

\begin_layout Paragraph
Definition 0.
\end_layout

\begin_layout Standard
In mathematics, an “algebra” is a vector space with multiplication and certain
 standard properties.
 For example, we need 
\begin_inset Formula $1*x=x$
\end_inset

, the addition must be commutative, the multiplication must be distributive
 over addition, etc.
 The set of all 
\begin_inset Formula $10\times10$
\end_inset

 matrices with real coefficients is an “algebra” in this sense.
 These matrices form a 
\begin_inset Formula $100$
\end_inset

-dimensional vector space, and they can be multiplied and added.
 This definition of 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 is not used in functional programming.
\end_layout

\begin_layout Paragraph
Definition 1.
\end_layout

\begin_layout Standard
For a given functor 
\begin_inset Formula $F$
\end_inset

, an 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

-algebra
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $F$
\end_inset

-algebra
\end_layout

\end_inset

 is a type 
\begin_inset Formula $A$
\end_inset

 and a function with type signature 
\begin_inset Formula $F^{A}\rightarrow A$
\end_inset

.
 (This definition comes from category theory.) The name 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

-algebra
\begin_inset Quotes erd
\end_inset

 emphasizes the dependence on a chosen functor 
\begin_inset Formula $F$
\end_inset

.
 There is no direct connection between this 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 and Definition
\begin_inset space ~
\end_inset

0, except when the functor 
\begin_inset Formula $F$
\end_inset

 is defined by 
\begin_inset Formula $F^{A}\triangleq A\times A$
\end_inset

: a function of type 
\begin_inset Formula $A\times A\rightarrow A$
\end_inset

 may then be interpreted as a 
\begin_inset Quotes eld
\end_inset

multiplication
\begin_inset Quotes erd
\end_inset

 operation.
 However, 
\begin_inset Formula $A$
\end_inset

 is a type and not a vector space, and there are no distributivity or commutativ
ity laws.
 This book does not use 
\begin_inset Formula $F$
\end_inset

-algebras because knowing their category-theoretical properties does not
 help in practical programming.
\end_layout

\begin_layout Paragraph
Definition 2.
\end_layout

\begin_layout Standard
Polynomial functors are often called “algebraic data types”.
 However, they are not “algebraic” in the sense of Definitions
\begin_inset space ~
\end_inset

0 or 1.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Option[A], Int]
\end_layout

\end_inset

 is considered an “algebraic data type”, denoted by 
\begin_inset Formula $F^{A}\triangleq1+A+\text{Int}$
\end_inset

 in the type notation.
 However, values of the type 
\begin_inset Formula $F^{A}$
\end_inset

 do not support the addition and multiplication operations required by Definitio
n
\begin_inset space ~
\end_inset

0 of 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

.
 The type 
\begin_inset Formula $F^{A}$
\end_inset

 may admit some binary or unary operations (e.g., that of a monoid), but these
 operations will likely not be commutative or distributive.
 Also, there is not necessarily a function with type 
\begin_inset Formula $F^{A}\rightarrow A$
\end_inset

, as required for Definition
\begin_inset space ~
\end_inset

1.
 Rather, the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 refers to 
\begin_inset Quotes eld
\end_inset

school-level algebra
\begin_inset Quotes erd
\end_inset

 dealing with polynomials, since these data types are built from sums and
 products of types.
 If the data contains a function type, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int => A]
\end_layout

\end_inset

, the type is no longer polynomial.
 This book uses more precise terms “polynomial types” and “exponential-polynomia
l types”.
\end_layout

\begin_layout Paragraph
Definition 3.
\end_layout

\begin_layout Standard
People talk about the “algebra” of properties of functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, meaning that these functions satisfy certain 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 laws (e.g., the composition, naturality, or associativity laws).
 But these laws do not make functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 into an algebra in the sense of Definition
\begin_inset space ~
\end_inset

0 or in the sense of Definition
\begin_inset space ~
\end_inset

1.
 There is also no relation to the algebraic data types of Definition
\begin_inset space ~
\end_inset

2.
 So, this is a different usage of the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

.
 However, there is no general 
\begin_inset Quotes eld
\end_inset

algebra of laws
\begin_inset Quotes erd
\end_inset

 that we can use; every derivation proceeds in a different way, specific
 to the laws being proved.
 In mathematics, 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 equations are distinguished from differential or integral equations.
 In that sense, the laws used in functional programming are 
\emph on
always
\emph default
 algebraic: they are just equations with compositions and applications of
 functions.
 So, it brings no particular advantage to call laws 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

.
 This book calls them 
\begin_inset Quotes eld
\end_inset

equations
\begin_inset Quotes erd
\end_inset

 or just 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
Definition 4.
\end_layout

\begin_layout Standard
The Church encoding of a free monad (also known as the 
\begin_inset Quotes eld
\end_inset

tagless final
\begin_inset Index idx
status open

\begin_layout Plain Layout
tagless final
\end_layout

\end_inset

 interpreter
\begin_inset Quotes erd
\end_inset

) is the type 
\begin_inset Formula $\forall E^{\bullet}.\,(S^{E^{\bullet}}\leadsto E^{\bullet})\rightarrow E^{A}$
\end_inset

.
 It uses a higher-order type constructor 
\begin_inset Formula $S^{E^{\bullet}}$
\end_inset

 parameterized by a 
\emph on
type constructor
\emph default
 parameter 
\begin_inset Formula $E^{\bullet}$
\end_inset

.
 In this context, one calls an 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 a value of type 
\begin_inset Formula $S^{E^{\bullet}}\leadsto E^{\bullet}$
\end_inset

, which is an 
\begin_inset Formula $S$
\end_inset

-algebra in the category of 
\begin_inset Quotes eld
\end_inset

type constructors
\begin_inset Quotes erd
\end_inset

 (functors in a category without any non-identity morphisms).
 So, Definition
\begin_inset space ~
\end_inset

4 is related to Definition
\begin_inset space ~
\end_inset

1, with a specific choice of a functor.
 However, knowing that 
\begin_inset Formula $S^{E^{\bullet}}\leadsto E^{\bullet}$
\end_inset

 is an 
\begin_inset Formula $S$
\end_inset

-algebra in the category of type constructors does not provide any help
 or additional insights for practical work with the Church encoding of a
 free monad.
\end_layout

\begin_layout Standard
The higher-order type constructor 
\begin_inset Formula $S$
\end_inset

 is used to parameterize the effects described by a Church-encoded free
 monad, so this book calls it the 
\begin_inset Quotes eld
\end_inset

effect constructor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
So, it appears that the current usage of the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 in functional programming is both inconsistent and unhelpful to practitioners.
 In this book, the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 always means a branch of mathematics, as in 
\begin_inset Quotes eld
\end_inset

high-school algebra
\begin_inset Quotes erd
\end_inset

.
 Instead of 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 as in Definitions
\begin_inset space ~
\end_inset

1 to
\begin_inset space ~
\end_inset

4, this book talks about 
\begin_inset Quotes eld
\end_inset

polynomial types
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

polynomial functors
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

exponential-polynomial functors
\begin_inset Quotes erd
\end_inset

 etc.; 
\begin_inset Quotes eld
\end_inset

equations
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

; and an 
\begin_inset Quotes eld
\end_inset

effect constructor
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Chapter
Inferring code from types with the LJT algorithm
\begin_inset CommandInset label
LatexCommand label
name "app:CH-correspondence-LJT-algorithm"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "Gentzen-Vorobieff-Hudelmaier algorithm"
target "http://apt13.unibe.ch/slides/Dyckhoff.pdf"
literal "false"

\end_inset

 and its generalizations
\end_layout

\begin_layout Standard
See also the 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"
literal "false"

\end_inset

 project
\end_layout

\begin_layout Section
Slides
\end_layout

\begin_layout Standard
In formal logic, this statement is written in the syntax
\begin_inset Formula 
\[
X,Y,...,Z\vdash T
\]

\end_inset

and is called a 
\series bold
sequent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent (in logic)
\end_layout

\end_inset

 having the premises 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

 and the goal 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
A sequent in formal logic can be proved if proof task;
\end_layout

\begin_layout Standard
The elementary proof task is represented by a 
\series bold
sequent
\end_layout

\begin_layout Standard
Notation: 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

; the 
\series bold
premises
\series default
 are 
\begin_inset Formula $A,B,C$
\end_inset

 and the 
\series bold
goal
\series default
 is G
\end_layout

\begin_layout Standard
Proofs are achieved via axioms and derivation rules
\end_layout

\begin_layout Standard
Axioms: such and such sequents are already true
\end_layout

\begin_layout Standard
Derivation rules: this sequent is true if such and such sequents are true
\end_layout

\begin_layout Standard
To make connection with logic, represent code fragments as 
\series bold
sequents
\end_layout

\begin_layout Standard

\color blue
\begin_inset Formula $A,B\vdash C$
\end_inset


\color inherit
 represents an 
\emph on
expression
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
C
\family default
\size default
\color inherit
 that uses 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
y:
\begin_inset space \space{}
\end_inset

B
\end_layout

\begin_layout Standard
Examples in Scala:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

Int).toString + "abc"
\family default
\size default
\color inherit
 is an expression of type 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 that uses an 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

Int
\family default
\size default
\color inherit
 and is represented by the sequent 
\begin_inset Formula $\text{Int}\vdash\text{String}$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

Int) 
\begin_inset Formula $\rightarrow$
\end_inset

 x.toString + "abc"
\family default
\size default
\color inherit
 is an expression of type 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\rightarrow$
\end_inset

 String
\family default
\size default
\color inherit
 and is represented by the sequent 
\begin_inset Formula $\emptyset\vdash\text{Int}\rightarrow\text{String}$
\end_inset


\end_layout

\begin_layout Standard
Sequents only describe the 
\emph on
types
\emph default
 of expressions and their parts
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Translating language constructions into the logic II
\end_layout

\begin_layout Standard
What are the derivation rules for the logic of types?
\end_layout

\begin_layout Standard
Write all the constructions in FP languages as sequents
\end_layout

\begin_layout Standard
This will give all the derivation rules for the logic of types
\end_layout

\begin_layout Standard
Each type construction has an expression for creating it and an expression
 for using it
\end_layout

\begin_layout Standard
Tuple type 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A\times B\vdash A$
\end_inset

 and also 
\begin_inset Formula $A\times B\vdash B$
\end_inset


\end_layout

\begin_layout Standard
Function type 
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
Create: if we have 
\begin_inset Formula $A\vdash B$
\end_inset

 then we will have 
\begin_inset Formula $\emptyset\vdash A\rightarrow B$
\end_inset

 
\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A\rightarrow B,A\vdash B$
\end_inset


\end_layout

\begin_layout Standard
Disjunction type 
\begin_inset Formula $A+B$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $A\vdash A+B$
\end_inset

 and also 
\begin_inset Formula $B\vdash A+B$
\end_inset


\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A+B,A\rightarrow C,B\rightarrow C\vdash C$
\end_inset


\end_layout

\begin_layout Standard
Unit type 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $\emptyset\vdash1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Translating language constructions into the logic III
\end_layout

\begin_layout Standard
Additional rules for the logic of types
\end_layout

\begin_layout Standard
In addition to constructions that use types, we have 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 constructions:
\end_layout

\begin_layout Standard
a single, unmodified value of type 
\begin_inset Formula $A$
\end_inset

 is a valid expression of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
For any 
\begin_inset Formula $A$
\end_inset

 we have the sequent 
\begin_inset Formula $A\vdash A$
\end_inset


\end_layout

\begin_layout Standard
if a value can be computed using some given data, it can also be computed
 if given
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
,
\end_layout

\end_inset


\emph on
additional
\emph default
 data
\end_layout

\begin_layout Standard
If we have 
\begin_inset Formula $A,...,C\vdash G$
\end_inset

 then also 
\begin_inset Formula $A,...,C,D\vdash G$
\end_inset

 for any 
\begin_inset Formula $D$
\end_inset


\end_layout

\begin_layout Standard
For brevity, we denote by 
\begin_inset Formula $\Gamma$
\end_inset

 a sequence of arbitrary premises
\end_layout

\begin_layout Standard
the order in which data is given does not matter, we can still compute all
 the same things given the same premises in different order
\end_layout

\begin_layout Standard
If we have 
\begin_inset Formula $\Gamma,A,B\vdash G$
\end_inset

 then we also have 
\begin_inset Formula $\Gamma,B,A\vdash G$
\end_inset


\end_layout

\begin_layout Standard
Syntax conventions:
\end_layout

\begin_layout Standard
the implication operation associates 
\emph on
to the right
\end_layout

\begin_layout Standard
\begin_inset Formula $A\rightarrow B\rightarrow C$
\end_inset

 means 
\begin_inset Formula $A\rightarrow\left(B\rightarrow C\right)$
\end_inset


\end_layout

\begin_layout Standard
precedence order: implication, disjunction, conjunction
\end_layout

\begin_layout Standard
\begin_inset Formula $A+B\times C\rightarrow D$
\end_inset

 means 
\begin_inset Formula $\left(A+\left(B\times C\right)\right)\rightarrow D$
\end_inset


\end_layout

\begin_layout Standard
Quantifiers: implicitly, all our type variables are universally quantified
\end_layout

\begin_layout Standard
When we write 
\begin_inset Formula $A\rightarrow B\rightarrow A$
\end_inset

, we mean 
\begin_inset Formula $\forall A:\forall B:A\rightarrow B\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types I
\end_layout

\begin_layout Standard
Now we have all the axioms and the derivation rules of the logic of types.
\end_layout

\begin_layout Standard
What theorems can we derive in this logic?
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $A\rightarrow B\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Start with an axiom 
\begin_inset Formula $A\vdash A$
\end_inset

; add an unused extra premise 
\begin_inset Formula $B$
\end_inset

: 
\begin_inset Formula $A,B\vdash A$
\end_inset


\end_layout

\begin_layout Standard
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

, get 
\begin_inset Formula $A\vdash B\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B\rightarrow A$
\end_inset

, get the final sequent 
\begin_inset Formula $\emptyset\vdash A\rightarrow B\rightarrow A$
\end_inset

 showing that 
\begin_inset Formula $A\rightarrow B\rightarrow A$
\end_inset

 is a 
\series bold
theorem
\series default
 since it is derived from no premises
\end_layout

\begin_layout Standard
What code does this describe?
\end_layout

\begin_layout Standard
The axiom 
\begin_inset Formula $A\vdash A$
\end_inset

 represents the expression 
\begin_inset Formula $x^{A}$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 is of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
The unused premise 
\begin_inset Formula $B$
\end_inset

 corresponds to unused variable 
\begin_inset Formula $y^{B}$
\end_inset

 of type 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives the function 
\begin_inset Formula $y^{B}\rightarrow x^{A}$
\end_inset


\end_layout

\begin_layout Standard
The second 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives 
\begin_inset Formula $x^{A}\rightarrow\left(y^{B}\rightarrow x\right)$
\end_inset


\end_layout

\begin_layout Standard
Scala code: 
\family typewriter
\size footnotesize
\color blue
def f[A, B]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\rightarrow$
\end_inset

 B 
\begin_inset Formula $\rightarrow$
\end_inset

 A = (x:
\begin_inset space \space{}
\end_inset

A) 
\begin_inset Formula $\rightarrow$
\end_inset

 (y:
\begin_inset space \space{}
\end_inset

B) 
\begin_inset Formula $\rightarrow$
\end_inset

 x
\end_layout

\begin_layout Standard
Any code expression's type can be translated into a sequent
\end_layout

\begin_layout Standard
A proof of a theorem directly guides us in writing code for that type
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Correspondence between programs and proofs
\end_layout

\begin_layout Standard
By construction, any theorem can be implemented in code
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def identity[A](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

A = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def toUnit[A](x:
\begin_inset space \space{}
\end_inset

A): Unit = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def inLeft[A,B](x:A):
\begin_inset space \space{}
\end_inset

Either[A,B] = Left(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\times B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def first[A,B](p:
\begin_inset space \space{}
\end_inset

(A,B)):
\begin_inset space \space{}
\end_inset

A = p._1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\rightarrow B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def const[A,B](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

B
\begin_inset Formula $\rightarrow$
\end_inset

A = (y:B)
\begin_inset Formula $\rightarrow$
\end_inset

x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Also, non-theorems 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_layout Standard
Examples of non-theorems:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\rightarrow A$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:A+B\rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\rightarrow A\times B$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:(A\rightarrow B)\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Given a type's formula, can we implement it in code? Not obvious.
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $\forall A\forall B:((((A\rightarrow B)\rightarrow A)\rightarrow A)\rightarrow B)\rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
Can we write a function with this type? Can we prove this formula?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types II
\end_layout

\begin_layout Standard
What kind of logic is this? What do mathematicians call this logic?
\end_layout

\begin_layout Standard
This is called 
\begin_inset Quotes eld
\end_inset

intuitionistic propositional logic
\begin_inset Quotes erd
\end_inset

, IPL (also 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
This is a 
\begin_inset Quotes eld
\end_inset

nonclassical
\begin_inset Quotes erd
\end_inset

 logic because it is different from Boolean logic
\end_layout

\begin_layout Standard
Disjunction works very differently from Boolean logic
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $A\rightarrow B+C\vdash(A\rightarrow B)+(A\rightarrow C)$
\end_inset

 does not hold in IPL
\end_layout

\begin_layout Standard
This is counter-intuitive!
\end_layout

\begin_layout Standard
We cannot implement a function with this type:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
def q[A,B,C](f: A 
\begin_inset Formula $\rightarrow$
\end_inset

 Either[B, C]): Either[A 
\begin_inset Formula $\rightarrow$
\end_inset

 B, A 
\begin_inset Formula $\rightarrow$
\end_inset

 C]
\end_layout

\begin_layout Standard
Disjunction is 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

: need to supply one of the parts
\end_layout

\begin_layout Standard
But 
\family typewriter
\size footnotesize
\color blue
Either[A 
\begin_inset Formula $\rightarrow$
\end_inset

 B, A 
\begin_inset Formula $\rightarrow$
\end_inset

 C]
\family default
\size default
\color inherit
 is not a function of 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Implication works somewhat differently
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $\left(\left(A\rightarrow B\right)\rightarrow A\right)\rightarrow A$
\end_inset

 holds in Boolean logic but not in IPL
\end_layout

\begin_layout Standard
Cannot compute an 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 because of insufficient data
\end_layout

\begin_layout Standard
Conjunction works the same as in Boolean logic
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula 
\[
A\rightarrow B\times C\vdash\left(A\rightarrow B\right)\times\left(A\rightarrow C\right)
\]

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types III
\end_layout

\begin_layout Standard
How to determine whether a given IPL formula is a theorem?
\end_layout

\begin_layout Standard
The IPL cannot have a truth table with a fixed number of truth values
\end_layout

\begin_layout Standard
This was shown by G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
"
\end_layout

\end_inset

odel in 1932 (see 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia page"
target "https://en.wikipedia.org/wiki/Many-valued_logic"
literal "false"

\end_inset

)
\end_layout

\begin_layout Standard
The IPL has a decision procedure (algorithm) that either finds a proof for
 a given IPL formula, or determines that there is no proof
\end_layout

\begin_layout Standard
There may be several inequivalent proofs of an IPL theorem
\end_layout

\begin_layout Standard
Each proof can be 
\emph on
automatically translated
\emph default
 into code
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"
literal "false"

\end_inset

 library implements an IPL prover as a Scala macro, and generates Scala
 code from types
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "djinn-ghc"
target "https://hackage.haskell.org/package/djinn-ghc"
literal "false"

\end_inset

 compiler plugin and the 
\begin_inset CommandInset href
LatexCommand href
name "JustDoIt plugin"
target "https://github.com/nomeata/ghc-justdoit"
literal "false"

\end_inset

 implement an IPL prover in Haskell, and generate Haskell code from types
\end_layout

\begin_layout Standard
All these IPL provers use the same basic algorithm called LJT 
\end_layout

\begin_layout Standard
and all cite the same paper 
\size footnotesize

\begin_inset CommandInset href
LatexCommand href
name "[Dyckhoff 1992]"
target "https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
because most other papers on this subject are incomprehensible to non-specialist
s, or describe algorithms that are too complicated
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search I: looking for an algorithm
\end_layout

\begin_layout Standard
Why our initial presentation of IPL does not give a proof search algorithm
\end_layout

\begin_layout Standard
The FP type constructions give nine axioms and three derivation rules:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Itemize
\begin_inset Formula $\Gamma,A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash A$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\rightarrow B,A\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A+B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,B\vdash A+B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A+B,A\rightarrow C,B\rightarrow C\vdash C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma\vdash1$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A$
\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma,A\vdash B}{\Gamma\vdash A\rightarrow B}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma\vdash G}{\Gamma,D\vdash G}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma,A,B\vdash G}{\Gamma,B,A\vdash G}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Can we use these rules to obtain a finite and complete search tree? No.
\end_layout

\begin_layout Standard
Try proving 
\begin_inset Formula $A,B+C\vdash A\times B+C$
\end_inset

: cannot find matching rules
\end_layout

\begin_layout Standard
Need a better formulation of the logic
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search II: Gentzen's calculus LJ (1935)
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

complete and sound calculus
\begin_inset Quotes erd
\end_inset

 is a set of axioms and derivation rules that will yield all (and only!)
 theorems of the logic
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{}{\Gamma,{\color{blue}X}\vdash X}\:Id & \qquad\frac{}{\Gamma\vdash{\color{blue}\top}}\,\top\\
\frac{\Gamma,A\rightarrow B\vdash A\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A\rightarrow B}\vdash C}\:L\rightarrow & \qquad\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\rightarrow B}}\,R\rightarrow\\
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+ & \qquad\frac{\Gamma\vdash A_{i}}{\Gamma\vdash{\color{blue}A_{1}+A_{2}}}\,R+_{i}\\
\frac{\Gamma,A_{i}\vdash C}{\Gamma,{\color{blue}A_{1}\times A_{2}}\vdash C}\:L\times_{i} & \qquad\frac{\Gamma\vdash A\quad\;\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\times B}}\,R\times
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Two axioms and eight derivation rules
\end_layout

\begin_layout Standard
Each derivation rule says: The sequent at bottom will be proved if proofs
 are given for sequent(s) at top
\end_layout

\begin_layout Standard
Use these rules 
\begin_inset Quotes eld
\end_inset

bottom-up
\begin_inset Quotes erd
\end_inset

 to perform a proof search
\end_layout

\begin_layout Standard
Sequents are nodes and proofs are edges in the proof search tree
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search example I
\end_layout

\begin_layout Standard
Example: to prove 
\begin_inset Formula $\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q$
\end_inset


\end_layout

\begin_layout Standard
Root sequent 
\begin_inset Formula $S_{0}:\emptyset\vdash\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{0}$
\end_inset

 with rule 
\begin_inset Formula $R\rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{1}:\left(R\rightarrow R\right)\rightarrow Q\vdash Q$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{1}$
\end_inset

 with rule 
\begin_inset Formula $L\rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{2}:\left(R\rightarrow R\right)\rightarrow Q\vdash R\rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{3}:Q\vdash Q$
\end_inset


\end_layout

\begin_layout Standard
Sequent 
\begin_inset Formula $S_{3}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom; it remains to prove 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $L\rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{4}:\left(R\rightarrow R\right)\rightarrow Q\vdash R\rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{5}:Q\vdash R\rightarrow R$
\end_inset


\end_layout

\begin_layout Standard
We are stuck here because 
\begin_inset Formula $S_{4}=S_{2}$
\end_inset

 (we are in a loop)
\end_layout

\begin_layout Standard
We can prove 
\begin_inset Formula $S_{5}$
\end_inset

, but that will not help
\end_layout

\begin_layout Standard
So we backtrack (erase 
\begin_inset Formula $S_{4}$
\end_inset

, 
\begin_inset Formula $S_{5}$
\end_inset

) and apply another rule to 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $R\rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{6}:\left(R\rightarrow R\right)\rightarrow Q;R\vdash R$
\end_inset


\end_layout

\begin_layout Standard
Sequent 
\begin_inset Formula $S_{6}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom
\end_layout

\begin_layout Standard
Therefore we have proved 
\begin_inset Formula $S_{0}$
\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q$
\end_inset

 is derived from no premises, it is a theorem
\end_layout

\begin_layout Standard
\begin_inset Formula $Q.E.D.$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search III: The calculus LJT
\end_layout

\begin_layout Standard
Vorobieff-Hudelmaier-Dyckhoff, 1950-1990
\end_layout

\begin_layout Standard
The Gentzen calculus LJ will loop if rule 
\begin_inset Formula $L\rightarrow$
\end_inset

 is applied 
\begin_inset Formula $\geq2$
\end_inset

 times
\end_layout

\begin_layout Standard
The calculus LJT keeps all rules of LJ except rule 
\begin_inset Formula $L\rightarrow$
\end_inset


\end_layout

\begin_layout Standard
Replace rule 
\begin_inset Formula $L\rightarrow$
\end_inset

 by pattern-matching on 
\begin_inset Formula $A$
\end_inset

 in the premise 
\begin_inset Formula $A\rightarrow B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{\Gamma,X,B\vdash D}{\Gamma,X,{\color{blue}X\rightarrow B}\vdash D}\:L\rightarrow_{1}\\
\frac{\Gamma,A\rightarrow B\rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\rightarrow C}\vdash D}\:L\rightarrow_{2}\\
\frac{\Gamma,A\rightarrow C,B\rightarrow C\vdash D}{\Gamma,{\color{blue}(A+B)\rightarrow C}\vdash D}\:L\rightarrow_{3}\\
\frac{\Gamma,B\rightarrow C\vdash A\rightarrow B\quad\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\rightarrow B)\rightarrow C}\vdash D}\:L\rightarrow_{4}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
When using LJT rules, the proof tree has no loops and terminates
\end_layout

\begin_layout Standard
See 
\begin_inset CommandInset href
LatexCommand href
name "this paper"
target "http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2618"
literal "false"

\end_inset

 for an explicit decreasing measure on the proof tree
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search IV: The calculus LJT
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset


\emph on
It is obvious that it is obvious
\emph default

\begin_inset Quotes erd
\end_inset

 — a mathematician after thinking for a half-hour
\end_layout

\begin_layout Standard
Rule 
\begin_inset Formula $L\rightarrow_{4}$
\end_inset

 is based on the key theorem: 
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\rightarrow B\right)\rightarrow C\right)\rightarrow\left(A\rightarrow B\right)\,\Longleftrightarrow\,\left(B\rightarrow C\right)\rightarrow\left(A\rightarrow B\right)
\]

\end_inset


\end_layout

\begin_layout Standard
The key theorem for rule 
\begin_inset Formula $L\rightarrow_{4}$
\end_inset

 is attributed to Vorobieff (1958)
\end_layout

\begin_layout Standard
A stepping stone to this theorem:
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\rightarrow B\right)\rightarrow C\right)\rightarrow B\rightarrow C
\]

\end_inset


\size default
Proof: 
\begin_inset Formula $f^{\left(A\rightarrow B\right)\rightarrow C}\rightarrow b^{B}\rightarrow f\:(x^{A}\rightarrow b)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search V: From deduction rules to code
\end_layout

\begin_layout Standard
The new rules are equivalent to the old rules, therefore...
\end_layout

\begin_layout Standard
Proof of a sequent 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 code/expression 
\begin_inset Formula $t(a,b,c):G$
\end_inset


\end_layout

\begin_layout Standard
Also can be seen as a function 
\begin_inset Formula $t$
\end_inset

 from 
\begin_inset Formula $A,B,C$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Standard
Sequent in a proof follows from an axiom or from a transforming rule
\end_layout

\begin_layout Standard
The two axioms are fixed expressions, 
\begin_inset Formula $x^{A}\rightarrow x$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
Each rule has a 
\emph on
proof transformer
\emph default
 function: 
\begin_inset Formula $\text{PT}_{R\rightarrow}$
\end_inset

 , 
\begin_inset Formula $\text{PT}_{L+}$
\end_inset

 , etc.
\end_layout

\begin_layout Standard
Examples of proof transformer functions:
\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+\\
PT_{L+}(t_{1}^{A\rightarrow C},t_{2}^{B\rightarrow C})=x^{A+B}\rightarrow & \ x\ \text{match}\begin{cases}
a^{A}\rightarrow t_{1}(a)\\
b^{B}\rightarrow t_{2}(b)
\end{cases}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\rightarrow B\rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\rightarrow C}\vdash D}\:L\rightarrow_{2}\\
PT_{L\rightarrow_{2}}(f^{\left(A\rightarrow B\rightarrow C\right)\rightarrow D})=g^{A\times B\rightarrow C}\rightarrow & f\,(x^{A}\rightarrow y^{B}\rightarrow g(x,y))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Verify that we can indeed produce PTs for every rule of LJT
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search example II: deriving code
\end_layout

\begin_layout Standard
Once a proof tree is found, start from leaves and apply PTs
\end_layout

\begin_layout Standard
For each sequent 
\begin_inset Formula $S_{i}$
\end_inset

, this will derive a 
\series bold
proof expression
\series default
 
\begin_inset Formula $t_{i}$
\end_inset


\end_layout

\begin_layout Standard
Example: to prove 
\begin_inset Formula $S_{0}$
\end_inset

, start from 
\begin_inset Formula $S_{6}$
\end_inset

 backwards:
\size footnotesize

\begin_inset Formula 
\begin{align*}
S_{6}:\left(R\rightarrow R\right)\rightarrow Q;R\vdash R\quad(\text{axiom }Id)\quad & t_{6}(rrq,r)=r\\
S_{2}:\left(R\rightarrow R\right)\rightarrow Q\vdash\left(R\rightarrow R\right)\quad\text{PT}_{R\rightarrow}(t_{6})\quad & t_{2}(rrq)=\left(r\rightarrow t_{6}(rrq,r)\right)\\
S_{3}:Q\vdash Q\quad(\text{axiom }Id)\quad & t_{3}(q)=q\\
S_{1}:\left(R\rightarrow R\right)\rightarrow Q\vdash Q\quad\text{PT}_{L\rightarrow}(t_{2},t_{3})\quad & t_{1}(rrq)=t_{3}(rrq(t_{2}(rrq)))\\
S_{0}:\emptyset\vdash\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q\quad\text{PT}_{R\rightarrow}(t_{1})\quad & t_{0}=\left(rrq\rightarrow t_{1}(rrq)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The proof expression for 
\begin_inset Formula $S_{0}$
\end_inset

 is then obtained as
\begin_inset Formula 
\begin{align*}
t_{0} & =rrq\rightarrow t_{3}\left(rrq\left(t_{2}\left(rrq\right)\right)\right)=rrq\rightarrow rrq(r\rightarrow t_{6}\left(rrq,r\right)\\
 & =rrq\rightarrow rrq\left(r\rightarrow r\right)
\end{align*}

\end_inset

Simplified final code having the required type: 
\begin_inset Formula 
\[
t_{0}:\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q=\left(rrq\rightarrow rrq\left(r\rightarrow r\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
To 
\emph on
prove
\emph default
 that there is no proof, one needs to use methods of proof theory that are
 beyond the scope of this book.
 A good introduction to the required technique is the book 
\begin_inset Quotes eld
\end_inset


\emph on
Proof and Disproof in Formal Logic
\emph default

\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Bornat.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "R. Bornat, \"Proof and Disproof in Formal Logic\", Oxford, 2005 - link to Amazon.com"
target "https://www.amazon.com/Proof-Disproof-Formal-Logic-Introduction/dp/0198530277"
literal "false"

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
so suppose we we know we need this type how do we get this code turns out
 mathematicians have studied this question for a long time mathematicians
 were only studying the logical domain of course not the program in domain
 since about 1930 or so many mathematicians have studied this including
 church tarski girdle lots of people in Poland and Germany in England and
 in the United States it took a very long time about 50 years between 1913
 and 1980 between the beginning of this activity when this was first formulated
 as logic with these particular rules and the time when the Curie Howard
 respondents was realized that or was it wasn't was discovered at that time
 it became clear that these things have a direct bearing on functional programmi
ng actually helping people to write code because if you know how to prove
 things here you just directly write the code
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
showing here this is equivalent in Scala just different syntax importantly
 non theorems cannot be implemented in code some on theorems are statements
 in logic that cannot be derived statements that are false or undereye verbal
 examples of these statements are these for all a from one follows a now
 this is certainly suspicious in terms of logic what if a were false then
 we would have it from true false false that's very obviously wrong and
 we cannot implement a function of this type to implement it we would have
 to take a unit argument and produce a value of type a where a is arbitrary
 type but how can we produce a value of type a of the type that we don't
 even know what it is and there is no data for us to produce that value
 so it is impossible another example of an impossible type is this type
 so from a plus B follows a if you wanted to implement this function you
 would have to take a value of disjunction type a plus B and return a value
 of type a but how can you do that what exodus Junction type happens to
 contain B and no a just B it cannot contain a if it contains a B it's a
 disjunction so then we don't have an A and then we again cannot produce
 any and having a B which is a completely different arbitrary type doesn't
 help us to produce me exactly the same reason shows why we cannot produce
 an A a and B given a because that requires a B we cannot produce and also
 this is not implementable because we are required to produce an A but all
 we have is a function from A to B this function will consume an A if given
 only this function cannot possibly produce an A for us but we are required
 to produce an A as a result so we cannot and also there is no proof of
 this formula in the logic so these examples actually lead us to a natural
 question how can we decide given a certain formula whether it is a theorem
 in logic and therefore whether it can be implemented in code it is not
 obvious consider this example can we write a function with this type in
 Scala it is not obvious can we prove this formula it is not clear not quite
 obvious right now suppose I were of the opinion that this cannot be proved
 but how do I show that this cannot be proved I certainly cannot just try
 all possible proofs that would be infinitely many possible proofs that
 would give me all kinds of other formulas and that would give me nothing
 that I can stand oh how to answer these questions so it is really a very
 hard question we are not going to try to answer it on our own we were going
 to use the results of mathematicians they have studied these questions
 for many many years for centuries logic has been studied since ancient
 Greece more than 2,000 years of study all we need to do is to find out
 by what name mathematicians call this logic they are probably already studied
 it what kind of logic is this that we are using that follows from the type
 constructions remember and the very beginning of our consideration we started
 with the type constructions that our programming languages have so that's
 set of type constructions specifies the set of rules of derivation of the
 logic mathematicians call this logic intuitionistic propositional logic
 or IPL also they call it constructive propositional logic but it is less
 frequently used most frequently used name is this and mathematicians also
 call this a non classical logic because this logic is actually different
 from the boolean logic that we are familiar with the logic of the values
 true and false and their truth tables I assume that you are familiar with
 those computations using truth tables and operations and or not in the
 boolean logic so actually this logic the logic of types as I call it or
 intuitionistic propositional logic is very different from boolean logic
 in certain ways it's similar in other ways disjunction for instance works
 very differently here's an example consider this sequence if it has given
 that from a follows B plus C then either from a follows B or from a follows
 C it sounds right from the common-sense point of it if if B plus C Falls
 a B or C if I was I'm using plus as a logical or so if B or C follows then
 it kind of makes sense either B follows or C Falls indeed this is correct
 in the boolean logic which we can find out by writing the truth table so
 we enumerate all the possibilities for a B and C to be true or false or
 eight such possibilities and for each of those possibilities we write the
 truth value of this the truth value of this and we see from the table that
 whenever this is true then this is also true in the boolean logic but this
 does not hold in the intuitionistic logic for the logic of types well why
 does it not hold that's counterintuitive well in fact there is very little
 that's intuitive about this so-called intuitionistic logic actually we
 need to think differently about this logic we need to think can we implement
 an expression of this sequent so implementing it would mean if we're given
 this expression we can build an expression of this type so we're given
 an expression of type A to B plus C let's say some F of this type can we
 build an expression of this type we can this differently by asking can
 we implement a function that takes this as an argument and returns this
 well we know that this is equivalent one of our derivation rules is that
 if you have this sequence then you can also have a sequence that is a function
 type from this to this so for the programmer it is easier to reason about
 a function taking this as an argument and returning this so how can we
 implement this function this function takes F and needs to return a value
 of this type so the body of this function if we could implement it and
 have to construct a value of type either of something there are only two
 ways of constructing a value of type either one is to construct the left
 value second is to construct the right value how do we decide whether to
 construct the left value or the right value we have to decide it somehow
 on the basis of what information can we decide it we don't actually have
 any such information what we have here is a function from a to either BC
 so given some value of a of type a we could compute f of that value and
 then we would have either B or C we could decide them whether to we could
 take them that B or that C but that's not what we need to return we don't
 need to return either of BC we need to return either of this function or
 that function and that function is not yet applied to any a it is it is
 too late for us to ask what is the a we already have to return the left
 of this or a right of that in other words this type either of something-somethi
ng is not itself a function of a it contains functions away but itself it
 cannot be decided on the basis of any assets too late so we need to supply
 a left or right so here right away immediately we have to decide whether
 this will return a left or a right and we cannot really decide that if
 we decide we return the left we must then return a function from A to B
 so there's no way for us to construct this function if we're given this
 function because this function could sometimes return C instead of B and
 then we'll be stuck we cannot do this and we can also return we cannot
 also return the right either so it is impossible to implement a function
 of this type implication also works a little differently in the intuitionistic
 logic here's an example this holds in boolean logic but not in intuitionistic
 logic again let's see why how can we compute this given this this function
 will give us an e only when given an argument of this type but how can
 we produce a value of this type we cannot we don't have information that
 will allow us to produce a value of this type a and B are some arbitrary
 types remember there is universal quantifier outside of all this for all
 a and for all B we're supposed to produce this and that is impossible we
 don't have enough data to produce some values type a and so we cannot implement
 this function conjunction works kind of the same as in boolean logic so
 here's an example this implemented and this is also in boolean logic a
 true theorem now in boolean logic the usual way of deciding whether something
 is true or something is a theorem is to write a truth table unfortunately
 the intuitionistic logic cannot have a truth table it cannot have a fixed
 number of truth values even if you allow more than two truth values such
 that the validity of formulas the truth of theorems can be decided on the
 basis of the truth table this was shown by noodle and this means we should
 not actually try to reason about this logic using truth values it is not
 very useful even an infinite infinite number of truth values will not help
 instead however it turns out that this logic has a decision procedure or
 an algorithm and this algorithm is guaranteed either to find the proof
 for any given formula of the internation intuitionistic logic or to determine
 that there is no proof for that formula the algorithm can also find several
 in equivalent proofs if there is a theorem so a theorem could have several
 in equivalent proofs and since each proof could be automatically translated
 into code of that type it means we could generate several in equivalent
 expressions of some type sometimes so that is the situation with this logic
 which we discover if we write if we read papers about intuitionistic propositio
nal logic that are available in the literature and their open source projects
 on the web such as the gen GHC which is a compiler plugin for haskell this
 is another project doing the same thing and for Scala are implemented occurred
 the Clary Howard library both of these Scala and Haskell all of these color
 and Haskell projects do the same thing they take a type of some expression
 for function and generate code for it automatic by translating the type
 into sequence finding a proof in this logic using the algorithm and translating
 that proof back into code in the way that we have seen in an example it
 is interesting that all these provers and there's a few others there's
 one more for the idris language I did not mention here they all used the
 same decision procedure or the same basic algorithm which is called ljt
 which was explained in a paper by dick off here they all side the same
 paper and I believe this is so because most other papers on this subject
 are unreadable to non-specialists they are written in a very complicated
 way or they describe algorithms that are too complicated so I will show
 how this works in the rest of this tutorial in order to find out how to
 get an algorithm we need to ask well first of all do we have the rules
 of derivation that allow us to create an algorithm already here is a summary
 of the axioms and the rules of derivation that we have found so far these
 are direct translations of the cold expressions that we held in the programming
 language in the notation of sequence now there's one other notation for
 derivation rules which looks like a fraction like this the numerator is
 one or more sequins and the denominator is a sequence and this notation
 means in order to derive what is in the denominator you have to present
 proofs for what is in the numerator so this is the convention in the literature
 this fraction like syntax or notation now we keep in mind that proofs of
 sequence are actually just called expressions that have these types as
 some variables and this type is the entire expression so these are directly
 responding to proofs of this sequence and to the proofs of these derivation
 rules and so if we have a proof that operates by combining some of these
 axioms and some of these generation rules which directly translate that
 back into code now the question is do these rules give us an algorithm
 for finding a proof the answer is no how can we use these rules to obtain
 an algorithm well suppose we need to prove some sequence like this in order
 to prove it we could first see if the sequence is one of the axioms if
 so then we have already proved if we know what expression to write now
 in this case none of the axioms match this so much means maybe a is a times
 B so B here is C and then on the Left we must have C or you must have a
 times B now we don't you don't have C on the left as we have because even
 that's not the same we also don't have a times B at the premise we have
 a but we don't have a times B so these rules don't match the other rules
 don't match the premises and the goal either but also these rules so how
 can we use them well when the writer must be an implication we don't have
 an application on the right here we could try to delete some of the premises
 because it's unused well actually it doesn't look like a good idea could
 you read a for example and we end up with an really hopeless sequence from
 B plus C we cannot get an A ever and so but sounds hopeless so this doesn't
 seem to help and changing the order doesn't seem to help much either and
 so we cannot find matching rules but actually this sequence is provable
 just a clever combination of what axiom to start with and what role to
 use and then again some axiom and so on it will give us that time sure
 because I know how to write code for this this is not difficult you have
 a function with two arguments one of them is a the other is B plus C so
 disjunction of either B C and we are supposed to produce a disjunction
 of tuple a B or C that's easy look at this disjunction if we have a B in
 this disjunction then we can produce a left of the tuple a B because we
 always have an A anyway if we have a see in this disjunction then we could
 return this part of the disjunction in the right of C and we're done but
 unfortunately we see that the rules here do not give us an algorithm for
 deciding this we need a better formulation of the logic again mathematicians
 need to save us from the situation and they have done so mathematicians
 have studied this logic for a long time starting from the early 20th of
 the last century the first algorithmic formulation of the logic that was
 found is due to Jensen who published what he called the calculus just ignore
 the word calculus it means not very much complete and sound calculus means
 that he came up with some rules of derivation which are summarized here
 such that they are equivalent to these they derive all the same theorems
 and only the same theorems so they derive all the stuff that is right and
 only that stuff they don't derive any wrong statements it's very hard to
 come up with such a system of axioms and derivation rules that are equivalent
 to another one in this sense also it's very hard to prove that these are
 actually the rules that will give you all the theorems that could be right
 in this logic that you can actually derive all the theorems that are right
 yet work is already done by mathematicians so we're not going to try to
 do it ourselves we're just going to understand how these rules work now
 the syntax here is slightly enhanced compared with this the enhancement
 is that their names pretty cool now these are just labels they don't really
 do anything in terms of sequence these help us identify which we all have
 has been applied to which sequence and that's all we do so other than that
 it is the same notation so the fraction such as this one means that there
 is a sequence in the denominator which we will prove if there are proofs
 given for sequence in the numerator in this rule there are two sequence
 of them in the numerator other rules may have one sequence in the numerator
 or no sequence in the numerator so these rules that will have no previous
 sequence required those are axioms this axiom means if you have an atomic
 X in other words it's a variable it's a type variables not not a complicated
 expression just attack variable and you can derive that same variable this
 is our accion right here now why is it important that this is atomic that
 this is type variable and not a more complicated expression actually not
 important but it's the simplest rule that you can come up with and mathematicia
ns always like the most minimal set of rules so that's why they say let's
 only consider this rule for the type variables X not for more complicated
 expressions but we can consider this rule for any expression of course
 the identity axiom well here is a truth truth axiom net which derives the
 truth which is the ste symbol which I denote it by one the format in logical
 notation this is the T symbol well let's just call this one for clarity
 so that can be derived from any premises with no previous sequence necessary
 none of these other rules now what do these other rules do they do an interesti
ng thing actually each of these rules is either about something in the sequence
 on the left to the trans time or something in the sequence to the right
 of the transplant which I here shown in blue so these are the interesting
 parts of the sequence that are being worked on or transformed by the rule
 so here's an example this rule is actually two rules the eyes the index
 so I is one or two another two rules just written for gravity like this
 with index I and each of them says you will prove this if you prove one
 of if you prove this so for example you will prove C given if you're given
 a a one A two if you will prove C given just a one which makes sense because
 if you can prove C given a one you don't need a two we can ignore this
 a T we can already proved C from anyone so in this way it would be proved
 and so all these rules work in this way you can prove what's on the bottom
 of the seat of the of the fraction if you're given proofs for what's on
 the top so these are eight derivation rules and two axioms we can use this
 now to make a proof search how do we do that I start with a sequence we
 see which rule matches that sequence so the sequence must have something
 on the left and something on the right well at least one of these it cannot
 be empty so it must be something somewhere and there are only four kinds
 of expressions in our logic type variables conjunctions implications and
 disjunctions now notice I'm using this arithmetic arithmetic all notation
 for logic just because I like it better and I will show that it has advantages
 later so we take a sequence we see which rule matches one of them won't
 match because either in the premise we have one of these expressions were
 in the goal we have one of these expressions and then we find the rule
 of match that matches we apply that rule so we now have new sequence one
 or more that we will need to be proved and if they're true then we fork
 the tree and now we have to prove both of them son-in we continue doing
 that for each of the sequence until we hit axioms so the tree will and
 this leaf or we hit a sequence to which no rule applies in which case we
 cannot prove it and the entire thing is unprovable so in the search tree
 there will be sequence at the nodes of the tree and proofs will be at the
 edges of the tree so each node sends its proof to the root of the tree
 this calculus is guaranteed by mathematicians to be such that indeed if
 you cannot find a rule that applies that means the sequence cannot be proved
 which was not the case here the sequence can be proved and yet we cannot
 find a rule that applies so in this calculus we can use bottom-up approach
 to make a proof search as a tree here we cannot that is the advantage capitaliz
ing on the mathematicians results let us look at an example suppose we want
 to prove this formula this theorem so first step we need to write a sequence
 and this needs to be proved from no premises so we write a sequence s0
 which has an empty set of premises this is a single now what rule applies
 to this sequence with your bottom up so in other words we look at these
 rules and they refine which denominator matches our sequential and our
 cylinders empty set on the left so all the rules on the left cannot be
 applied but on the right we have an expression which is an implication
 at the top level of this expression there is this implies that so this
 is of the form a implies B so this rule applies we have a sequence of the
 form something in our case this is an empty set and then a implies B so
 we apply this rule which is the right implication and we get a new sequence
 which is that what was here before the implication is now put on the left
 to the trans of the to the left of the trans time and it means that this
 expression needs to be now to the left of the turnstile so now this is
 the sequence s1 now we need to prove s1 well we see what rule applies to
 us one well on the right there is just Q so nothing can be done of these
 rules and Q is not truth so we cannot use the axiom either so let's look
 at their left rules on the Left we have now an implication so this is let's
 say a and this is B so we have a rule which has a implication B on the
 left this is the row left implication let's apply it that law will give
 us two new sequence so these two new sequence are s2 and s3 no these ones
 as you can check if you match a location B against this implication Q so
 this is a this is B so then you get these two sequence now we have to prove
 these two sequence as 2 and s 3 s 3 is easy it is just the axiom of identity
 it is this now as 2 again has an implication on the left let's again apply
 the rule left implication to that we get two more sequence as foreign s5
 as for is this because 5 is this so now actually we are in trouble because
 as 2 and s 4 is are the same sequence as 5 actually we could prove with
 some more work but that won't help because we are in a situation when to
 prove as two we need to prove again s 2 so that's it that's a loop that
 will never give us anything it means we applied the wrong rule so we need
 to backtrack this step when we apply the rule left implication to s 2 we
 erase is 4 in this 5 and try a different rule to apply to s 2 which rule
 can apply to s 2 well as to is this it actually has implication on the
 right so we can use the right implication rule and if we do that we get
 a sequence s 6 which is this and this sequence immediately follows from
 the identity axiom because it has promise are on the left and premise are
 and goal are on the right and that is this axiom whatever other premises
 and the premise X on the left premise X on the right and that is a type
 variable so that's perfect we have done the proof as 6 follows from the
 axiom and therefore we have proved s0 no more sequins need to be proved
 and because sequence s0 shows this to be derived from no premises than
 this formula is the theorem that's what the theorem means in the logic
 so that is how we use this calculus to do proof search now we notice that
 we were a bit stuck at some point we had a loop now if we are in the loop
 we don't know what to do maybe we need to continue applying the same rule
 maybe some new sequence come up or maybe we should not continue it is not
 clear what to do and just looking at the rule left implication shows us
 that it's copying this premise a implication B it is copied into the premises
 of the new sequence and so it will generate a loop assuredly after the
 second time you apply it however this sequence might be new so we might
 need to apply it second time we don't know that so that is a problem it
 will do now there have been a lot of work trying to fix this problem and
 literally decades from research by mathematicians the main ones I found
 were what are the off we published in the Soviet Union who de Meyer and
 dick Hoff who published in the United States over this time discovered
 gradually a new set of rules which is called ljt or the calculus ljt which
 cures this problem of looping the way it clears this problem is by replacing
 this rule left implication through four new rules which are listed here
 all other rules are kept the same from this calculus except the rule left
 implication which is replaced in what way so left implication was applying
 it applied to a sequence when the sequin had an implication among the premises
 or on the left to the left of the turnstile the new rules look in more
 detail at what is that implication so that implication could have one of
 the four expressions as the argument of the implication it could have an
 atomic expression as the argument it would have a conjunction as the argument
 could have a disjunction as the argument or it could have an implication
 as the argument in our logic there are no more expressions except these
 four atomic variables conjunctions disjunction and implications and so
 we have here enumerated all the possibilities for what could be to the
 left of the implication in this premise which I have here shown in the
 blue in blue and so for each of these we do certain things replacing this
 sequence with one or more other sequence again it's quite a lot of work
 to prove that these rules are equivalent to these and also that the new
 rules are somehow better they are not giving loops a lot of work which
 I am NOT going to go through because that's far too complicated for the
 scope so what we need suffice it to say that we have very smart people
 who published on this and it is reasonably sure that this is correct so
 the T in the name lgt starts stands for terminating so if we use these
 rules in the same way by by creating a proof tree the proof tree will have
 no loops and will terminate after a finite number of steps and there is
 actually this paper that is also helpful for understanding how to implement
 this algorithm and this paper shows explicitly how to construct an integer
 function from sequence to integers which is a measure of the complexity
 of the sequence and this measure decreases every time you apply a rule
 so it strictly decreases and since this is a strictly decreasing measure
 on the proof tree it means that all the next nodes in the proof tree will
 have a smaller value of this measure so eventually it will hit zero and
 the proof tree will terminate at that leaf either that or you have no more
 rules to apply and if you have no more laws to apply then again mathematicians
 have proved it means our sequence cannot be proved so this is an important
 result that we are going to use and note that this this rule is quite complicat
ed it does a very interesting thing it takes this expression which has implicati
on inside an implication and it transforms this expression in a weird way
 namely the B here is separated from the C by parenthesis but here it is
 not separated so this transformation is highly non-trivial and unexpected
 and its validity is based on this theorem that this in the intuitionistic
 logic is equivalent to this equivalent means they're both following from
 the other so from this promos that and from there follows this so this
 key theorem was attributed to rob you off my dick off in this paper and
 this is this lemma 2 which says that if this sorry that the this derivation
 is if and only if that derivations will have these two equivalences and
 the proof is trivial and the 34 is a reference to to borrow be off now
 when a mathematician says that something is trivial doesn't mean that a
 statement is easy to understand it doesn't mean that the proof is easy
 to find or that it has trees easy to understand it means none of these
 things it just means that right now for this mathematician it is not interestin
g to talk about how it is done that's all it means could be for any number
 of reasons for example mathematicians could just be lazy or have no time
 to again explain this and so they say it's trivial don't be don't be deceived
 when you see somebody says that something is trivial in a mathematical
 text so to prove this one stepping stone could be to prove this first this
 is an easier theorem and if you prove this then clearly from here you can
 get B to C B to C you can substitute in here you can get a to B and then
 you have here a to B so in this way you can show this equivalence in one
 direction now the proof of this statement is obviously trivial in order
 to show the expression of this type I will use my short notation so this
 is F which has this type the first argument of the function the second
 is B which is at this type then we need to produce a see how do we produce
 a C we apply F to an argument of this type the argument of this type is
 a function that takes a and returns a B so we take some X of type a and
 we return a B which was this B so we ignore this X we just returned that
 B and that's the argument of F so this expression is the proof of this
 sequence in other words this is the code that has this type and therefore
 the proof must be available somehow so the details of proving this theorem
 are left as an exercise for the reader again when you see in a mathematical
 text that something is left as an exercise for the reader it does not mean
 that it is easy to do it does not mean that for you it would be a useful
 exercise to do it also does not mean that the author knows how to do it
 it means none of these things it just means the author doesn't feel like
 doing it right now and showing it to you for whatever reason could be because
 they are lazy it could be because I don't know how to do it could be because
 they feel that they should know how to do it but they don't really do know
 how to do it could be any of these reasons don't be deceived when you see
 something like this but of course I had to actually produce an expression
 function of this type in order to implement my curry forward language because
 as I will show in a moment we need to be able to implement all these has
 code in order to help approver so why is that we believe the mathematicians
 that the new rules are equivalent to the old rules which means that if
 you find a proof using these rules somehow you should be able to find the
 proof also using our initial rules which means that if you found that proof
 it would easily translate that to code because each step here is directly
 corresponding to a certain code expression as we have seen at the beginning
 of this tutorial these cold expressions from each of these operations so
 in order to do this with new rules in other words in order to create code
 from proof using new rules we need to show equivalence or we need to show
 how to get code out of each of the new rules now proof of a sequence means
 that we have some expression let's say T what uses variables a B and C
 of these types and expression itself has type G and also as I have shown
 this could be conveniently seen as a function the T as a function from
 a B and C from these three arguments to the type G so for each sequencing
 a proof we should be able to show either that it follows from an axiom
 one of these or that it show it follows from a derivation rule and the
 derivations all transforms one proof into another the axioms are just fixed
 expressions as we had before the axiom that actually didn't change between
 our initial formulation of the logic and the new calculus lgt they actually
 did not change the derivation rules changed each new derivation rule means
 that you're given expressions that prove the sequence in the numerator
 one or more and you are out of these expressions somehow you have to construct
 an expression that proves this sequence now when I say an expression proves
 the sequence what it means is that expression has the type that is described
 by the sequence it's the same thing because we described types of expressions
 through sequence and only those sequence that correspond to valid and existing
 expressions in the programming language only those sequence can be proved
 by the logic this is by construction so now we need to just find what are
 these expressions that corresponds to each of the derivation rules in each
 rule has a proof transformer function as I call it and the proof transfer
 function is explicitly a function that takes one or more expressions that
 are in the numerator and converts that to the expression in the denominator
 that has this type so it has an expression as it has an explicit function
 we need to write down for each of the derivation rules so let's see how
 this is done for these two examples of derivation laws first example have
 a rule that says if you want to derive this sequence we need to derive
 these two sequence now this sequence represents an expression of type C
 which uses an expression of type A plus B so let's represent this as a
 function from a plus B to C now we will be able to just ignore these other
 premises which are common arguments and all these functions we just pass
 them and we don't write them out what is the proof transformer for this
 derivation rule the proof transformer for it is a function that has two
 arguments t1 which is the proof of this must be a function of type II to
 see and t2 which is a proof of this sequence which must be a function of
 type B to see now earlier I said that sequence represent expressions that
 use certain variables but equivalently we can say these are functions that
 take these variables and return these expressions that's more convenient
 when you implement this in code so what we need is a function that takes
 a to C and B to C and returns a function from a plus B to C and this is
 the code that does it we take an argument of type a plus B and we return
 a match expression if it's in the left we applied t1 to that value and
 we get to see if it's in the right we apply t2 to that value and we get
 a C so in any case we get a syllabus so this is a function from a plus
 B to C as required another example is the proof transformer for this rule
 this rule has one sequence going to one sequence so in order to transform
 is proof into this we need a function that takes argument of type A to
 B to C to D and returns a function of type tuple a B going to C to D so
 here's the code we take a function f of type A to B to C to D we return
 a function that takes a G of this type shown here in blue and return we
 need to return a D so how do we get a deal we apply F to a function of
 type A to B to C so we create that function out of G X of type a going
 to Y of type B going to G of x1 so this is a function of type A to B to
 C which is the argument of F as required and the result is of type D so
 that is what we write so this kind of code is the proof transformer for
 this derivation arrow and we need to produce this proof transformers for
 every rule of the calculus lgt and I have done it because I have implemented
 the Korea Howard library that uses LG T so I'll must have done it for each
 flow this is a bit tedious because there are many of those rules and you
 need to implement all this machinery of passing arguments no matter how
 many in this gamma which are emitted from this notation for brevity but
 in of course in the real code you have to deal with all that too so let's
 see how this works on an example because once the proof tree is found we
 need to start backwards from the leaves of the tree back to the root on
 each step we take the proof expression apply the proof transformer to ative
 according to the rule that was used on that step we get a new proof expression
 and so on so for each sequence we will get a proof expression and at the
 end we'll have a proof expression for the root sequence and that will be
 the answer so I will denote denote by T I the proof expressions for the
 sequence s hi so starting from s6 s6 was this sequence in our proof so
 I mean yes just just going through the proof example it was here backwards
 from a 6 back to a 0 s-six was this it followed from axiom identity it's
 proof expression t6 is a function of two variables these two variables
 of these two types and this function just returns the second variable so
 it's a function of RR q and r and just denote this by our argued and Garibaldi'
s types r RQ variable of this type is hard here so this function is very
 simple just ignores the first argument and returns or so that is what the
 axiom does the next sequence was as to as to was obtained by rule our implicati
on or right implication from s 6 so the proof transformer for right implication
 let's look at the right implication and see what the proof transformer
 must be so we are given this sequence for this expression which is the
 function body the function body that uses a variable of type a somehow
 out of this we need to produce a function expression that takes an argument
 of type a and returns that functional body so this is the code which is
 just writing a new argument returning the function body that was our proof
 transformer we need to convert function body into a function so we just
 write that argument and arrow in the function body so in our case we need
 this as a function body and so our t2 is a function of our Q and this function
 is this the sequence s 3 followed from the axiom and so it was just this
 function this is just the identity function then we used the left implication
 so this was actually still done in the calculus algae but the same thing
 works in the calculus lgt I'm just using algae because it's simpler for
 example here proof transformer for the left implication is a little more
 complicated and so if you look at it what what does it have to be it takes
 these two expressions and returns this expression so it takes a function
 from A to B to a and from B to C and it returns a function from A to B
 to see how does it do it given a function a to b you use this to derive
 a from it then you substitute that a into the function into B you get a
 B when you use this to derive see from that B and that's your C so you
 use this function a to be twice you put it in here once and then you get
 an A and substitute back into the same function when you get a B then you
 use that and that's exactly what the proof transformer does it takes this
 rrq and it uses it twice substitutes into it something that was obtained
 from one of the terms and then uses the second term on the result so then
 this is the proof transformer for the rule left implication the result
 of the proof transformation is the proof for the sequence s1 finally we
 use the right implication again which is just this function construction
 and we get the proof expression for the sequence s0 now this proof expression
 is written through these t1 t2 t3 we have to substitute all this back in
 order to get the final expression so if we substitute first of all we find
 this is our our cubone going to tea one of our cutie one of our queue is
 this so we have to put it here now t3 is just identity so we can just remove
 that so that gets you riq going to our Q of T 2 T 2 is less if I have to
 put it in T 6 is just identity on R so this is our going to our and so
 finally you have this expression so that is the final code that has the
 required type notice that we have derived this code completely algorithmic
 to it there was no guessing we found which rules applied to the sequence
 with transformed sequence according to the rules once we found the proof
 which was if we use the calculus ljt the proof will be just a finite tree
 with no loops it will terminate you can get an exhaustive depth-first search
 for it for example and you find all the possible proofs if you want as
 well well you will find many in any case in some for some expressions and
 then we use the proof transformers which are fixed functions that you can
 upfront compute for each these expressions are proof transformers applied
 to the previous proofs so these are completely fixed algorithmically fixed
 so we have derived this code completely algorithmically given this expression
 this type so it is in this way that the career Howard correspondence allows
 us to derive the code of functions from there type signatures another important
 application of the correspondence is to analyze type by some morphisms
 or type equivalences and I was led to this by asking the question so in
 this logic or in the types are these operations plus and times as I denoted
 them more like logic more like the disjunction and conjunction or are they
 more like arithmetic plus and times because this is kind of not so clear
 right away our logic is this intuitionistic logic it in any case this is
 different from boolean logic so what are the properties of these types
 really so are the properties such that it is better to think about these
 operations as plus and times rather than logical conjunction and disjunction
 can answer this question I looked at identities that we have in the water
 these are some identities from simple ones obvious ones to less obvious
 identities like this the equal sign here stands for implication in both
 directions so both this implies that and vice versa because of this each
 of the implications means a function so since these are all identities
 in logic it means that for example the implication from here to here is
 a theorem of logic and so it can be implemented as we know all our identities
 in logic can be implemented in code and we even have an algorithm now that
 can automatically produce proofs and automatically produce code so that
 means for any of these identities that has some ik some expression X on
 the left and some Y on the right so some kind of X equals y we have X implies
 Y and y implies X if we convert that to code we will have a pair of functions
 function from X to one and the function from Y to X what do these functions
 do well they convert values in some ways from type X to type Y and back
 so do these functions Express the equivalence of the types x and y so that
 any value of type X can be converted to some equivalent value type while
 and back without any loss of information is that so that was the question
 I asked I looked at some examples well first what does it mean more rigorously
 that types are equivalent for as mathematicians say isomorphic the types
 are isomorphic and we will use this notation for that if there is a one-to-one
 correspondence between the sets of values of these types and in order to
 demonstrate that we need a pair of functions one going from A to B the
 other going from B to a such that the composition of these functions in
 both directions is equal to identity function so F compose G or F value
 G will give you from A to B and then from B to a is back so that would
 be identity of a to a this will be identity of B to B if this is true if
 the composition is identity it means we indeed did not lose any information
 let's consider an example this is an identity in the logic a conjunction
 with one is equal to a in Scala the types responding to the left and the
 right hand sides of this conjunction all of this are equivalent are the
 conjunction of a and unit and a itself now we need functions with these
 types indeed we can write functions is having these types a pair of a and
 unit we need to produce an a out of that we'll just take the first element
 of the pair you are done take an X of type a will produce tuple of a and
 unit very easy just put a unit value in the tuple in here done and it's
 easy to verify that composition of these functions will not change any
 values so it will be identity in both directions another example this is
 an identity in logic if this is understood as a disjunction one or a or
 true or a is true that is an identity in logic for theorem in the logic
 are the types equivalent though the type for 1 plus a is the option in
 Scala it is option in Haskell at is called maybe this type is standard
 library type in pretty much every functional programming language now option
 of a is a disjunction of one or unit and a it is certainly not equivalent
 to just unit because this type could contain a value of a in it but this
 could not so there is no way that you could transform this type to this
 and then back without losing information you could transform so since this
 is a theorem you have functions from this type to this type and back some
 functions you have them but these functions do not compose to identity
 they cannot because what if you had a here you must map it into unit from
 this unit back you must map into this unit you cannot get an a out of unit
 and so that will erase this information and that cannot become isomorphism
 so we see that some logic identities do yield isomorphism types but others
 do not why is that let's look at some more examples to figure out why in
 all these examples we can implement functions F 1 and F 2 between the two
 sets to two types in both directions and then we can check we certainly
 can implement them because these are logical identities but then we can
 check if the compositions are identity functions and if so the types are
 isomorphic but we find that in the first three examples we can do it but
 in this last example we can note now I have written the logical identities
 logical theorems with the arithmetic notation I call this arithmetical
 notation because this suggests arithmetic operations plus and times and
 if you look at these identities this looks like a well-known algebraic
 identity from the school algebra in this too but this certainly seen your
 own as an arithmetic as an as an arithmetic identity this is certainly
 not true in arithmetic it is true in logical if you replace this with disjuncti
on and this with conjunction this is an identity in logic so this suggests
 an interesting thing if you replace disjunction by plus and conjunction
 by x and the result is an identity in arithmetic then it is an isomorphism
 of types otherwise it is not let's see why this is so indeed this is so
 I call this the arithmetic arithmetic oh very hard correspondence to see
 how it works let's consider only the types without loss of generation of
 generality that have a finite set of possible values for example a boolean
 type has only two possible true and false integer let's say in the computers
 all the integers are fine nights ago so those types have a finite set of
 possible values and this does not limit our generality because in the computer
 everything is finite all types have a finite set of possible values now
 let's consider how many values a given type has so that would be the size
 of the type or using the mathematical terminology it's called a cardinality
 of the type so let's see what is the cardinality of various type constructions
 the sum type for example if the cardinality of types a and B is known and
 the cardinality of a plus B the sum type the disjunction of a and B is
 the sum of the two cardinalities or sizes this is because a value of the
 disjunction type is constructed as either a value of the first part or
 a value of the second part and so you cannot have both together and so
 obviously the different number of values is just the sum of the two sizes
 that the number of different values of the sum type is just the sum of
 the numbers of different values of types a and B for the product type again
 we have an interesting thing it's the arithmetic product of the sizes of
 a and B because for every a value you could have an arbitrary B value so
 this is a direct product or transient product of sets and we have school
 level identities about the operations plus and times such as these identities
 or these all of these identities are valid for arithmetic and they show
 if you translate that into statements about the sizes of types they show
 that the size of the type on the left is equal to the size of the type
 on the right and that is very suggestive in other words if you take a identity
 like this and you compute the size of the type on the left and the size
 of the type on the right you get an arithmetic identity of the sizes but
 you don't get that identity here because the earth medical formula is not
 right this is very suggestive if the sizes are equal and maybe the types
 are equivalent or isomorphic when the sizes are not equal then certainly
 they cannot be equivalent the function type very interestingly also is
 described in the same way it provides the set of all maps between the two
 sets of values so for example from integer to boolean that would be all
 the functions that take some integer and return some boolean so that's
 and a number of boolean values ^ the number of integer values that's how
 many different functions you can have as a combinatorial number so it's
 an exponential and so the size of the type of function a to be is the size
 of the type of B ^ the size of type of a and again we have all the school
 identities about powers and how to multiply powers and so on and they are
 directly translated into these three identities if you take the sizes of
 the types on the left and on the right the sizes will be equal due to these
 three identities since the sizes are equal it's very likely that the type
 our actual equivalent so far haven't seen any counter examples to this
 in these constructions so this gives us a meaning of the Curie Howard correspon
dence so far we have seen three facets of the curly Howard correspondence
 one is the correspondence between types and logical formulas two is the
 correspondence between code and proofs and three the correspondence between
 the cardinality of a type or the set size of the type and the arithmetic
 identities that we have in the school algebra about these types so arithmetical
 identities signify type equivalence or isomorphism while logic identities
 only talk about how you create some value of this type out of value of
 another type so that does not guarantee that it preserves information it
 just guarantees that you can implement some function of that type it doesn't
 tell you that the function will be an isomorphism so if one type is logically
 equivalent to another it means are equally implementable if one is implementabl
e another is also implementable but no more than that whereas arithmetical
 identities actually tell you about isomorphism of types therefore if you
 look at types and write them using my preferred notation which is using
 the arithmetic all symbols instead of logical symbols instead of these
 I'll use these symbols if I do that this is very suggestive of a possible
 isomorphism of types then it becomes very easy for me to reason about types
 I can see right away that these two are isomorphic types or that these
 two are isomorphic types because I am used to looking at school algebra
 it's very obvious then that this is not an isomorphism of types because
 this doesn't make sense in the school algebra so reasoning about isomorphic
 types is basically school level algebra involving polynomials and powers
 so if you are familiar with all these identities as you should be it will
 be very easy for you the reason about what types are equivalent as long
 as all these types are made up of constants or primitive types disjunctions
 tuples or conjunctions and functions which will then directly be translated
 into exponential polynomial expressions constants sums products and expand
 powers or Exponential's so I call these exponential polynomial types that
 is types built up from these type constructions so all we have been talking
 about in this tutorial is what I call exponential polynomial types these
 are the basic type constructions that I started with tuple product function
 exponential disjunction some unit constant or 1 now just one comment that
 in the functional programming community today there is a terminology algebraic
 types so people usually call algebraic types the types that are made from
 constant types sums and products excluding Exponential's I do not find
 this terminology it's very helpful I find it confusing because what is
 particularly an algebraic about these identities these are identities of
 school algebra the properties of the function type are described by algebraic
 identities like this so it would be strange to call the function type not
 algebraic whereas these types are algebraic they are very similar to each
 other in terms of their properties being described by identity is known
 from school algebra so instead of algebraic types I would prefer to say
 polynomial types this is much more descriptive and precise and if you want
 to talk about function types as well then you just can you can just say
 exponential polynomial types or exfoli types for short so by way of summarizing
 what we have done so far what are the practical implications of the career
 Howard correspondence so one set of implications is actually for writing
 code and reason and eternal code one thing we can do now is if we're given
 a function with some type and usually this will be typed with type parameters
 all type trainers fully parametric types such as the function we have been
 considering here all these functions do not have any types that are specific
 like integer or string all the types are fully parametric and then there
 are some constructions some type expressions made out of these types so
 these are what I call fully parametric functions for these functions we
 have a decision procedure an algorithm that based on the ljt calculus which
 decides whether this function can be implemented in code and computer scientist
s a type is inhabited if you can produce a value of this type in your program
 so CH of T is this proposition which they call type is inhabited and I
 prefer to call it just that you can compute a value of this type or code
 has the type O code can create a value of this type and so we have a algorithm
 that can also generate the code from type when it is possible if it is
 not possible the algorithm will tell you so often not always but often
 this algorithm can be used actually to generate the code you want we can
 also use what I call the arithmetic of glory Harvard correspondence to
 reason about type isomorphisms and to transform types isomorphic we simplify
 type expressions just like we simplify expressions in school level algebra
 by expanding brackets by permuting the order of terms like a plus B is
 equal to B plus a or associativity a times B all times C can be expanded
 and so on so this allows us once we have written types in the short notation
 in the notation that I prefer which resembles school algebra because it
 uses the plus and times symbols instead of the logic symbols so once we
 rewrite our types and this notation which I have been doing consistently
 in this tutorial it enables us the reason very easily but which types are
 equal or isomorphic because we are all familiar with the school level algebra
 what are the problems that we cannot solve using this knowledge one thing
 we cannot do is to generate code automatically such that it will be an
 isomorphism so for instance in an example here we are able to generate
 automatically the code of these functions but it will not be an isomorphism
 and the lgt algorithm cannot check that this is nice a morphism that's
 the important thing this algorithm does not know about equations or isomorphism
s it only knows that it found some code that has the type you wanted whether
 this code is useful to you or not we don't know the algorithm doesn't know
 this also if the algorithm finds several such several proofs of a sequence
 it will generate several not in equivalent versions of your code it doesn't
 know which one is is useful maybe some of them are useless maybe not the
 algorithm cannot automatically decide that in general another thing we
 cannot do is to express complicated conditions via types such as that array
 is sorted the type system is not powerful enough in all the languages I
 listed you need a much more powerful type system such as that in the programmin
g language interests or add them or cook those are much more powerful type
 systems that can express such complicated conditions but for those type
 systems there is no algorithm that will generate code another thing we
 cannot do is to generate code that has type constructors such as the map
 function here's an example in Scala this is a map function on a list so
 there's the list of a a is a type parameter and then we say dot map and
 map has another type frame to be it takes a function from A to B for any
 B so a is fixed but now from any B we can take a function from A to B and
 generate a list of B so if we wrote this formula in the short type notation
 this would look something like this I'm writing subscript a because this
 is a type parameter so this is like an argument or a type parameter I'm
 writing it like this and then from this this is the first argument of the
 function and then there is a second argument which is this F and that is
 another quantifier for B inside parentheses so this formula has a quantifier
 inside so far we have been dealing with formulas that have all quantifiers
 outside and so we never write quantifiers explicitly but here we have to
 write them inside this is a more powerful logic which is called first-order
 logic in other words this is a logic where you have quantifiers anywhere
 in the formula including inside the formula unfortunately this logic is
 undecidable so there is no algorithm that we can use either to find the
 proof and therefore code freedom type or to show that there is no proof
 no code so we're kind of stuck in all these directions some more remarks
 about the curry Harvard correspondence first is that only with parameterize
 types we can get some interesting information out of it if we take concrete
 types like integer then the proposition CH event meaning that our code
 can have a value of type int it that's always true can always write any
 some integer value we don't need any previous data for it so for all specific
 types all these propositions are always choice completely void of information
 the only interesting part comes when we start considering type variables
 if we start asking can we make a type which is either of a B going to a
 going to B in soon for all a B once we start doing this with type parameters
 a B and so on then we get interesting information as we have seen in this
 tutorial another remark is that functions like this one are not sufficiently
 described by their type so that this is the type of integer going to integer
 now looking at this type we can put this into a sequence but we'll never
 get enough information to actually get this function so only certain class
 of functions which are fully typed biometric their type signature is informativ
e enough so that we can derive code automatically only in much more powerful
 type systems you can have type information that is enough to specify fully
 a code like this another caveat is that I don't know the proof that arithmetic
 identity guarantees the type equivalence it is certainly a necessary condition
 because if two types have different cardinality or different size of their
 sets of values that they cannot be equivalent or they cannot be isomorphic
 so this is a necessary condition but it's not a sufficient condition it
 looks like I don't know if this is sufficient I haven't seen any counter
 examples so far final remarks about type correspondence the logical constant
 false did not appear in any of my slides so far this was on purpose it
 has extremely limited practical use in programming languages because actually
 we have types corresponding to false Scala has type called nothing Haskell
 has type usually called void that corresponds to the logical constant false
 what does it mean CH of nothing is false it means your code can never have
 a value of type nothing or in Haskell void you can never compute a value
 of this type so clearly it has a very limited practical significance you
 will never be able to compute any values of this type ever in any program
 it's identically falseness this constant so if you want to add it to the
 logic it's very easy you just have one rule and you're not done you can
 derive things with it if you want but they will have almost never any use
 in practical code also we did not talk about negation none of the calculus
 calculate that I should have in logical negation as in operation again
 for the same reason we do not have a programming language construction
 that represents logical negation negation by definition is like this is
 an application from 8 to 4 so that's not a not a means from a follows falsehood
 now since you cannot ever get false in a programming language you cannot
 really implement this function in any useful sense and so i have seen some
 haskell library that used this type void as a type parameter in some way
 but certainly it's a very limited and rare use and so it is not really
 lumen 18 to include negation it could probably find some very esoteric
 uses of it but almost never useful and finally there is another set of
 important implications from the Kurihara correspondence these are implications
 for people who want to design new programming languages as we have seen
 the Karaka with correspondence maps the type system of a programming language
 into a certain logical system where prepositions follow from each other
 or can be proved from each other and this enables us to reason about programmed
 to see what kind of code can be written if some other kind of code can
 be written and logical reasoning is very powerful it's simpler than trying
 to write code and it gives you algorithms and all kinds of mathematical
 results that have been found over the centuries so languages like those
 listed here have all the five type constructions that I wasted in the beginning
 of this tutorial and mapping them into logic gives a full constructive
 logic or full intuitionistic logic with all logical operations and or so
 conjunction disjunction implication and the truth constant whereas languages
 such as C C++ Java and c-sharp and so on they're mapped to incomplete logics
 because they do not have some of these operations for instance they do
 not have type constructions of correspond to disjunction we also do not
 have the true constant or the false constant so they are mapped to a logic
 that lacks some of the foundational logical operation so it can be only
 fewer theorems can be proved in that logic and so your reasoning about
 theory types is hampered languages called scripting languages sometimes
 such as Python or JavaScript will be and so on also our belongs there in
 that line those languages only have one type they actually don't check
 types at compile time and so they're mapped to logics with only one proposition
 those logics are extremely small in terms of what kind of things you can
 reason about and so if you write a program in these languages you are completel
y unable to reason at the level of types whereas in these languages you
 are able to reason but in a limited way you're not having a complete logic
 so this suggests a principle for designing the type system in a new programming
 language the first step would be to choose a good and complete logic that
 is free of inconsistency mathematicians have studied all kinds of logics
 and they are always interested in questions such as is this logic consistent
 consistent means you cannot derive false from true is this logic complete
 can you derive all things that are true are there enough axioms and rules
 of derivation or maybe there are too many axioms and rules of derivation
 you can delete some of them and have fewer mathematicians have always been
 interested in such questions they found all kinds of interesting logics
 where you can derive a lot of interesting theorems non trivial theorems
 and they found the minimum sets of axioms and rules of derivations for
 these logics use their results take one of the logics that they do them
 and develop such as intuitionistic logic model logic temporal logic linear
 logic and so on take one of these logics for each of the basic operations
 of this logic provide type constructions in your programming language that
 are easy to use for instance your logic has disjunction implication or
 something else provide a type constructor for each of them that's easy
 to use easy to write down such as provided by the languages we have seen
 then every type will be mapped to a logical form of the OPF logical formula
 for every type and there will be a type for every logical formula and then
 for each rule of the new logic for each derivation rule there should be
 a construct in the code that corresponds to it so that you could transform
 proofs in logic into code and code into proofs if you do that your language
 will be faithful to the scorecard correspondence you will be able to use
 logic to reason about your language and one important result at this level
 while we have seen that you can sometimes generate code that is maybe nice
 but a very important result is that if your logic is free of inconsistency
 it means that no program will ever be able to derive an inconsistent an
 inconsistent type means that you had a function that requires some type
 a but it was called with a different type beam which is incompatible and
 that basically crashes so in languages like C and C++ we have all kinds
 of crashes like a segmentation fault in Java the exceptions nullpointerexceptio
n or class cast exception which happens when you call a function on the
 wrong type of argument and that happens if your logic is inconsistent if
 your logic can derive incorrect statements from correct premises then if
 you translate that derivation into code and the that code will derive incompati
ble type at the wrong place and it will crash the crash will happen at runtime
 the compiler will not catch this inconsistency because the compiler only
 checks the logic of types and the logic checks out you have followed the
 rules of derivation of the logic the compiler can check out all these logical
 rules but the compiler does not know that your logic is inconsistent maybe
 and then it will deep have derived an inconsistent result falsehood from
 truth for example and that will crash at runtime now we know that crashing
 at runtime is not a good outcome so in fact languages like Oh camel have
 been studied and for other languages some subsets of Haskell I believe
 called safe Haskell have been studied and it has been shown that they cannot
 crash and they're the way to show it mathematically is to use the fact
 that they are based on a complete and consistent logic and then all you
 need to show is that your compiler does not have some critical bugs that
 allow it to oversee that you have not followed the derivation rules of
 the logic that is an extremely valuable feature of functional programming
 languages that are based on the Curie habit correspondence you can prove
 their safety at compile time or at least exclude a large number of possible
 bugs and errors certainly these languages are quite large and they include
 features that are not covered by the Carey Hart correspondence type constructor
s that I have not considered in this tutorial and those might may not be
 safe but at least the foundation of these languages the foundation of the
 type system will be safe so that is the final lesson from the great Howard
 correspondence this concludes the tutorial 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Parametricity theorem and naturality laws
\begin_inset CommandInset label
LatexCommand label
name "app:Proofs-of-naturality-parametricity"

\end_inset


\end_layout

\begin_layout Standard
Functional programming (FP) focuses on a small set of language features
 — the six type constructions and the nine code constructions
\begin_inset Index idx
status open

\begin_layout Plain Layout
nine code constructions
\end_layout

\end_inset

, introduced in Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Type-notation-and-standard-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

; see also Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Mathematical-notation-for-basic-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 These constructions create 
\series bold
fully parametric
\series default
 programs
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code
\end_layout

\end_inset

 and are sufficient to implement all design patterns of FP.
 At the same time, restricting programs to be fully parametric will enable
 several ways of mathematical reasoning about code.
 Examples of such reasoning are treating programs as mathematical values
 (referential transparency); deriving the most general type from code (type
 inference); and deriving code from type (code inference).
\end_layout

\begin_layout Standard
Another property of fully parametric code is automatic adherence to naturality
 laws.
 By the 
\series bold
parametricity theorem
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
parametricity theorem|textit
\end_layout

\end_inset

, any fully parametric function with a type parameter will satisfy a certain
 naturality law.
 Not having to derive and verify naturality laws by hand saves a lot of
 time.
\end_layout

\begin_layout Standard
\begin_inset Wrap table
lines 0
placement l
overhang 0in
width "58col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset VSpace -20baselineskip%
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala example
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
unit or a 
\begin_inset Quotes eld
\end_inset

named unit
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
product type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
co-product type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
function type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[F[_]]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Fix}^{F^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!type constructions
\end_layout

\end_inset

The six type constructions of fully parametric programs.
\begin_inset CommandInset label
LatexCommand label
name "tab:six-pure-type-constructions"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -20baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Code construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala example
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Code notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use unit value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use argument (bound variable)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => expression
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x\rightarrow expression$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f(x)$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $x\triangleright f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a\times b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (a, b) => ...
 }
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a\times b\rightarrow...$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $p\triangleright\pi_{1}$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $p\triangleright\pi_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create disjunctive value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](a)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "19col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset VSpace 20baselineskip%
\end_inset


\begin_inset Formula $a^{:A}+\bbnum 0^{:B}$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Formula $\begin{array}{|cc|}
a & \bbnum 0\end{array}$
\end_inset


\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use disjunctive value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p match { case Left(a)   => f(a)            case Right(b)  => g(b)     
     }
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "23col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset VSpace 20baselineskip%
\end_inset


\begin_inset Formula $p\triangleright\,\begin{array}{|c||c|}
 & C\\
\hline A & f\\
B & g
\end{array}\,~\text{ or }~p\triangleright\,\begin{array}{||c|}
f\\
g
\end{array}$
\end_inset


\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use recursive call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f(x) = { ...
 f(y) ...
 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x)\triangleq...~\overline{f}(y)~...$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code constructions
\end_layout

\end_inset

The nine code constructions of fully parametric programs.
\begin_inset CommandInset label
LatexCommand label
name "tab:nine-pure-code-constructions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Philip Wadler
\end_layout

\end_inset

The paper 
\begin_inset Quotes eld
\end_inset


\emph on
Theorems for free
\emph default

\begin_inset Quotes erd
\end_inset

 by Philip Wadler
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps"

\end_inset


\family default
 and some further explanations in the blog posts 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://reasonablypolymorphic.com/blog/theorems-for-free/"

\end_inset


\family default
 and 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://bartoszmilewski.com/2014/09/22/"

\end_inset


\end_layout

\end_inset

 derives the parametricity theorem from J.
\begin_inset space ~
\end_inset

Reynolds's 
\begin_inset Quotes eld
\end_inset

abstraction theorem
\begin_inset Quotes erd
\end_inset

.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
John Reynolds
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See the 
\begin_inset CommandInset href
LatexCommand href
name "paper"
target "https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf"
literal "false"

\end_inset

 by J.
\begin_inset space ~
\end_inset

Reynolds, 
\begin_inset Quotes eld
\end_inset


\emph on
Types, abstraction, and parametric polymorphism
\emph default

\begin_inset Quotes erd
\end_inset

, Information Processing
\begin_inset space ~
\end_inset

83, p.
\begin_inset space ~
\end_inset

513 (1983).
\end_layout

\end_inset

 Finding naturality laws via the Reynolds-Wadler approach is hard: their
 technique is based on replacing functions by 
\begin_inset Quotes eld
\end_inset

relations
\begin_inset Quotes erd
\end_inset

 (both between types and between values).
 One first needs to learn special new rules for working with relations.
\begin_inset Foot
status open

\begin_layout Plain Layout
Tutorials on that subject are rare; one is the 
\begin_inset CommandInset href
LatexCommand href
name "paper"
target "https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions"
literal "false"

\end_inset

 by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ronald Backhouse
\end_layout

\end_inset

R.
\begin_inset space ~
\end_inset

Backhouse, 
\begin_inset Quotes eld
\end_inset

On a relation on functions
\begin_inset Quotes erd
\end_inset

 (1990).
 See also the 
\begin_inset CommandInset href
LatexCommand href
name "book"
target "https://themattchan.com/docs/algprog.pdf"
literal "false"

\end_inset

 by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bird
\end_layout

\end_inset

R.
\begin_inset space ~
\end_inset

Bird and O.
\begin_inset space ~
\end_inset

de Moor, 
\begin_inset Quotes eld
\end_inset

The algebra of programming
\begin_inset Quotes erd
\end_inset

 (1997).
\begin_inset Note Note
status open

\begin_layout Plain Layout
Solutions to exercises are available here: 
\begin_inset CommandInset href
LatexCommand href
target "https://web.archive.org/web/19981205052219/http://www.comlab.ox.ac.uk/oucl/publications/books/algebra/book.html"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 Then the parametricity theorem gives a statement about certain properties
 of relations.
 To derive a naturality law for functions, we must somehow replace each
 relation by a function.
 This replacement is done by 
\emph on
guessing
\emph default
: the parametricity theorem provides no guidance at that point.
\end_layout

\begin_layout Standard
Adapting the parametricity theorem to the needs of FP practitioners, this
 Appendix derives all naturality laws for fully parametric code without
 using relations and without guessing.
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Additional literature:
\end_layout

\begin_layout Plain Layout
[1]: Girard, J.-Y.; Scedrov, A.
 & Scott, P.
 J.
 Normal Forms and Cut-Free Proofs as Natural Transformations.
 Logic From Computer Science, Mathematical Science Research Institute Publicatio
ns 21, Springer-Verlag, 1992, 217-241.
 http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.811
\end_layout

\begin_layout Plain Layout
[2]: Bainbridge, E.
 S.; Freyd, P.
 J.; Scedrov, A.
 & Scott, P.
 J.
 Functorial polymorphism.
 Theoretical computer science, Elsevier, 1990, 70, 35-64.
 https://core.ac.uk/display/82270459
\end_layout

\begin_layout Plain Layout
[3]: De Lataillade, J.
 Dinatural Terms in System F.
 Logic in Computer Science, 24th Annual IEEE Symposium, 267-276, 2009.
 https://www.irif.fr/~delatail/dinat.pdf
\end_layout

\begin_layout Plain Layout
[4]: Pistone, P.
 On completeness and parametricity in the realizability semantics of System
 F.
 https://arxiv.org/abs/1802.05143
\end_layout

\begin_layout Plain Layout
See discussion here: https://cstheory.stackexchange.com/questions/42256/is-case-an
alysis-on-normal-forms-of-lambda-terms-sufficient-to-prove-parametrici
\end_layout

\end_inset


\end_layout

\begin_layout Section
Commutativity laws for profunctors and bifunctors
\begin_inset CommandInset label
LatexCommand label
name "sec:Commutativity-laws-for-type-constructors"

\end_inset


\end_layout

\begin_layout Standard
The first result concerns type constructors with two type parameters, such
 as bifunctors.
 The bifunctor commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

) was introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Bifunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We will now prove the commutativity law by induction on the type structure
 of a given bifunctor.
\begin_inset Foot
status open

\begin_layout Plain Layout
In the blog post 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://byorgey.wordpress.com/2018/03/30/"

\end_inset


\family default
, Brent Yorgey
\begin_inset Index idx
status open

\begin_layout Plain Layout
Brent Yorgey
\end_layout

\end_inset

 gave a proof of the commutativity law for bifunctors by using the Reynolds-Wadl
er parametricity theorem.
 
\end_layout

\end_inset

 It turns out that the proof also requires the commutativity laws for type
 constructors with 
\emph on
contravariant
\emph default
 type parameters.
 All those proofs are completely analogous, so we will first prove the commutati
vity law for profunctors, which are type constructors with one contravariant
 and one covariant type parameter.
 The profunctor commutativity law will be important for the proof of the
 main parametricity theorem (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Naturality-laws-for-fully-parametric-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsection
Proof of the profunctor commutativity law
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proof-of-the-profunctor-commutativity-law"

\end_inset


\end_layout

\begin_layout Standard
Given an arbitrary type constructor 
\begin_inset Formula $P^{A,B}$
\end_inset

 contravariant with respect to 
\begin_inset Formula $A$
\end_inset

 and covariant with respect to 
\begin_inset Formula $B$
\end_inset

, we formulate the profunctor 
\series bold
commutativity law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
commutativity law!of profunctors
\end_layout

\end_inset

 by analogy with the bifunctor law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
\text{commutativity law of }P:\quad & \text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})\bef\text{fmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})=\text{fmap}_{P^{C,\bullet}}(g)\bef\text{cmap}_{P^{\bullet,D}}(f)\quad,\nonumber \\
\text{in a shorter notation}:\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.\label{eq:profunctor-commutativity-law}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "38col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -170baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{6.0pc}P^{C,B}\ar[r]\sp(0.55){\text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})~~~}\ar[d]\sb(0.45){\text{fmap}_{P^{C,\bullet}}(g)} & P^{A,B}\ar[d]\sb(0.45){\text{fmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})}\\
P^{C,D}\ar[r]\sb(0.45){~~~~\text{cmap}_{P^{\bullet,D}}(f)} & P^{A,D}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -170baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now prove that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for any 
\series bold
fully parametric profunctor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!profunctor
\end_layout

\end_inset

 
\begin_inset Formula $P^{A,B}$
\end_inset

, i.e., a profunctor defined via a combination of the six type constructions
 from Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We will assume that all contrafunctor liftings such as 
\begin_inset Formula $f^{\downarrow P^{\bullet,B}}$
\end_inset

 and all functor liftings such as 
\begin_inset Formula $g^{\uparrow P^{A,\bullet}}$
\end_inset

 are implemented as shown in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for functors and contrafunctors corresponding to each of the type constructions.
 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Uniqueness-of-functor-and-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show that the code from Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the only possible lawful implementation of the liftings.)
\end_layout

\begin_layout Standard
The proof goes by induction on the type structure of 
\begin_inset Formula $P^{A,B}$
\end_inset

.
 The base case contains the first two constructions (the unit type and the
 type parameter), which gives two possibilities: 
\begin_inset Formula $P^{A,B}\triangleq\bbnum 1$
\end_inset

 (constant profunctor) and 
\begin_inset Formula $P^{A,B}\triangleq B$
\end_inset

 (identity profunctor).
 The other possibility of using a type parameter, 
\begin_inset Formula $P^{A,B}\triangleq A$
\end_inset

, does not give a profunctor since 
\begin_inset Formula $P^{A,B}$
\end_inset

 must be contravariant in 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
The commutativity law holds for 
\begin_inset Formula $P^{A,B}\triangleq\bbnum 1$
\end_inset

 because all liftings are identity functions: 
\begin_inset Formula $\text{cmap}_{P^{\bullet,B}}(f)=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{P^{A,\bullet}}(g)=\text{id}$
\end_inset

.
 For the same reason, the law will also hold for the constant profunctor
 
\begin_inset Formula $P^{A,B}\triangleq Z$
\end_inset

 where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type (or a type parameter other than 
\begin_inset Formula $A$
\end_inset

 or 
\begin_inset Formula $B$
\end_inset

).
\end_layout

\begin_layout Standard
For the profunctor 
\begin_inset Formula $P^{A,B}\triangleq B$
\end_inset

, the law holds because 
\begin_inset Formula $\text{cmap}_{P^{\bullet,B}}(f)=\text{id}$
\end_inset

.
 So, the base case is proved.
\end_layout

\begin_layout Standard
The inductive step looks at the outer construction in the type expression
 of 
\begin_inset Formula $P^{A,B}$
\end_inset

, which must be one of product, co-product, function, or recursion.
 These constructions create larger type expressions out of smaller ones;
 for example, 
\begin_inset Formula $P^{A,B}\triangleq\left(A\rightarrow B\right)\times B$
\end_inset

 uses the product construction with sub-expressions 
\begin_inset Formula $A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, which can be viewed as profunctors 
\begin_inset Formula $R^{A,B}\triangleq A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $S^{A,B}\triangleq B$
\end_inset

.
 The inductive assumption is that the commutativity law is already proved
 for all sub-expression types (such as 
\begin_inset Formula $R^{A,B}$
\end_inset

 or 
\begin_inset Formula $S^{A,B}$
\end_inset

).
 We will then need to prove the law for the entire type expression 
\begin_inset Formula $P^{A,B}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Product type
\end_layout

\begin_layout Standard
If the outer level of 
\begin_inset Formula $P^{A,B}$
\end_inset

 is a product, we must have 
\begin_inset Formula $P^{A,B}=R^{A,B}\times S^{A,B}$
\end_inset

 where 
\begin_inset Formula $R^{A,B}$
\end_inset

 and 
\begin_inset Formula $S^{A,B}$
\end_inset

 are some profunctors.
 The code for liftings follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,B}}\triangleq f^{\downarrow R^{\bullet,B}}\boxtimes f^{\downarrow S^{\bullet,B}}\quad,\quad\quad g^{\uparrow P^{A,\bullet}}\triangleq g^{\uparrow R^{A,\bullet}}\boxtimes g^{\uparrow S^{A,\bullet}}\quad.
\]

\end_inset

By inductive assumption, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 already satisfy the commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we compute
\begin_inset Formula 
\begin{align*}
\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:\quad & \gunderline{f^{\downarrow P^{\bullet,B}}}\bef\gunderline{g^{\uparrow P^{A,\bullet}}}=\big(f^{\downarrow R^{\bullet,B}}\boxtimes f^{\downarrow S^{\bullet,B}}\big)\bef\big(g^{\uparrow R^{A,\bullet}}\boxtimes g^{\uparrow S^{A,\bullet}}\big)\\
\text{composition law~(\ref{eq:pair-product-composition-law})}:\quad & =\big(\gunderline{f^{\downarrow R^{\bullet,B}}\bef g^{\uparrow R^{A,\bullet}}}\big)\boxtimes\big(\gunderline{f^{\downarrow S^{\bullet,B}}\bef g^{\uparrow S^{A,\bullet}}}\big)\\
\text{inductive assumption}:\quad & =\big(g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}}\big)\boxtimes\big(g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}\big)\\
\text{composition law~(\ref{eq:pair-product-composition-law})}:\quad & =\big(\gunderline{g^{\uparrow R^{C,\bullet}}\boxtimes g^{\uparrow S^{C,\bullet}}}\big)\bef\big(\gunderline{f^{\downarrow R^{\bullet,D}}\boxtimes f^{\downarrow S^{\bullet,D}}}\big)=g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Co-product type
\end_layout

\begin_layout Standard
In this case, we must have 
\begin_inset Formula $P^{A,B}=R^{A,B}+S^{A,B}$
\end_inset

 where 
\begin_inset Formula $R^{A,B}$
\end_inset

 and 
\begin_inset Formula $S^{A,B}$
\end_inset

 are some profunctors.
 The code for liftings follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,B}}\triangleq\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,B}}
\end{array}\quad,\quad\quad g^{\uparrow P^{A,\bullet}}\triangleq\,\begin{array}{||cc|}
g^{\uparrow R^{A,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{A,\bullet}}
\end{array}\quad.
\]

\end_inset

By inductive assumption, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 already satisfy the commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we compute
\begin_inset Formula 
\begin{align*}
\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,B}}
\end{array}\,\bef\,\begin{array}{||cc|}
g^{\uparrow R^{A,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{A,\bullet}}
\end{array}\\
\text{matrix composition}:\quad & =\,\begin{array}{||cc|}
\gunderline{f^{\downarrow R^{\bullet,B}}\bef g^{\uparrow R^{A,\bullet}}} & \bbnum 0\\
\bbnum 0 & \gunderline{f^{\downarrow S^{\bullet,B}}\bef g^{\uparrow S^{A,\bullet}}}
\end{array}\\
\text{inductive assumption}:\quad & =\,\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}
\end{array}\quad.
\end{align*}

\end_inset

The right-hand side of the law, 
\begin_inset Formula $g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}$
\end_inset

, can be rewritten as
\begin_inset Formula 
\begin{align*}
 & g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}=\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}
\end{array}\,\bef\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,D}}
\end{array}\\
\text{matrix composition}:\quad & =\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}
\end{array}\quad.
\end{align*}

\end_inset

This now coincides with the left-hand side of the law.
\end_layout

\begin_layout Paragraph
Function type
\end_layout

\begin_layout Standard
The type expression 
\begin_inset Formula $P^{A,B}\triangleq R^{B,A}\rightarrow S^{A,B}$
\end_inset

 (note the swapped type parameters in 
\begin_inset Formula $R^{B,A}$
\end_inset

) is contravariant in 
\begin_inset Formula $A$
\end_inset

 and covariant in 
\begin_inset Formula $B$
\end_inset

 when 
\begin_inset Formula $R^{A,B}$
\end_inset

 and 
\begin_inset Formula $S^{A,B}$
\end_inset

 are any profunctors.
 The lifting code follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-contrafunctor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
(f^{:A\rightarrow C})^{\downarrow P^{\bullet,B}}\triangleq p^{:P^{C,B}}\rightarrow f^{\uparrow R^{B,\bullet}}\bef p\bef f^{\downarrow S^{\bullet,B}}\quad,\quad\quad(g^{:B\rightarrow D})^{\uparrow P^{A,\bullet}}\triangleq p^{:P^{A,B}}\rightarrow g^{\downarrow R^{\bullet,A}}\bef p\bef g^{\uparrow S^{A,\bullet}}\quad.
\]

\end_inset

By inductive assumption, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 satisfy the commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Omitting types, we compute
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & f^{\downarrow P}\bef g^{\uparrow P}=\big(p\rightarrow f^{\uparrow R}\bef p\bef f^{\downarrow S}\big)\bef\big(p\rightarrow g^{\downarrow R}\bef p\bef g^{\uparrow S}\big)\\
\text{compute composition}:\quad & =p\rightarrow\gunderline{g^{\downarrow R}\bef f^{\uparrow R}}\bef p\bef\gunderline{f^{\downarrow S}\bef g^{\uparrow S}}\\
\text{inductive assumption}:\quad & =p\rightarrow f^{\uparrow R}\bef g^{\downarrow R}\bef p\bef g^{\uparrow S}\bef f^{\downarrow S}\quad.
\end{align*}

\end_inset

The right-hand side of the law is then transformed to the same expression:
\begin_inset Formula 
\begin{align*}
 & g^{\uparrow P}\bef f^{\downarrow P}=\big(p\rightarrow g^{\downarrow R}\bef p\bef g^{\uparrow S}\big)\bef\big(p\rightarrow f^{\uparrow R}\bef p\bef f^{\downarrow S}\big)\\
\text{compute composition}:\quad & =p\rightarrow f^{\uparrow R}\bef g^{\downarrow R}\bef p\bef g^{\uparrow S}\bef f^{\downarrow S}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Recursive type
\end_layout

\begin_layout Standard
A recursive profunctor 
\begin_inset Formula $P$
\end_inset

 is defined using a type equation of the form
\begin_inset Formula 
\[
P^{A,B}\triangleq S^{A,B,P^{A,B}}\quad,\quad\text{equivalently denoted as}\quad P^{A,B}\triangleq\text{Fix}^{S^{A,B,\bullet}}\quad,
\]

\end_inset

where 
\begin_inset Formula $S^{A,B,R}$
\end_inset

 must be contravariant in 
\begin_inset Formula $A$
\end_inset

 but covariant in 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 The liftings are defined by
\begin_inset Formula 
\[
(f^{:A\rightarrow C})^{\downarrow P^{\bullet,B}}\triangleq f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,B,\bullet}}\quad,\quad\quad(g^{:B\rightarrow D})^{\uparrow P^{A,\bullet}}\triangleq g^{\uparrow S^{A,\bullet,P^{A,B}}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\quad.
\]

\end_inset

The inductive assumption is two-fold: first, that the recursively used lifting
 to 
\begin_inset Formula $P^{A,B}$
\end_inset

 already satisfies the commutativity law.
 Second, that the profunctor 
\begin_inset Formula $S^{A,B,R}$
\end_inset

 satisfies the commutativity law with respect to 
\emph on
any
\emph default
 two parameters (we will prove that law for covariant type parameters in
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proofs-of-commutativity-for-bifunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Both sides of the commutativity law are functions of type 
\begin_inset Formula $P^{C,B}\rightarrow P^{A,D}$
\end_inset

 or equivalently (if we expand the type recursion) as functions of type
 
\begin_inset Formula $S^{C,B,P^{C,B}}\rightarrow S^{A,D,P^{A,D}}$
\end_inset

.
 To avoid mistakes, we write out the type parameters in this computation:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef\gunderline{\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,B,\bullet}}\bef g^{\uparrow S^{A,\bullet,P^{A,B}}}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\\
^{B,R}\text{-commutativity of }S^{A,B,R}:\quad & =\gunderline{f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef g^{\uparrow S^{A,\bullet,P^{C,B}}}}\bef\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,D,\bullet}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\\
^{A,B}\text{-commutativity of }S^{A,B,R}:\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(\gunderline{f^{\overline{\downarrow P^{\bullet,B}}}\bef g^{\overline{\uparrow P^{A,\bullet}}}}\big)^{\uparrow S^{A,D,\bullet}}\\
\text{inductive assumption}:\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\bef f^{\overline{\downarrow P^{\bullet,D}}}\gunderline{\big)^{\uparrow S^{A,D,\bullet}}}\\
\text{composition under }^{\uparrow S^{A,D,\bullet}}:\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef\gunderline{f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}}\bef\big(f^{\overline{\downarrow P^{\bullet,D}}}\big)^{\uparrow S^{A,D,\bullet}}\\
^{A,R}\text{-commutativity of }S^{A,B,R}:\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\big)^{\uparrow S^{C,D,\bullet}}\bef f^{\downarrow S^{\bullet,D,P^{C,D}}}\bef\big(f^{\overline{\downarrow P^{\bullet,D}}}\big)^{\uparrow S^{A,D,\bullet}}\\
\text{definitions of liftings}:\quad & =g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This concludes the proof of the profunctor commutativity law.
\end_layout

\begin_layout Subsection
Commutativity laws for bifunctors and bi-contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proofs-of-commutativity-for-bifunctor"

\end_inset


\end_layout

\begin_layout Standard
A bi-contrafunctor 
\begin_inset Formula $P^{A,B}$
\end_inset

 is a type constructor contravariant with respect to both 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 The commutativity law for bi-contrafunctors is formulated as 
\begin_inset Formula 
\begin{align}
\text{commutativity law of }P:\quad & \text{cmap}_{P^{\bullet,D}}(f^{:A\rightarrow C})\bef\text{cmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})=\text{cmap}_{P^{C,\bullet}}(g)\bef\text{cmap}_{P^{\bullet,B}}(f)\quad.\nonumber \\
\text{shorter notation}:\quad & f^{\downarrow P^{\bullet,D}}\bef g^{\downarrow P^{A,\bullet}}=g^{\downarrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,B}}\quad.\label{eq:bi-contrafunctor-commutativity-law}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "43col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -170baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{6.0pc}P^{C,D}\ar[r]\sp(0.55){\text{cmap}_{P^{\bullet,D}}(f^{:A\rightarrow C})~~~}\ar[d]\sb(0.45){\text{cmap}_{P^{C,\bullet}}(g^{:B\rightarrow D})} & P^{A,D}\ar[d]\sb(0.45){\text{cmap}_{P^{A,\bullet}}(g)}\\
P^{C,B}\ar[r]\sb(0.45){~~~~\text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})} & P^{A,B}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -170baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Any bifunctor or bi-contrafunctor whose type expression is built up using
 the six type constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will satisfy its commutativity law.
 To prove that, we need to repeat the same calculations as for profunctors
 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proof-of-the-profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 except for changing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 or back when needed.
 We only need to check that the proof will still work after such changes.
 Looking over the proof in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proof-of-the-profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we find that we never used the functor or contrafunctor 
\emph on
composition law
\emph default
 for 
\begin_inset Formula $P$
\end_inset

.
 The only usage of the composition law was with respect to the type parameter
 
\begin_inset Formula $R$
\end_inset

 in the structure functor 
\begin_inset Formula $S^{A,B,R}$
\end_inset

 of the recursive type construction.
 However, in all cases 
\begin_inset Formula $S^{A,B,R}$
\end_inset

 needs to be 
\emph on
covariant
\emph default
 in 
\begin_inset Formula $R$
\end_inset

 because that is required by the recursive type equation.
 So, we are assured that the same proof with minor changes will work for
 bifunctors and bi-contrafunctors.
\end_layout

\begin_layout Standard
The same techniques and proofs apply to type constructors with more than
 two type parameters.
\end_layout

\begin_layout Section
Naturality laws for fully parametric functions
\begin_inset CommandInset label
LatexCommand label
name "sec:Naturality-laws-for-fully-parametric-functions"

\end_inset


\end_layout

\begin_layout Standard
The goal of this section is to derive and prove a naturality law for any
 function implemented via fully parametric code.
 Simple examples of such functions are the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 methods for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 functor, whose type signatures can be written as
\begin_inset Formula 
\begin{align*}
 & \text{fmap}_{\text{Opt}}^{A,B}:\left(A\rightarrow B\right)\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad,\\
 & \text{filt}_{\text{Opt}}^{A}:\left(A\rightarrow\bbnum 2\right)\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{A}\quad,\\
 & \text{fold}_{\text{Opt}}^{A,B}:B\times\left(A\times B\rightarrow B\right)\rightarrow\text{Opt}^{A}\rightarrow B\quad.
\end{align*}

\end_inset

These methods satisfy appropriate naturality laws — one law per type parameter.
 When a method's type signature is that of a natural transformation between
 functors (or between contrafunctors), the naturality laws have the form
 derived in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Naturality-laws-and-natural-transformations"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For instance, fixing the type parameter 
\begin_inset Formula $A$
\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method, we obtain a type signature of the form 
\begin_inset Formula $F^{B}\rightarrow G^{B}$
\end_inset

 where 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 are functors:
\begin_inset Formula 
\[
\text{fmap}_{\text{Opt}}^{B}:F^{B}\rightarrow G^{B}\quad,\quad\quad F^{B}\triangleq A\rightarrow B\quad,\quad\quad G^{B}\triangleq\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad.
\]

\end_inset

The corresponding naturality law (which is equivalent to the functor composition
 law) is
\begin_inset Formula 
\[
f^{\uparrow F}\bef\text{fmap}_{\text{Opt}}=\text{fmap}_{\text{Opt}}\bef f^{\uparrow G}\quad.
\]

\end_inset

However, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 is not of the form 
\begin_inset Formula $P^{B}\rightarrow Q^{B}$
\end_inset

 with any functors or contrafunctors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

.
 In general, it is not obvious how to write the naturality law for transformatio
ns with such type signatures.
 The parametricity theorem provides a recipe for writing naturality laws
 and also gives a proof that fully parametric functions always satisfy their
 naturality laws.
\end_layout

\begin_layout Standard
The key insight for deriving that theorem is that type signatures of a fully
 parametric function must always contain type parameters in either covariant
 or contravariant positions.
 So, any such type signature may be written as 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 using some 
\emph on
profunctors
\emph default
 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 For instance, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset Formula $B$
\end_inset

 (with the parameter 
\begin_inset Formula $A$
\end_inset

 fixed) is written as
\begin_inset Formula 
\begin{equation}
\text{fold}_{\text{Opt}}^{B}:P^{B,B}\rightarrow Q^{B,B}\quad,\quad\text{where}\quad P^{X,Y}\triangleq Y\times\left(A\times X\rightarrow Y\right)\quad,\quad\quad Q^{X,Y}\triangleq\text{Opt}^{A}\rightarrow Y\quad.\label{eq:fold-type-signature-via-profunctors-derivation1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The next task is to motivate the naturality law for transformations having
 type 
\begin_inset Formula $\forall A.\,P^{A,A}\rightarrow Q^{A,A}$
\end_inset

, where the type parameters of the profunctors are set to be the same.
 Such transformations are called 
\begin_inset Quotes eld
\end_inset

dinatural
\begin_inset Quotes erd
\end_inset

.
 (
\emph on
Natural
\emph default
 transformations between profunctors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 have a different type signature, namely 
\begin_inset Formula $\forall(A,B).\,P^{A,B}\rightarrow Q^{A,B}$
\end_inset

, where the type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 must be independent).
\end_layout

\begin_layout Subsection
Dinatural transformations between profunctors
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
dinatural transformation
\end_layout

\end_inset

A 
\series bold
dinatural transformation
\series default
 is a function 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

, where 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 are profunctors contravariant in 
\begin_inset Formula $X$
\end_inset

 and covariant in 
\begin_inset Formula $Y$
\end_inset

.
 A dinatural transformation 
\begin_inset Formula $t$
\end_inset

 must satisfy the naturality law
\begin_inset Formula 
\begin{equation}
(f^{:A\rightarrow B})^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.\label{eq:naturality-law-for-dinatural-transformations-of-profunctors}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "43col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{2.5pc} & P^{A,A}\ar[r]\sp(0.5){t} & Q^{A,A}\ar[rd]\sb(0.45){\text{xmap}_{Q}(\text{id})(f)}\\
P^{B,A}\ar[rd]\sp(0.55){\text{xmap}_{P}(\text{id})(f)}\ar[ru]\sb(0.55){\text{xmap}_{P}(f)(\text{id})} &  &  & Q^{A,B}\\
 & P^{B,B}\ar[r]\sp(0.5){t} & Q^{B,B}\ar[ru]\sp(0.45){\text{xmap}_{Q}(f)(\text{id})}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To build up intuition for that law (see diagram at left), compare the laws
 of natural transformations 
\begin_inset Formula $t^{A}:F^{A}\rightarrow G^{A}$
\end_inset

 when 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 are functors,
\begin_inset Formula 
\begin{equation}
t^{A}\bef(f^{:A\rightarrow B})^{\uparrow G}=(f^{:A\rightarrow B})^{\uparrow F}\bef t^{B}\quad,\label{eq:naturality-law-for-case-of-functors}
\end{equation}

\end_inset

and when 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 are contrafunctors,
\begin_inset Formula 
\begin{equation}
(f^{:A\rightarrow B})^{\downarrow F}\bef t^{A}=t^{B}\bef(f^{:A\rightarrow B})^{\downarrow G}\quad.\label{eq:naturality-law-for-case-of-contrafunctors}
\end{equation}

\end_inset

We would obtain naturality laws of that form if we could fix the type parameter
 
\begin_inset Formula $A$
\end_inset

 in the profunctors 
\begin_inset Formula $P^{A,B}$
\end_inset

 and 
\begin_inset Formula $Q^{A,B}$
\end_inset

 and consider then as functors with respect to the type parameter 
\begin_inset Formula $B$
\end_inset

.
 However, this requires us to have a transformation 
\begin_inset Formula $\tilde{t}:P^{A,B}\rightarrow Q^{A,B}$
\end_inset

 defined for arbitrary (not necessarily equal) type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 We do not have such a function: we are only given a transformation with
 the type signature 
\begin_inset Formula $t:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

, defined only in the 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 case
\begin_inset Foot
status open

\begin_layout Plain Layout
As a memory aid, we may consider the word 
\begin_inset Quotes eld
\end_inset

dinaturality
\begin_inset Quotes erd
\end_inset

 to be a shorthand for 
\begin_inset Quotes eld
\end_inset

diagonal naturality
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Formula $A=B$
\end_inset

.
 As a rule, we cannot extend the code of 
\begin_inset Formula $t$
\end_inset

 to some 
\begin_inset Formula $\tilde{t}$
\end_inset

 that works with arbitrary type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 A law for 
\begin_inset Formula $t$
\end_inset

 must be an equation that somehow transforms both type parameters of 
\begin_inset Formula $t$
\end_inset

 by using a lifted function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) combines the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-case-of-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-case-of-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) in the way required for all types to match.
 On the other hand, the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-case-of-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-case-of-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will follow from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) when 
\begin_inset Formula $P^{A,A}$
\end_inset

 and 
\begin_inset Formula $Q^{A,A}$
\end_inset

 are both functors or both contrafunctors in 
\begin_inset Formula $A$
\end_inset

.
 To further motivate the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we will now derive the known forms of naturality laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 for arbitrary filterable or foldable functors 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-derive-naturality-of-filter-from-dinaturality"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-derive-naturality-of-filter-from-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

)
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To derive the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

's type signature through profunctors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 as
\begin_inset Formula 
\[
\text{filt}_{F}^{A}:P^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad P^{X,Y}\triangleq(X\rightarrow\bbnum 2)\quad,\quad\quad Q^{X,Y}\triangleq F^{X}\rightarrow F^{Y}\quad,
\]

\end_inset

and then write the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

),
\begin_inset Formula 
\begin{equation}
f^{\downarrow P^{\bullet,A}}\bef\text{filt}_{F}^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{?}{=}f^{\uparrow P^{B,\bullet}}\bef\text{filt}_{F}^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.\label{eq:filter-law-via-dinatural-transformation-derivation1}
\end{equation}

\end_inset

It remains to substitute the code for the liftings using the specific types
 of 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\begin{align*}
(f^{:A\rightarrow B})^{\downarrow P^{\bullet,A}}=p^{:B\rightarrow\bbnum 2}\rightarrow f\bef p\quad, & \quad\quad f^{\uparrow P^{B,\bullet}}=\text{id}\quad,\\
(f^{:A\rightarrow B})^{\downarrow Q^{\bullet,B}}=q^{:F^{B}\rightarrow F^{B}}\rightarrow f^{\uparrow F}\bef q\quad, & \quad\quad f^{\uparrow Q^{A,\bullet}}=q^{:F^{A}\rightarrow F^{A}}\rightarrow q\bef f^{\uparrow F}\quad.
\end{align*}

\end_inset

Then we rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:filter-law-via-dinatural-transformation-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\[
(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\overset{?}{=}\text{id}\bef\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)\quad.
\]

\end_inset

To simplify the form of the naturality law, apply both sides to an arbitrary
 
\begin_inset Formula $p^{:P^{B,A}}=p^{:B\rightarrow\bbnum 2}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p\triangleright(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\\
\triangleright\text{-notation}:\quad & \quad=\gunderline{p\triangleright(p}\rightarrow f\bef p)\triangleright\text{filt}_{F}\triangleright(q\rightarrow q\bef f^{\uparrow F})\\
\text{apply functions}:\quad & \quad=\gunderline{(f\bef p)\triangleright\text{filt}_{F}}\triangleright(q\rightarrow q\bef f^{\uparrow F})=\gunderline{\text{filt}_{F}(f\bef p)\triangleright(q}\rightarrow q\bef f^{\uparrow F})=\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}\quad,\\
\text{right-hand side}:\quad & p\triangleright\gunderline{\text{id}\bef}\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)=p\triangleright\text{filt}_{F}\triangleright(q\rightarrow f^{\uparrow F}\bef q)\\
 & \quad=\gunderline{\text{filt}_{F}(p)\triangleright(q}\rightarrow f^{\uparrow F}\bef q)=f^{\uparrow F}\bef\text{filt}_{F}(p)\quad.
\end{align*}

\end_inset

So, we obtained the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}=f^{\uparrow F}\bef\text{filt}_{F}(p)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-derive-naturality-of-fold-from-dinaturality"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-derive-naturality-of-fold-from-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

)
\end_layout

\begin_layout Standard
To derive the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset Formula $B$
\end_inset

, we begin with Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fold-type-signature-via-profunctors-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that shows the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 as a transformation of type 
\begin_inset Formula $P^{B,B}\rightarrow Q^{B,B}$
\end_inset

 between profunctors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

.
 Since the type parameter 
\begin_inset Formula $A$
\end_inset

 is fixed, the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) now involves an arbitrary function 
\begin_inset Formula $f^{:B\rightarrow C}$
\end_inset

,
\begin_inset Formula 
\begin{equation}
(f^{:B\rightarrow C})^{\downarrow P^{\bullet,B}}\bef\text{fold}_{F}^{B}\bef f^{\uparrow Q^{B,\bullet}}=f^{\uparrow P^{C,\bullet}}\bef\text{fold}_{F}^{C}\bef f^{\downarrow Q^{\bullet,C}}\quad.\label{eq:fold-naturality-from-profunctor-derivation2}
\end{equation}

\end_inset

The lifting code required for the profunctors 
\begin_inset Formula $P^{X,Y}\triangleq Y\times\left(A\times X\rightarrow Y\right)$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}\triangleq F^{A}\rightarrow Y$
\end_inset

 is
\begin_inset Formula 
\begin{align*}
(f^{:B\rightarrow C})^{\downarrow P^{\bullet,B}}=\text{id}^{B}\boxtimes(h^{:A\times C\rightarrow B}\rightarrow a^{:A}\times b^{:B}\rightarrow h(a\times f(b)))\quad, & \quad\quad f^{\uparrow P^{C,\bullet}}=f\boxtimes(h^{:A\times C\rightarrow B}\rightarrow h\bef f)\quad,\\
(f^{:B\rightarrow C})^{\downarrow Q^{\bullet,C}}=\text{id}\quad, & \quad\quad f^{\uparrow Q^{B,\bullet}}=q^{:F^{A}\rightarrow B}\rightarrow q\bef f\quad.
\end{align*}

\end_inset

Substituting this code into the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fold-naturality-from-profunctor-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and applying to an arbitrary 
\begin_inset Formula $p^{:P^{C,B}}=z^{:B}\times h^{:A\times C\rightarrow B}$
\end_inset

, we get
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (z\times h)\triangleright\gunderline{(f^{:B\rightarrow C})^{\downarrow P^{\bullet,B}}}\bef\text{fold}_{F}\bef\gunderline{f^{\uparrow Q^{B,\bullet}}}\\
\text{definitions of liftings}:\quad & \quad=(z\times h)\triangleright(\text{id}\boxtimes(h\rightarrow a\times b\rightarrow h(a\times f(b))))\gunderline{\bef}\text{fold}_{F}\gunderline{\bef}(q\rightarrow q\bef f)\\
\triangleright\text{-notation}:\quad & \quad=(z\times h)\triangleright(\text{id}\boxtimes(h\rightarrow a\times b\rightarrow h(a\times f(b))))\triangleright\text{fold}_{F}\triangleright(q\rightarrow q\bef f)\\
\text{apply functions}:\quad & \quad=\text{fold}_{F}(z\times(a\times b\rightarrow h(a\times f(b))))\bef f\quad,\\
\text{right-hand side}:\quad & (z\times h)\triangleright\gunderline{f^{\uparrow P^{C,\bullet}}}\bef\text{fold}_{F}\bef\gunderline{f^{\downarrow Q^{\bullet,C}}}=(z\times h)\triangleright(f\boxtimes(h^{:A\times C\rightarrow B}\rightarrow h\bef f))\bef\text{fold}_{F}\bef\text{id}\\
\text{apply functions}:\quad & \quad=\text{fold}_{F}(f(z)\times(h\bef f))\quad.
\end{align*}

\end_inset

We obtained a naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{fold}_{F}(f(z)\times(h\bef f))=\text{fold}_{F}(z\times(a\times b\rightarrow h(a\times f(b))))\bef f\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
These examples illustrate how we may derive the form of the naturality law
 for any type signature by specializing the general law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to specific profunctors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\begin_layout Standard
In the next subsections, we will prove
\begin_inset Foot
status open

\begin_layout Plain Layout
The proof builds upon ideas from the paper by E.
\begin_inset space ~
\end_inset

S.
\begin_inset space ~
\end_inset

Bainbridge et al., 
\begin_inset Quotes eld
\end_inset

Functorial polymorphism
\begin_inset Quotes erd
\end_inset

 (Theor.
\begin_inset space ~
\end_inset

Comp.
\begin_inset space ~
\end_inset

Sci.
\begin_inset space ~
\end_inset

70, p.
\begin_inset space ~
\end_inset

35, 1990), see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.sciencedirect.com/science/article/pii/0304397590901517"

\end_inset


\family default
.
 A more rigorous but significantly more complicated proof was given by Joachim
 de Lataillade
\begin_inset Index idx
status open

\begin_layout Plain Layout
Joachim de Lataillade
\end_layout

\end_inset

 in the paper 
\begin_inset Quotes eld
\end_inset

Dinatural terms in System 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.irif.fr/~delatail/dinat.pdf"

\end_inset


\family default
, based on deriving the syntactic form of naturality laws in full detail.
 
\end_layout

\end_inset

 that any fully parametric function 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 is dinatural, i.e., satisfies its naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Since the form of the law depends only on the type signature, all functions
 
\begin_inset Formula $t^{A}$
\end_inset

 satisfy the same naturality law.
 
\end_layout

\begin_layout Standard
The restriction to 
\emph on
fully parametric
\emph default
 programs
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!program
\end_layout

\end_inset

 is essential because it excludes, for instance, any use of mutable variables,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 values, exceptions, run-time type identification, run-time code loading,
 or values defined in external libraries that are not known to be fully
 parametric.
 Code that uses those features of Scala is not covered by parametricity
 theorems and may violate naturality laws, as we have seen elsewhere in
 this book.
\end_layout

\begin_layout Paragraph
Dinatural expressions
\end_layout

\begin_layout Standard
We note that the type constructor 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 is neither covariant nor contravariant in 
\begin_inset Formula $A$
\end_inset

, but it is itself a profunctor that we may denote by 
\begin_inset Formula $T$
\end_inset

.
 The naturality law is simpler when formulated via 
\begin_inset Formula $T$
\end_inset

:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-expression-wedge-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-expression-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using the profunctor 
\begin_inset Formula $T^{X,Y}\triangleq P^{Y,X}\rightarrow Q^{X,Y}$
\end_inset

, the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is written as
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 9
placement l
overhang 0in
width "24col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{3.0pc} & T^{B,B}\ar[d]\sp(0.37){f^{\downarrow T^{\bullet,B}}}\\
T^{A,A}\ar[r]\sp(0.5){~~~f^{\uparrow T^{A,\bullet}}} & T^{A,B}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
t^{A}\triangleright f^{\uparrow T^{A,\bullet}}=t^{B}\triangleright f^{\downarrow T^{\bullet,B}}\quad,\label{eq:dinaturality-wedge-law}
\end{equation}

\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
where the transformation 
\begin_inset Formula $t$
\end_inset

 is viewed as a value of type 
\begin_inset Formula $\forall Z.\,T^{Z,Z}$
\end_inset

, while the function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is arbitrary.
 This law is known as the 
\series bold
wedge law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
wedge law
\end_layout

\end_inset

 for 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The two liftings for 
\begin_inset Formula $T$
\end_inset

 are expressed as
\begin_inset Formula 
\begin{align*}
f^{\uparrow T^{A,\bullet}}:T^{A,A}\rightarrow T^{A,B}\quad, & \quad\quad t^{A}\triangleright f^{\uparrow T^{A,\bullet}}=p^{:P^{B,A}}\rightarrow t^{A}(p\triangleright f^{\downarrow P^{\bullet,A}})\triangleright f^{\uparrow Q^{A,\bullet}}=f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}\quad,\\
f^{\downarrow T^{\bullet,B}}:T^{B,B}\rightarrow T^{A,B}\quad, & \quad\quad t^{B}\triangleright f^{\uparrow T^{\bullet,B}}=p^{:P^{B,A}}\rightarrow t^{B}(p\triangleright f^{\uparrow P^{B,\bullet}})\triangleright f^{\downarrow Q^{\bullet,B}}=f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\end{align*}

\end_inset

It follows that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equivalent to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which proves the statement.
\end_layout

\begin_layout Standard
Expressions 
\begin_inset Formula $t$
\end_inset

 of type 
\begin_inset Formula $\forall Z.\,T^{Z,Z}$
\end_inset

 satisfying the wedge law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are called 
\series bold
dinatural expressions
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dinatural expression
\end_layout

\end_inset

.
 The wedge law formulates the dinaturality condition for any expression
 
\begin_inset Formula $t$
\end_inset

 with a type parameter, whether 
\begin_inset Formula $t$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

transformation
\begin_inset Quotes erd
\end_inset

 (i.e., a function) or not.
 It can be derived from the parametricity theorem that any fully parametric
 expression of type 
\begin_inset Formula $\forall Z.\,T^{Z,Z}$
\end_inset

 is dinatural.
\end_layout

\begin_layout Subsection
Composition of natural and dinatural transformations
\end_layout

\begin_layout Standard
In the proof of the parametricity theorem, we will need to compose some
 dinatural transformations.
 Composition of 
\emph on
natural
\emph default
 transformations is easily shown to be again natural.
 However, proving the same property for dinatural transformations requires
 additional assumptions.
 To show why, first consider the composition of two natural transformations
 
\begin_inset Formula $u:P^{A}\rightarrow Q^{A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A}\rightarrow R^{A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-natural-transformations-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-natural-transformations-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The composition 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 is a natural transformation, 
\begin_inset Formula $t:P^{A}\rightarrow R^{A}$
\end_inset

, assuming that 
\begin_inset Formula $u:P^{A}\rightarrow Q^{A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A}\rightarrow R^{A}$
\end_inset

 satisfy their naturality laws, and that 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 are functors.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The naturality laws for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are written with an arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 as
\begin_inset Formula 
\[
f^{\uparrow P}\bef u=u\bef f^{\uparrow Q}\quad,\quad\quad f^{\uparrow Q}\bef v=v\bef f^{\uparrow R}\quad.
\]

\end_inset

The required naturality law for 
\begin_inset Formula $t$
\end_inset

 is derived by a direct calculation,
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 6
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{3.0pc}P^{A}\ar[d]\sp(0.45){f^{\uparrow P}}\ar[r]\sp(0.5){u} & Q^{A}\ar[d]\sp(0.45){f^{\uparrow Q}}\ar[r]\sp(0.5){v} & R^{A}\ar[d]\sp(0.45){f^{\uparrow R}}\\
P^{B}\ar[r]\sp(0.5){u} & Q^{B}\ar[r]\sp(0.5){v} & R^{B}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -180baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\text{expect to equal }t\bef f^{\uparrow R}:\quad & f^{\uparrow P}\bef\gunderline t=\gunderline{f^{\uparrow P}\bef u}\bef v\\
\text{naturality of }u:\quad & =u\bef\gunderline{f^{\uparrow Q}\bef v}\\
\text{naturality of }v:\quad & =\gunderline{u\bef v}\bef f^{\uparrow R}=t\bef f^{\uparrow R}\quad.
\end{align*}

\end_inset

This calculation shows that the above type diagram commutes.
\end_layout

\begin_layout Standard
In the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-natural-transformations-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we derived the naturality law for the composed transformation 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 directly from the naturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 with no further assumptions.
 In particular, we did not need to assume that 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are implemented by fully parametric code.
 We will now see that the composition property for dinatural transformations
 cannot be derived in the same way.
 
\end_layout

\begin_layout Standard
Consider two dinatural transformations 
\begin_inset Formula $u:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A,A}\rightarrow R^{A,A}$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 are any profunctors.
 The naturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are written as
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef f^{\uparrow Q^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad,\quad\quad f^{\downarrow Q^{\bullet,A}}\bef v^{A}\bef f^{\uparrow R^{A,\bullet}}=f^{\uparrow Q^{B,\bullet}}\bef v^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

 The composition 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 has type signature 
\begin_inset Formula $t:P^{A,A}\rightarrow R^{A,A}$
\end_inset

, and so its naturality law is
\begin_inset Formula 
\begin{equation}
f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow R^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-naturality-law-for-t-derivation1}
\end{equation}

\end_inset

Can we derive that law by combining the naturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

? Note that 
\emph on
both
\emph default
 sides of the laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 contain a lifting of 
\begin_inset Formula $f$
\end_inset

 to 
\begin_inset Formula $Q$
\end_inset

, while Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) does not contain that lifting.
 The function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 does not satisfy any known equations that we could use in the proof.
 So, we do not have any law that would allow us to eliminate 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

 or 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

 from the laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 (If, e.g., we knew that 
\begin_inset Formula $f$
\end_inset

 is invertible, we would use a function 
\begin_inset Formula $g^{:B\rightarrow A}$
\end_inset

 satisfying 
\begin_inset Formula $f\bef g=\text{id}$
\end_inset

 and 
\begin_inset Formula $g\bef f=\text{id}$
\end_inset

 and so eliminate 
\begin_inset Formula $f$
\end_inset

.
 But Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) must hold for arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.) No matter how we combine those laws, starting from one side or from the
 other, the resulting expressions will always contain 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

 and/or 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

.
 Similarly, starting from any side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we cannot 
\emph on
introduce
\emph default
 the function 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

 or 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

 into the expression.
 So, we are unable to obtain an expression in which we could use the laws
 of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 12
placement l
overhang 0in
width "55col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.3pc}\xyScaleX{2.3pc} & P^{A,A}\ar[r]\sp(0.5){u} & Q^{A,A}\ar[r]\sp(0.5){v}\ar[rd]\sb(0.45){f^{\uparrow Q^{A,\bullet}}\negthickspace\negthickspace} & R^{A,A}\ar[rd]\sp(0.45){f^{\uparrow R^{A,\bullet}}}\\
P^{B,A}\ar[ru]\sp(0.5){f^{\downarrow P^{\bullet,A}}\negthickspace\negthickspace\negthickspace\negthickspace}\ar[rd]\sb(0.5){f^{\uparrow P^{B,\bullet}}\negthickspace\negthickspace} & Q^{B,A}\ar[ru]\sb(0.55){\negthickspace\negthickspace f^{\downarrow Q^{\bullet,A}}}\ar[rd]\sp(0.5){f^{\uparrow Q^{B,\bullet}}\negthickspace\negthickspace} &  & Q^{A,B} & R^{A,B}\\
 & P^{B,B}\ar[r]\sp(0.5){u} & Q^{B,B}\ar[r]\sp(0.5){v}\ar[ru]\sp(0.5){f^{\downarrow Q^{\bullet,B}}\negthickspace\negthickspace\negthickspace} & R^{B,B}\ar[ru]\sb(0.55){\negthickspace\negthickspace f^{\downarrow R^{\bullet,B}}}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -110baselineskip%
\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Composition of dinatural transformations.
\begin_inset CommandInset label
LatexCommand label
name "fig:Type-diagram-for-composition-of-dinatural-transformations"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The type diagram in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Type-diagram-for-composition-of-dinatural-transformations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 combines the diagrams for the laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 in an attempt to derive the law of 
\begin_inset Formula $t$
\end_inset

.
 We can see a value of type 
\begin_inset Formula $Q^{B,A}$
\end_inset

 acting as a 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Quotes erd
\end_inset

 of some arrows.
 It means that we are required to have a value of type 
\begin_inset Formula $Q^{B,A}$
\end_inset

 in order for the complete diagram to commute.
 But we are given only an arbitrary value 
\begin_inset Formula $p:P^{B,A}$
\end_inset

, and we are required to fill out the remainder of the diagram starting
 from that value.
 We cannot compute a value of type 
\begin_inset Formula $Q^{B,A}$
\end_inset

 from 
\begin_inset Formula $p:P^{B,A}$
\end_inset

 because we are given only a 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 transformation 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and not a function of type 
\begin_inset Formula $P^{X,Y}\rightarrow Q^{X,Y}$
\end_inset

 with arbitrary type parameters 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

.
 So, we cannot prove in this way that the diagram commutes.
 
\end_layout

\begin_layout Standard
Nevertheless, it is true that the composition of dinatural transformations
 is dinatural — as long as the code is fully parametric, which is always
 assumed by the parametricity theorem.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-transformation-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given any profunctors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 and any two fully parametric dinatural transformations 
\begin_inset Formula $u:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A,A}\rightarrow R^{A,A}$
\end_inset

, the transformation 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 is also dinatural.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to show that the naturality law holds for 
\begin_inset Formula $t$
\end_inset

: for any 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\begin{align}
 &  & p\triangleright f^{\downarrow P^{\bullet,A}}\bef\gunderline{t^{A}}\bef f^{\uparrow R^{A,\bullet}} & \overset{?}{=}p\triangleright f^{\uparrow P^{B,\bullet}}\bef\gunderline{t^{B}}\bef f^{\downarrow R^{\bullet,B}}\quad.\nonumber \\
 & \text{substitute }t\triangleq u\bef v:\quad & p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef v^{A}\bef f^{\uparrow R^{A,\bullet}} & \overset{?}{=}p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef v^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-composition-derivation1}
\end{align}

\end_inset

It is given that the naturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 both hold: for any 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 and 
\begin_inset Formula $q^{:Q^{B,A}}$
\end_inset

,
\begin_inset Formula 
\[
p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef f^{\uparrow Q^{A,\bullet}}=p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad,\quad\quad q\triangleright f^{\downarrow Q^{\bullet,A}}\bef v^{A}\bef f^{\uparrow R^{A,\bullet}}=q\triangleright f^{\uparrow Q^{B,\bullet}}\bef v^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

We will be able to establish Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-composition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) only if we find a suitable value 
\begin_inset Formula $q:Q^{B,A}$
\end_inset

 that correctly fits the inner square of the type diagram in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Type-diagram-for-composition-of-dinatural-transformations"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which can be written as the equation
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "32col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.3pc}\xyScaleX{2.6pc} & Q^{A,A}\ar[rd]\sb(0.45){f^{\uparrow Q^{A,\bullet}}\negthickspace\negthickspace}\\
Q^{B,A}\ar[ru]\sb(0.55){\negthickspace\negthickspace f^{\downarrow Q^{\bullet,A}}}\ar[rd]\sp(0.5){f^{\uparrow Q^{B,\bullet}}\negthickspace\negthickspace} &  & Q^{A,B}\\
 & Q^{B,B}\ar[ru]\sp(0.5){f^{\downarrow Q^{\bullet,B}}\negthickspace\negthickspace\negthickspace}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Formula 
\[
q\triangleright f^{\downarrow Q^{\bullet,A}}\bef f^{\uparrow Q^{A,\bullet}}=q\triangleright f^{\uparrow Q^{B,\bullet}}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
By the commutativity law of the profunctor 
\begin_inset Formula $Q$
\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proof-of-the-profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), this equation holds for 
\emph on
any
\emph default
 value 
\begin_inset Formula $q^{:Q^{B,A}}$
\end_inset

.
 It remains to show that a suitable value 
\begin_inset Formula $q$
\end_inset

 can be found such that we may replace 
\begin_inset Formula $p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}$
\end_inset

 by 
\begin_inset Formula $q\triangleright f^{\downarrow Q^{\bullet,A}}$
\end_inset

 and 
\begin_inset Formula $p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}$
\end_inset

 by 
\begin_inset Formula $q\triangleright f^{\uparrow Q^{B,\bullet}}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-composition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In other words, 
\begin_inset Formula $q$
\end_inset

 must satisfy the equations
\begin_inset Formula 
\begin{equation}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad q\triangleright f^{\downarrow Q^{\bullet,A}}=p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\quad,\quad\quad q\triangleright f^{\uparrow Q^{B,\bullet}}=p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\quad.\label{eq:dinaturality-conditions-on-q-derivation1}
\end{equation}

\end_inset

We will complete the proof of law if we are able to compute a suitable value
 
\begin_inset Formula $q$
\end_inset

 for 
\emph on
any
\emph default
 given 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

, and 
\begin_inset Formula $u^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

.
 However, such 
\begin_inset Formula $q$
\end_inset

 does not always exist without further assumptions.
 A simple counterexample is found by choosing the profunctor 
\begin_inset Formula $Q^{X,Y}\triangleq X\rightarrow Y$
\end_inset

 and setting
\begin_inset Formula 
\[
u^{A}\triangleq\_^{:P^{A,A}}\rightarrow\text{id}^{:A\rightarrow A}\quad.
\]

\end_inset

With this choice of 
\begin_inset Formula $u$
\end_inset

, the value 
\begin_inset Formula $p$
\end_inset

 is ignored, and so we can simplify Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-conditions-on-q-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to
\begin_inset Formula 
\[
f^{:A\rightarrow B}\bef q^{:B\rightarrow A}=\text{id}^{:A\rightarrow A}\quad,\quad\quad q^{:B\rightarrow A}\bef f^{:A\rightarrow B}=\text{id}^{:B\rightarrow B}\quad.
\]

\end_inset

This is possible only if the function 
\begin_inset Formula $q^{:B\rightarrow A}$
\end_inset

 is the inverse of 
\begin_inset Formula $f$
\end_inset

; but, of course, not all functions 
\begin_inset Formula $f$
\end_inset

 are invertible.
 Also, the existence of an inverse for a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 means that the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are 
\emph on
equivalent
\emph default
 (
\begin_inset Formula $A\cong B$
\end_inset

) due to the isomorphism 
\begin_inset Formula $f$
\end_inset

, which is clearly not true for arbitrary types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
To proceed with the proof, we use a trick: we first prove the naturality
 law of 
\begin_inset Formula $t$
\end_inset

 when restricted to isomorphic types 
\begin_inset Formula $A\cong B$
\end_inset

 and to invertible functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Then we use the fact that a fully parametric function 
\begin_inset Formula $t$
\end_inset

 cannot use any type information about 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 or any information about the function 
\begin_inset Formula $f$
\end_inset

, and so the naturality law must actually hold for all types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 and for all 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
\end_layout

\begin_layout Standard
When the function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 has an inverse 
\begin_inset Formula $g^{:B\rightarrow A}$
\end_inset

, we may define 
\begin_inset Formula $q$
\end_inset

 according to
\begin_inset Formula 
\[
q^{:Q^{B,A}}\triangleq p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef g^{\downarrow Q^{\bullet,A}}\quad.
\]

\end_inset

This will satisfy the first requirement in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-conditions-on-q-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) because
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}:\quad & q\triangleright f^{\downarrow Q^{\bullet,A}}=p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef\gunderline{g^{\downarrow Q^{\bullet,A}}\bef f^{\downarrow Q^{\bullet,A}}}\\
\text{composition under lifting}:\quad & =p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef(\gunderline{g\bef f})^{\downarrow Q^{\bullet,A}}\\
\text{use }g\bef f=\text{id}:\quad & =p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\quad.
\end{align*}

\end_inset

The second of the requirements in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-conditions-on-q-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is then also satisfied:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}:\quad & q\triangleright f^{\uparrow Q^{B,\bullet}}=p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef g^{\downarrow Q^{\bullet,A}}\bef f^{\uparrow Q^{B,\bullet}}\\
\text{commutativity law of }Q:\quad & =p^{:P^{B,A}}\triangleright\gunderline{f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef f^{\uparrow Q^{A,\bullet}}}\bef g^{\downarrow Q^{\bullet,B}}\\
\text{naturality law of }u:\quad & =p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef\gunderline{f^{\downarrow Q^{\bullet,B}}\bef g^{\downarrow Q^{\bullet,B}}}\\
\text{composition under lifting}:\quad & =p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef(\gunderline{f\bef g})^{\downarrow Q^{\bullet,B}}=p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We can now substitute Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-conditions-on-q-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-composition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and obtain
\begin_inset Formula 
\[
q\triangleright f^{\downarrow Q^{\bullet,A}}\bef v^{A}\bef f^{\uparrow R^{A,\bullet}}\overset{?}{=}q\triangleright f^{\uparrow Q^{B,\bullet}}\bef v^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

This holds due to the given naturality law of 
\begin_inset Formula $v$
\end_inset

.
 So, we have shown that the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $t$
\end_inset

 is satisfied for 
\emph on
invertible
\emph default
 functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
\end_layout

\begin_layout Standard
It remains to remove the assumption of invertibility of 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 At this point, we need to use the fact that the code of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 is fully parametric.
 Then so is the code of 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

.
 The naturality law of 
\begin_inset Formula $t$
\end_inset

 has the form of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Both sides of that equation can be written out as some code that combines
 the code of 
\begin_inset Formula $t$
\end_inset

 and the code of the required liftings of 
\begin_inset Formula $f$
\end_inset

.
 As we have seen in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and in the proof of the profunctor commutativity law (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proof-of-the-profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), all lifting code is fully parametric and uses the arbitrary function
 
\begin_inset Formula $f$
\end_inset

 only by applying 
\begin_inset Formula $f$
\end_inset

 to some arguments.
 So, the code corresponding to both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is fully parametric and involves the function 
\begin_inset Formula $f$
\end_inset

 as an unevaluated value (a 
\begin_inset Quotes eld
\end_inset

free variable
\begin_inset Index idx
status open

\begin_layout Plain Layout
free variable
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

).
 We can symbolically write that code as the equation 
\begin_inset Formula 
\[
a(f)=b(f)\quad,
\]

\end_inset

where 
\begin_inset Formula $a(f)$
\end_inset

 and 
\begin_inset Formula $b(f)$
\end_inset

 are some expressions of type 
\begin_inset Formula $P^{B,A}\rightarrow R^{A,B}$
\end_inset

 that are built up from the nine code constructions from Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It follows that the code of 
\begin_inset Formula $a(f)$
\end_inset

 and 
\begin_inset Formula $b(f)$
\end_inset

 may apply the given function 
\begin_inset Formula $f$
\end_inset

 but cannot use the inverse function 
\begin_inset Formula $g$
\end_inset

 assumed in the proof above.
 So, the only possibility for the equation 
\begin_inset Formula $a(f)=b(f)$
\end_inset

 to hold is when the programs 
\begin_inset Formula $a(f)$
\end_inset

 and 
\begin_inset Formula $b(f)$
\end_inset

 are 
\emph on
equal
\emph default
 
\emph on
as symbolic expressions
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
This step in the proof seems plausible but is not rigorously derived in
 the present version of this book.
\end_layout

\end_inset

 up to equivalence transformations 
\begin_inset Formula $g=x\rightarrow g(x)$
\end_inset

 and 
\begin_inset Formula $y\triangleright(x\rightarrow g(x))=g(y)$
\end_inset

.
 So, the equation 
\begin_inset Formula $a(f)=b(f)$
\end_inset

 must hold for arbitrary functions 
\begin_inset Formula $f$
\end_inset

 and for arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 
\end_layout

\begin_layout Standard
This concludes the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The proof of the main parametricity theorem is made shorter if we use the
 following property: If the type parameters of a natural transformation
 are substituted by some profunctors, we will obtain a dinatural transformation.
 Two versions of this property are proved next.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-substitute-functor-in-natural"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $u^{A}:G^{A}\rightarrow H^{A}$
\end_inset

 is a natural transformation, and suppose 
\begin_inset Formula $P^{X,Y}$
\end_inset

 is some fully parametric profunctor.
 Define the transformation
\begin_inset Formula 
\[
t^{A}:G^{P^{A,A}}\rightarrow H^{P^{A,A}}\quad,\quad\quad t^{A}\triangleq u^{P^{A,A}}\quad,
\]

\end_inset

by using the unmodified code of the function 
\begin_inset Formula $u^{A}$
\end_inset

 with a substituted type parameter, 
\begin_inset Formula $P^{A,A}$
\end_inset

 instead of 
\begin_inset Formula $A$
\end_inset

.
 Then 
\begin_inset Formula $t$
\end_inset

 is a dinatural transformation between profunctors 
\begin_inset Formula $G^{P^{A,A}}$
\end_inset

 and 
\begin_inset Formula $H^{P^{A,A}}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
By assumption, the naturality law of 
\begin_inset Formula $u$
\end_inset

 holds for any 
\begin_inset Formula $k^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
k^{\uparrow G}\bef u^{B}=u^{A}\bef k^{\uparrow H}\quad.
\]

\end_inset

The naturality law of 
\begin_inset Formula $t$
\end_inset

 is an equality of functions of type 
\begin_inset Formula $G^{P^{B,A}}\rightarrow H^{P^{A,B}}$
\end_inset

 for an arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\[
\big(f^{\downarrow P^{\bullet,A}}\big)^{\uparrow G}\bef t^{A}\bef\big(f^{\uparrow P^{\bullet,A}}\big)^{\uparrow H}\overset{?}{=}\big(f^{\uparrow P^{B,\bullet}}\big)^{\uparrow G}\bef t^{B}\bef\big(f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}\quad.
\]

\end_inset

Begin the calculation with the left-hand side of that law:
\begin_inset Formula 
\begin{align*}
\text{use }t^{A}=u^{P^{A,A}}:\quad & \big(f^{\downarrow P^{\bullet,A}}\big)^{\uparrow G}\bef\underline{t^{A}}\bef\big(f^{\uparrow P^{A,\bullet}}\big)^{\uparrow H}=\gunderline{\big(f^{\downarrow P^{\bullet,A}}\big)^{\uparrow G}\bef u^{P^{A,A}}}\bef\big(f^{\uparrow P^{A,\bullet}}\big)^{\uparrow H}\\
\text{naturality of }u:\quad & =u^{P^{B,A}}\bef\gunderline{\big(f^{\downarrow P^{\bullet,A}}\big)^{\uparrow H}\bef\big(f^{\uparrow P^{A,\bullet}}\big)^{\uparrow H}}=u^{P^{B,A}}\bef\big(f^{\downarrow P^{\bullet,A}}\bef f^{\uparrow P^{A,\bullet}}\big)^{\uparrow H}\quad.
\end{align*}

\end_inset

Now write the right-hand side:
\begin_inset Formula 
\begin{align*}
\text{use }t^{B}=u^{P^{B,B}}:\quad & \big(f^{\uparrow P^{B,\bullet}}\big)^{\uparrow G}\bef\gunderline{t^{B}}\bef\big(f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}=\gunderline{\big(f^{\uparrow P^{B,\bullet}}\big)^{\uparrow G}\bef u^{P^{B,B}}}\bef\big(f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}\\
\text{naturality of }u:\quad & =u^{P^{B,A}}\bef\gunderline{\big(f^{\uparrow P^{B,\bullet}}\big)^{\uparrow H}\bef\big(f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}}=u^{P^{B,A}}\bef\big(f^{\uparrow P^{B,\bullet}}\bef f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}\quad.
\end{align*}

\end_inset

The difference between the left-hand side and the right-hand side is now
 only in the order of applying lifted functions 
\begin_inset Formula $f$
\end_inset

.
 By the profunctor commutativity law of 
\begin_inset Formula $P$
\end_inset

, we have
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,A}}\bef f^{\uparrow P^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef f^{\downarrow P^{\bullet,B}}\quad,
\]

\end_inset

which completes the proof.
\end_layout

\begin_layout Standard
The following more general version of the same property will be also useful.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-substitute-profunctor-in-natural"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-profunctor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $G^{X,Y}$
\end_inset

 and 
\begin_inset Formula $H^{X,Y}$
\end_inset

 are some bifunctors, 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 are some profunctors, all fully parametric, and 
\begin_inset Formula $u^{A,B}:G^{A,B}\rightarrow H^{A,B}$
\end_inset

 is a natural transformation separately in the type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 Define the transformation 
\begin_inset Formula 
\[
t^{A}:G^{P^{A,A},Q^{A,A}}\rightarrow H^{P^{A,A},Q^{A,A}}\quad,\quad\quad t\triangleq u^{P^{A,A,},Q^{A,A}}\quad,
\]

\end_inset

by using the unmodified code of 
\begin_inset Formula $u^{A,B}$
\end_inset

 with substituted type parameters, 
\begin_inset Formula $P^{A,A}$
\end_inset

 and 
\begin_inset Formula $Q^{A,A}$
\end_inset

 instead of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 Then 
\begin_inset Formula $t$
\end_inset

 is a dinatural transformation between profunctors 
\begin_inset Formula $G^{P^{A,A},Q^{A,A}}$
\end_inset

 and 
\begin_inset Formula $H^{P^{A,A},Q^{A,A}}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The assumed naturality law of 
\begin_inset Formula $u$
\end_inset

 holds separately with respect to both type parameters,
\begin_inset Formula 
\[
f^{\uparrow G^{\bullet,B}}\bef u^{B,B}=u^{A,B}\bef f^{\uparrow H^{\bullet,B}}\quad,\quad\quad f^{\uparrow G^{A,\bullet}}\bef u^{A,B}=u^{A,A}\bef f^{\uparrow H^{A,\bullet}}\quad.
\]

\end_inset

 The naturality law of 
\begin_inset Formula $t$
\end_inset

 is written, after substituting 
\begin_inset Formula $t=u$
\end_inset

, as
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (f^{\downarrow P})^{\uparrow G^{\bullet,Q^{B,A}}}\bef(f^{\downarrow Q})^{\uparrow G^{P^{A,A},\bullet}}\bef u^{P^{A,A},Q^{A,A}}\bef(f^{\uparrow P})^{\uparrow H^{\bullet,Q^{A,A}}}\bef(f^{\uparrow Q})^{\uparrow H^{P^{A,B},\bullet}}\\
\text{right-hand side}:\quad & \quad\overset{?}{=}(f^{\uparrow P})^{\uparrow G^{\bullet,Q^{B,A}}}\bef(f^{\uparrow Q})^{\uparrow G^{P^{B,B},\bullet}}\bef u^{P^{B,B},Q^{B,B}}\bef(f^{\downarrow P})^{\uparrow H^{\bullet,Q^{B,B}}}\bef(f^{\downarrow Q})^{\uparrow H^{P^{A,B},\bullet}}\quad.
\end{align*}

\end_inset

The naturality law of 
\begin_inset Formula $u$
\end_inset

 allows us to move all 
\begin_inset Formula $G$
\end_inset

-lifted functions to the right of 
\begin_inset Formula $u$
\end_inset

, where they become 
\begin_inset Formula $H$
\end_inset

-lifted.
 The law becomes
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & u^{P^{B,A},Q^{B,A}}\bef(f^{\downarrow P})^{\uparrow H^{\bullet,Q^{B,A}}}\bef(f^{\downarrow Q})^{\uparrow H^{P^{A,A},\bullet}}\bef(f^{\uparrow P})^{\uparrow H^{\bullet,Q^{A,A}}}\bef(f^{\uparrow Q})^{\uparrow H^{P^{A,B},\bullet}}\\
\text{right-hand side}:\quad & \quad\overset{?}{=}u^{P^{B,A},Q^{B,A}}\bef(f^{\uparrow P})^{\uparrow H^{\bullet,Q^{B,A}}}\bef(f^{\uparrow Q})^{\uparrow H^{P^{B,B},\bullet}}\bef(f^{\downarrow P})^{\uparrow H^{\bullet,Q^{B,B}}}\bef(f^{\downarrow Q})^{\uparrow H^{P^{A,B},\bullet}}\quad.
\end{align*}

\end_inset

The remaining difference between the two sides is only in the application
 order of lifted functions 
\begin_inset Formula $f$
\end_inset

.
 All those liftings commute due to the profunctor and bifunctor commutativity
 laws.
\end_layout

\begin_layout Subsection
Proof of the parametricity theorem
\end_layout

\begin_layout Standard
We will now prove that any fully parametric 
\begin_inset Formula $t^{A}$
\end_inset

 expressed as 
\begin_inset Formula 
\[
t^{A}:P^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad t\triangleq p^{:P^{A,A}}\rightarrow\text{expression}\quad,
\]

\end_inset

satisfies the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It is assumed that the function body, denoted by 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, is some fully parametric code built up from the nine code constructions
 of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The proof goes by induction on the structure of 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 The base case contains the first two constructions (
\begin_inset Quotes eld
\end_inset

use unit value
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

use argument
\begin_inset Quotes erd
\end_inset

) since those constructions do not assume any previous code.
 We will need to prove that the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds in those cases.
 The inductive step covers the remaining seven constructions, which create
 larger code expressions from smaller ones.
 We will need to prove that the code for 
\begin_inset Formula $t$
\end_inset

 satisfies the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) under the inductive assumption that all previous code expressions already
 satisfy their versions of that law.
\end_layout

\begin_layout Standard
For example, the product construction (
\begin_inset Quotes eld
\end_inset

create tuple
\begin_inset Quotes erd
\end_inset

) combines two previously available code expressions (
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

) into a tuple 
\begin_inset Formula $a\times b$
\end_inset

.
 The corresponding transformations are 
\begin_inset Formula $p\rightarrow a$
\end_inset

, 
\begin_inset Formula $p\rightarrow b$
\end_inset

, and 
\begin_inset Formula $p\rightarrow a\times b$
\end_inset

.
 Note that the naturality laws have different forms for each of the transformati
ons 
\begin_inset Formula $p\rightarrow a$
\end_inset

, 
\begin_inset Formula $p\rightarrow b$
\end_inset

, and 
\begin_inset Formula $p\rightarrow a\times b$
\end_inset

 because those functions have different types.
 Assuming that the profunctor transformations 
\begin_inset Formula $p\rightarrow a$
\end_inset

 and 
\begin_inset Formula $p\rightarrow b$
\end_inset

 already satisfy their respective naturality laws, we will need to prove
 that 
\begin_inset Formula $p\rightarrow a\times b$
\end_inset

 also satisfies the corresponding law.
 (The proof is in item 5 below.)
\end_layout

\begin_layout Standard
We will now prove the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for each of the nine code constructions.
\end_layout

\begin_layout Paragraph
1) Use unit value
\end_layout

\begin_layout Standard
This is a base case where 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is just the unit value, 
\begin_inset Formula $1$
\end_inset

.
 The code of 
\begin_inset Formula $t$
\end_inset

 is a constant function that always returns that value: 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow1$
\end_inset

.
 In that case, 
\begin_inset Formula $Q^{X,Y}\triangleq\bbnum 1$
\end_inset

 and so the liftings for 
\begin_inset Formula $Q$
\end_inset

 consist of identity functions, 
\begin_inset Formula $f^{\downarrow Q^{\bullet,B}}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f^{\uparrow Q^{A,\bullet}}=\text{id}$
\end_inset

.
 We can also write 
\begin_inset Formula $t=\_\rightarrow1$
\end_inset

.
 Both sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are then functions that ignore their arguments and always return 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Standard
A quicker way of proving the dinaturality of 
\begin_inset Formula $t$
\end_inset

 is to use Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $G^{A}\triangleq A$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Paragraph
2) Use argument 
\end_layout

\begin_layout Standard
This is a base case where 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is just the given argument of the transformation, i.e., the code of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $t\triangleq p\rightarrow p$
\end_inset

.
 Since 
\begin_inset Formula $t$
\end_inset

 is an identity function, it has type 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow P^{A,A}$
\end_inset

, and so we must have 
\begin_inset Formula $P=Q$
\end_inset

.
 The naturality law follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $G^{A}\triangleq H^{A}\triangleq A$
\end_inset

.
\end_layout

\begin_layout Standard
The rest of the proof goes over the remaining code constructions, which
 are inductive steps.
\end_layout

\begin_layout Paragraph
3) Create function
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a nameless function 
\begin_inset Formula $z\rightarrow r$
\end_inset

, so 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow z\rightarrow r$
\end_inset

, where the sub-expression 
\begin_inset Formula $r$
\end_inset

 may use both 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 as bound variables.
 Since the code of 
\begin_inset Formula $r$
\end_inset

 is fully parametric, the types of 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 must be expressible as 
\begin_inset Formula $R^{A,A}$
\end_inset

 and 
\begin_inset Formula $Z^{A,A}$
\end_inset

, where 
\begin_inset Formula $R^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Z^{X,Y}$
\end_inset

 are some profunctors.
 The form of 
\begin_inset Formula $t$
\end_inset

 implies that 
\begin_inset Formula $Q^{X,Y}\triangleq Z^{Y,X}\rightarrow R^{X,Y}$
\end_inset

 (note the reverse order of parameters in 
\begin_inset Formula $Z^{Y,X}$
\end_inset

).
 The inductive assumption says that the naturality law is already satisfied
 by 
\emph on
any
\emph default
 transformation whose 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is just 
\begin_inset Formula $r$
\end_inset

.
 Such a transformation must have code of the form 
\begin_inset Formula $u\triangleq s\rightarrow r$
\end_inset

, where the type of the argument 
\begin_inset Formula $s$
\end_inset

 must contain the bound variables 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 that may be used in 
\begin_inset Formula $r$
\end_inset

.
 So, we set 
\begin_inset Formula $s=p\times z$
\end_inset

 and write the code of 
\begin_inset Formula $u$
\end_inset

 as 
\begin_inset Formula $u=p^{:P^{A,A}}\times z^{:Z^{A,A}}\rightarrow r$
\end_inset

.
 We then have
\begin_inset Formula 
\begin{equation}
t=p^{:P^{A,A}}\rightarrow z^{:Z^{A,A}}\rightarrow u(p\times z)\quad,\quad\quad u=p^{:P^{A,A}}\times z^{:Z^{A,A}}\rightarrow t(p)(z)\quad.\label{eq:dinaturality-u-function-type-derivation0}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Denoting the profunctor 
\begin_inset Formula $U^{X,Y}\triangleq P^{X,Y}\times Z^{X,Y}$
\end_inset

, we write the naturality law for 
\begin_inset Formula $u:U^{A,A}\rightarrow R^{A,A}$
\end_inset

 as
\begin_inset Formula 
\begin{equation}
f^{\downarrow U^{\bullet,A}}\bef u^{A}\bef f^{\uparrow R^{A,\bullet}}=f^{\uparrow U^{B,\bullet}}\bef u^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-u-function-type-derivation1}
\end{equation}

\end_inset

This equation holds by the inductive assumption.
 We will derive the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $t$
\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-u-function-type-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by using the type definitions 
\begin_inset Formula $U^{X,Y}\triangleq P^{X,Y}\times Z^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}\triangleq Z^{Y,X}\rightarrow R^{X,Y}$
\end_inset

 to express the liftings of 
\begin_inset Formula $U$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 through the liftings of 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

, and 
\begin_inset Formula $Z$
\end_inset

 via the standard functor/contrafunctor codes:
\begin_inset Formula 
\begin{align}
f^{\downarrow U^{\bullet,A}}=f^{\downarrow P^{\bullet,A}}\boxtimes f^{\downarrow Z^{\bullet,A}}\quad, & \quad\quad f^{\uparrow U^{B,\bullet}}=f^{\uparrow P^{B,\bullet}}\boxtimes f^{\uparrow Z^{B,\bullet}}\quad,\label{eq:dinaturality-u-function-type-derivation2}\\
f^{\uparrow Q^{A,\bullet}}=q^{:Q^{A,A}}\rightarrow f^{\downarrow Z^{\bullet,A}}\bef q\bef f^{\uparrow R^{A,\bullet}}\quad, & \quad\quad f^{\downarrow Q^{\bullet,B}}=q^{:Q^{B,B}}\rightarrow f^{\uparrow Z^{B,\bullet}}\bef q\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-u-function-type-derivation3}
\end{align}

\end_inset

Substituting the relevant formulas into the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and applying to 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

, we find
\begin_inset Formula 
\begin{align*}
\text{Eq.~(\ref{eq:dinaturality-u-function-type-derivation0})}:\quad & p\triangleright f^{\downarrow P^{\bullet,A}}\bef\gunderline t\bef\gunderline{f^{\uparrow Q^{A,\bullet}}}=p\triangleright f^{\downarrow P^{\bullet,A}}\,\gunderline{\triangleright\big(p}\rightarrow z\rightarrow u(p\times z)\big)\,\gunderline{\triangleright\big(q^{:Q^{A,A}}}\rightarrow f^{\downarrow Z^{\bullet,A}}\bef q\bef f^{\uparrow R^{A,\bullet}}\big)\\
 & =\gunderline{f^{\downarrow Z^{\bullet,A}}\bef\big(}z\rightarrow u((p\triangleright f^{\downarrow P^{\bullet,A}})\times\gunderline z)\big)\bef f^{\uparrow R^{A,\bullet}}=z\rightarrow u\big(\gunderline{(p\triangleright f^{\downarrow P^{\bullet,A}})\times(z\triangleright f^{\downarrow Z^{\bullet,A}})}\big)\triangleright f^{\uparrow R^{A,\bullet}}\\
 & =z\rightarrow\gunderline{u\big(}(p\times z)\triangleright\big(f^{\downarrow P^{\bullet,A}}\boxtimes f^{\downarrow Z^{\bullet,A}}\big)\gunderline{\big)}\triangleright f^{\uparrow R^{A,\bullet}}=z\rightarrow(p\times z)\triangleright\big(\gunderline{f^{\downarrow P^{\bullet,A}}\boxtimes f^{\downarrow Z^{\bullet,A}}}\big)\triangleright u\triangleright f^{\uparrow R^{A,\bullet}}\\
\text{Eq.~(\ref{eq:dinaturality-u-function-type-derivation2})}:\quad & =z\rightarrow(p\times z)\triangleright\gunderline{f^{\downarrow U^{\bullet,A}}\bef u\bef f^{\uparrow R^{A,\bullet}}}\\
\text{Eq.~(\ref{eq:dinaturality-u-function-type-derivation1})}:\quad & =z\rightarrow(p\times z)\triangleright\gunderline{f^{\uparrow U^{B,\bullet}}}\bef\gunderline u\bef f^{\downarrow R^{\bullet,B}}\\
\text{Eq.~(\ref{eq:dinaturality-u-function-type-derivation2})}:\quad & =z\rightarrow\gunderline{(p\times z)\triangleright\big(}f^{\uparrow P^{B,\bullet}}\boxtimes f^{\uparrow Z^{B,\bullet}}\big)\triangleright\big(p\times z\rightarrow t(p)(z)\big)\triangleright f^{\downarrow R^{\bullet,B}}\\
 & =z\rightarrow t\big(p\triangleright f^{\uparrow P^{B,\bullet}}\big)\big(z\triangleright f^{\uparrow Z^{B,\bullet}}\big)\triangleright f^{\downarrow R^{\bullet,B}}.
\end{align*}

\end_inset

Now apply the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to the same value 
\begin_inset Formula $p$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{use Eq.~(\ref{eq:dinaturality-u-function-type-derivation3})}:\quad & p\triangleright f^{\uparrow P^{B,\bullet}}\bef t\bef\gunderline{f^{\downarrow Q^{\bullet,B}}}=\gunderline{p\triangleright f^{\uparrow P^{B,\bullet}}\triangleright t\triangleright\big(}q^{:Q^{B,B}}\rightarrow f^{\uparrow Z^{B,\bullet}}\bef q\bef f^{\downarrow R^{\bullet,B}}\big)\\
 & =f^{\uparrow Z^{B,\bullet}}\bef t(p\triangleright f^{\uparrow P^{B,\bullet}})\bef f^{\downarrow R^{\bullet,B}}=z\rightarrow z\triangleright f^{\uparrow Z^{B,\bullet}}\triangleright t(p\triangleright f^{\uparrow P^{B,\bullet}})\triangleright f^{\downarrow R^{\bullet,B}}\\
 & =z\rightarrow t\big(p\triangleright f^{\uparrow P^{B,\bullet}}\big)\big(z\triangleright f^{\uparrow Z^{B,\bullet}}\big)\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\end{align*}

\end_inset

We obtain the same expression as for the left-hand side, which proves that
 the law holds.
\end_layout

\begin_layout Standard
The proof does not assume that the expression 
\begin_inset Formula $t(p)(r)$
\end_inset

 actually uses both arguments 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

.
 So, the law holds also for functions that ignore some of their arguments.
\end_layout

\begin_layout Paragraph
4) Use function 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a function application such as 
\begin_inset Formula $f(z)$
\end_inset

.
 Then we may write the code of 
\begin_inset Formula $t$
\end_inset

 as 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow f(z)$
\end_inset

, where 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are some other expressions.
 Since these expressions are parts of the code 
\begin_inset Formula $p\rightarrow f(z)$
\end_inset

, it must be possible to compute 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 separately, given 
\begin_inset Formula $p$
\end_inset

.
 So, we can write fully parametric code for the two transformations 
\begin_inset Formula $u\triangleq p\rightarrow f$
\end_inset

 and 
\begin_inset Formula $v\triangleq p\rightarrow z$
\end_inset

.
 The inductive assumption is that the naturality law holds for any transformatio
ns whose code contains 
\begin_inset Formula $f$
\end_inset

 or 
\begin_inset Formula $z$
\end_inset

 as the function body.
 So, we may use the naturality laws for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Standard
What are the possible types of 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

? Since 
\begin_inset Formula $z$
\end_inset

 is computed by fully parametric code, the type of 
\begin_inset Formula $z$
\end_inset

 can be expressed as 
\begin_inset Formula $z^{:Z^{A,A}}$
\end_inset

 via some profunctor 
\begin_inset Formula $Z^{X,Y}$
\end_inset

.
 To match the types, the function 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $Z^{A,A}\rightarrow Q^{A,A}$
\end_inset

.
 It will be convenient to express 
\begin_inset Formula $t$
\end_inset

 as a composition of two transformations: the first, denoted by 
\begin_inset Formula $s$
\end_inset

, simply gathers 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 in a tuple,
\begin_inset Formula 
\[
s:P^{A,A}\rightarrow(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\quad,\quad\quad s\triangleq p\rightarrow u(p)\times v(p)\quad.
\]

\end_inset

The second, denoted 
\begin_inset Formula $w$
\end_inset

, applies the function:
\begin_inset Formula 
\[
w:(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad w\triangleq f\times z\rightarrow f(z)\quad.
\]

\end_inset

We will show separately that 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are dinatural.
 Since both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are implemented via fully parametric code, it will follow by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the composition 
\begin_inset Formula $t=s\bef w$
\end_inset

 is also dinatural.
\end_layout

\begin_layout Standard
Defining the profunctor 
\begin_inset Formula $G^{X,Y}\triangleq Z^{Y,X}\rightarrow Q^{X,Y}$
\end_inset

, we write the type signatures of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 as 
\begin_inset Formula 
\[
u:P^{A,A}\rightarrow G^{A,A}\quad,\quad\quad v:P^{A,A}\rightarrow Z^{A,A}\quad.
\]

\end_inset

Since 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are dinatural, we may apply the derivation in item 5 below (which does
 not use any other assumptions) with 
\begin_inset Formula $R\triangleq G$
\end_inset

 and 
\begin_inset Formula $S\triangleq Z$
\end_inset

 to show that the transformation 
\begin_inset Formula $s\triangleq p\rightarrow u(p)\times v(p)$
\end_inset

 of type 
\begin_inset Formula $P^{A,A}\rightarrow G^{A,A}\times Z^{A,A}$
\end_inset

 is also dinatural.
\end_layout

\begin_layout Standard
It remains to show that the transformation 
\begin_inset Formula $w\triangleq g\times z\rightarrow z\triangleright g$
\end_inset

 is dinatural.
 For brevity, we will omit type annotations and write 
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 instead of 
\begin_inset Formula $f^{\uparrow G^{X,\bullet}}$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow G}$
\end_inset

 instead of 
\begin_inset Formula $f^{\downarrow G^{\bullet,Y}}$
\end_inset

, with 
\begin_inset Formula $G$
\end_inset

 and other profunctors.
 Since profunctors have one contravariant and one covariant type parameter,
 the choice of the type parameter in a lifting will remain unambiguous.
 The naturality law is then written as
\begin_inset Formula 
\begin{equation}
(f^{\downarrow G}\boxtimes f^{\downarrow Z})\bef w\bef f^{\uparrow Q}\overset{?}{=}(f^{\uparrow G}\boxtimes f^{\uparrow Z})\bef w\bef f^{\downarrow Q}\quad.\label{eq:dinaturality-law-application-derivation1}
\end{equation}

\end_inset

It helps to write out the liftings to 
\begin_inset Formula $G$
\end_inset

.
 For arbitrary 
\begin_inset Formula $g^{:G^{B,A}}$
\end_inset

 and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, we have 
\begin_inset Formula $g\triangleright f^{\downarrow G^{\bullet,A}}$
\end_inset

 of type 
\begin_inset Formula $G^{A,A}=Z^{A,A}\rightarrow Q^{A,A}$
\end_inset

, so
\begin_inset Formula 
\begin{align*}
g^{:G^{B,A}}\triangleright f^{\downarrow G} & =z^{:Z^{A,A}}\rightarrow(z\triangleright f^{\uparrow Z})\triangleright g\bef f^{\downarrow Q}=f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset

Similarly
\begin_inset Formula 
\[
g^{:G^{B,A}}\triangleright f^{\uparrow G}=z^{:Z^{B,B}}\rightarrow(z\triangleright f^{\downarrow Z})\triangleright g\bef f^{\uparrow Q}=f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\quad.
\]

\end_inset

Now apply the left-hand side of the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to an arbitrary 
\begin_inset Formula $g^{:G^{B,A}}\times z^{:Z^{B,A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{definitions of }\boxtimes\text{ and }w:\quad & (g^{:G^{B,A}}\times z^{:Z^{B,A}})\triangleright(f^{\downarrow G}\boxtimes f^{\downarrow Z})\bef w\bef f^{\uparrow Q}=(z\triangleright f^{\downarrow Z})\triangleright(\gunderline{g\triangleright f^{\downarrow G}})\bef f^{\uparrow Q}\\
\text{definition of }g\triangleright f^{\downarrow G}:\quad & =(z\triangleright f^{\downarrow Z})\triangleright f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}=z\triangleright f^{\downarrow Z}\bef f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}\quad.
\end{align*}

\end_inset

Applying the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $g\times z$
\end_inset

 gives similarly
\begin_inset Formula 
\begin{align*}
\text{definitions of }\boxtimes\text{ and }w:\quad & (g^{:G^{B,A}}\times z^{:Z^{B,A}})\triangleright(f^{\uparrow G}\boxtimes f^{\uparrow Z})\bef w\bef f^{\downarrow Q}=(z\triangleright f^{\uparrow Z})\triangleright(\gunderline{g\triangleright f^{\uparrow G}})\bef f^{\downarrow Q}\\
\text{definition of }g\triangleright f^{\uparrow G}:\quad & =(z\triangleright f^{\uparrow Z})\triangleright f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}=z\triangleright f^{\uparrow Z}\bef f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset

The two sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) now differ only by the order of application of lifted functions 
\begin_inset Formula $f^{\uparrow Z}$
\end_inset

, 
\begin_inset Formula $f^{\downarrow Z}$
\end_inset

, 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

, and 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

.
 These applications commute by the profunctor commutativity laws of 
\begin_inset Formula $Z$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow Z}\bef f^{\uparrow Z}=f^{\uparrow Z}\bef f^{\downarrow Z}\quad,\quad\quad f^{\downarrow Q}\bef f^{\uparrow Q}=f^{\uparrow Q}\bef f^{\downarrow Q}\quad.
\]

\end_inset

This concludes the proof of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and so proves the entire item 4.
\end_layout

\begin_layout Paragraph
5) Create tuple 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a tuple, so the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow r\times s$
\end_inset

 where 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 are some expressions.
 In general, the types of 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 will be given by some profunctors 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, so that 
\begin_inset Formula $Q^{X,Y}=R^{X,Y}\times S^{X,Y}$
\end_inset

.
 Since the code of 
\begin_inset Formula $t$
\end_inset

 computes 
\begin_inset Formula $r\times s$
\end_inset

 from 
\begin_inset Formula $p$
\end_inset

, we should be able to compute 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 separately from 
\begin_inset Formula $p$
\end_inset

.
 It means that we have well-defined transformations 
\begin_inset Formula $u\triangleq p\rightarrow r$
\end_inset

 and 
\begin_inset Formula $v\triangleq p\rightarrow s$
\end_inset

 having types 
\begin_inset Formula $u:P^{A.A}\rightarrow R^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:P^{A,A}\rightarrow S^{A,A}$
\end_inset

.
 The inductive assumption is that the naturality law already holds for any
 transformation whose function body is 
\begin_inset Formula $r$
\end_inset

 or 
\begin_inset Formula $s$
\end_inset

.
 So, we may assume that the law holds separately for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow P}\bef u\bef f^{\uparrow R}=f^{\uparrow P}\bef u\bef f^{\downarrow R}\quad,\quad\quad f^{\downarrow P}\bef v\bef f^{\uparrow S}=f^{\uparrow P}\bef v\bef f^{\downarrow S}\quad.
\]

\end_inset

The lifting for 
\begin_inset Formula $Q$
\end_inset

 is expressed through the liftings for 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 as
\begin_inset Formula 
\[
f^{\uparrow Q}=f^{\uparrow R}\boxtimes f^{\uparrow S}\quad,\quad\quad f^{\downarrow Q}=f^{\downarrow R}\boxtimes f^{\downarrow S}\quad.
\]

\end_inset

We can now verify the naturality law of 
\begin_inset Formula $t$
\end_inset

 by expressing 
\begin_inset Formula $t=p\rightarrow u(p)\times v(p)=\Delta\bef(u\boxtimes v)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect }f^{\uparrow P}\bef t\bef f^{\downarrow Q}:\quad & f^{\downarrow P}\bef\gunderline t\bef\gunderline{f^{\uparrow Q}}=\gunderline{f^{\downarrow P}\bef\Delta}\bef(u\boxtimes v)\bef\big(f^{\uparrow R}\boxtimes f^{\uparrow S}\big)\\
\text{naturality of }\Delta:\quad & =\Delta\bef(f^{\downarrow P}\boxtimes f^{\downarrow P})\bef(u\boxtimes v)\bef\big(f^{\uparrow R}\boxtimes f^{\uparrow S}\big)=\Delta\bef\big(\gunderline{f^{\downarrow P}\bef u\bef f^{\uparrow R}}\big)\boxtimes\big(\gunderline{f^{\downarrow P}\bef v\bef f^{\uparrow S}}\big)\\
\text{inductive assumption}:\quad & =\Delta\bef\big(f^{\uparrow P}\bef u\bef f^{\downarrow R}\big)\boxtimes\big(f^{\uparrow P}\bef v\bef f^{\downarrow S}\big)=\gunderline{\Delta\bef\big(f^{\uparrow P}\boxtimes f^{\uparrow P}\big)}\bef(u\boxtimes v)\bef\big(\gunderline{f^{\downarrow R}\boxtimes f^{\downarrow S}}\big)\\
\text{naturality of }\Delta:\quad & =f^{\uparrow P}\bef\gunderline{\Delta\bef(u\boxtimes v)}\bef f^{\downarrow Q}=f^{\uparrow P}\bef t\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
6) Use tuple 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 contains a tuple accessor, such as 
\begin_inset Formula $\pi_{1}$
\end_inset

.
 It is sufficient to prove the law for 
\begin_inset Formula $\pi_{1}$
\end_inset

, since all tuple accessors work similarly.
 So, we assume that the type 
\begin_inset Formula $P$
\end_inset

 is a product, 
\begin_inset Formula $P^{X,Y}\triangleq Q^{X,Y}\times R^{X,Y}$
\end_inset

, and that the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq\pi_{1}=p^{:Q^{A,A}\times R^{A,A}}\rightarrow p\triangleright\pi_{1}$
\end_inset

.
 This is just the natural transformation 
\begin_inset Formula $\pi_{1}$
\end_inset

 with substituted type parameters, so the dinaturality of 
\begin_inset Formula $t$
\end_inset

 follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-profunctor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $G^{X,Y}\triangleq X\times Y$
\end_inset

, 
\begin_inset Formula $H^{X,Y}\triangleq X$
\end_inset

, 
\begin_inset Formula $P\triangleq Q$
\end_inset

, and 
\begin_inset Formula $Q\triangleq R$
\end_inset

.
\end_layout

\begin_layout Paragraph
7) Create disjunctive value 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 contains a case class constructor such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some
\end_layout

\end_inset

.
 We may assume that 
\begin_inset Formula $Q^{X,Y}=R^{X,Y}+S^{X,Y}$
\end_inset

 for some profunctors 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

, and that the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow r^{:R^{A,A}}+\bbnum 0^{:S^{A,A}}$
\end_inset

 where 
\begin_inset Formula $r$
\end_inset

 is some expression of type 
\begin_inset Formula $R^{A,A}$
\end_inset

.
 It is sufficient to prove the law for 
\begin_inset Formula $t=p\rightarrow r+\bbnum 0$
\end_inset

, because all other disjunctive cases such as 
\begin_inset Formula $t=p\rightarrow\bbnum 0+s$
\end_inset

 work analogously.
\end_layout

\begin_layout Standard
Since the code of 
\begin_inset Formula $t$
\end_inset

 is fully parametric, the value 
\begin_inset Formula $r$
\end_inset

 can be also computed from 
\begin_inset Formula $p$
\end_inset

 using fully parametric code.
 So the inductive assumption is that the transformation 
\begin_inset Formula $u\triangleq p\rightarrow r$
\end_inset

 is already known to be dinatural, with the law
\begin_inset Formula 
\[
f^{\downarrow P}\bef u\bef f^{\uparrow R}=f^{\uparrow P}\bef u\bef f^{\downarrow R}\quad.
\]

\end_inset

 The naturality law for 
\begin_inset Formula $t$
\end_inset

 is
\begin_inset Formula 
\[
f^{\downarrow P}\bef t\bef f^{\uparrow Q}\overset{?}{=}f^{\uparrow P}\bef t\bef f^{\downarrow Q}\quad.
\]

\end_inset

The liftings to 
\begin_inset Formula $Q$
\end_inset

 are disjunctive functions written in the matrix notation as
\begin_inset Formula 
\[
f^{\uparrow Q^{B,\bullet}}=\,\begin{array}{|c||cc|}
 & R^{B,B} & S^{B,B}\\
\hline R^{B,A} & f^{\uparrow R^{B,\bullet}} & \bbnum 0\\
S^{B,A} & \bbnum 0 & f^{\uparrow S^{B,\bullet}}
\end{array}\quad,\quad\quad f^{\downarrow Q^{\bullet,A}}=\,\begin{array}{|c||cc|}
 & R^{A,A} & S^{A,A}\\
\hline R^{B,A} & f^{\downarrow R^{\bullet,A}} & \bbnum 0\\
S^{B,A} & \bbnum 0 & f^{\downarrow S^{\bullet,A}}
\end{array}\quad.
\]

\end_inset

Omitting type annotations, we apply the naturality law to a value 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 and get
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p\triangleright f^{\downarrow P}\bef t\bef f^{\uparrow Q}=\big((p\triangleright f^{\downarrow P}\triangleright u)+\bbnum 0\big)\triangleright\,\begin{array}{||cc|}
f^{\uparrow R} & \bbnum 0\\
\bbnum 0 & f^{\uparrow S}
\end{array}\\
\text{apply disjunctive function}:\quad & \quad=p\triangleright f^{\downarrow P}\bef u\bef f^{\uparrow R}\quad.\\
\text{right-hand side}:\quad & p\triangleright f^{\uparrow P}\bef t\bef f^{\downarrow Q}=\big((p\triangleright f^{\uparrow P}\triangleright u)+\bbnum 0\big)\triangleright\,\begin{array}{||cc|}
f^{\downarrow R} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S}
\end{array}\\
\text{apply disjunctive function}:\quad & \quad=p\triangleright\gunderline{f^{\uparrow P}\bef u\bef f^{\downarrow R}}\\
\text{dinaturality of }u:\quad & \quad=p\triangleright f^{\downarrow P}\bef u\bef f^{\uparrow R}\quad.
\end{align*}

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Paragraph
8) Use disjunctive value 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a pattern match, so the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula 
\[
t\triangleq p^{:P^{A,A}}\rightarrow e\triangleright\,\begin{array}{||c|}
g\\
h
\end{array}\quad,
\]

\end_inset

where 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 are known functions.
 The expressions 
\begin_inset Formula $e$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $h$
\end_inset

 are used as part of the code, and so they must be all fully parametric
 and computable from 
\begin_inset Formula $p$
\end_inset

.
 We then choose the inductive assumption that the transformations 
\begin_inset Formula $p\rightarrow e$
\end_inset

, 
\begin_inset Formula $p\rightarrow g$
\end_inset

, 
\begin_inset Formula $p\rightarrow h$
\end_inset

 are dinatural.
 As in item 4, we can represent 
\begin_inset Formula $t$
\end_inset

 as a composition of two transformations, 
\begin_inset Formula 
\[
t=u\bef v\quad,\quad\quad u\triangleq p\rightarrow e\times g\times h\quad,\quad\quad v\triangleq e\times g\times h\rightarrow e\triangleright\,\begin{array}{||c|}
g\\
h
\end{array}\quad.
\]

\end_inset

To show that the transformation 
\begin_inset Formula $u$
\end_inset

 is dinatural, we apply the argument in item 5 twice.
 It remains to show that 
\begin_inset Formula $v$
\end_inset

 is dinatural.
 Since the code of 
\begin_inset Formula $v$
\end_inset

 is fully parametric, it will follow by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the composition 
\begin_inset Formula $t=u\bef v$
\end_inset

 is dinatural.
\end_layout

\begin_layout Standard
Assume that the types of 
\begin_inset Formula $e$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

 are 
\begin_inset Formula $e:R^{A,A}+S^{A,A}$
\end_inset

, 
\begin_inset Formula $g:R^{A,A}\rightarrow Q^{A,A}$
\end_inset

, and 
\begin_inset Formula $h:S^{A,A}\rightarrow Q^{A,A}$
\end_inset

, where 
\begin_inset Formula $R^{X,Y}$
\end_inset

 and 
\begin_inset Formula $S^{X,Y}$
\end_inset

 are some profunctors.
 For convenience, let us define the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 by
\begin_inset Formula 
\[
K^{X,Y}\triangleq R^{Y,X}\rightarrow Q^{X,Y}\quad,\quad\quad L^{X,Y}\triangleq S^{Y,X}\rightarrow Q^{X,Y}\quad.
\]

\end_inset

The type of 
\begin_inset Formula $v$
\end_inset

 is then 
\begin_inset Formula $v^{A}:(R^{A,A}+S^{A,A})\times K^{A,A}\times L^{A,A}\rightarrow Q^{A,A}$
\end_inset

, so its naturality law is 
\begin_inset Formula 
\[
\big(f^{\downarrow(R+S)}\boxtimes f^{\downarrow K}\boxtimes f^{\downarrow L}\big)\bef v\bef f^{\uparrow Q}\overset{?}{=}\big(f^{\uparrow(R+S)}\boxtimes f^{\uparrow K}\boxtimes f^{\uparrow L}\big)\bef v\bef f^{\downarrow Q}\quad.
\]

\end_inset

The code of the required liftings is defined by
\begin_inset Formula 
\begin{align*}
f^{\downarrow(R+S)}=\,\begin{array}{||cc|}
f^{\downarrow R} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S}
\end{array}\quad, & \quad\quad f^{\uparrow(R+S)}=\,\begin{array}{||cc|}
f^{\uparrow R} & \bbnum 0\\
\bbnum 0 & f^{\uparrow S}
\end{array}\quad,\\
g\triangleright f^{\downarrow K}=f^{\uparrow R}\bef g\bef f^{\downarrow Q}\quad, & \quad\quad g\triangleright f^{\uparrow K}=f^{\downarrow R}\bef g\bef f^{\uparrow Q}\quad,\\
h\triangleright f^{\downarrow L}=f^{\uparrow S}\bef h\bef f^{\downarrow Q}\quad, & \quad\quad h\triangleright f^{\uparrow L}=f^{\downarrow S}\bef h\bef f^{\uparrow Q}\quad.
\end{align*}

\end_inset

Apply the left-hand side of the naturality law to a value 
\begin_inset Formula $e^{:R^{B,A}+S^{B,A}}\times g^{:R^{A,B}\rightarrow Q^{B,A}}\times h^{:S^{A,B}\rightarrow Q^{B,A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expand }\boxtimes:\quad & \gunderline{e\times g\times h\triangleright\big(}f^{\downarrow(R+S)}\boxtimes f^{\downarrow K}\boxtimes f^{\downarrow L}\big)\bef v\bef f^{\uparrow Q}=(e\triangleright f^{\downarrow(R+S)})\times(\gunderline{g\triangleright f^{\downarrow K}})\times(\gunderline{h\triangleright f^{\downarrow L}})\triangleright v\bef f^{\uparrow Q}\\
\text{definition of }v:\quad & =e\triangleright\,\begin{array}{||cc|}
f^{\downarrow R} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S}
\end{array}\,\bef\,\begin{array}{||c|}
g\triangleright f^{\downarrow K}\\
h\triangleright f^{\downarrow L}
\end{array}\,\bef f^{\uparrow Q}\\
\text{composition}:\quad & =e\triangleright\,\begin{array}{||c|}
f^{\downarrow R}\bef f^{\uparrow R}\bef g\bef f^{\downarrow Q}\\
f^{\downarrow S}\bef f^{\uparrow S}\bef h\bef f^{\downarrow Q}
\end{array}\,\bef f^{\uparrow Q}=e\triangleright\,\begin{array}{||c|}
f^{\downarrow R}\bef f^{\uparrow R}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}\\
f^{\downarrow S}\bef f^{\uparrow S}\bef h\bef f^{\downarrow Q}\bef f^{\uparrow Q}
\end{array}\quad.
\end{align*}

\end_inset

Apply the right-hand side to the same value:
\begin_inset Formula 
\begin{align*}
\text{expand }\boxtimes:\quad & \gunderline{e\times g\times h\triangleright\big(}f^{\uparrow(R+S)}\boxtimes f^{\uparrow K}\boxtimes f^{\uparrow L}\big)\bef v\bef f^{\downarrow Q}=(e\triangleright f^{\uparrow(R+S)})\times(\gunderline{g\triangleright f^{\uparrow K}})\times(\gunderline{h\triangleright f^{\uparrow L}})\triangleright v\bef f^{\downarrow Q}\\
\text{definition of }v:\quad & =e\triangleright\,\begin{array}{||cc|}
f^{\uparrow R} & \bbnum 0\\
\bbnum 0 & f^{\uparrow S}
\end{array}\,\bef\,\begin{array}{||c|}
g\triangleright f^{\uparrow K}\\
h\triangleright f^{\uparrow L}
\end{array}\,\bef f^{\downarrow Q}\\
\text{composition}:\quad & =e\triangleright\,\begin{array}{||c|}
f^{\uparrow R}\bef f^{\downarrow R}\bef g\bef f^{\uparrow Q}\\
f^{\uparrow S}\bef f^{\downarrow S}\bef h\bef f^{\uparrow Q}
\end{array}\,\bef f^{\downarrow Q}=e\triangleright\,\begin{array}{||c|}
f^{\uparrow R}\bef f^{\downarrow R}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}\\
f^{\uparrow S}\bef f^{\downarrow S}\bef h\bef f^{\uparrow Q}\bef f^{\downarrow Q}
\end{array}\quad.
\end{align*}

\end_inset

The two sides of the naturality law now differ only by the application order
 of lifted functions 
\begin_inset Formula $f$
\end_inset

.
 Applying the profunctor commutativity law of 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

, and 
\begin_inset Formula $Q$
\end_inset

, we find that the two sides of the naturality law are equal.
\end_layout

\begin_layout Paragraph
9) Use recursion
\end_layout

\begin_layout Standard
Here the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is the value of the function 
\begin_inset Formula $t$
\end_inset

 itself, so the code of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow\overline{t}$
\end_inset

 (the overline in 
\begin_inset Formula $\overline{t}$
\end_inset

 denotes the recursive use of 
\begin_inset Formula $t$
\end_inset

).
 We treat 
\begin_inset Formula $\overline{t}$
\end_inset

 as just code for some function that is already known (by the inductive
 assumption) to obey its naturality law.
 Assume that the type of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

; then the recursive invocation 
\begin_inset Formula $\overline{t}$
\end_inset

 has the type 
\begin_inset Formula $Q^{A,A}$
\end_inset

 (which is a recursive type assumed to be equivalent to 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

).
 The naturality law of 
\begin_inset Formula $t$
\end_inset

 applied to an arbitrary 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 is
\begin_inset Formula 
\[
p\triangleright f^{\downarrow P}\bef t\bef f^{\uparrow Q}\overset{?}{=}p\triangleright f^{\uparrow P}\bef t\bef f^{\downarrow Q}\quad.
\]

\end_inset

Substituting 
\begin_inset Formula $t=p\rightarrow\overline{t}$
\end_inset

, we find
\begin_inset Formula 
\[
p\triangleright f^{\downarrow P}\triangleright(p\rightarrow\overline{t})\triangleright f^{\uparrow Q}=\overline{t}\triangleright f^{\uparrow Q}\overset{?}{=}p\triangleright f^{\uparrow P}\triangleright(p\rightarrow\overline{t})\triangleright f^{\downarrow Q}=\overline{t}\triangleright f^{\downarrow Q}\quad.
\]

\end_inset

It remains to show that 
\begin_inset Formula 
\[
\overline{t}\triangleright f^{\uparrow Q}\overset{?}{=}\overline{t}\triangleright f^{\downarrow Q}\quad.
\]

\end_inset

This is the 
\begin_inset Quotes eld
\end_inset

wedge law
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Formula $\overline{t}$
\end_inset

, which follows from the assumed dinaturality of 
\begin_inset Formula $\overline{t}$
\end_inset

 by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-expression-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
This concludes the proof of what is commonly known as 
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

 parametricity theorem: Any fully parametric function with a type parameter
 will automatically satisfy a naturality law.
 For functions having several type parameters, we can fix all the type parameter
s except one and apply the parametricity theorem separately, obtaining one
 naturality law for each type parameter.
\end_layout

\begin_layout Subsection
Uniqueness of functor and contrafunctor typeclass instances
\begin_inset CommandInset label
LatexCommand label
name "sec:Uniqueness-of-functor-and-contrafunctor"

\end_inset


\end_layout

\begin_layout Standard
An important consequence of the parametricity theorem is the fact that functors
 and contrafunctors can be implemented in only one way.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-functor-is-unique"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-functor-is-unique"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!functor
\end_layout

\end_inset


\series bold
fully parametric functor
\series default
, i.e., a functor 
\begin_inset Formula $F$
\end_inset

 whose type is a combination of the constructions of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, has a unique lawful and fully parametric implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 derived lawful and fully parametric implementations of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method for all functors 
\begin_inset Formula $F$
\end_inset

 build up from the six type constructions.
 The naturality laws obtained from the parametricity theorem must use precisely
 those 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, because the proof of the parametricity theorem significantly depends on
 the code of those implementations.
 Throughout this book, the standard lifting code is denoted by 
\begin_inset Formula $\text{fmap}_{F}(f)$
\end_inset

 or by 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

.
 Now suppose that there exists 
\emph on
another
\emph default
 lawful and fully parametric implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for 
\begin_inset Formula $F$
\end_inset

, denoted by 
\begin_inset Formula $\text{fmap}_{F}^{\prime}(f)$
\end_inset

:
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}\quad,\quad\quad\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B})=\text{???}^{:F^{A}\rightarrow F^{B}}\quad.
\]

\end_inset

We will now show that 
\begin_inset Formula $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$
\end_inset

.
 Let us fix the type parameter 
\begin_inset Formula $A$
\end_inset

 and apply the parametricity theorem to 
\begin_inset Formula $\text{fmap}_{F}^{\prime}$
\end_inset

 with respect to 
\begin_inset Formula $B$
\end_inset

.
 The resulting naturality law involves an arbitrary 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

:
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]

\end_inset

Within the naturality law, the lifting 
\begin_inset Formula $g^{\uparrow F}$
\end_inset

 must use the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 lifting code 
\begin_inset Formula $g^{\uparrow F}\triangleq\text{fmap}_{F}(g)$
\end_inset

.
 By assumption, 
\begin_inset Formula $\text{fmap}_{F}^{\prime}$
\end_inset

 is lawful, so we may use its composition law and write
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(f\bef g)=\text{fmap}_{F}^{\prime}(f)\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]

\end_inset

Since 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is arbitrary, we can choose 
\begin_inset Formula $A=B$
\end_inset

 and 
\begin_inset Formula $f=\text{id}^{:B\rightarrow B}$
\end_inset

 to obtain
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(\text{id})\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(\text{id})\bef g^{\uparrow F}\quad.
\]

\end_inset

The identity law for 
\begin_inset Formula $\text{fmap}_{F}^{\prime}$
\end_inset

 gives 
\begin_inset Formula $\text{fmap}_{F}^{\prime}(\text{id})=\text{id}$
\end_inset

, so we can simplify the last equation to
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(g)\overset{!}{=}g^{\uparrow F}=\text{fmap}_{F}(g)\quad.
\]

\end_inset

This must hold for arbitrary 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, which proves that 
\begin_inset Formula $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-contrafunctor-is-unique"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-contrafunctor-is-unique"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A contrafunctor 
\begin_inset Formula $H$
\end_inset

 whose type expression is a combination of the six type constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) has a unique fully parametric implementation of a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 method.
 
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We use similar arguments as in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-functor-is-unique"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For any lawful, fully parametric alternative implementation 
\begin_inset Formula $\text{cmap}_{H}^{\prime}$
\end_inset

, the parametricity theorem gives the naturality law
\begin_inset Formula 
\[
\text{cmap}_{H}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}(g^{:B\rightarrow C})^{\downarrow H}\bef\text{cmap}_{H}^{\prime}(f)\quad.
\]

\end_inset

By assumption, the identity and composition law hold for 
\begin_inset Formula $\text{cmap}_{H}^{\prime}$
\end_inset

.
 Setting 
\begin_inset Formula $f=\text{id}^{:B\rightarrow B}$
\end_inset

, we get
\begin_inset Formula 
\[
\text{cmap}_{H}^{\prime}(\text{id}\bef g)=\text{cmap}_{H}^{\prime}(g)\overset{!}{=}g^{\downarrow H}\bef\text{cmap}_{H}^{\prime}(\text{id})=g^{\downarrow H}\quad.
\]

\end_inset

This must hold for arbitrary 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, which shows that 
\begin_inset Formula $\text{cmap}_{H}^{\prime}(g)=g^{\downarrow H}=\text{cmap}_{H}(g)$
\end_inset

 as required.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
We have proved three parametricity results that apply to all fully parametric
 code:
\end_layout

\begin_layout Itemize
The lifting methods of any bifunctor, profunctor, or bi-contrafunctor obey
 the commutativity law such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Because of this, any fully parametric type constructor 
\begin_inset Formula $F^{A,B}$
\end_inset

 which is a functor separately with respect to 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 is always a bifunctor whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 method satisfies the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-bimap-composition-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Similar properties hold for profunctors and for bi-contrafunctors.
 The proof goes by induction on the exponential-polynomial type expression
 of 
\begin_inset Formula $F^{A,B}$
\end_inset

, which must be built up via the six type constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Itemize
Any function of type 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 (where 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 are profunctors) obeys the general naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which allows us to derive a specific naturality law for any fully parametric
 function.
 The form of the law depends only on the function's type signature and applies
 to all fully parametric implementations of that type signature.
 The proof goes by induction on the structure of the expression, which must
 be built up via the nine code constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Itemize
The lifting methods of functors and contrafunctors can be implemented in
 only one way once the identity and composition laws are imposed.
 The unique correct implementations are defined by the standard procedures
 shown in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and there are no other inequivalent implementations.
 Here we do not distinguish 
\emph on
equivalent
\emph default
 implementations such as 
\begin_inset Formula $f(x)$
\end_inset

 and 
\begin_inset Formula $(y\rightarrow y)(f)(x)$
\end_inset

, which are syntactically different programs that will always give the same
 results.
 So, there is only one lawful implementation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contrafunctor
\end_layout

\end_inset

 typeclass instances for a given type constructor.
 (For many other typeclasses, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, a given type constructor may have several inequivalent and lawful typeclass
 instances.)
\end_layout

\begin_layout Chapter
A humorous disclaimer
\end_layout

\begin_layout Standard

\emph on
The following text is quoted in part from an anonymous online source (
\begin_inset space ~
\end_inset


\begin_inset Quotes eld
\end_inset

Project Guten Tag
\begin_inset Quotes erd
\end_inset

) dating back at least to 1997.
 The original text is no longer available on the Internet.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\noun on
Warranto Limitensis; Disclamatantus Damagensis
\end_layout

\begin_layout Standard
Solus exceptus 
\begin_inset Quotes eld
\end_inset

Rectum Replacator Refundiens
\begin_inset Quotes erd
\end_inset

 describitus ecci,
\end_layout

\begin_layout Enumerate
Projectus (etque nunquam partum quis hic etext remitibus cum 
\noun on
Project Guten Tag
\noun default

\begin_inset Formula $^{\text{TM}}$
\end_inset

 identificator) disclamabat omni liabilitus tuus damagensis, pecuniensisque,
 includibantus pecunia legalitus, et 
\end_layout

\begin_layout Enumerate

\noun on
Remedia Negligentitia Non Habet Tuus, Warrantus Destructi
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

bus Contractus Nullibus Ni Liabilitus Sumus, Inclutatibus Non Limitatus
 Destructio Directibus, Consequentius, Punitio, O Incidentus, Non Sunt Si
 Nos Notificat Vobis
\noun default
.
 
\end_layout

\begin_layout Standard
Sit discubriatus defectus en etextum sic entram diariam noventam recibidio,
 pecuniam tuum refundatorium receptorus posset, sic scribatis vendor.
 Sit veniabat medium physicalis, vobis idem reternat et replacator possit
 copius.
 Sit venitabat electronicabilis, sic viri datus chansus segundibus.
 
\end_layout

\begin_layout Standard

\noun on
Hic Etext Venid 
\begin_inset Quotes eld
\end_inset

Como-asi
\begin_inset Quotes erd
\end_inset

.
 Nihil Warranti Nunquam Classum, Expressito Ni Implicato, Le Macchen Como
 Si Etexto Bene Sit O Il Medio Bene Sit, Inclutat Et Non Limitat Warranti
 Mercatensis, Appropriatensis Purposem.
 
\end_layout

\begin_layout Standard
Statuen varias non permitatent disclamabaris ni warranti implicatoren ni
 exclusioni limitatio damagaren consequentialis, ecco lo qua disclamatori
 exclusato
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

rique non vobis applicant, et potat optia alia legali.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
twocolumn
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
GNU Free Documentation License
\begin_inset CommandInset label
LatexCommand label
name "sec:GFDL"

\end_inset

 
\end_layout

\begin_layout Standard

\size footnotesize
Version 1.2, November 2002
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) 2000,2001,2002 Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
\end_layout

\begin_layout Standard

\size tiny
Everyone is permitted to copy and distribute verbatim copies of this license
 document, but changing it is not allowed.
\end_layout

\begin_layout Standard

\size tiny
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setcounter{subsection}{-1}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*

\size tiny
Preamble
\end_layout

\begin_layout Standard

\size tiny
The purpose of this License is to make a manual, textbook, or other functional
 and useful document free in the sense of freedom: to assure everyone the
 effective freedom to copy and redistribute it, with or without modifying
 it, either commercially or noncommercially.
 Secondarily, this License preserves for the author and publisher a way
 to get credit for their work, while not being considered responsible for
 modifications made by others.
\end_layout

\begin_layout Standard

\size tiny
This License is a kind of “copyleft
\begin_inset Quotes erd
\end_inset

, which means that derivative works of the document must themselves be free
 in the same sense.
 It complements the GNU General Public License, which is a copyleft license
 designed for free software.
\end_layout

\begin_layout Standard

\size tiny
We have designed this License in order to use it for manuals for free software,
 because free software needs free documentation: a free program should come
 with manuals providing the same freedoms that the software does.
 But this License is not limited to software manuals; it can be used for
 any textual work, regardless of subject matter or whether it is published
 as a printed book.
 We recommend this License principally for works whose purpose is instruction
 or reference.
\end_layout

\begin_layout Subsection
Applicability and definitions
\begin_inset CommandInset label
LatexCommand label
name "subsec:1Applicability-and-definitions"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
This License applies to any manual or other work, in any medium, that contains
 a notice placed by the copyright holder saying it can be distributed under
 the terms of this License.
 Such a notice grants a world-wide, royalty-free license, unlimited in duration,
 to use that work under the conditions stated herein.
 The “Document'', below, refers to any such manual or work.
 Any member of the public is a licensee, and is addressed as “you''.
 You accept the license if you copy, modify or distribute the work in a
 way requiring permission under copyright law.
\end_layout

\begin_layout Standard

\size tiny
A “Modified Version
\begin_inset Quotes erd
\end_inset

 of the Document means any work containing the Document or a portion of
 it, either copied verbatim, or with modifications and/or translated into
 another language.
\end_layout

\begin_layout Standard

\size tiny
A “Secondary Section
\begin_inset Quotes erd
\end_inset

 is a named appendix or a front-matter section of the Document that deals
 exclusively with the relationship of the publishers or authors of the Document
 to the Document's overall subject (or to related matters) and contains
 nothing that could fall directly within that overall subject.
 (Thus, if the Document is in part a textbook of mathematics, a Secondary
 Section may not explain any mathematics.) The relationship could be a matter
 of historical connection with the subject or with related matters, or of
 legal, commercial, philosophical, ethical or political position regarding
 them.
\end_layout

\begin_layout Standard

\size tiny
The “Invariant Sections'' are certain Secondary Sections whose titles are
 designated, as being those of Invariant Sections, in the notice that says
 that the Document is released under this License.
 If a section does not fit the above definition of Secondary then it is
 not allowed to be designated as Invariant.
 The Document may contain zero Invariant Sections.
 If the Document does not identify any Invariant Sections then there are
 none.
\end_layout

\begin_layout Standard

\size tiny
The “Cover Texts'' are certain short passages of text that are listed, as
 Front-Cover Texts or Back-Cover Texts, in the notice that says that the
 Document is released under this License.
 A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be
 at most 25 words.
\end_layout

\begin_layout Standard

\size tiny
A “Transparent'' copy of the Document means a machine-readable copy, represented
 in a format whose specification is available to the general public, that
 is suitable for revising the document straightforwardly with generic text
 editors or (for images composed of pixels) generic paint programs or (for
 drawings) some widely available drawing editor, and that is suitable for
 input to text formatters or for automatic translation to a variety of formats
 suitable for input to text formatters.
 A copy made in an otherwise Transparent file format whose markup, or absence
 of markup, has been arranged to thwart or discourage subsequent modification
 by readers is not Transparent.
 An image format is not Transparent if used for any substantial amount of
 text.
 A copy that is not “Transparent'' is called “Opaque
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
Examples of suitable formats for Transparent copies include plain ASCII
 without markup, Texinfo input format, \SpecialChar LaTeX
 input format, SGML or XML using
 a publicly available DTD, and standard-conforming simple HTML, PostScript
 or PDF designed for human modification.
 Examples of transparent image formats include PNG, XCF and JPG.
 Opaque formats include proprietary formats that can be read and edited
 only by proprietary word processors, SGML or XML for which the DTD and/or
 processing tools are not generally available, and the machine-generated
 HTML, PostScript or PDF produced by some word processors for output purposes
 only.
\end_layout

\begin_layout Standard

\size tiny
The 
\begin_inset Quotes eld
\end_inset

Title Page
\begin_inset Quotes erd
\end_inset

 means, for a printed book, the title page itself, plus such following pages
 as are needed to hold, legibly, the material this License requires to appear
 in the title page.
 For works in formats which do not have any title page as such, “Title Page”
 means the text near the most prominent appearance of the work's title,
 preceding the beginning of the body of the text.
\end_layout

\begin_layout Standard

\size tiny
A section 
\begin_inset Quotes eld
\end_inset

Entitled XYZ
\begin_inset Quotes erd
\end_inset

 means a named subunit of the Document whose title either is precisely XYZ
 or contains XYZ in parentheses following text that translates XYZ in another
 language.
 (Here XYZ stands for a specific section name mentioned below, such as “Acknowle
dgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the
 Title” of such a section when you modify the Document means that it remains
 a section “Entitled XYZ” according to this definition.
\end_layout

\begin_layout Standard

\size tiny
The Document may include Warranty Disclaimers next to the notice which states
 that this License applies to the Document.
 These Warranty Disclaimers are considered to be included by reference in
 this License, but only as regards disclaiming warranties: any other implication
 that these Warranty Disclaimers may have is void and has no effect on the
 meaning of this License.
\end_layout

\begin_layout Subsection
Verbatim copying
\begin_inset CommandInset label
LatexCommand label
name "subsec:2Verbatim-copying"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
You may copy and distribute the Document in any medium, either commercially
 or noncommercially, provided that this License, the copyright notices,
 and the license notice saying this License applies to the Document are
 reproduced in all copies, and that you add no other conditions whatsoever
 to those of this License.
 You may not use technical measures to obstruct or control the reading or
 further copying of the copies you make or distribute.
 However, you may accept compensation in exchange for copies.
 If you distribute a large enough number of copies you must also follow
 the conditions in section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
You may also lend copies, under the same conditions stated above, and you
 may publicly display copies.
\end_layout

\begin_layout Subsection
Copying in quantity
\begin_inset CommandInset label
LatexCommand label
name "subsec:3Copying-in-quantity"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
If you publish printed copies (or copies in media that commonly have printed
 covers) of the Document, numbering more than 100, and the Document's license
 notice requires Cover Texts, you must enclose the copies in covers that
 carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on
 the front cover, and Back-Cover Texts on the back cover.
 Both covers must also clearly and legibly identify you as the publisher
 of these copies.
 The front cover must present the full title with all words of the title
 equally prominent and visible.
 You may add other material on the covers in addition.
 Copying with changes limited to the covers, as long as they preserve the
 title of the Document and satisfy these conditions, can be treated as verbatim
 copying in other respects.
\end_layout

\begin_layout Standard

\size tiny
If the required texts for either cover are too voluminous to fit legibly,
 you should put the first ones listed (as many as fit reasonably) on the
 actual cover, and continue the rest onto adjacent pages.
\end_layout

\begin_layout Standard

\size tiny
If you publish or distribute Opaque copies of the Document numbering more
 than 100, you must either include a machine-readable Transparent copy along
 with each Opaque copy, or state in or with each Opaque copy a computer-network
 location from which the general network-using public has access to download
 using public-standard network protocols a complete Transparent copy of
 the Document, free of added material.
 If you use the latter option, you must take reasonably prudent steps, when
 you begin distribution of Opaque copies in quantity, to ensure that this
 Transparent copy will remain thus accessible at the stated location until
 at least one year after the last time you distribute an Opaque copy (directly
 or through your agents or retailers) of that edition to the public.
\end_layout

\begin_layout Standard

\size tiny
It is requested, but not required, that you contact the authors of the Document
 well before redistributing any large number of copies, to give them a chance
 to provide you with an updated version of the Document.
\end_layout

\begin_layout Subsection
Modifications
\begin_inset CommandInset label
LatexCommand label
name "subsec:4Modifications"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
You may copy and distribute a Modified Version of the Document under the
 conditions of sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:2Verbatim-copying"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

 above, provided that you release the Modified Version under precisely this
 License, with the Modified Version filling the role of the Document, thus
 licensing distribution and modification of the Modified Version to whoever
 possesses a copy of it.
 In addition, you must do these things in the Modified Version:
\end_layout

\begin_layout Standard

\size tiny
A.
 Use in the Title Page (and on the covers, if any) a title distinct from
 that of the Document, and from those of previous versions (which should,
 if there were any, be listed in the History section of the Document).
 You may use the same title as a previous version if the original publisher
 of that version gives permission.
\end_layout

\begin_layout Standard

\size tiny
B.
 List on the Title Page, as authors, one or more persons or entities responsible
 for authorship of the modifications in the Modified Version, together with
 at least five of the principal authors of the Document (all of its principal
 authors, if it has fewer than five), unless they release you from this
 requirement.
\end_layout

\begin_layout Standard

\size tiny
C.
 State on the Title page the name of the publisher of the Modified Version,
 as the publisher.
\end_layout

\begin_layout Standard

\size tiny
D.
 Preserve all the copyright notices of the Document.
\end_layout

\begin_layout Standard

\size tiny
E.
 Add an appropriate copyright notice for your modifications adjacent to
 the other copyright notices.
\end_layout

\begin_layout Standard

\size tiny
F.
 Include, immediately after the copyright notices, a license notice giving
 the public permission to use the Modified Version under the terms of this
 License, in the form shown in the Addendum below.
\end_layout

\begin_layout Standard

\size tiny
G.
 Preserve in that license notice the full lists of Invariant Sections and
 required Cover Texts given in the Document's license notice.
\end_layout

\begin_layout Standard

\size tiny
H.
 Include an unaltered copy of this License.
\end_layout

\begin_layout Standard

\size tiny
I.
 Preserve the section Entitled 
\begin_inset Quotes eld
\end_inset

History
\begin_inset Quotes erd
\end_inset

, Preserve its Title, and add to it an item stating at least the title,
 year, new authors, and publisher of the Modified Version as given on the
 Title Page.
 If there is no section Entitled “History” in the Document, create one stating
 the title, year, authors, and publisher of the Document as given on its
 Title Page, then add an item describing the Modified Version as stated
 in the previous sentence.
\end_layout

\begin_layout Standard

\size tiny
J.
 Preserve the network location, if any, given in the Document for public
 access to a Transparent copy of the Document, and likewise the network
 locations given in the Document for previous versions it was based on.
 These may be placed in the 
\begin_inset Quotes eld
\end_inset

History
\begin_inset Quotes erd
\end_inset

 section.
 You may omit a network location for a work that was published at least
 four years before the Document itself, or if the original publisher of
 the version it refers to gives permission.
\end_layout

\begin_layout Standard

\size tiny
K.
 For any section Entitled 
\begin_inset Quotes eld
\end_inset

Acknowledgements
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Dedications
\begin_inset Quotes erd
\end_inset

, Preserve the Title of the section, and preserve in the section all the
 substance and tone of each of the contributor acknowledgements and/or dedicatio
ns given therein.
\end_layout

\begin_layout Standard

\size tiny
L.
 Preserve all the Invariant Sections of the Document, unaltered in their
 text and in their titles.
 Section numbers or the equivalent are not considered part of the section
 titles.
\end_layout

\begin_layout Standard

\size tiny
M.
 Delete any section Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

.
 Such a section may not be included in the Modified Version.
\end_layout

\begin_layout Standard

\size tiny
N.
 Do not retitle any existing section to be Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

 or to conflict in title with any Invariant Section.
\end_layout

\begin_layout Standard

\size tiny
O.
 Preserve any Warranty Disclaimers.
\end_layout

\begin_layout Standard

\size tiny
If the Modified Version includes new front-matter sections or appendices
 that qualify as Secondary Sections and contain no material copied from
 the Document, you may at your option designate some or all of these sections
 as invariant.
 To do this, add their titles to the list of Invariant Sections in the Modified
 Version's license notice.
 These titles must be distinct from any other section titles.
\end_layout

\begin_layout Standard

\size tiny
You may add a section Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

, provided it contains nothing but endorsements of your Modified Version
 by various parties — for example, statements of peer review or that the
 text has been approved by an organization as the authoritative definition
 of a standard.
\end_layout

\begin_layout Standard

\size tiny
You may add a passage of up to five words as a Front-Cover Text, and a passage
 of up to 25 words as a Back-Cover Text, to the end of the list of Cover
 Texts in the Modified Version.
 Only one passage of Front-Cover Text and one of Back-Cover Text may be
 added by (or through arrangements made by) any one entity.
 If the Document already includes a cover text for the same cover, previously
 added by you or by arrangement made by the same entity you are acting on
 behalf of, you may not add another; but you may replace the old one, on
 explicit permission from the previous publisher that added the old one.
\end_layout

\begin_layout Standard

\size tiny
The author(s) and publisher(s) of the Document do not by this License give
 permission to use their names for publicity for or to assert or imply endorseme
nt of any Modified Version.
\end_layout

\begin_layout Subsection*

\size tiny
Combining documents
\end_layout

\begin_layout Standard

\size tiny
You may combine the Document with other documents released under this License,
 under the terms defined in section 4 above for modified versions, provided
 that you include in the combination all of the Invariant Sections of all
 of the original documents, unmodified, and list them all as Invariant Sections
 of your combined work in its license notice, and that you preserve all
 their Warranty Disclaimers.
\end_layout

\begin_layout Standard

\size tiny
The combined work need only contain one copy of this License, and multiple
 identical Invariant Sections may be replaced with a single copy.
 If there are multiple Invariant Sections with the same name but different
 contents, make the title of each such section unique by adding at the end
 of it, in parentheses, the name of the original author or publisher of
 that section if known, or else a unique number.
 Make the same adjustment to the section titles in the list of Invariant
 Sections in the license notice of the combined work.
\end_layout

\begin_layout Standard

\size tiny
In the combination, you must combine any sections Entitled “History” in
 the various original documents, forming one section Entitled “History”;
 likewise combine any sections Entitled “Acknowledgements”, and any sections
 Entitled “Dedications”.
 You must delete all sections Entitled “Endorsements.”
\end_layout

\begin_layout Subsection*

\size tiny
Collections of documents
\end_layout

\begin_layout Standard

\size tiny
You may make a collection consisting of the Document and other documents
 released under this License, and replace the individual copies of this
 License in the various documents with a single copy that is included in
 the collection, provided that you follow the rules of this License for
 verbatim copying of each of the documents in all other respects.
\end_layout

\begin_layout Standard

\size tiny
You may extract a single document from such a collection, and distribute
 it individually under this License, provided you insert a copy of this
 License into the extracted document, and follow this License in all other
 respects regarding verbatim copying of that document.
\end_layout

\begin_layout Subsection*

\size tiny
Aggregation with independent works
\end_layout

\begin_layout Standard

\size tiny
A compilation of the Document or its derivatives with other separate and
 independent documents or works, in or on a volume of a storage or distribution
 medium, is called an “aggregate” if the copyright resulting from the compilatio
n is not used to limit the legal rights of the compilation's users beyond
 what the individual works permit.
 When the Document is included an aggregate, this License does not apply
 to the other works in the aggregate which are not themselves derivative
 works of the Document.
\end_layout

\begin_layout Standard

\size tiny
If the Cover Text requirement of section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

 is applicable to these copies of the Document, then if the Document is
 less than one half of the entire aggregate, the Document's Cover Texts
 may be placed on covers that bracket the Document within the aggregate,
 or the electronic equivalent of covers if the Document is in electronic
 form.
 Otherwise they must appear on printed covers that bracket the whole aggregate.
\end_layout

\begin_layout Subsection*

\size tiny
Translation
\end_layout

\begin_layout Standard

\size tiny
Translation is considered a kind of modification, so you may distribute
 translations of the Document under the terms of section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:4Modifications"

\end_inset

.
 Replacing Invariant Sections with translations requires special permission
 from their copyright holders, but you may include translations of some
 or all Invariant Sections in addition to the original versions of these
 Invariant Sections.
 You may include a translation of this License, and all the license notices
 in the Document, and any Warranty Disclaimers, provided that you also include
 the original English version of this License and the original versions
 of those notices and disclaimers.
 In case of a disagreement between the translation and the original version
 of this License or a notice or disclaimer, the original version will prevail.
\end_layout

\begin_layout Standard

\size tiny
If a section in the Document is Entitled “Acknowledgements”, “Dedications”,
 or “History”, the requirement (section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:4Modifications"

\end_inset

) to Preserve its Title (section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:1Applicability-and-definitions"

\end_inset

) will typically require changing the actual title.
\end_layout

\begin_layout Subsection*

\size tiny
Termination
\end_layout

\begin_layout Standard

\size tiny
You may not copy, modify, sublicense, or distribute the Document except
 as expressly provided for under this License.
 Any other attempt to copy, modify, sublicense or distribute the Document
 is void, and will automatically terminate your rights under this License.
 However, parties who have received copies, or rights, from you under this
 License will not have their licenses terminated so long as such parties
 remain in full compliance.
\end_layout

\begin_layout Subsection*

\size tiny
Future revisions of this license
\end_layout

\begin_layout Standard

\size tiny
The Free Software Foundation may publish new, revised versions of the GNU
 Free Documentation License from time to time.
 Such new versions will be similar in spirit to the present version, but
 may differ in detail to address new problems or concerns.
 See 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
url{http://www.gnu.org/copyleft/}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
Each version of the License is given a distinguishing version number.
 If the Document specifies that a particular numbered version of this License
 “or any later version” applies to it, you have the option of following
 the terms and conditions either of that specified version or of any later
 version that has been published (not as a draft) by the Free Software Foundatio
n.
 If the Document does not specify a version number of this License, you
 may choose any version ever published (not as a draft) by the Free Software
 Foundation.
\end_layout

\begin_layout Subsection*

\size tiny
\noun on
Addendum
\noun default
: How to use this License for your documents
\end_layout

\begin_layout Standard

\size tiny
To use this License in a document you have written, include a copy of the
 License in the document and put the following copyright and license notices
 just after the title page:
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) <year> <your name>.
 Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.2 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is included in the section entitled “GNU Free Documentati
on License”.
\end_layout

\begin_layout Standard

\size tiny
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
 replace the “with...Texts.” line with this:
\end_layout

\begin_layout Standard

\size tiny
with the Invariant Sections being <list their titles>, with the Front-Cover
 Texts being <list>, and with the Back-Cover Texts being <list>.
\end_layout

\begin_layout Standard

\size tiny
If you have Invariant Sections without Cover Texts, or some other combination
 of the three, merge those two alternatives to suit the situation.
\end_layout

\begin_layout Standard

\size tiny
If your document contains nontrivial examples of program code, we recommend
 releasing these examples in parallel under your choice of free software
 license, such as the GNU General Public License, to permit their use in
 free software.
\end_layout

\begin_layout Subsection*

\size tiny
Copyright 
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) 2000, 2001, 2002 Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
\end_layout

\begin_layout Standard

\size tiny
Everyone is permitted to copy and distribute verbatim copies of this license
 document, but changing it is not allowed.
\end_layout

\end_body
\end_document
