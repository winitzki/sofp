#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks. Should be very close to black but not quite.
\definecolor{hlink}{rgb}{0.0, 0.01, 0.05}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=darkgray"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\start_of_appendix
Notations
\begin_inset CommandInset label
LatexCommand label
name "chap:Appendix-Notations"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\pplus}{{\displaystyle }{+\negmedspace+}}
{{\color{lime}++}}
\end_inset

Certain notations and terms were chosen in this book differently from what
 the functional programming community currently uses.
 The proposed notation is well adapted to reasoning about types and code,
 and especially for designing data types and proving the laws of various
 typeclasses.
\end_layout

\begin_layout Section
Summary of notations for types and code
\end_layout

\begin_layout Description
\begin_inset Formula $F^{A}$
\end_inset

 type constructor 
\begin_inset Formula $F$
\end_inset

 with type argument 
\begin_inset Formula $A$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}$
\end_inset

 value 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\bbnum 1,\,1$
\end_inset

 the unit type and its value; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\bbnum 0$
\end_inset

 the void type.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A+B$
\end_inset

 a disjunctive type.
 In Scala, this type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 a value of a disjunctive type 
\begin_inset Formula $A+B$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A\times B$
\end_inset

 a product (tuple) type.
 In Scala, this type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $a^{:A}\times b^{:B}$
\end_inset

 value of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $A\rightarrow B$
\end_inset

 the function type, mapping from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $x^{:A}\rightarrow f$
\end_inset

 a nameless function (as a value).
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x:A => f }
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\text{id}$
\end_inset

 the identity function; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\triangleq$
\end_inset

 
\begin_inset Quotes eld
\end_inset

is defined to be
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

is equal by definition
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\overset{!}{=}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

must be equal according to what we know
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\overset{?}{=}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

we ask — is it equal? — because we still need to prove that
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\square$
\end_inset

 
\begin_inset Quotes eld
\end_inset

this proof or this derivation is finished
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\cong$
\end_inset

 for types, a natural isomorphism between types; for values, 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

 values according to an already established isomorphism
\end_layout

\begin_layout Description
\begin_inset Formula $A^{:F^{B}}$
\end_inset

 special type annotation, used for defining unfunctors (GADTs)
\end_layout

\begin_layout Description
\begin_inset Formula $\wedge$
\end_inset

 logical conjunction; 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

both 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\vee$
\end_inset

 logical disjunction; 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

either 
\begin_inset Formula $\alpha$
\end_inset

 or 
\begin_inset Formula $\beta$
\end_inset

 or both are true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\Rightarrow$
\end_inset

 logical implication; 
\begin_inset Formula $\alpha\Rightarrow\beta$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\alpha$
\end_inset

 is true then 
\begin_inset Formula $\beta$
\end_inset

 is true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 of a functor 
\begin_inset Formula $F$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor[F].fmap
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\text{flm}_{F},\text{ftn}_{F},\text{pu}_{F}$
\end_inset

 the standard methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 of a monad 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $F^{\bullet}$
\end_inset

 the type constructor 
\begin_inset Formula $F$
\end_inset

 understood as a type-level function.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $F^{\bullet}\leadsto G^{\bullet}$
\end_inset

 or 
\begin_inset Formula $F\leadsto G$
\end_inset

 a natural transformation between functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F ~> G
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\forall A.P^{A}$
\end_inset

 a universally quantified type expression.
 In Scala 3, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[A] => P[A]
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\exists A.P^{A}$
\end_inset

 an existentially quantified type expression.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ type A; val x: P[A] }
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $\bef$
\end_inset

 the forward composition of functions: 
\begin_inset Formula $f\bef g$
\end_inset

 is 
\begin_inset Formula $x\rightarrow g(f(x))$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\circ$
\end_inset

 the backward composition of functions: 
\begin_inset Formula $f\circ g$
\end_inset

 is 
\begin_inset Formula $x\rightarrow f(g(x))$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f compose g
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\circ$
\end_inset

 the backward composition of type constructors: 
\begin_inset Formula $F\circ G$
\end_inset

 is 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[G[A]]
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $\triangleright$
\end_inset

 use a value as the argument of a function: 
\begin_inset Formula $x\triangleright f$
\end_inset

 is 
\begin_inset Formula $f(x)$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 a function 
\begin_inset Formula $f$
\end_inset

 raised to a functor 
\begin_inset Formula $G$
\end_inset

; same as 
\begin_inset Formula $\text{fmap}_{G}f$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $f^{\uparrow G\uparrow H}$
\end_inset

 a function raised first to 
\begin_inset Formula $G$
\end_inset

 and then to 
\begin_inset Formula $H$
\end_inset

.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.map(_.map(f))
\end_layout

\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 a function 
\begin_inset Formula $f$
\end_inset

 raised to a contrafunctor 
\end_layout

\begin_layout Description
\begin_inset Formula $\diamond_{M}$
\end_inset

 the Kleisli product operation for the monad 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $L\varangle M$
\end_inset

 or equivalently 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 — the monad 
\begin_inset Formula $L$
\end_inset

's transformer applied to a monad 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\oplus$
\end_inset

 the binary operation of a monoid.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x |+| y
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\Delta$
\end_inset

 the 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function of type 
\begin_inset Formula $\forall A.\,A\rightarrow A\times A$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\pi_{1},\pi_{2},...$
\end_inset

 the projections from a tuple to its first, second, ..., parts
\end_layout

\begin_layout Description
\begin_inset Formula $\boxtimes$
\end_inset

 pair product of functions, 
\begin_inset Formula $(f\boxtimes g)(a\times b)\triangleq f(a)\times g(b)$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\left[a,b,c\right]$
\end_inset

 an ordered sequence of values.
 In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(a, b, c)
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\begin{array}{||cc|}
x\rightarrow x & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}$
\end_inset

 
\begin_inset space ~
\end_inset

a function that works with disjunctive types (a 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive functions
\end_layout

\end_inset

disjunctive function
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Section
Detailed explanations
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{A}$
\end_inset

 means a type constructor 
\begin_inset Formula $F$
\end_inset

 with a type parameter 
\begin_inset Formula $A$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

.
 Type constructors with multiple type parameters are denoted by 
\begin_inset Formula $F^{A,B,C}$
\end_inset

.
 Nested type parameters such as Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[G[A]]
\end_layout

\end_inset

 are denoted by 
\begin_inset Formula $F^{G^{A}}$
\end_inset

, meaning 
\begin_inset Formula $F^{(G^{A})}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}$
\end_inset

 means a value 
\begin_inset Formula $x$
\end_inset

 that has type 
\begin_inset Formula $A$
\end_inset

; this is a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
type annotation
\end_layout

\end_inset

type annotation
\series default
.
 In Scala, a type annotation is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 The colon symbol, 
\begin_inset Formula $:$
\end_inset

, in the superscript shows that 
\begin_inset Formula $A$
\end_inset

 is not a type argument (as it would be in a type constructor, 
\begin_inset Formula $F^{A}$
\end_inset

).
 The notation 
\begin_inset Formula $x:A$
\end_inset

 can be used as well, but 
\begin_inset Formula $x^{:A}$
\end_inset

 is easier to read when 
\begin_inset Formula $x$
\end_inset

 is inside a larger code expression.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\bbnum 1$
\end_inset

 means the unit type
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type
\end_layout

\end_inset

, and 
\begin_inset Formula $1$
\end_inset

 means the value of the unit type.
 In Scala, the unit type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, and its value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 Example of using the unit type is 
\begin_inset Formula $\bbnum 1+A$
\end_inset

, which corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 in Scala.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bbnum 0$
\end_inset

 means the void
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 type (the type with no values).
 In Scala, this is the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 Example of using the void type is to denote the empty part of a disjunction.
 For example, in the disjunction 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 the non-empty part is 
\begin_inset Formula $\bbnum 0+A$
\end_inset

, which in Scala corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

.
 The empty part 
\begin_inset Formula $\bbnum 1+\bbnum 0$
\end_inset

 corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 Similarly, 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 denotes the left part of the type 
\begin_inset Formula $A+B$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A]
\end_layout

\end_inset

), while 
\begin_inset Formula $\bbnum 0+B$
\end_inset

 denotes its right part (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right[A]
\end_layout

\end_inset

).
 Values of disjunctive types are denoted similarly.
 For instance, 
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 denotes a value of the left part of the type 
\begin_inset Formula $A+B$
\end_inset

; in Scala, this value is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A,B](x)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $A+B$
\end_inset

 means the disjunctive type made from types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 (or, a disjunction of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

).
 In Scala, this is the type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 denotes a value of a disjunctive type 
\begin_inset Formula $A+B$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 is the value of type 
\begin_inset Formula $A$
\end_inset

, which is the chosen case, and 
\begin_inset Formula $\bbnum 0$
\end_inset

 stands for other possible cases.
 For example, 
\begin_inset Formula $x^{:A}+\bbnum 0^{B}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A,B](x)
\end_layout

\end_inset

 in Scala.
 Type annotations 
\begin_inset Formula $^{:A}$
\end_inset

 and 
\begin_inset Formula $^{:B}$
\end_inset

 may be omitted if the types are unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $A\times B$
\end_inset

 means the product type made from types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 In Scala, this is the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $a^{:A}\times b^{:B}$
\end_inset

 means a value of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

; in Scala, this is the tuple value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

.
 Type annotations 
\begin_inset Formula $^{:A}$
\end_inset

 and 
\begin_inset Formula $^{:B}$
\end_inset

 may be omitted if the types are unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $A\rightarrow B$
\end_inset

 means a function type from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

.
 In Scala, this is the function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $x^{:A}\rightarrow y$
\end_inset

 means a nameless function with argument 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

 and function body 
\begin_inset Formula $y$
\end_inset

.
 (Usually, the body 
\begin_inset Formula $y$
\end_inset

 will be an expression that uses 
\begin_inset Formula $x$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x: A => y }
\end_layout

\end_inset

.
 Type annotation 
\begin_inset Formula $^{:A}$
\end_inset

 may be omitted if the type is unambiguous from the context.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{id}$
\end_inset

 means the identity function.
 The type of its argument should be either specified as 
\begin_inset Formula $\text{id}^{A}$
\end_inset

 or 
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

, or else should be unambiguous from the context.
 In Scala,  
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset

 corresponds to 
\begin_inset Formula $\text{id}^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\triangleq$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

equal by definition
\begin_inset Quotes erd
\end_inset

.
 A definition of a function 
\begin_inset Formula $f$
\end_inset

 is written as 
\begin_inset Formula $f\triangleq(x^{:\text{Int}}\rightarrow x+10)$
\end_inset

; in Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val f = { x: Int => x + 10 }
\end_layout

\end_inset

.
 A definition of a type constructor 
\begin_inset Formula $F$
\end_inset

 is written as 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

; in Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Option[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\cong$
\end_inset

 for types means an equivalence (an isomorphism) of types.
 For example, 
\begin_inset Formula $A+A\times B\cong A\times\left(\bbnum 1+B\right)$
\end_inset

.
 The same symbol 
\begin_inset Formula $\cong$
\end_inset

 for 
\emph on
values
\emph default
 means 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

 according to an equivalence relation that needs to be established in the
 text.
 For example, if we have established an equivalence that allows nested tuples
 to be reordered whenever needed, we can write 
\begin_inset Formula $\left(a\times b\right)\times c\cong a\times\left(b\times c\right)$
\end_inset

, meaning that these values are mapped to each other by the established
 isomorphism functions.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $A^{:F^{B}}$
\end_inset

 in type expressions means that the type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 assigns the type 
\begin_inset Formula $F^{B}$
\end_inset

 to the type expression 
\begin_inset Formula $A$
\end_inset

.
 This notation is used for defining unfunctors (GADTs).
 For example, the Scala code
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

case class F1() extends F[Int]
\end_layout

\begin_layout Plain Layout

case class F2[A](a: A) extends F[(A, String)]
\end_layout

\end_inset

defines an unfunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
unfunctor
\end_layout

\end_inset

, which is denoted by 
\begin_inset Formula $F^{A}\triangleq\bbnum 1^{:F^{\text{Int}}}+A^{:F^{A\times\text{String}}}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\wedge$
\end_inset

 (conjunction), 
\begin_inset Formula $\vee$
\end_inset

 (disjunction), and 
\begin_inset Formula $\Rightarrow$
\end_inset

 (implication) are used in formulas of Boolean as well as constructive logic
 in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:5-Curry-Howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

, e.g., 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

, where Greek letters stand for logical propositions.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 means the standard method 
\begin_inset Formula $\text{fmap}$
\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass, implemented for the functor 
\begin_inset Formula $F$
\end_inset

.
 In Scala, this may be written as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor[F].fmap
\end_layout

\end_inset


\family default
.
 Since each functor 
\begin_inset Formula $F$
\end_inset

 has its own specific implementation of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

, the subscript 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 is not a type parameter of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

.
 The method 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 actually has 
\emph on
two
\emph default
 type parameters, which can be written out as 
\begin_inset Formula $\text{fmap}_{F}^{A,B}$
\end_inset

.
 Then the type signature of 
\begin_inset Formula $\text{fmap}$
\end_inset

 is written in full as 
\begin_inset Formula $\text{fmap}_{F}^{A,B}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}$
\end_inset

.
 For clarity, we may sometimes write out the type parameters 
\begin_inset Formula $A,B$
\end_inset

 in the expression 
\begin_inset Formula $\text{fmap}_{F}^{A,B}$
\end_inset

, but in most cases these type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 can be omitted without loss of clarity.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 denotes a monad 
\begin_inset Formula $F$
\end_inset

's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

.
 This function has type signature 
\begin_inset Formula $A\rightarrow F^{A}$
\end_inset

 that contains a type parameter 
\begin_inset Formula $A$
\end_inset

.
 In the code notation, the type parameter may be either omitted or denoted
 as 
\begin_inset Formula $\text{pu}_{F}^{A}$
\end_inset

.
 If we are using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method with a complicated type, e.g., 
\begin_inset Formula $\bbnum 1+P^{A}$
\end_inset

, instead of the type parameter 
\begin_inset Formula $A$
\end_inset

, we might want to write this type parameter for clarity and write 
\begin_inset Formula $\text{pu}_{F}^{\bbnum 1+P^{A}}$
\end_inset

.
 The type signature of that function is then 
\begin_inset Formula 
\[
\text{pu}_{F}^{1+P^{A}}:\bbnum 1+P^{A}\rightarrow F^{\bbnum 1+P^{A}}\quad.
\]

\end_inset

But in most cases we will not need to write out the type parameters.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{flm}_{F}$
\end_inset

 denotes the curried version of a monad 
\begin_inset Formula $F$
\end_inset

's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 The type signature of 
\begin_inset Formula $\text{flm}_{F}$
\end_inset

 is 
\begin_inset Formula $\text{flm}_{F}:(A\rightarrow F^{B})\rightarrow F^{A}\rightarrow F^{B}$
\end_inset

.
 Note that Scala's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 type signature is not curried.
 The curried method 
\begin_inset Formula $\text{flm}_{F}$
\end_inset

 is easier to use in calculations involving the monad laws.
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{ftn}_{F}$
\end_inset

 denotes a monad 
\begin_inset Formula $F$
\end_inset

's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 with the type signature 
\begin_inset Formula $\text{ftn}_{F}:F^{F^{A}}\rightarrow F^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{\bullet}$
\end_inset

 means the type constructor 
\begin_inset Formula $F$
\end_inset

 understood as a type-level function, — that is, with a type parameter unspecifi
ed.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

.
 The bullet symbol, 
\begin_inset Formula $\bullet$
\end_inset

, is used as a placeholder for the missing type parameter.
 When no type parameter is needed, 
\begin_inset Formula $F$
\end_inset

 means the same as 
\begin_inset Formula $F^{\bullet}$
\end_inset

.
 (For example, 
\begin_inset Quotes eld
\end_inset

a functor 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

a functor 
\begin_inset Formula $F^{\bullet}$
\end_inset


\begin_inset Quotes erd
\end_inset

 mean the same thing.) However, it is useful for clarity to be able to indicate
 the place where the type parameter would appear.
 For instance, functor composition is denoted as 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

; in Scala 2, this is 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Lambda[X => F[G[X]]]
\end_layout

\end_inset


\family default
 when using the 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
kind@
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 plugin
\end_layout

\end_inset

 plugin.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/typelevel/kind-projector"
target "https://github.com/typelevel/kind-projector"
literal "false"

\end_inset


\end_layout

\end_inset

 When the type parameter 
\begin_inset Formula $B$
\end_inset

 of a bifunctor 
\begin_inset Formula $P^{A,B}$
\end_inset

 is fixed to 
\begin_inset Formula $Z$
\end_inset

, we get a functor (with respect to 
\begin_inset Formula $A$
\end_inset

) denoted by 
\begin_inset Formula $P^{\bullet,Z}$
\end_inset

.
 Another example: 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 denotes a monad transformer for the base monad 
\begin_inset Formula $L$
\end_inset

 and the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 The foreign monad 
\begin_inset Formula $M$
\end_inset

 is a type parameter in 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

.
 The symbol 
\begin_inset Formula $\bullet$
\end_inset

 stands for the transformer's second type parameter.
 (The base monad 
\begin_inset Formula $L$
\end_inset

 is not a type parameter in 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 because the construction of the monad transformer depends on the internal
 details of 
\begin_inset Formula $L$
\end_inset

.)
\end_layout

\begin_layout Standard
\begin_inset Formula $F^{\bullet}\leadsto G^{\bullet}$
\end_inset

 or 
\begin_inset Formula $F\leadsto G$
\end_inset

 means a natural transformation between two functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

.
 In some Scala libraries, this is denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F ~> G
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\forall A.P^{A}$
\end_inset

 is a universally quantified type expression, in which 
\begin_inset Formula $A$
\end_inset

 is a bound type parameter.
\end_layout

\begin_layout Standard
\begin_inset Formula $\exists A.P^{A}$
\end_inset

 is an existentially quantified type expression, in which 
\begin_inset Formula $A$
\end_inset

 is a bound type parameter.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bef$
\end_inset

 means the forward composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
forward composition
\end_layout

\end_inset

 of functions: 
\begin_inset Formula $f\bef g$
\end_inset

 (reads 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset

 before 
\begin_inset Formula $g$
\end_inset


\begin_inset Quotes erd
\end_inset

) is the function defined as 
\begin_inset Formula $x\rightarrow g(f(x))$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\circ$
\end_inset

 means the backward composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
backward composition
\end_layout

\end_inset

 of functions: 
\begin_inset Formula $f\circ g$
\end_inset

 (reads 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset

 after 
\begin_inset Formula $g$
\end_inset


\begin_inset Quotes erd
\end_inset

) is the function defined as 
\begin_inset Formula $x\rightarrow f(g(x))$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\circ$
\end_inset

 with type constructors means their (backward) composition, for example
 
\begin_inset Formula $F\circ G$
\end_inset

 denotes the type constructor 
\begin_inset Formula $F^{G^{\bullet}}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[G[A]]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $x\triangleright f$
\end_inset

 (the 
\series bold
pipe notation
\series default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
$@
\begin_inset Formula $\triangleright$
\end_inset

-notation!see 
\begin_inset Quotes eld
\end_inset

pipe notation
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 is a different syntax for 
\begin_inset Formula $f(x)$
\end_inset

.
 The value 
\begin_inset Formula $x$
\end_inset

 is passed as the argument to the function 
\begin_inset Formula $f$
\end_inset

.
 In Scala, the expression 
\begin_inset Formula $x\triangleright f$
\end_inset

 is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 or, if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is a method, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.f
\end_layout

\end_inset

.
 This syntax is used with many standard methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toSeq
\end_layout

\end_inset

.
 Because the argument 
\begin_inset Formula $x$
\end_inset

 is to the left of the function 
\begin_inset Formula $f$
\end_inset

 in this notation, forward compositions of functions such as 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

 are naturally grouped to the left as it is done in Scala code, for example
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.toSeq.sorted
\end_layout

\end_inset

.
 The operation 
\begin_inset Formula $\triangleright$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

pipe
\begin_inset Quotes erd
\end_inset

) groups weaker than the forward composition (
\begin_inset Formula $\bef$
\end_inset

), and so we have 
\begin_inset Formula $x\triangleright f\bef g=x\triangleright f\triangleright g$
\end_inset

 in this notation.
 Reasoning about code in the pipe notation uses the identities
\begin_inset Formula 
\begin{align*}
x\triangleright f=f(x)\quad,\quad\quad & \left(x\triangleright f\right)\triangleright g=x\triangleright f\triangleright g\quad,\\
x\triangleright f\bef g=x\triangleright\left(f\bef g\right)\quad,\quad\quad & x\triangleright f\triangleright g=x\triangleright f\bef g\quad.
\end{align*}

\end_inset

The pipe symbol groups stronger than the function arrow, so 
\begin_inset Formula $x\rightarrow y\triangleright f=x\rightarrow(y\triangleright f)$
\end_inset

.
 Here are some examples of reasoning with functions in the pipe notation:
\begin_inset Formula 
\begin{align*}
 & \left(a\rightarrow a\triangleright f\right)=\left(a\rightarrow f(a)\right)=f\quad,\\
 & f\triangleright\left(y\rightarrow a\triangleright y\right)=a\triangleright f=f(a)\quad,\\
 & f(y(x))=x\triangleright y\triangleright f\neq x\triangleright\left(y\triangleright f\right)=f(y)(x)\quad.
\end{align*}

\end_inset

The correspondence between the forward composition and the backward composition:
\begin_inset Formula 
\begin{align*}
 & f\bef g=g\circ f\quad,\\
 & x\triangleright(f\bef g)=x\triangleright f\bef g=x\triangleright f\triangleright g=g(f(x))=(g\circ f)(x)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 means a function 
\begin_inset Formula $f$
\end_inset

 lifted to a functor 
\begin_inset Formula $G$
\end_inset

.
 For a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, the application of 
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 to a value 
\begin_inset Formula $g^{:G^{A}}$
\end_inset

 is written as 
\begin_inset Formula $f^{\uparrow G}(g)$
\end_inset

 or as 
\begin_inset Formula $g\triangleright f^{\uparrow G}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g.map(f)
\end_layout

\end_inset

.
 Nested lifting (i.e., lifting to the functor composition 
\begin_inset Formula $H\circ G$
\end_inset

) can be written as 
\begin_inset Formula $f^{\uparrow G\uparrow H}$
\end_inset

, which means 
\begin_inset Formula $\left(f^{\uparrow G}\right)^{\uparrow H}$
\end_inset

, and produces a function of type 
\begin_inset Formula $H^{G^{A}}\rightarrow H^{G^{B}}$
\end_inset

.
 Applying a nested lifting to a value 
\begin_inset Formula $h$
\end_inset

 of type 
\begin_inset Formula $H^{G^{A}}$
\end_inset

 is written as 
\begin_inset Formula $h\triangleright f^{\uparrow G\uparrow H}$
\end_inset

.
 In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.map(_.map(f))
\end_layout

\end_inset

.
 The functor composition law is written as
\begin_inset Formula 
\[
p^{\uparrow G}\bef q^{\uparrow G}=\left(p\bef q\right)^{\uparrow G}\quad.
\]

\end_inset

The notation 
\begin_inset Formula $x\triangleright p^{\uparrow G}\triangleright q^{\uparrow G}$
\end_inset

 is intended to be similar to the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(p).map(q)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 means a function 
\begin_inset Formula $f$
\end_inset

 lifted to a contrafunctor 
\begin_inset Formula $H$
\end_inset

.
 For a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, the application of 
\begin_inset Formula $f^{\downarrow H}$
\end_inset

 to a value 
\begin_inset Formula $h:H^{B}$
\end_inset

 is written as 
\begin_inset Formula $h\triangleright f^{\downarrow H}$
\end_inset

 and yields a value of type 
\begin_inset Formula $H^{A}$
\end_inset

.
 In Scala, this may be written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h.contramap(f)
\end_layout

\end_inset

.
 Nested lifting is denoted as, e.g., 
\begin_inset Formula $f^{\downarrow H\uparrow G}\triangleq(f^{\downarrow H})^{\uparrow G}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\diamond_{M}$
\end_inset

 means the Kleisli product operation for a given monad 
\begin_inset Formula $M$
\end_inset

.
 This is a binary operation working on two Kleisli functions of types 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $B\rightarrow M^{C}$
\end_inset

 and yields a new function of type 
\begin_inset Formula $A\rightarrow M^{C}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $L\varangle M$
\end_inset

 denotes the monad 
\begin_inset Formula $L$
\end_inset

's transformer applied to a foreign monad 
\begin_inset Formula $M$
\end_inset

.
 We define 
\begin_inset Formula $(K\varangle L)\varangle M\triangleq K\varangle(L\varangle M)$
\end_inset

, which makes the monad transformer application into an associative operation.
\end_layout

\begin_layout Standard
\begin_inset Formula $\oplus$
\end_inset

 means the binary operation of a monoid, e.g., 
\begin_inset Formula $x\oplus y$
\end_inset

.
 For this expression to make sense, a specific monoid type should be defined
 .
 In Scala libraries, 
\begin_inset Formula $x\oplus y$
\end_inset

 is often denoted as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x |+| y
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\Delta$
\end_inset

 means the standard 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function of type 
\begin_inset Formula $\forall A.\,A\rightarrow A\times A$
\end_inset

, i.e., 
\begin_inset Formula $\Delta\triangleq a^{:A}\rightarrow a\times a$
\end_inset

.
 In Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta[A](a: A): (A, A) = (a, a)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\pi_{1},\pi_{2},...$
\end_inset

 denote the functions extracting the first, second, ..., parts in a tuple.
 In Scala, 
\begin_inset Formula $\pi_{1}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_._1)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\boxtimes$
\end_inset

 means the pair product
\begin_inset Index idx
status open

\begin_layout Plain Layout
pair product of functions
\end_layout

\end_inset

 of functions, defined by 
\begin_inset Formula $(f\boxtimes g)(a\times b)=f(a)\times g(b)$
\end_inset

.
 In Scala, the pair product can be implemented as a higher-order function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pair_product[A,B,P,Q](f: A => P, g: B => Q): ((A, B)) => (P, Q) = {
\end_layout

\begin_layout Plain Layout

  case (a, b) => (f(a), g(b))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The operations 
\begin_inset Formula $\Delta$
\end_inset

, 
\begin_inset Formula $\pi_{i}$
\end_inset

 (where 
\begin_inset Formula $i=1,2,...$
\end_inset

), and 
\begin_inset Formula $\boxtimes$
\end_inset

 allow us to express any function operating on tuples.
 Useful properties for reasoning about code of such functions: 
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \Delta\bef\pi_{i}=\text{id}\quad,\\
\text{naturality law}:\quad & f\bef\Delta=\Delta\bef(f\boxtimes f)\quad,\\
\text{left and right projection laws}:\quad & (f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f\quad,\quad\quad(f\boxtimes g)\bef\pi_{2}=\pi_{2}\bef g\quad,\\
\text{composition law}:\quad & (f\boxtimes g)\bef(p\boxtimes q)=(f\bef p)\boxtimes(g\bef q)\quad,
\end{align*}

\end_inset

as well as the functor lifting laws for 
\begin_inset Formula $\Delta$
\end_inset

 and 
\begin_inset Formula $\pi_{i}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow F}\bef\Delta=\Delta\bef f^{\uparrow(F\times F)}=\Delta\bef(f^{\uparrow F}\boxtimes f^{\uparrow F})\quad,\\
 & (f^{\uparrow F}\boxtimes f^{\uparrow G})\bef\pi_{1}=f^{\uparrow(F\times G)}\bef\pi_{1}=\pi_{1}\bef f^{\uparrow F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left[a,b,c\right]$
\end_inset

 means an ordered sequence of values, such as a list or an array.
 In Scala, this can be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(a, b, c)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vector(a, b, c)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array(a, b, c)
\end_layout

\end_inset

, or another collection type.
\end_layout

\begin_layout Standard
\begin_inset Formula $f^{:Z+A\rightarrow Z+A\times A}\triangleq\,\begin{array}{||cc|}
z\rightarrow z & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}\,\,$
\end_inset

 is the 
\series bold
matrix notation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
matrix notation
\end_layout

\end_inset

 for a function whose input and/or output type is a disjunctive type (
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive functions
\end_layout

\end_inset

a 
\series bold
disjunctive function
\series default
).
 In Scala, the function 
\begin_inset Formula $f$
\end_inset

 is implemented as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[Z, A]: Either[Z, A] => Either[Z, (A, A)] = {
\end_layout

\begin_layout Plain Layout

  case Left(z)   => Left(z) // Identity function on Z.
\end_layout

\begin_layout Plain Layout

  case Right(a)  => Right((a, a)) // Delta on A.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The rows of the matrix indicate the different 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

s in the function's code, corresponding to the different parts of the input
 disjunctive type.
 If the input type is not disjunctive, there will be only one row.
 The columns of the matrix indicate the parts of the output disjunctive
 type.
 If the output type is not disjunctive, there will be only one column.
\end_layout

\begin_layout Standard
A matrix may show all parts of the disjunctive types in separate 
\begin_inset Quotes eld
\end_inset

type row
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

type column
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{equation}
f^{:Z+A\rightarrow Z+A\times A}\triangleq\,\begin{array}{|c||cc|}
 & Z & A\times A\\
\hline Z & \text{id} & \bbnum 0\\
A & \bbnum 0 & a\rightarrow a\times a
\end{array}\quad.
\end{equation}

\end_inset

This notation clearly indicates the input and the output types of the function
 and is useful for reasoning about the code.
 The vertical double line separates the 
\emph on
input
\emph default
 types from the function code (output types have a single line).
 In the code above, the 
\begin_inset Quotes eld
\end_inset

type column
\begin_inset Quotes erd
\end_inset

 shows the parts of the input disjunctive type 
\begin_inset Formula $Z+A$
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

type row
\begin_inset Quotes erd
\end_inset

 shows the parts of the output disjunctive type 
\begin_inset Formula $Z+A\times A$
\end_inset

.
\end_layout

\begin_layout Standard
The matrix notation is adapted to 
\emph on
forward
\emph default
 function composition (
\begin_inset Formula $f\bef g$
\end_inset

).
 Assume that 
\begin_inset Formula $A$
\end_inset

 is a monoid type, and consider the composition of the function 
\begin_inset Formula $f$
\end_inset

 shown above and the function 
\begin_inset Formula $g$
\end_inset

 defined as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g[Z, A: Monoid]: Either[Z, (A, A)] => A = {
\end_layout

\begin_layout Plain Layout

  case Left(_)          => Monoid[A].empty
\end_layout

\begin_layout Plain Layout

  case Right((a1, a2))  => a1 |+| a2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the matrix notation, the function 
\begin_inset Formula $g$
\end_inset

 is written (with and without types) as
\begin_inset Formula 
\[
g\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline Z & \_\rightarrow e^{:A}\\
A\times A & a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\quad,\quad\quad g\triangleq\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\quad.
\]

\end_inset

The forward composition 
\begin_inset Formula $f\bef g$
\end_inset

 is computed by forward-composing the matrix elements using the rules of
 the ordinary matrix multiplication, omitting any terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f\bef g & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}\,\bef\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\\
 & =\,\,\begin{array}{||c|}
\text{id}\bef(\_\rightarrow e^{:A})\\
\left(a\rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}\right)
\end{array}\,=\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a\rightarrow a\oplus a
\end{array}\quad.
\end{align*}

\end_inset

Applying a function to a disjunctive value such as 
\begin_inset Formula $x^{:Z+A}$
\end_inset

 is computed by writing 
\begin_inset Formula $x$
\end_inset

 as a row vector:
\begin_inset Formula 
\[
x=z^{:Z}+\bbnum 0^{:A}=\,\begin{array}{|cc|}
z^{:Z} & \bbnum 0\end{array}\quad,
\]

\end_inset

and the computation 
\begin_inset Formula $x\triangleright f\bef g$
\end_inset

 again follows the rules of matrix multiplication:
\begin_inset Formula 
\[
x\triangleright f\bef g=\,\begin{array}{|cc|}
z^{:Z} & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a\rightarrow a\oplus a
\end{array}\,=z\triangleright(\_\rightarrow e)=e\quad.
\]

\end_inset

Since the standard rules of matrix multiplication are associative, the propertie
s of the 
\begin_inset Formula $\triangleright$
\end_inset

-notation such as 
\begin_inset Formula $x\triangleright(f\bef g)=(x\triangleright f)\triangleright g$
\end_inset

 are guaranteed to hold.
\end_layout

\begin_layout Standard
To use the matrix notation with 
\emph on
backward
\emph default
 compositions (
\begin_inset Formula $f\circ g$
\end_inset

), all function matrices need to be transposed.
 (A standard identity of matrix calculus is that the transposition reverses
 the order of composition, 
\begin_inset Formula $\left(AB\right)^{T}=B^{T}A^{T}$
\end_inset

.) The input types will then appear in the top row and the output types in
 the left column; the double line is above the matrix since that is where
 the function inputs come from.
 The above calculations are then rewritten as
\begin_inset Formula 
\begin{align*}
g\circ f & =\,\begin{array}{|c|cc|}
 & Z & A\times A\\
\hline\hline A & \_\rightarrow e^{:A} & a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\,\circ\,\begin{array}{|c|cc|}
 & Z & A\\
\hline\hline Z & \text{id} & \bbnum 0\\
A\times A & \bbnum 0 & a\rightarrow a\times a
\end{array}\\
 & =\,\,\begin{array}{|cc|}
\hline\hline \text{id}\bef(\_\rightarrow e^{:A}) & \left(a\rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}\right)\end{array}\,=\,\begin{array}{|cc|}
\hline\hline \_\rightarrow e^{:A} & a\rightarrow a\oplus a\end{array}\quad.\\
(g\circ f)(x) & =\,\begin{array}{|cc|}
\hline\hline \_\rightarrow e^{:A} & a\rightarrow a\oplus a\end{array}\,\,\begin{array}{|c|}
z^{:Z}\\
\bbnum 0
\end{array}\,=(\_\rightarrow e^{:A})(z)=e\quad.
\end{align*}

\end_inset

The 
\emph on
forward
\emph default
 composition seems to be easier to read and to reason about in the matrix
 notation.
\end_layout

\begin_layout Chapter
Glossary of terms
\begin_inset CommandInset label
LatexCommand label
name "chap:Appendix-Glossary-of-terms"

\end_inset


\end_layout

\begin_layout Description
Code
\begin_inset space ~
\end_inset

notation 
\begin_inset Index idx
status open

\begin_layout Plain Layout
code notation
\end_layout

\end_inset

A mathematical notation developed in this book for deriving properties of
 code in functional programs.
 Variables have optional type annotations, such as 
\begin_inset Formula $x^{:A}$
\end_inset

 or 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Nameless functions are denoted by
\begin_inset Formula $x^{:A}\rightarrow f$
\end_inset

, products by 
\begin_inset Formula $a\times b$
\end_inset

, and values of a disjunctive type 
\begin_inset Formula $A+B$
\end_inset

 are written as 
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset

.
 Functions working with disjunctive types are denoted by matrices.
 Lifting of functions to functors, such as 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

, is denoted by 
\begin_inset Formula $f^{\uparrow L}$
\end_inset

; function compositions are denoted by 
\begin_inset Formula $f\bef g$
\end_inset

 (forward composition) and 
\begin_inset Formula $f\circ g$
\end_inset

 (backward composition); and function applications by 
\begin_inset Formula $f(x)$
\end_inset

 or equivalently 
\begin_inset Formula $x\triangleright f$
\end_inset

.
 See Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Appendix-Notations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
contrafunctor
\end_layout

\end_inset

Contrafunctor A type constructor having the properties of a contravariant
 functor
\begin_inset Index idx
status open

\begin_layout Plain Layout
contrafunctor
\end_layout

\end_inset

 with respect to a type parameter.
 Instead of 
\begin_inset Quotes eld
\end_inset

contravariant functor
\begin_inset Quotes erd
\end_inset

, this book uses the shorter name 
\begin_inset Quotes eld
\end_inset

contrafunctor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
Disjunctive
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type
\end_layout

\end_inset

A type representing one of several distinct possibilities.
 In Scala, this is usually implemented as a sealed trait extended by several
 case classes.
 The standard Scala disjunction types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

.
 Also known as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
sum type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\series bold
sum 
\series default
type, 
\series bold
tagged union
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
tagged union type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 type, 
\series bold
co-product
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
co-product type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 type, and variant type (in Object Pascal and in OCaml).
 The shortest name is 
\begin_inset Quotes eld
\end_inset

sum type,
\begin_inset Quotes erd
\end_inset

 but the English word 
\begin_inset Quotes eld
\end_inset

disjunctive
\begin_inset Quotes erd
\end_inset

 is less ambiguous to the ear than 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
Exponential-polynomial
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exponential-polynomial type
\end_layout

\end_inset

A type constructor built using products, disjunctions (sums or co-products),
 and function types (
\begin_inset Quotes eld
\end_inset

exponentials
\begin_inset Quotes erd
\end_inset

), as well as type parameters and fixed types.
 For example,  
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Either[(A,A), Int=>A]
\end_layout

\end_inset

 is an exponential-polynomial type constructor.
 Such type constructors are always profunctors and can also be functors
 or contrafunctors.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor block
\end_layout

\end_inset

Functor
\begin_inset space ~
\end_inset

block A short syntax for composing several 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operations applied to a functor-typed value.
 The type constructor corresponding to that value must be a functor and
 is fixed throughout the entire functor block.
 For example, the Scala code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for { x <- List(1,2,3); y <- List(10, x); if y > 2 }
\end_layout

\begin_layout Plain Layout

  yield 2 * y
\end_layout

\end_inset

is equivalent to the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(1, 2, 3).flatMap(x => List(10, x))
\end_layout

\begin_layout Plain Layout

  .filter(y => y > 1).map(y => 2 * y)
\end_layout

\end_inset

and computes the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(20, 20, 20, 6)
\end_layout

\end_inset

.
 This is a functor block that 
\begin_inset Quotes eld
\end_inset

raises
\begin_inset Quotes erd
\end_inset

 computations to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor.
 Similar syntax exists in a number of languages and is called a 
\series bold

\begin_inset Quotes eld
\end_inset

for-comprehension
\begin_inset Quotes erd
\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
for
\family default
-comprehensions (Python)
\end_layout

\end_inset

 or a 
\begin_inset Quotes eld
\end_inset

list comprehension
\begin_inset Quotes erd
\end_inset

 in Python, 
\series bold

\begin_inset Quotes eld
\end_inset

do-notation
\begin_inset Quotes erd
\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
do
\family default
-notation (Haskell)
\end_layout

\end_inset

 in Haskell, and 
\series bold

\begin_inset Quotes eld
\end_inset

computation expressions
\begin_inset Quotes erd
\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
computation expressions (F#)
\end_layout

\end_inset

 in F#.
 I use the name 
\begin_inset Quotes eld
\end_inset

functor block
\begin_inset Quotes erd
\end_inset

 in this book because it is shorter and more descriptive.
 (The type constructor used in a functor block needs to be at least a functor
 but does not have to be a monad.)
\end_layout

\begin_layout Description
Kleisli
\begin_inset space ~
\end_inset

function 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli!functions
\end_layout

\end_inset

 A function with type signature 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => M[B]
\end_layout

\end_inset

) for some fixed monad 
\begin_inset Formula $M$
\end_inset

.
 Also called a Kleisli morphism
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kleisli!morphisms
\end_layout

\end_inset

 (a morphism in the Kleisli category corresponding to the monad 
\begin_inset Formula $M$
\end_inset

).
 The monadic method 
\begin_inset Formula $\text{pure}_{M}:A\rightarrow M^{A}$
\end_inset

 has the type signature of a Kleisli function.
 The Kleisli composition operation, 
\begin_inset Formula $\diamond_{M}$
\end_inset

, is a binary operation that combines two Kleisli functions (of types 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $B\rightarrow M^{C}$
\end_inset

) into a new Kleisli function (of type 
\begin_inset Formula $A\rightarrow M^{C}$
\end_inset

).
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
method
\end_layout

\end_inset

Method This word is used in two ways: 1) A method
\begin_inset Formula $_{1}$
\end_inset

 is a Scala function defined as a member of a typeclass.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 is a method defined in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

 typeclass.
 2) A method
\begin_inset Formula $_{2}$
\end_inset

 is a Scala function defined as a member of a data type declared as a Java-compa
tible 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

.
 Trait methods
\begin_inset Formula $_{2}$
\end_inset

 are necessary in Scala when implementing functions whose arguments have
 type parameters (because Scala function values defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 cannot have type parameters).
 So, many typeclasses such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, whose methods
\begin_inset Formula $_{1}$
\end_inset

 require type parameters, will use Scala 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traits
\end_layout

\end_inset

 with methods
\begin_inset Formula $_{2}$
\end_inset

 for their implementation.
 The same applies to type constructions with quantified types, such as the
 Church encoding.
 
\end_layout

\begin_layout Description
Nameless
\begin_inset space ~
\end_inset

function 
\begin_inset Index idx
status open

\begin_layout Plain Layout
nameless function
\end_layout

\end_inset

An expression of function type, representing a function.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: Int) => x * 2
\end_layout

\end_inset

.
 Also known as function expression, function literal, anonymous function,
\begin_inset Index idx
status open

\begin_layout Plain Layout
anonymous function!see 
\begin_inset Quotes eld
\end_inset

nameless functions
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 closure, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
lambda-function!see 
\begin_inset Quotes eld
\end_inset

nameless function
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

lambda-function, lambda-expression, or simply a 
\begin_inset Quotes eld
\end_inset

lambda
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Description
Partial
\begin_inset space ~
\end_inset

type-to-value
\begin_inset space ~
\end_inset

function
\begin_inset space ~
\end_inset

(PTVF) A function with a type parameter but defined only for a certain subset
 of types.
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial type-to-value function
\end_layout

\end_inset

 In Scala, PTVFs are implemented via a typeclass constraint:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def double[T: Semigroup](t: T): T = implicitly[Semigroup[T]].combine(t, t)
\end_layout

\end_inset

This PTVF is defined only for types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 for which a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 typeclass instance is available.
\end_layout

\begin_layout Description
Polynomial
\begin_inset space ~
\end_inset

functor 
\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial functor
\end_layout

\end_inset

A type constructor built using disjunctions (sums), products (tuples), type
 parameters and fixed types.
 For example, in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Either[(Int, A), A]
\end_layout

\end_inset

 is a polynomial functor with respect to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 is a fixed type (not a type parameter).
 Polynomial functors are also known as 
\series bold
algebraic data types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic data type
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
Product
\begin_inset space ~
\end_inset

type 
\begin_inset Index idx
status open

\begin_layout Plain Layout
product type
\end_layout

\end_inset

A type representing several values given at once.
 In Scala, product types are the tuple types, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

, and case classes.
 Also known as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples
\end_layout

\end_inset


\series bold
tuple
\series default
 type, 
\series bold
struct
\series default
 (in C and C++), and 
\series bold
record
\series default
.
\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
profunctor
\end_layout

\end_inset

Profunctor A type constructor whose type parameter occurs in both covariant
 and contravariant positions and satisfying the appropriate laws; see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Description
Type
\begin_inset space ~
\end_inset

notation 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation
\end_layout

\end_inset

A mathematical notation for type expressions developed in this book for
 easier reasoning about types in functional programs.
 Disjunctive types are denoted by 
\begin_inset Formula $+$
\end_inset

, product types by 
\begin_inset Formula $\times$
\end_inset

, and function types by 
\begin_inset Formula $\rightarrow$
\end_inset

.
 The unit type is denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

, and the void type by 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 The function arrow 
\begin_inset Formula $\rightarrow$
\end_inset

 groups weaker than 
\begin_inset Formula $+$
\end_inset

, which in turn groups weaker than 
\begin_inset Formula $\times$
\end_inset

.
 This means
\begin_inset Formula 
\[
Z+A\rightarrow Z+A\times A\quad\text{is the same as}\quad\left(Z+A\right)\rightarrow\left(Z+\left(A\times A\right)\right)\quad.
\]

\end_inset

 Type parameters are denoted by superscripts.
 As an example, the Scala definition
\family typewriter

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = Either[(A, A => Option[Int]), String => List[A]]
\end_layout

\end_inset


\family default
is written in the type notation as 
\begin_inset Formula 
\[
F^{A}\triangleq A\times\left(A\rightarrow\bbnum 1+\text{Int}\right)+(\text{String}\rightarrow\text{List}^{A})\quad.
\]

\end_inset


\end_layout

\begin_layout Description
\begin_inset Index idx
status open

\begin_layout Plain Layout
unfunctor
\end_layout

\end_inset

Unfunctor A type constructor that cannot possibly be a functor, nor a contrafunc
tor, nor a profunctor.
 An example is a type constructor with explicitly indexed type parameters,
 such as 
\begin_inset Formula $F^{A}\triangleq\left(A\times A\right)^{:F^{\text{Int}}}+\left(\text{Int}\times A\right)^{:F^{\bbnum 1}}$
\end_inset

.
 The Scala code for this type constructor is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A](x: A, y: A)   extends F[Int]
\end_layout

\begin_layout Plain Layout

final case class F2[A](s: Int, t: A) extends F[Unit]
\end_layout

\end_inset

This can be seen as a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
GADT!see 
\begin_inset Quotes eld
\end_inset

unfunctor
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\series bold
GADT
\series default
 (generalized algebraic data type) that uses specific values of type parameters
 instead of the type parameter 
\begin_inset Formula $A$
\end_inset

 in at least some of its case classes.
\end_layout

\begin_layout Section
How the term 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 is used in functional programming
\end_layout

\begin_layout Standard
This book avoids using the terms 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebra
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 because these terms are too ambiguous.
 As we will see, the FP community uses the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 in at least 
\emph on
four
\emph default
 incompatible ways.
\end_layout

\begin_layout Paragraph
Definition 0.
\end_layout

\begin_layout Standard
In mathematics, an “algebra” is a vector space with a multiplication operation
 satisfying certain properties.
 For example, we need 
\begin_inset Formula $1*x=x$
\end_inset

, and the multiplication must be distributive with respect to addition.
 For example, the set of all 
\begin_inset Formula $10\times10$
\end_inset

 matrices with real coefficients is a 
\begin_inset Formula $100$
\end_inset

-dimensional vector space that supports distributive multiplication.
 Such matrices form an “algebra” in the mathematical sense.
 (This meaning of the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 is 
\emph on
not
\emph default
 used in FP.)
\end_layout

\begin_layout Paragraph
Definition 1.
\end_layout

\begin_layout Standard
For a given functor 
\begin_inset Formula $F$
\end_inset

, an 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

-algebra
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $F$
\end_inset

-algebra
\end_layout

\end_inset

 is a type 
\begin_inset Formula $T$
\end_inset

 and a function with type signature 
\begin_inset Formula $F^{T}\rightarrow T$
\end_inset

.
 (This definition comes from category theory.
 This book does not use 
\begin_inset Formula $F$
\end_inset

-algebras because knowing their category-theoretical properties does not
 help in practical programming.) The name 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

-algebra
\begin_inset Quotes erd
\end_inset

 emphasizes the dependence on a chosen functor 
\begin_inset Formula $F$
\end_inset

.
 There is no direct connection between this 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 and Definition
\begin_inset space ~
\end_inset

0, except when the functor 
\begin_inset Formula $F$
\end_inset

 is defined by 
\begin_inset Formula $F^{A}\triangleq A\times A$
\end_inset

: a function of type 
\begin_inset Formula $T\times T\rightarrow T$
\end_inset

 may then be interpreted as a 
\begin_inset Quotes eld
\end_inset

multiplication
\begin_inset Quotes erd
\end_inset

 operation for values of type 
\begin_inset Formula $T$
\end_inset

.
 However, 
\begin_inset Formula $T$
\end_inset

 is usually not a vector space, so it has no distributivity or commutativity
 laws.
 
\end_layout

\begin_layout Paragraph
Definition 2.
\end_layout

\begin_layout Standard
Polynomial functors are often called “algebraic data types”.
 However, they are not “algebraic” in the sense of Definitions
\begin_inset space ~
\end_inset

0 or 1.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[(A, A)]
\end_layout

\end_inset

 is an “algebraic data type”, written as 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times A$
\end_inset

 in the type notation.
 The word 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 suggests 
\begin_inset Quotes eld
\end_inset

school-level algebra
\begin_inset Quotes erd
\end_inset

 dealing with polynomials: those data types are built from sums and products
 of types.
 However, values of the type 
\begin_inset Formula $F^{A}$
\end_inset

 do not support the addition and multiplication operations required by Definitio
n
\begin_inset space ~
\end_inset

0 of 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

.
 The type 
\begin_inset Formula $F^{A}$
\end_inset

 may admit some binary or unary operations (e.g., that of a monoid), but these
 operations will likely not be commutative or distributive.
 Also, 
\begin_inset Formula $F^{A}$
\end_inset

 is not a 
\begin_inset Formula $G$
\end_inset

-algebra for some functor 
\begin_inset Formula $G$
\end_inset

, in the sense of Definition
\begin_inset space ~
\end_inset

1.
 This book uses the terms “polynomial types” and “exponential-polynomial
 types”.
 Data types containing functions, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int => (A, A)]
\end_layout

\end_inset

, are exponential-polynomial (but not polynomial).
\end_layout

\begin_layout Paragraph
Definition 3.
\end_layout

\begin_layout Standard
One talks about the “algebra” of properties of functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, meaning that these functions satisfy certain 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 laws (e.g., the composition, naturality, or associativity laws).
 But these laws do not make functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 into an algebra in the sense of Definition
\begin_inset space ~
\end_inset

0 or in the sense of Definition
\begin_inset space ~
\end_inset

1.
 There is also no relation to the algebraic data types of Definition
\begin_inset space ~
\end_inset

2.
 So, this is a different usage of the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

.
 However, there is no general 
\begin_inset Quotes eld
\end_inset

algebra of laws
\begin_inset Quotes erd
\end_inset

 that we can use; every derivation proceeds in a different way, specific
 to the laws being proved.
 In mathematics, 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 equations are distinguished from differential or integral equations.
 In that sense, the laws used in FP are 
\emph on
always
\emph default
 algebraic: they are just equations with compositions and applications of
 functions.
 So, there is no advantage in calling laws 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

 within the context of FP.
 This book calls them 
\begin_inset Quotes eld
\end_inset

equations
\begin_inset Quotes erd
\end_inset

 or just 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
Definition 4.
\end_layout

\begin_layout Standard
The Church encoding of a free monad (also known as the 
\begin_inset Quotes eld
\end_inset

tagless final
\begin_inset Index idx
status open

\begin_layout Plain Layout
tagless final
\end_layout

\end_inset

 interpreter
\begin_inset Quotes erd
\end_inset

) is the type 
\begin_inset Formula $\forall E^{\bullet}.\,(S^{E^{\bullet}}\leadsto E^{\bullet})\rightarrow E^{A}$
\end_inset

.
 It uses a higher-order type constructor 
\begin_inset Formula $S^{E^{\bullet}}$
\end_inset

 parameterized by a 
\emph on
type constructor
\emph default
 parameter 
\begin_inset Formula $E^{\bullet}$
\end_inset

.
 In this context, one calls an 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 a value of type 
\begin_inset Formula $S^{E^{\bullet}}\leadsto E^{\bullet}$
\end_inset

, which is an 
\begin_inset Formula $S$
\end_inset

-algebra in the category of type constructors.
 So, Definition
\begin_inset space ~
\end_inset

4 is related to Definition
\begin_inset space ~
\end_inset

1, with a specific choice of a functor.
 However, knowing that 
\begin_inset Formula $S^{E^{\bullet}}\leadsto E^{\bullet}$
\end_inset

 is an 
\begin_inset Formula $S$
\end_inset

-algebra in the category of type constructors does not provide any help
 or additional insights for practical work with the Church encoding of free
 monads.
\end_layout

\begin_layout Standard
The higher-order type constructor 
\begin_inset Formula $S$
\end_inset

 is used to parameterize the effects described by a Church-encoded free
 monad, so this book calls it the 
\begin_inset Quotes eld
\end_inset

effect constructor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
We find that the current usage of the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 in FP is both inconsistent and unhelpful to software practitioners.
 In this book, the word 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 always means a branch of mathematics, as in 
\begin_inset Quotes eld
\end_inset

high-school algebra
\begin_inset Quotes erd
\end_inset

.
 Instead of 
\begin_inset Quotes eld
\end_inset

algebra
\begin_inset Quotes erd
\end_inset

 as in Definitions
\begin_inset space ~
\end_inset

1 to
\begin_inset space ~
\end_inset

4, this book talks about 
\begin_inset Quotes eld
\end_inset

polynomial types
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

polynomial functors
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

exponential-polynomial functors
\begin_inset Quotes erd
\end_inset

 etc.; 
\begin_inset Quotes eld
\end_inset

equations
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

; and an 
\begin_inset Quotes eld
\end_inset

effect constructor
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Chapter
Inferring code from types with the LJT algorithm
\begin_inset CommandInset label
LatexCommand label
name "app:CH-correspondence-LJT-algorithm"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "Gentzen-Vorobieff-Hudelmaier algorithm"
target "http://apt13.unibe.ch/slides/Dyckhoff.pdf"
literal "false"

\end_inset

 and its generalizations
\end_layout

\begin_layout Standard
See also the 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"
literal "false"

\end_inset

 project
\end_layout

\begin_layout Section
Slides
\end_layout

\begin_layout Standard
In formal logic, this statement is written in the syntax
\begin_inset Formula 
\[
X,Y,...,Z\vdash T
\]

\end_inset

and is called a 
\series bold
sequent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent (in logic)
\end_layout

\end_inset

 having the premises 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

 and the goal 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
A sequent in formal logic can be proved if proof task;
\end_layout

\begin_layout Standard
The elementary proof task is represented by a 
\series bold
sequent
\end_layout

\begin_layout Standard
Notation: 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

; the 
\series bold
premises
\series default
 are 
\begin_inset Formula $A,B,C$
\end_inset

 and the 
\series bold
goal
\series default
 is G
\end_layout

\begin_layout Standard
Proofs are achieved via axioms and derivation rules
\end_layout

\begin_layout Standard
Axioms: such and such sequents are already true
\end_layout

\begin_layout Standard
Derivation rules: this sequent is true if such and such sequents are true
\end_layout

\begin_layout Standard
To make connection with logic, represent code fragments as 
\series bold
sequents
\end_layout

\begin_layout Standard

\color blue
\begin_inset Formula $A,B\vdash C$
\end_inset


\color inherit
 represents an 
\emph on
expression
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
C
\family default
\size default
\color inherit
 that uses 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
y:
\begin_inset space \space{}
\end_inset

B
\end_layout

\begin_layout Standard
Examples in Scala:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

Int).toString + "abc"
\family default
\size default
\color inherit
 is an expression of type 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 that uses an 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

Int
\family default
\size default
\color inherit
 and is represented by the sequent 
\begin_inset Formula $\text{Int}\vdash\text{String}$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

Int) 
\begin_inset Formula $\rightarrow$
\end_inset

 x.toString + "abc"
\family default
\size default
\color inherit
 is an expression of type 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\rightarrow$
\end_inset

 String
\family default
\size default
\color inherit
 and is represented by the sequent 
\begin_inset Formula $\emptyset\vdash\text{Int}\rightarrow\text{String}$
\end_inset


\end_layout

\begin_layout Standard
Sequents only describe the 
\emph on
types
\emph default
 of expressions and their parts
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Translating language constructions into the logic II
\end_layout

\begin_layout Standard
What are the derivation rules for the logic of types?
\end_layout

\begin_layout Standard
Write all the constructions in FP languages as sequents
\end_layout

\begin_layout Standard
This will give all the derivation rules for the logic of types
\end_layout

\begin_layout Standard
Each type construction has an expression for creating it and an expression
 for using it
\end_layout

\begin_layout Standard
Tuple type 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A\times B\vdash A$
\end_inset

 and also 
\begin_inset Formula $A\times B\vdash B$
\end_inset


\end_layout

\begin_layout Standard
Function type 
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
Create: if we have 
\begin_inset Formula $A\vdash B$
\end_inset

 then we will have 
\begin_inset Formula $\emptyset\vdash A\rightarrow B$
\end_inset

 
\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A\rightarrow B,A\vdash B$
\end_inset


\end_layout

\begin_layout Standard
Disjunction type 
\begin_inset Formula $A+B$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $A\vdash A+B$
\end_inset

 and also 
\begin_inset Formula $B\vdash A+B$
\end_inset


\end_layout

\begin_layout Standard
Use: 
\begin_inset Formula $A+B,A\rightarrow C,B\rightarrow C\vdash C$
\end_inset


\end_layout

\begin_layout Standard
Unit type 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
Create: 
\begin_inset Formula $\emptyset\vdash1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Translating language constructions into the logic III
\end_layout

\begin_layout Standard
Additional rules for the logic of types
\end_layout

\begin_layout Standard
In addition to constructions that use types, we have 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 constructions:
\end_layout

\begin_layout Standard
a single, unmodified value of type 
\begin_inset Formula $A$
\end_inset

 is a valid expression of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
For any 
\begin_inset Formula $A$
\end_inset

 we have the sequent 
\begin_inset Formula $A\vdash A$
\end_inset


\end_layout

\begin_layout Standard
if a value can be computed using some given data, it can also be computed
 if given
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
,
\end_layout

\end_inset


\emph on
additional
\emph default
 data
\end_layout

\begin_layout Standard
If we have 
\begin_inset Formula $A,...,C\vdash G$
\end_inset

 then also 
\begin_inset Formula $A,...,C,D\vdash G$
\end_inset

 for any 
\begin_inset Formula $D$
\end_inset


\end_layout

\begin_layout Standard
For brevity, we denote by 
\begin_inset Formula $\Gamma$
\end_inset

 a sequence of arbitrary premises
\end_layout

\begin_layout Standard
the order in which data is given does not matter, we can still compute all
 the same things given the same premises in different order
\end_layout

\begin_layout Standard
If we have 
\begin_inset Formula $\Gamma,A,B\vdash G$
\end_inset

 then we also have 
\begin_inset Formula $\Gamma,B,A\vdash G$
\end_inset


\end_layout

\begin_layout Standard
Syntax conventions:
\end_layout

\begin_layout Standard
the implication operation associates 
\emph on
to the right
\end_layout

\begin_layout Standard
\begin_inset Formula $A\rightarrow B\rightarrow C$
\end_inset

 means 
\begin_inset Formula $A\rightarrow\left(B\rightarrow C\right)$
\end_inset


\end_layout

\begin_layout Standard
precedence order: implication, disjunction, conjunction
\end_layout

\begin_layout Standard
\begin_inset Formula $A+B\times C\rightarrow D$
\end_inset

 means 
\begin_inset Formula $\left(A+\left(B\times C\right)\right)\rightarrow D$
\end_inset


\end_layout

\begin_layout Standard
Quantifiers: implicitly, all our type variables are universally quantified
\end_layout

\begin_layout Standard
When we write 
\begin_inset Formula $A\rightarrow B\rightarrow A$
\end_inset

, we mean 
\begin_inset Formula $\forall A:\forall B:A\rightarrow B\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types I
\end_layout

\begin_layout Standard
Now we have all the axioms and the derivation rules of the logic of types.
\end_layout

\begin_layout Standard
What theorems can we derive in this logic?
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $A\rightarrow B\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Start with an axiom 
\begin_inset Formula $A\vdash A$
\end_inset

; add an unused extra premise 
\begin_inset Formula $B$
\end_inset

: 
\begin_inset Formula $A,B\vdash A$
\end_inset


\end_layout

\begin_layout Standard
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

, get 
\begin_inset Formula $A\vdash B\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B\rightarrow A$
\end_inset

, get the final sequent 
\begin_inset Formula $\emptyset\vdash A\rightarrow B\rightarrow A$
\end_inset

 showing that 
\begin_inset Formula $A\rightarrow B\rightarrow A$
\end_inset

 is a 
\series bold
theorem
\series default
 since it is derived from no premises
\end_layout

\begin_layout Standard
What code does this describe?
\end_layout

\begin_layout Standard
The axiom 
\begin_inset Formula $A\vdash A$
\end_inset

 represents the expression 
\begin_inset Formula $x^{A}$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 is of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
The unused premise 
\begin_inset Formula $B$
\end_inset

 corresponds to unused variable 
\begin_inset Formula $y^{B}$
\end_inset

 of type 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives the function 
\begin_inset Formula $y^{B}\rightarrow x^{A}$
\end_inset


\end_layout

\begin_layout Standard
The second 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives 
\begin_inset Formula $x^{A}\rightarrow\left(y^{B}\rightarrow x\right)$
\end_inset


\end_layout

\begin_layout Standard
Scala code: 
\family typewriter
\size footnotesize
\color blue
def f[A, B]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\rightarrow$
\end_inset

 B 
\begin_inset Formula $\rightarrow$
\end_inset

 A = (x:
\begin_inset space \space{}
\end_inset

A) 
\begin_inset Formula $\rightarrow$
\end_inset

 (y:
\begin_inset space \space{}
\end_inset

B) 
\begin_inset Formula $\rightarrow$
\end_inset

 x
\end_layout

\begin_layout Standard
Any code expression's type can be translated into a sequent
\end_layout

\begin_layout Standard
A proof of a theorem directly guides us in writing code for that type
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Correspondence between programs and proofs
\end_layout

\begin_layout Standard
By construction, any theorem can be implemented in code
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def identity[A](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

A = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def toUnit[A](x:
\begin_inset space \space{}
\end_inset

A): Unit = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def inLeft[A,B](x:A):
\begin_inset space \space{}
\end_inset

Either[A,B] = Left(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\times B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def first[A,B](p:
\begin_inset space \space{}
\end_inset

(A,B)):
\begin_inset space \space{}
\end_inset

A = p._1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\rightarrow B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def const[A,B](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

B
\begin_inset Formula $\rightarrow$
\end_inset

A = (y:B)
\begin_inset Formula $\rightarrow$
\end_inset

x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Also, non-theorems 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_layout Standard
Examples of non-theorems:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\rightarrow A$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:A+B\rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\rightarrow A\times B$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:(A\rightarrow B)\rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Given a type's formula, can we implement it in code? Not obvious.
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $\forall A\forall B:((((A\rightarrow B)\rightarrow A)\rightarrow A)\rightarrow B)\rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
Can we write a function with this type? Can we prove this formula?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types II
\end_layout

\begin_layout Standard
What kind of logic is this? What do mathematicians call this logic?
\end_layout

\begin_layout Standard
This is called 
\begin_inset Quotes eld
\end_inset

intuitionistic propositional logic
\begin_inset Quotes erd
\end_inset

, IPL (also 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
This is a 
\begin_inset Quotes eld
\end_inset

nonclassical
\begin_inset Quotes erd
\end_inset

 logic because it is different from Boolean logic
\end_layout

\begin_layout Standard
Disjunction works very differently from Boolean logic
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $A\rightarrow B+C\vdash(A\rightarrow B)+(A\rightarrow C)$
\end_inset

 does not hold in IPL
\end_layout

\begin_layout Standard
This is counter-intuitive!
\end_layout

\begin_layout Standard
We cannot implement a function with this type:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
def q[A,B,C](f: A 
\begin_inset Formula $\rightarrow$
\end_inset

 Either[B, C]): Either[A 
\begin_inset Formula $\rightarrow$
\end_inset

 B, A 
\begin_inset Formula $\rightarrow$
\end_inset

 C]
\end_layout

\begin_layout Standard
Disjunction is 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

: need to supply one of the parts
\end_layout

\begin_layout Standard
But 
\family typewriter
\size footnotesize
\color blue
Either[A 
\begin_inset Formula $\rightarrow$
\end_inset

 B, A 
\begin_inset Formula $\rightarrow$
\end_inset

 C]
\family default
\size default
\color inherit
 is not a function of 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Implication works somewhat differently
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $\left(\left(A\rightarrow B\right)\rightarrow A\right)\rightarrow A$
\end_inset

 holds in Boolean logic but not in IPL
\end_layout

\begin_layout Standard
Cannot compute an 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 because of insufficient data
\end_layout

\begin_layout Standard
Conjunction works the same as in Boolean logic
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula 
\[
A\rightarrow B\times C\vdash\left(A\rightarrow B\right)\times\left(A\rightarrow C\right)
\]

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The logic of types III
\end_layout

\begin_layout Standard
How to determine whether a given IPL formula is a theorem?
\end_layout

\begin_layout Standard
The IPL cannot have a truth table with a fixed number of truth values
\end_layout

\begin_layout Standard
This was shown by G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
"
\end_layout

\end_inset

odel in 1932 (see 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia page"
target "https://en.wikipedia.org/wiki/Many-valued_logic"
literal "false"

\end_inset

)
\end_layout

\begin_layout Standard
The IPL has a decision procedure (algorithm) that either finds a proof for
 a given IPL formula, or determines that there is no proof
\end_layout

\begin_layout Standard
There may be several inequivalent proofs of an IPL theorem
\end_layout

\begin_layout Standard
Each proof can be 
\emph on
automatically translated
\emph default
 into code
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"
literal "false"

\end_inset

 library implements an IPL prover as a Scala macro, and generates Scala
 code from types
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset href
LatexCommand href
name "djinn-ghc"
target "https://hackage.haskell.org/package/djinn-ghc"
literal "false"

\end_inset

 compiler plugin and the 
\begin_inset CommandInset href
LatexCommand href
name "JustDoIt plugin"
target "https://github.com/nomeata/ghc-justdoit"
literal "false"

\end_inset

 implement an IPL prover in Haskell, and generate Haskell code from types
\end_layout

\begin_layout Standard
All these IPL provers use the same basic algorithm called LJT 
\end_layout

\begin_layout Standard
and all cite the same paper 
\size footnotesize

\begin_inset CommandInset href
LatexCommand href
name "[Dyckhoff 1992]"
target "https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
because most other papers on this subject are incomprehensible to non-specialist
s, or describe algorithms that are too complicated
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search I: looking for an algorithm
\end_layout

\begin_layout Standard
Why our initial presentation of IPL does not give a proof search algorithm
\end_layout

\begin_layout Standard
The FP type constructions give nine axioms and three derivation rules:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Itemize
\begin_inset Formula $\Gamma,A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash A$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\rightarrow B,A\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A+B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,B\vdash A+B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A+B,A\rightarrow C,B\rightarrow C\vdash C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma\vdash1$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A$
\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma,A\vdash B}{\Gamma\vdash A\rightarrow B}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma\vdash G}{\Gamma,D\vdash G}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma,A,B\vdash G}{\Gamma,B,A\vdash G}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Can we use these rules to obtain a finite and complete search tree? No.
\end_layout

\begin_layout Standard
Try proving 
\begin_inset Formula $A,B+C\vdash A\times B+C$
\end_inset

: cannot find matching rules
\end_layout

\begin_layout Standard
Need a better formulation of the logic
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search II: Gentzen's calculus LJ (1935)
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

complete and sound calculus
\begin_inset Quotes erd
\end_inset

 is a set of axioms and derivation rules that will yield all (and only!)
 theorems of the logic
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{}{\Gamma,{\color{blue}X}\vdash X}\:Id & \qquad\frac{}{\Gamma\vdash{\color{blue}\top}}\,\top\\
\frac{\Gamma,A\rightarrow B\vdash A\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A\rightarrow B}\vdash C}\:L\rightarrow & \qquad\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\rightarrow B}}\,R\rightarrow\\
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+ & \qquad\frac{\Gamma\vdash A_{i}}{\Gamma\vdash{\color{blue}A_{1}+A_{2}}}\,R+_{i}\\
\frac{\Gamma,A_{i}\vdash C}{\Gamma,{\color{blue}A_{1}\times A_{2}}\vdash C}\:L\times_{i} & \qquad\frac{\Gamma\vdash A\quad\;\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\times B}}\,R\times
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Two axioms and eight derivation rules
\end_layout

\begin_layout Standard
Each derivation rule says: The sequent at bottom will be proved if proofs
 are given for sequent(s) at top
\end_layout

\begin_layout Standard
Use these rules 
\begin_inset Quotes eld
\end_inset

bottom-up
\begin_inset Quotes erd
\end_inset

 to perform a proof search
\end_layout

\begin_layout Standard
Sequents are nodes and proofs are edges in the proof search tree
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search example I
\end_layout

\begin_layout Standard
Example: to prove 
\begin_inset Formula $\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q$
\end_inset


\end_layout

\begin_layout Standard
Root sequent 
\begin_inset Formula $S_{0}:\emptyset\vdash\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{0}$
\end_inset

 with rule 
\begin_inset Formula $R\rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{1}:\left(R\rightarrow R\right)\rightarrow Q\vdash Q$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{1}$
\end_inset

 with rule 
\begin_inset Formula $L\rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{2}:\left(R\rightarrow R\right)\rightarrow Q\vdash R\rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{3}:Q\vdash Q$
\end_inset


\end_layout

\begin_layout Standard
Sequent 
\begin_inset Formula $S_{3}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom; it remains to prove 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $L\rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{4}:\left(R\rightarrow R\right)\rightarrow Q\vdash R\rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{5}:Q\vdash R\rightarrow R$
\end_inset


\end_layout

\begin_layout Standard
We are stuck here because 
\begin_inset Formula $S_{4}=S_{2}$
\end_inset

 (we are in a loop)
\end_layout

\begin_layout Standard
We can prove 
\begin_inset Formula $S_{5}$
\end_inset

, but that will not help
\end_layout

\begin_layout Standard
So we backtrack (erase 
\begin_inset Formula $S_{4}$
\end_inset

, 
\begin_inset Formula $S_{5}$
\end_inset

) and apply another rule to 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $R\rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{6}:\left(R\rightarrow R\right)\rightarrow Q;R\vdash R$
\end_inset


\end_layout

\begin_layout Standard
Sequent 
\begin_inset Formula $S_{6}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom
\end_layout

\begin_layout Standard
Therefore we have proved 
\begin_inset Formula $S_{0}$
\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q$
\end_inset

 is derived from no premises, it is a theorem
\end_layout

\begin_layout Standard
\begin_inset Formula $Q.E.D.$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search III: The calculus LJT
\end_layout

\begin_layout Standard
Vorobieff-Hudelmaier-Dyckhoff, 1950-1990
\end_layout

\begin_layout Standard
The Gentzen calculus LJ will loop if rule 
\begin_inset Formula $L\rightarrow$
\end_inset

 is applied 
\begin_inset Formula $\geq2$
\end_inset

 times
\end_layout

\begin_layout Standard
The calculus LJT keeps all rules of LJ except rule 
\begin_inset Formula $L\rightarrow$
\end_inset


\end_layout

\begin_layout Standard
Replace rule 
\begin_inset Formula $L\rightarrow$
\end_inset

 by pattern-matching on 
\begin_inset Formula $A$
\end_inset

 in the premise 
\begin_inset Formula $A\rightarrow B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{\Gamma,X,B\vdash D}{\Gamma,X,{\color{blue}X\rightarrow B}\vdash D}\:L\rightarrow_{1}\\
\frac{\Gamma,A\rightarrow B\rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\rightarrow C}\vdash D}\:L\rightarrow_{2}\\
\frac{\Gamma,A\rightarrow C,B\rightarrow C\vdash D}{\Gamma,{\color{blue}(A+B)\rightarrow C}\vdash D}\:L\rightarrow_{3}\\
\frac{\Gamma,B\rightarrow C\vdash A\rightarrow B\quad\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\rightarrow B)\rightarrow C}\vdash D}\:L\rightarrow_{4}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
When using LJT rules, the proof tree has no loops and terminates
\end_layout

\begin_layout Standard
See 
\begin_inset CommandInset href
LatexCommand href
name "this paper"
target "http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2618"
literal "false"

\end_inset

 for an explicit decreasing measure on the proof tree
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search IV: The calculus LJT
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset


\emph on
It is obvious that it is obvious
\emph default

\begin_inset Quotes erd
\end_inset

 — a mathematician after thinking for a half-hour
\end_layout

\begin_layout Standard
Rule 
\begin_inset Formula $L\rightarrow_{4}$
\end_inset

 is based on the key theorem: 
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\rightarrow B\right)\rightarrow C\right)\rightarrow\left(A\rightarrow B\right)\,\Longleftrightarrow\,\left(B\rightarrow C\right)\rightarrow\left(A\rightarrow B\right)
\]

\end_inset


\end_layout

\begin_layout Standard
The key theorem for rule 
\begin_inset Formula $L\rightarrow_{4}$
\end_inset

 is attributed to Vorobieff (1958)
\end_layout

\begin_layout Standard
A stepping stone to this theorem:
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\rightarrow B\right)\rightarrow C\right)\rightarrow B\rightarrow C
\]

\end_inset


\size default
Proof: 
\begin_inset Formula $f^{\left(A\rightarrow B\right)\rightarrow C}\rightarrow b^{B}\rightarrow f\:(x^{A}\rightarrow b)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search V: From deduction rules to code
\end_layout

\begin_layout Standard
The new rules are equivalent to the old rules, therefore...
\end_layout

\begin_layout Standard
Proof of a sequent 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 code/expression 
\begin_inset Formula $t(a,b,c):G$
\end_inset


\end_layout

\begin_layout Standard
Also can be seen as a function 
\begin_inset Formula $t$
\end_inset

 from 
\begin_inset Formula $A,B,C$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Standard
Sequent in a proof follows from an axiom or from a transforming rule
\end_layout

\begin_layout Standard
The two axioms are fixed expressions, 
\begin_inset Formula $x^{A}\rightarrow x$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
Each rule has a 
\emph on
proof transformer
\emph default
 function: 
\begin_inset Formula $\text{PT}_{R\rightarrow}$
\end_inset

 , 
\begin_inset Formula $\text{PT}_{L+}$
\end_inset

 , etc.
\end_layout

\begin_layout Standard
Examples of proof transformer functions:
\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+\\
PT_{L+}(t_{1}^{A\rightarrow C},t_{2}^{B\rightarrow C})=x^{A+B}\rightarrow & \ x\ \text{match}\begin{cases}
a^{A}\rightarrow t_{1}(a)\\
b^{B}\rightarrow t_{2}(b)
\end{cases}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\rightarrow B\rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\rightarrow C}\vdash D}\:L\rightarrow_{2}\\
PT_{L\rightarrow_{2}}(f^{\left(A\rightarrow B\rightarrow C\right)\rightarrow D})=g^{A\times B\rightarrow C}\rightarrow & f\,(x^{A}\rightarrow y^{B}\rightarrow g(x,y))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Verify that we can indeed produce PTs for every rule of LJT
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
Proof search example II: deriving code
\end_layout

\begin_layout Standard
Once a proof tree is found, start from leaves and apply PTs
\end_layout

\begin_layout Standard
For each sequent 
\begin_inset Formula $S_{i}$
\end_inset

, this will derive a 
\series bold
proof expression
\series default
 
\begin_inset Formula $t_{i}$
\end_inset


\end_layout

\begin_layout Standard
Example: to prove 
\begin_inset Formula $S_{0}$
\end_inset

, start from 
\begin_inset Formula $S_{6}$
\end_inset

 backwards:
\size footnotesize

\begin_inset Formula 
\begin{align*}
S_{6}:\left(R\rightarrow R\right)\rightarrow Q;R\vdash R\quad(\text{axiom }Id)\quad & t_{6}(rrq,r)=r\\
S_{2}:\left(R\rightarrow R\right)\rightarrow Q\vdash\left(R\rightarrow R\right)\quad\text{PT}_{R\rightarrow}(t_{6})\quad & t_{2}(rrq)=\left(r\rightarrow t_{6}(rrq,r)\right)\\
S_{3}:Q\vdash Q\quad(\text{axiom }Id)\quad & t_{3}(q)=q\\
S_{1}:\left(R\rightarrow R\right)\rightarrow Q\vdash Q\quad\text{PT}_{L\rightarrow}(t_{2},t_{3})\quad & t_{1}(rrq)=t_{3}(rrq(t_{2}(rrq)))\\
S_{0}:\emptyset\vdash\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q\quad\text{PT}_{R\rightarrow}(t_{1})\quad & t_{0}=\left(rrq\rightarrow t_{1}(rrq)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The proof expression for 
\begin_inset Formula $S_{0}$
\end_inset

 is then obtained as
\begin_inset Formula 
\begin{align*}
t_{0} & =rrq\rightarrow t_{3}\left(rrq\left(t_{2}\left(rrq\right)\right)\right)=rrq\rightarrow rrq(r\rightarrow t_{6}\left(rrq,r\right)\\
 & =rrq\rightarrow rrq\left(r\rightarrow r\right)
\end{align*}

\end_inset

Simplified final code having the required type: 
\begin_inset Formula 
\[
t_{0}:\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q=\left(rrq\rightarrow rrq\left(r\rightarrow r\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
To 
\emph on
prove
\emph default
 that there is no proof, one needs to use methods of proof theory that are
 beyond the scope of this book.
 A good introduction to the required technique is the book 
\begin_inset Quotes eld
\end_inset


\emph on
Proof and Disproof in Formal Logic
\emph default

\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Bornat.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "R. Bornat, \"Proof and Disproof in Formal Logic\", Oxford, 2005 - link to Amazon.com"
target "https://www.amazon.com/Proof-Disproof-Formal-Logic-Introduction/dp/0198530277"
literal "false"

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
so suppose we we know we need this type how do we get this code turns out
 mathematicians have studied this question for a long time mathematicians
 were only studying the logical domain of course not the program in domain
 since about 1930 or so many mathematicians have studied this including
 church tarski girdle lots of people in Poland and Germany in England and
 in the United States it took a very long time about 50 years between 1913
 and 1980 between the beginning of this activity when this was first formulated
 as logic with these particular rules and the time when the Curie Howard
 respondents was realized that or was it wasn't was discovered at that time
 it became clear that these things have a direct bearing on functional programmi
ng actually helping people to write code because if you know how to prove
 things here you just directly write the code
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
showing here this is equivalent in Scala just different syntax importantly
 non theorems cannot be implemented in code some on theorems are statements
 in logic that cannot be derived statements that are false or undereye verbal
 examples of these statements are these for all a from one follows a now
 this is certainly suspicious in terms of logic what if a were false then
 we would have it from true false false that's very obviously wrong and
 we cannot implement a function of this type to implement it we would have
 to take a unit argument and produce a value of type a where a is arbitrary
 type but how can we produce a value of type a of the type that we don't
 even know what it is and there is no data for us to produce that value
 so it is impossible another example of an impossible type is this type
 so from a plus B follows a if you wanted to implement this function you
 would have to take a value of disjunction type a plus B and return a value
 of type a but how can you do that what exodus Junction type happens to
 contain B and no a just B it cannot contain a if it contains a B it's a
 disjunction so then we don't have an A and then we again cannot produce
 any and having a B which is a completely different arbitrary type doesn't
 help us to produce me exactly the same reason shows why we cannot produce
 an A a and B given a because that requires a B we cannot produce and also
 this is not implementable because we are required to produce an A but all
 we have is a function from A to B this function will consume an A if given
 only this function cannot possibly produce an A for us but we are required
 to produce an A as a result so we cannot and also there is no proof of
 this formula in the logic so these examples actually lead us to a natural
 question how can we decide given a certain formula whether it is a theorem
 in logic and therefore whether it can be implemented in code it is not
 obvious consider this example can we write a function with this type in
 Scala it is not obvious can we prove this formula it is not clear not quite
 obvious right now suppose I were of the opinion that this cannot be proved
 but how do I show that this cannot be proved I certainly cannot just try
 all possible proofs that would be infinitely many possible proofs that
 would give me all kinds of other formulas and that would give me nothing
 that I can stand oh how to answer these questions so it is really a very
 hard question we are not going to try to answer it on our own we were going
 to use the results of mathematicians they have studied these questions
 for many many years for centuries logic has been studied since ancient
 Greece more than 2,000 years of study all we need to do is to find out
 by what name mathematicians call this logic they are probably already studied
 it what kind of logic is this that we are using that follows from the type
 constructions remember and the very beginning of our consideration we started
 with the type constructions that our programming languages have so that's
 set of type constructions specifies the set of rules of derivation of the
 logic mathematicians call this logic intuitionistic propositional logic
 or IPL also they call it constructive propositional logic but it is less
 frequently used most frequently used name is this and mathematicians also
 call this a non classical logic because this logic is actually different
 from the boolean logic that we are familiar with the logic of the values
 true and false and their truth tables I assume that you are familiar with
 those computations using truth tables and operations and or not in the
 boolean logic so actually this logic the logic of types as I call it or
 intuitionistic propositional logic is very different from boolean logic
 in certain ways it's similar in other ways disjunction for instance works
 very differently here's an example consider this sequence if it has given
 that from a follows B plus C then either from a follows B or from a follows
 C it sounds right from the common-sense point of it if if B plus C Falls
 a B or C if I was I'm using plus as a logical or so if B or C follows then
 it kind of makes sense either B follows or C Falls indeed this is correct
 in the boolean logic which we can find out by writing the truth table so
 we enumerate all the possibilities for a B and C to be true or false or
 eight such possibilities and for each of those possibilities we write the
 truth value of this the truth value of this and we see from the table that
 whenever this is true then this is also true in the boolean logic but this
 does not hold in the intuitionistic logic for the logic of types well why
 does it not hold that's counterintuitive well in fact there is very little
 that's intuitive about this so-called intuitionistic logic actually we
 need to think differently about this logic we need to think can we implement
 an expression of this sequent so implementing it would mean if we're given
 this expression we can build an expression of this type so we're given
 an expression of type A to B plus C let's say some F of this type can we
 build an expression of this type we can this differently by asking can
 we implement a function that takes this as an argument and returns this
 well we know that this is equivalent one of our derivation rules is that
 if you have this sequence then you can also have a sequence that is a function
 type from this to this so for the programmer it is easier to reason about
 a function taking this as an argument and returning this so how can we
 implement this function this function takes F and needs to return a value
 of this type so the body of this function if we could implement it and
 have to construct a value of type either of something there are only two
 ways of constructing a value of type either one is to construct the left
 value second is to construct the right value how do we decide whether to
 construct the left value or the right value we have to decide it somehow
 on the basis of what information can we decide it we don't actually have
 any such information what we have here is a function from a to either BC
 so given some value of a of type a we could compute f of that value and
 then we would have either B or C we could decide them whether to we could
 take them that B or that C but that's not what we need to return we don't
 need to return either of BC we need to return either of this function or
 that function and that function is not yet applied to any a it is it is
 too late for us to ask what is the a we already have to return the left
 of this or a right of that in other words this type either of something-somethi
ng is not itself a function of a it contains functions away but itself it
 cannot be decided on the basis of any assets too late so we need to supply
 a left or right so here right away immediately we have to decide whether
 this will return a left or a right and we cannot really decide that if
 we decide we return the left we must then return a function from A to B
 so there's no way for us to construct this function if we're given this
 function because this function could sometimes return C instead of B and
 then we'll be stuck we cannot do this and we can also return we cannot
 also return the right either so it is impossible to implement a function
 of this type implication also works a little differently in the intuitionistic
 logic here's an example this holds in boolean logic but not in intuitionistic
 logic again let's see why how can we compute this given this this function
 will give us an e only when given an argument of this type but how can
 we produce a value of this type we cannot we don't have information that
 will allow us to produce a value of this type a and B are some arbitrary
 types remember there is universal quantifier outside of all this for all
 a and for all B we're supposed to produce this and that is impossible we
 don't have enough data to produce some values type a and so we cannot implement
 this function conjunction works kind of the same as in boolean logic so
 here's an example this implemented and this is also in boolean logic a
 true theorem now in boolean logic the usual way of deciding whether something
 is true or something is a theorem is to write a truth table unfortunately
 the intuitionistic logic cannot have a truth table it cannot have a fixed
 number of truth values even if you allow more than two truth values such
 that the validity of formulas the truth of theorems can be decided on the
 basis of the truth table this was shown by noodle and this means we should
 not actually try to reason about this logic using truth values it is not
 very useful even an infinite infinite number of truth values will not help
 instead however it turns out that this logic has a decision procedure or
 an algorithm and this algorithm is guaranteed either to find the proof
 for any given formula of the internation intuitionistic logic or to determine
 that there is no proof for that formula the algorithm can also find several
 in equivalent proofs if there is a theorem so a theorem could have several
 in equivalent proofs and since each proof could be automatically translated
 into code of that type it means we could generate several in equivalent
 expressions of some type sometimes so that is the situation with this logic
 which we discover if we write if we read papers about intuitionistic propositio
nal logic that are available in the literature and their open source projects
 on the web such as the gen GHC which is a compiler plugin for haskell this
 is another project doing the same thing and for Scala are implemented occurred
 the Clary Howard library both of these Scala and Haskell all of these color
 and Haskell projects do the same thing they take a type of some expression
 for function and generate code for it automatic by translating the type
 into sequence finding a proof in this logic using the algorithm and translating
 that proof back into code in the way that we have seen in an example it
 is interesting that all these provers and there's a few others there's
 one more for the idris language I did not mention here they all used the
 same decision procedure or the same basic algorithm which is called ljt
 which was explained in a paper by dick off here they all side the same
 paper and I believe this is so because most other papers on this subject
 are unreadable to non-specialists they are written in a very complicated
 way or they describe algorithms that are too complicated so I will show
 how this works in the rest of this tutorial in order to find out how to
 get an algorithm we need to ask well first of all do we have the rules
 of derivation that allow us to create an algorithm already here is a summary
 of the axioms and the rules of derivation that we have found so far these
 are direct translations of the cold expressions that we held in the programming
 language in the notation of sequence now there's one other notation for
 derivation rules which looks like a fraction like this the numerator is
 one or more sequins and the denominator is a sequence and this notation
 means in order to derive what is in the denominator you have to present
 proofs for what is in the numerator so this is the convention in the literature
 this fraction like syntax or notation now we keep in mind that proofs of
 sequence are actually just called expressions that have these types as
 some variables and this type is the entire expression so these are directly
 responding to proofs of this sequence and to the proofs of these derivation
 rules and so if we have a proof that operates by combining some of these
 axioms and some of these generation rules which directly translate that
 back into code now the question is do these rules give us an algorithm
 for finding a proof the answer is no how can we use these rules to obtain
 an algorithm well suppose we need to prove some sequence like this in order
 to prove it we could first see if the sequence is one of the axioms if
 so then we have already proved if we know what expression to write now
 in this case none of the axioms match this so much means maybe a is a times
 B so B here is C and then on the Left we must have C or you must have a
 times B now we don't you don't have C on the left as we have because even
 that's not the same we also don't have a times B at the premise we have
 a but we don't have a times B so these rules don't match the other rules
 don't match the premises and the goal either but also these rules so how
 can we use them well when the writer must be an implication we don't have
 an application on the right here we could try to delete some of the premises
 because it's unused well actually it doesn't look like a good idea could
 you read a for example and we end up with an really hopeless sequence from
 B plus C we cannot get an A ever and so but sounds hopeless so this doesn't
 seem to help and changing the order doesn't seem to help much either and
 so we cannot find matching rules but actually this sequence is provable
 just a clever combination of what axiom to start with and what role to
 use and then again some axiom and so on it will give us that time sure
 because I know how to write code for this this is not difficult you have
 a function with two arguments one of them is a the other is B plus C so
 disjunction of either B C and we are supposed to produce a disjunction
 of tuple a B or C that's easy look at this disjunction if we have a B in
 this disjunction then we can produce a left of the tuple a B because we
 always have an A anyway if we have a see in this disjunction then we could
 return this part of the disjunction in the right of C and we're done but
 unfortunately we see that the rules here do not give us an algorithm for
 deciding this we need a better formulation of the logic again mathematicians
 need to save us from the situation and they have done so mathematicians
 have studied this logic for a long time starting from the early 20th of
 the last century the first algorithmic formulation of the logic that was
 found is due to Jensen who published what he called the calculus just ignore
 the word calculus it means not very much complete and sound calculus means
 that he came up with some rules of derivation which are summarized here
 such that they are equivalent to these they derive all the same theorems
 and only the same theorems so they derive all the stuff that is right and
 only that stuff they don't derive any wrong statements it's very hard to
 come up with such a system of axioms and derivation rules that are equivalent
 to another one in this sense also it's very hard to prove that these are
 actually the rules that will give you all the theorems that could be right
 in this logic that you can actually derive all the theorems that are right
 yet work is already done by mathematicians so we're not going to try to
 do it ourselves we're just going to understand how these rules work now
 the syntax here is slightly enhanced compared with this the enhancement
 is that their names pretty cool now these are just labels they don't really
 do anything in terms of sequence these help us identify which we all have
 has been applied to which sequence and that's all we do so other than that
 it is the same notation so the fraction such as this one means that there
 is a sequence in the denominator which we will prove if there are proofs
 given for sequence in the numerator in this rule there are two sequence
 of them in the numerator other rules may have one sequence in the numerator
 or no sequence in the numerator so these rules that will have no previous
 sequence required those are axioms this axiom means if you have an atomic
 X in other words it's a variable it's a type variables not not a complicated
 expression just attack variable and you can derive that same variable this
 is our accion right here now why is it important that this is atomic that
 this is type variable and not a more complicated expression actually not
 important but it's the simplest rule that you can come up with and mathematicia
ns always like the most minimal set of rules so that's why they say let's
 only consider this rule for the type variables X not for more complicated
 expressions but we can consider this rule for any expression of course
 the identity axiom well here is a truth truth axiom net which derives the
 truth which is the ste symbol which I denote it by one the format in logical
 notation this is the T symbol well let's just call this one for clarity
 so that can be derived from any premises with no previous sequence necessary
 none of these other rules now what do these other rules do they do an interesti
ng thing actually each of these rules is either about something in the sequence
 on the left to the trans time or something in the sequence to the right
 of the transplant which I here shown in blue so these are the interesting
 parts of the sequence that are being worked on or transformed by the rule
 so here's an example this rule is actually two rules the eyes the index
 so I is one or two another two rules just written for gravity like this
 with index I and each of them says you will prove this if you prove one
 of if you prove this so for example you will prove C given if you're given
 a a one A two if you will prove C given just a one which makes sense because
 if you can prove C given a one you don't need a two we can ignore this
 a T we can already proved C from anyone so in this way it would be proved
 and so all these rules work in this way you can prove what's on the bottom
 of the seat of the of the fraction if you're given proofs for what's on
 the top so these are eight derivation rules and two axioms we can use this
 now to make a proof search how do we do that I start with a sequence we
 see which rule matches that sequence so the sequence must have something
 on the left and something on the right well at least one of these it cannot
 be empty so it must be something somewhere and there are only four kinds
 of expressions in our logic type variables conjunctions implications and
 disjunctions now notice I'm using this arithmetic arithmetic all notation
 for logic just because I like it better and I will show that it has advantages
 later so we take a sequence we see which rule matches one of them won't
 match because either in the premise we have one of these expressions were
 in the goal we have one of these expressions and then we find the rule
 of match that matches we apply that rule so we now have new sequence one
 or more that we will need to be proved and if they're true then we fork
 the tree and now we have to prove both of them son-in we continue doing
 that for each of the sequence until we hit axioms so the tree will and
 this leaf or we hit a sequence to which no rule applies in which case we
 cannot prove it and the entire thing is unprovable so in the search tree
 there will be sequence at the nodes of the tree and proofs will be at the
 edges of the tree so each node sends its proof to the root of the tree
 this calculus is guaranteed by mathematicians to be such that indeed if
 you cannot find a rule that applies that means the sequence cannot be proved
 which was not the case here the sequence can be proved and yet we cannot
 find a rule that applies so in this calculus we can use bottom-up approach
 to make a proof search as a tree here we cannot that is the advantage capitaliz
ing on the mathematicians results let us look at an example suppose we want
 to prove this formula this theorem so first step we need to write a sequence
 and this needs to be proved from no premises so we write a sequence s0
 which has an empty set of premises this is a single now what rule applies
 to this sequence with your bottom up so in other words we look at these
 rules and they refine which denominator matches our sequential and our
 cylinders empty set on the left so all the rules on the left cannot be
 applied but on the right we have an expression which is an implication
 at the top level of this expression there is this implies that so this
 is of the form a implies B so this rule applies we have a sequence of the
 form something in our case this is an empty set and then a implies B so
 we apply this rule which is the right implication and we get a new sequence
 which is that what was here before the implication is now put on the left
 to the trans of the to the left of the trans time and it means that this
 expression needs to be now to the left of the turnstile so now this is
 the sequence s1 now we need to prove s1 well we see what rule applies to
 us one well on the right there is just Q so nothing can be done of these
 rules and Q is not truth so we cannot use the axiom either so let's look
 at their left rules on the Left we have now an implication so this is let's
 say a and this is B so we have a rule which has a implication B on the
 left this is the row left implication let's apply it that law will give
 us two new sequence so these two new sequence are s2 and s3 no these ones
 as you can check if you match a location B against this implication Q so
 this is a this is B so then you get these two sequence now we have to prove
 these two sequence as 2 and s 3 s 3 is easy it is just the axiom of identity
 it is this now as 2 again has an implication on the left let's again apply
 the rule left implication to that we get two more sequence as foreign s5
 as for is this because 5 is this so now actually we are in trouble because
 as 2 and s 4 is are the same sequence as 5 actually we could prove with
 some more work but that won't help because we are in a situation when to
 prove as two we need to prove again s 2 so that's it that's a loop that
 will never give us anything it means we applied the wrong rule so we need
 to backtrack this step when we apply the rule left implication to s 2 we
 erase is 4 in this 5 and try a different rule to apply to s 2 which rule
 can apply to s 2 well as to is this it actually has implication on the
 right so we can use the right implication rule and if we do that we get
 a sequence s 6 which is this and this sequence immediately follows from
 the identity axiom because it has promise are on the left and premise are
 and goal are on the right and that is this axiom whatever other premises
 and the premise X on the left premise X on the right and that is a type
 variable so that's perfect we have done the proof as 6 follows from the
 axiom and therefore we have proved s0 no more sequins need to be proved
 and because sequence s0 shows this to be derived from no premises than
 this formula is the theorem that's what the theorem means in the logic
 so that is how we use this calculus to do proof search now we notice that
 we were a bit stuck at some point we had a loop now if we are in the loop
 we don't know what to do maybe we need to continue applying the same rule
 maybe some new sequence come up or maybe we should not continue it is not
 clear what to do and just looking at the rule left implication shows us
 that it's copying this premise a implication B it is copied into the premises
 of the new sequence and so it will generate a loop assuredly after the
 second time you apply it however this sequence might be new so we might
 need to apply it second time we don't know that so that is a problem it
 will do now there have been a lot of work trying to fix this problem and
 literally decades from research by mathematicians the main ones I found
 were what are the off we published in the Soviet Union who de Meyer and
 dick Hoff who published in the United States over this time discovered
 gradually a new set of rules which is called ljt or the calculus ljt which
 cures this problem of looping the way it clears this problem is by replacing
 this rule left implication through four new rules which are listed here
 all other rules are kept the same from this calculus except the rule left
 implication which is replaced in what way so left implication was applying
 it applied to a sequence when the sequin had an implication among the premises
 or on the left to the left of the turnstile the new rules look in more
 detail at what is that implication so that implication could have one of
 the four expressions as the argument of the implication it could have an
 atomic expression as the argument it would have a conjunction as the argument
 could have a disjunction as the argument or it could have an implication
 as the argument in our logic there are no more expressions except these
 four atomic variables conjunctions disjunction and implications and so
 we have here enumerated all the possibilities for what could be to the
 left of the implication in this premise which I have here shown in the
 blue in blue and so for each of these we do certain things replacing this
 sequence with one or more other sequence again it's quite a lot of work
 to prove that these rules are equivalent to these and also that the new
 rules are somehow better they are not giving loops a lot of work which
 I am NOT going to go through because that's far too complicated for the
 scope so what we need suffice it to say that we have very smart people
 who published on this and it is reasonably sure that this is correct so
 the T in the name lgt starts stands for terminating so if we use these
 rules in the same way by by creating a proof tree the proof tree will have
 no loops and will terminate after a finite number of steps and there is
 actually this paper that is also helpful for understanding how to implement
 this algorithm and this paper shows explicitly how to construct an integer
 function from sequence to integers which is a measure of the complexity
 of the sequence and this measure decreases every time you apply a rule
 so it strictly decreases and since this is a strictly decreasing measure
 on the proof tree it means that all the next nodes in the proof tree will
 have a smaller value of this measure so eventually it will hit zero and
 the proof tree will terminate at that leaf either that or you have no more
 rules to apply and if you have no more laws to apply then again mathematicians
 have proved it means our sequence cannot be proved so this is an important
 result that we are going to use and note that this this rule is quite complicat
ed it does a very interesting thing it takes this expression which has implicati
on inside an implication and it transforms this expression in a weird way
 namely the B here is separated from the C by parenthesis but here it is
 not separated so this transformation is highly non-trivial and unexpected
 and its validity is based on this theorem that this in the intuitionistic
 logic is equivalent to this equivalent means they're both following from
 the other so from this promos that and from there follows this so this
 key theorem was attributed to rob you off my dick off in this paper and
 this is this lemma 2 which says that if this sorry that the this derivation
 is if and only if that derivations will have these two equivalences and
 the proof is trivial and the 34 is a reference to to borrow be off now
 when a mathematician says that something is trivial doesn't mean that a
 statement is easy to understand it doesn't mean that the proof is easy
 to find or that it has trees easy to understand it means none of these
 things it just means that right now for this mathematician it is not interestin
g to talk about how it is done that's all it means could be for any number
 of reasons for example mathematicians could just be lazy or have no time
 to again explain this and so they say it's trivial don't be don't be deceived
 when you see somebody says that something is trivial in a mathematical
 text so to prove this one stepping stone could be to prove this first this
 is an easier theorem and if you prove this then clearly from here you can
 get B to C B to C you can substitute in here you can get a to B and then
 you have here a to B so in this way you can show this equivalence in one
 direction now the proof of this statement is obviously trivial in order
 to show the expression of this type I will use my short notation so this
 is F which has this type the first argument of the function the second
 is B which is at this type then we need to produce a see how do we produce
 a C we apply F to an argument of this type the argument of this type is
 a function that takes a and returns a B so we take some X of type a and
 we return a B which was this B so we ignore this X we just returned that
 B and that's the argument of F so this expression is the proof of this
 sequence in other words this is the code that has this type and therefore
 the proof must be available somehow so the details of proving this theorem
 are left as an exercise for the reader again when you see in a mathematical
 text that something is left as an exercise for the reader it does not mean
 that it is easy to do it does not mean that for you it would be a useful
 exercise to do it also does not mean that the author knows how to do it
 it means none of these things it just means the author doesn't feel like
 doing it right now and showing it to you for whatever reason could be because
 they are lazy it could be because I don't know how to do it could be because
 they feel that they should know how to do it but they don't really do know
 how to do it could be any of these reasons don't be deceived when you see
 something like this but of course I had to actually produce an expression
 function of this type in order to implement my curry forward language because
 as I will show in a moment we need to be able to implement all these has
 code in order to help approver so why is that we believe the mathematicians
 that the new rules are equivalent to the old rules which means that if
 you find a proof using these rules somehow you should be able to find the
 proof also using our initial rules which means that if you found that proof
 it would easily translate that to code because each step here is directly
 corresponding to a certain code expression as we have seen at the beginning
 of this tutorial these cold expressions from each of these operations so
 in order to do this with new rules in other words in order to create code
 from proof using new rules we need to show equivalence or we need to show
 how to get code out of each of the new rules now proof of a sequence means
 that we have some expression let's say T what uses variables a B and C
 of these types and expression itself has type G and also as I have shown
 this could be conveniently seen as a function the T as a function from
 a B and C from these three arguments to the type G so for each sequencing
 a proof we should be able to show either that it follows from an axiom
 one of these or that it show it follows from a derivation rule and the
 derivations all transforms one proof into another the axioms are just fixed
 expressions as we had before the axiom that actually didn't change between
 our initial formulation of the logic and the new calculus lgt they actually
 did not change the derivation rules changed each new derivation rule means
 that you're given expressions that prove the sequence in the numerator
 one or more and you are out of these expressions somehow you have to construct
 an expression that proves this sequence now when I say an expression proves
 the sequence what it means is that expression has the type that is described
 by the sequence it's the same thing because we described types of expressions
 through sequence and only those sequence that correspond to valid and existing
 expressions in the programming language only those sequence can be proved
 by the logic this is by construction so now we need to just find what are
 these expressions that corresponds to each of the derivation rules in each
 rule has a proof transformer function as I call it and the proof transfer
 function is explicitly a function that takes one or more expressions that
 are in the numerator and converts that to the expression in the denominator
 that has this type so it has an expression as it has an explicit function
 we need to write down for each of the derivation rules so let's see how
 this is done for these two examples of derivation laws first example have
 a rule that says if you want to derive this sequence we need to derive
 these two sequence now this sequence represents an expression of type C
 which uses an expression of type A plus B so let's represent this as a
 function from a plus B to C now we will be able to just ignore these other
 premises which are common arguments and all these functions we just pass
 them and we don't write them out what is the proof transformer for this
 derivation rule the proof transformer for it is a function that has two
 arguments t1 which is the proof of this must be a function of type II to
 see and t2 which is a proof of this sequence which must be a function of
 type B to see now earlier I said that sequence represent expressions that
 use certain variables but equivalently we can say these are functions that
 take these variables and return these expressions that's more convenient
 when you implement this in code so what we need is a function that takes
 a to C and B to C and returns a function from a plus B to C and this is
 the code that does it we take an argument of type a plus B and we return
 a match expression if it's in the left we applied t1 to that value and
 we get to see if it's in the right we apply t2 to that value and we get
 a C so in any case we get a syllabus so this is a function from a plus
 B to C as required another example is the proof transformer for this rule
 this rule has one sequence going to one sequence so in order to transform
 is proof into this we need a function that takes argument of type A to
 B to C to D and returns a function of type tuple a B going to C to D so
 here's the code we take a function f of type A to B to C to D we return
 a function that takes a G of this type shown here in blue and return we
 need to return a D so how do we get a deal we apply F to a function of
 type A to B to C so we create that function out of G X of type a going
 to Y of type B going to G of x1 so this is a function of type A to B to
 C which is the argument of F as required and the result is of type D so
 that is what we write so this kind of code is the proof transformer for
 this derivation arrow and we need to produce this proof transformers for
 every rule of the calculus lgt and I have done it because I have implemented
 the Korea Howard library that uses LG T so I'll must have done it for each
 flow this is a bit tedious because there are many of those rules and you
 need to implement all this machinery of passing arguments no matter how
 many in this gamma which are emitted from this notation for brevity but
 in of course in the real code you have to deal with all that too so let's
 see how this works on an example because once the proof tree is found we
 need to start backwards from the leaves of the tree back to the root on
 each step we take the proof expression apply the proof transformer to ative
 according to the rule that was used on that step we get a new proof expression
 and so on so for each sequence we will get a proof expression and at the
 end we'll have a proof expression for the root sequence and that will be
 the answer so I will denote denote by T I the proof expressions for the
 sequence s hi so starting from s6 s6 was this sequence in our proof so
 I mean yes just just going through the proof example it was here backwards
 from a 6 back to a 0 s-six was this it followed from axiom identity it's
 proof expression t6 is a function of two variables these two variables
 of these two types and this function just returns the second variable so
 it's a function of RR q and r and just denote this by our argued and Garibaldi'
s types r RQ variable of this type is hard here so this function is very
 simple just ignores the first argument and returns or so that is what the
 axiom does the next sequence was as to as to was obtained by rule our implicati
on or right implication from s 6 so the proof transformer for right implication
 let's look at the right implication and see what the proof transformer
 must be so we are given this sequence for this expression which is the
 function body the function body that uses a variable of type a somehow
 out of this we need to produce a function expression that takes an argument
 of type a and returns that functional body so this is the code which is
 just writing a new argument returning the function body that was our proof
 transformer we need to convert function body into a function so we just
 write that argument and arrow in the function body so in our case we need
 this as a function body and so our t2 is a function of our Q and this function
 is this the sequence s 3 followed from the axiom and so it was just this
 function this is just the identity function then we used the left implication
 so this was actually still done in the calculus algae but the same thing
 works in the calculus lgt I'm just using algae because it's simpler for
 example here proof transformer for the left implication is a little more
 complicated and so if you look at it what what does it have to be it takes
 these two expressions and returns this expression so it takes a function
 from A to B to a and from B to C and it returns a function from A to B
 to see how does it do it given a function a to b you use this to derive
 a from it then you substitute that a into the function into B you get a
 B when you use this to derive see from that B and that's your C so you
 use this function a to be twice you put it in here once and then you get
 an A and substitute back into the same function when you get a B then you
 use that and that's exactly what the proof transformer does it takes this
 rrq and it uses it twice substitutes into it something that was obtained
 from one of the terms and then uses the second term on the result so then
 this is the proof transformer for the rule left implication the result
 of the proof transformation is the proof for the sequence s1 finally we
 use the right implication again which is just this function construction
 and we get the proof expression for the sequence s0 now this proof expression
 is written through these t1 t2 t3 we have to substitute all this back in
 order to get the final expression so if we substitute first of all we find
 this is our our cubone going to tea one of our cutie one of our queue is
 this so we have to put it here now t3 is just identity so we can just remove
 that so that gets you riq going to our Q of T 2 T 2 is less if I have to
 put it in T 6 is just identity on R so this is our going to our and so
 finally you have this expression so that is the final code that has the
 required type notice that we have derived this code completely algorithmic
 to it there was no guessing we found which rules applied to the sequence
 with transformed sequence according to the rules once we found the proof
 which was if we use the calculus ljt the proof will be just a finite tree
 with no loops it will terminate you can get an exhaustive depth-first search
 for it for example and you find all the possible proofs if you want as
 well well you will find many in any case in some for some expressions and
 then we use the proof transformers which are fixed functions that you can
 upfront compute for each these expressions are proof transformers applied
 to the previous proofs so these are completely fixed algorithmically fixed
 so we have derived this code completely algorithmically given this expression
 this type so it is in this way that the career Howard correspondence allows
 us to derive the code of functions from there type signatures another important
 application of the correspondence is to analyze type by some morphisms
 or type equivalences and I was led to this by asking the question so in
 this logic or in the types are these operations plus and times as I denoted
 them more like logic more like the disjunction and conjunction or are they
 more like arithmetic plus and times because this is kind of not so clear
 right away our logic is this intuitionistic logic it in any case this is
 different from boolean logic so what are the properties of these types
 really so are the properties such that it is better to think about these
 operations as plus and times rather than logical conjunction and disjunction
 can answer this question I looked at identities that we have in the water
 these are some identities from simple ones obvious ones to less obvious
 identities like this the equal sign here stands for implication in both
 directions so both this implies that and vice versa because of this each
 of the implications means a function so since these are all identities
 in logic it means that for example the implication from here to here is
 a theorem of logic and so it can be implemented as we know all our identities
 in logic can be implemented in code and we even have an algorithm now that
 can automatically produce proofs and automatically produce code so that
 means for any of these identities that has some ik some expression X on
 the left and some Y on the right so some kind of X equals y we have X implies
 Y and y implies X if we convert that to code we will have a pair of functions
 function from X to one and the function from Y to X what do these functions
 do well they convert values in some ways from type X to type Y and back
 so do these functions Express the equivalence of the types x and y so that
 any value of type X can be converted to some equivalent value type while
 and back without any loss of information is that so that was the question
 I asked I looked at some examples well first what does it mean more rigorously
 that types are equivalent for as mathematicians say isomorphic the types
 are isomorphic and we will use this notation for that if there is a one-to-one
 correspondence between the sets of values of these types and in order to
 demonstrate that we need a pair of functions one going from A to B the
 other going from B to a such that the composition of these functions in
 both directions is equal to identity function so F compose G or F value
 G will give you from A to B and then from B to a is back so that would
 be identity of a to a this will be identity of B to B if this is true if
 the composition is identity it means we indeed did not lose any information
 let's consider an example this is an identity in the logic a conjunction
 with one is equal to a in Scala the types responding to the left and the
 right hand sides of this conjunction all of this are equivalent are the
 conjunction of a and unit and a itself now we need functions with these
 types indeed we can write functions is having these types a pair of a and
 unit we need to produce an a out of that we'll just take the first element
 of the pair you are done take an X of type a will produce tuple of a and
 unit very easy just put a unit value in the tuple in here done and it's
 easy to verify that composition of these functions will not change any
 values so it will be identity in both directions another example this is
 an identity in logic if this is understood as a disjunction one or a or
 true or a is true that is an identity in logic for theorem in the logic
 are the types equivalent though the type for 1 plus a is the option in
 Scala it is option in Haskell at is called maybe this type is standard
 library type in pretty much every functional programming language now option
 of a is a disjunction of one or unit and a it is certainly not equivalent
 to just unit because this type could contain a value of a in it but this
 could not so there is no way that you could transform this type to this
 and then back without losing information you could transform so since this
 is a theorem you have functions from this type to this type and back some
 functions you have them but these functions do not compose to identity
 they cannot because what if you had a here you must map it into unit from
 this unit back you must map into this unit you cannot get an a out of unit
 and so that will erase this information and that cannot become isomorphism
 so we see that some logic identities do yield isomorphism types but others
 do not why is that let's look at some more examples to figure out why in
 all these examples we can implement functions F 1 and F 2 between the two
 sets to two types in both directions and then we can check we certainly
 can implement them because these are logical identities but then we can
 check if the compositions are identity functions and if so the types are
 isomorphic but we find that in the first three examples we can do it but
 in this last example we can note now I have written the logical identities
 logical theorems with the arithmetic notation I call this arithmetical
 notation because this suggests arithmetic operations plus and times and
 if you look at these identities this looks like a well-known algebraic
 identity from the school algebra in this too but this certainly seen your
 own as an arithmetic as an as an arithmetic identity this is certainly
 not true in arithmetic it is true in logical if you replace this with disjuncti
on and this with conjunction this is an identity in logic so this suggests
 an interesting thing if you replace disjunction by plus and conjunction
 by x and the result is an identity in arithmetic then it is an isomorphism
 of types otherwise it is not let's see why this is so indeed this is so
 I call this the arithmetic arithmetic oh very hard correspondence to see
 how it works let's consider only the types without loss of generation of
 generality that have a finite set of possible values for example a boolean
 type has only two possible true and false integer let's say in the computers
 all the integers are fine nights ago so those types have a finite set of
 possible values and this does not limit our generality because in the computer
 everything is finite all types have a finite set of possible values now
 let's consider how many values a given type has so that would be the size
 of the type or using the mathematical terminology it's called a cardinality
 of the type so let's see what is the cardinality of various type constructions
 the sum type for example if the cardinality of types a and B is known and
 the cardinality of a plus B the sum type the disjunction of a and B is
 the sum of the two cardinalities or sizes this is because a value of the
 disjunction type is constructed as either a value of the first part or
 a value of the second part and so you cannot have both together and so
 obviously the different number of values is just the sum of the two sizes
 that the number of different values of the sum type is just the sum of
 the numbers of different values of types a and B for the product type again
 we have an interesting thing it's the arithmetic product of the sizes of
 a and B because for every a value you could have an arbitrary B value so
 this is a direct product or transient product of sets and we have school
 level identities about the operations plus and times such as these identities
 or these all of these identities are valid for arithmetic and they show
 if you translate that into statements about the sizes of types they show
 that the size of the type on the left is equal to the size of the type
 on the right and that is very suggestive in other words if you take a identity
 like this and you compute the size of the type on the left and the size
 of the type on the right you get an arithmetic identity of the sizes but
 you don't get that identity here because the earth medical formula is not
 right this is very suggestive if the sizes are equal and maybe the types
 are equivalent or isomorphic when the sizes are not equal then certainly
 they cannot be equivalent the function type very interestingly also is
 described in the same way it provides the set of all maps between the two
 sets of values so for example from integer to boolean that would be all
 the functions that take some integer and return some boolean so that's
 and a number of boolean values ^ the number of integer values that's how
 many different functions you can have as a combinatorial number so it's
 an exponential and so the size of the type of function a to be is the size
 of the type of B ^ the size of type of a and again we have all the school
 identities about powers and how to multiply powers and so on and they are
 directly translated into these three identities if you take the sizes of
 the types on the left and on the right the sizes will be equal due to these
 three identities since the sizes are equal it's very likely that the type
 our actual equivalent so far haven't seen any counter examples to this
 in these constructions so this gives us a meaning of the Curie Howard correspon
dence so far we have seen three facets of the curly Howard correspondence
 one is the correspondence between types and logical formulas two is the
 correspondence between code and proofs and three the correspondence between
 the cardinality of a type or the set size of the type and the arithmetic
 identities that we have in the school algebra about these types so arithmetical
 identities signify type equivalence or isomorphism while logic identities
 only talk about how you create some value of this type out of value of
 another type so that does not guarantee that it preserves information it
 just guarantees that you can implement some function of that type it doesn't
 tell you that the function will be an isomorphism so if one type is logically
 equivalent to another it means are equally implementable if one is implementabl
e another is also implementable but no more than that whereas arithmetical
 identities actually tell you about isomorphism of types therefore if you
 look at types and write them using my preferred notation which is using
 the arithmetic all symbols instead of logical symbols instead of these
 I'll use these symbols if I do that this is very suggestive of a possible
 isomorphism of types then it becomes very easy for me to reason about types
 I can see right away that these two are isomorphic types or that these
 two are isomorphic types because I am used to looking at school algebra
 it's very obvious then that this is not an isomorphism of types because
 this doesn't make sense in the school algebra so reasoning about isomorphic
 types is basically school level algebra involving polynomials and powers
 so if you are familiar with all these identities as you should be it will
 be very easy for you the reason about what types are equivalent as long
 as all these types are made up of constants or primitive types disjunctions
 tuples or conjunctions and functions which will then directly be translated
 into exponential polynomial expressions constants sums products and expand
 powers or Exponential's so I call these exponential polynomial types that
 is types built up from these type constructions so all we have been talking
 about in this tutorial is what I call exponential polynomial types these
 are the basic type constructions that I started with tuple product function
 exponential disjunction some unit constant or 1 now just one comment that
 in the functional programming community today there is a terminology algebraic
 types so people usually call algebraic types the types that are made from
 constant types sums and products excluding Exponential's I do not find
 this terminology it's very helpful I find it confusing because what is
 particularly an algebraic about these identities these are identities of
 school algebra the properties of the function type are described by algebraic
 identities like this so it would be strange to call the function type not
 algebraic whereas these types are algebraic they are very similar to each
 other in terms of their properties being described by identity is known
 from school algebra so instead of algebraic types I would prefer to say
 polynomial types this is much more descriptive and precise and if you want
 to talk about function types as well then you just can you can just say
 exponential polynomial types or exfoli types for short so by way of summarizing
 what we have done so far what are the practical implications of the career
 Howard correspondence so one set of implications is actually for writing
 code and reason and eternal code one thing we can do now is if we're given
 a function with some type and usually this will be typed with type parameters
 all type trainers fully parametric types such as the function we have been
 considering here all these functions do not have any types that are specific
 like integer or string all the types are fully parametric and then there
 are some constructions some type expressions made out of these types so
 these are what I call fully parametric functions for these functions we
 have a decision procedure an algorithm that based on the ljt calculus which
 decides whether this function can be implemented in code and computer scientist
s a type is inhabited if you can produce a value of this type in your program
 so CH of T is this proposition which they call type is inhabited and I
 prefer to call it just that you can compute a value of this type or code
 has the type O code can create a value of this type and so we have a algorithm
 that can also generate the code from type when it is possible if it is
 not possible the algorithm will tell you so often not always but often
 this algorithm can be used actually to generate the code you want we can
 also use what I call the arithmetic of glory Harvard correspondence to
 reason about type isomorphisms and to transform types isomorphic we simplify
 type expressions just like we simplify expressions in school level algebra
 by expanding brackets by permuting the order of terms like a plus B is
 equal to B plus a or associativity a times B all times C can be expanded
 and so on so this allows us once we have written types in the short notation
 in the notation that I prefer which resembles school algebra because it
 uses the plus and times symbols instead of the logic symbols so once we
 rewrite our types and this notation which I have been doing consistently
 in this tutorial it enables us the reason very easily but which types are
 equal or isomorphic because we are all familiar with the school level algebra
 what are the problems that we cannot solve using this knowledge one thing
 we cannot do is to generate code automatically such that it will be an
 isomorphism so for instance in an example here we are able to generate
 automatically the code of these functions but it will not be an isomorphism
 and the lgt algorithm cannot check that this is nice a morphism that's
 the important thing this algorithm does not know about equations or isomorphism
s it only knows that it found some code that has the type you wanted whether
 this code is useful to you or not we don't know the algorithm doesn't know
 this also if the algorithm finds several such several proofs of a sequence
 it will generate several not in equivalent versions of your code it doesn't
 know which one is is useful maybe some of them are useless maybe not the
 algorithm cannot automatically decide that in general another thing we
 cannot do is to express complicated conditions via types such as that array
 is sorted the type system is not powerful enough in all the languages I
 listed you need a much more powerful type system such as that in the programmin
g language interests or add them or cook those are much more powerful type
 systems that can express such complicated conditions but for those type
 systems there is no algorithm that will generate code another thing we
 cannot do is to generate code that has type constructors such as the map
 function here's an example in Scala this is a map function on a list so
 there's the list of a a is a type parameter and then we say dot map and
 map has another type frame to be it takes a function from A to B for any
 B so a is fixed but now from any B we can take a function from A to B and
 generate a list of B so if we wrote this formula in the short type notation
 this would look something like this I'm writing subscript a because this
 is a type parameter so this is like an argument or a type parameter I'm
 writing it like this and then from this this is the first argument of the
 function and then there is a second argument which is this F and that is
 another quantifier for B inside parentheses so this formula has a quantifier
 inside so far we have been dealing with formulas that have all quantifiers
 outside and so we never write quantifiers explicitly but here we have to
 write them inside this is a more powerful logic which is called first-order
 logic in other words this is a logic where you have quantifiers anywhere
 in the formula including inside the formula unfortunately this logic is
 undecidable so there is no algorithm that we can use either to find the
 proof and therefore code freedom type or to show that there is no proof
 no code so we're kind of stuck in all these directions some more remarks
 about the curry Harvard correspondence first is that only with parameterize
 types we can get some interesting information out of it if we take concrete
 types like integer then the proposition CH event meaning that our code
 can have a value of type int it that's always true can always write any
 some integer value we don't need any previous data for it so for all specific
 types all these propositions are always choice completely void of information
 the only interesting part comes when we start considering type variables
 if we start asking can we make a type which is either of a B going to a
 going to B in soon for all a B once we start doing this with type parameters
 a B and so on then we get interesting information as we have seen in this
 tutorial another remark is that functions like this one are not sufficiently
 described by their type so that this is the type of integer going to integer
 now looking at this type we can put this into a sequence but we'll never
 get enough information to actually get this function so only certain class
 of functions which are fully typed biometric their type signature is informativ
e enough so that we can derive code automatically only in much more powerful
 type systems you can have type information that is enough to specify fully
 a code like this another caveat is that I don't know the proof that arithmetic
 identity guarantees the type equivalence it is certainly a necessary condition
 because if two types have different cardinality or different size of their
 sets of values that they cannot be equivalent or they cannot be isomorphic
 so this is a necessary condition but it's not a sufficient condition it
 looks like I don't know if this is sufficient I haven't seen any counter
 examples so far final remarks about type correspondence the logical constant
 false did not appear in any of my slides so far this was on purpose it
 has extremely limited practical use in programming languages because actually
 we have types corresponding to false Scala has type called nothing Haskell
 has type usually called void that corresponds to the logical constant false
 what does it mean CH of nothing is false it means your code can never have
 a value of type nothing or in Haskell void you can never compute a value
 of this type so clearly it has a very limited practical significance you
 will never be able to compute any values of this type ever in any program
 it's identically falseness this constant so if you want to add it to the
 logic it's very easy you just have one rule and you're not done you can
 derive things with it if you want but they will have almost never any use
 in practical code also we did not talk about negation none of the calculus
 calculate that I should have in logical negation as in operation again
 for the same reason we do not have a programming language construction
 that represents logical negation negation by definition is like this is
 an application from 8 to 4 so that's not a not a means from a follows falsehood
 now since you cannot ever get false in a programming language you cannot
 really implement this function in any useful sense and so i have seen some
 haskell library that used this type void as a type parameter in some way
 but certainly it's a very limited and rare use and so it is not really
 lumen 18 to include negation it could probably find some very esoteric
 uses of it but almost never useful and finally there is another set of
 important implications from the Kurihara correspondence these are implications
 for people who want to design new programming languages as we have seen
 the Karaka with correspondence maps the type system of a programming language
 into a certain logical system where prepositions follow from each other
 or can be proved from each other and this enables us to reason about programmed
 to see what kind of code can be written if some other kind of code can
 be written and logical reasoning is very powerful it's simpler than trying
 to write code and it gives you algorithms and all kinds of mathematical
 results that have been found over the centuries so languages like those
 listed here have all the five type constructions that I wasted in the beginning
 of this tutorial and mapping them into logic gives a full constructive
 logic or full intuitionistic logic with all logical operations and or so
 conjunction disjunction implication and the truth constant whereas languages
 such as C C++ Java and c-sharp and so on they're mapped to incomplete logics
 because they do not have some of these operations for instance they do
 not have type constructions of correspond to disjunction we also do not
 have the true constant or the false constant so they are mapped to a logic
 that lacks some of the foundational logical operation so it can be only
 fewer theorems can be proved in that logic and so your reasoning about
 theory types is hampered languages called scripting languages sometimes
 such as Python or JavaScript will be and so on also our belongs there in
 that line those languages only have one type they actually don't check
 types at compile time and so they're mapped to logics with only one proposition
 those logics are extremely small in terms of what kind of things you can
 reason about and so if you write a program in these languages you are completel
y unable to reason at the level of types whereas in these languages you
 are able to reason but in a limited way you're not having a complete logic
 so this suggests a principle for designing the type system in a new programming
 language the first step would be to choose a good and complete logic that
 is free of inconsistency mathematicians have studied all kinds of logics
 and they are always interested in questions such as is this logic consistent
 consistent means you cannot derive false from true is this logic complete
 can you derive all things that are true are there enough axioms and rules
 of derivation or maybe there are too many axioms and rules of derivation
 you can delete some of them and have fewer mathematicians have always been
 interested in such questions they found all kinds of interesting logics
 where you can derive a lot of interesting theorems non trivial theorems
 and they found the minimum sets of axioms and rules of derivations for
 these logics use their results take one of the logics that they do them
 and develop such as intuitionistic logic model logic temporal logic linear
 logic and so on take one of these logics for each of the basic operations
 of this logic provide type constructions in your programming language that
 are easy to use for instance your logic has disjunction implication or
 something else provide a type constructor for each of them that's easy
 to use easy to write down such as provided by the languages we have seen
 then every type will be mapped to a logical form of the OPF logical formula
 for every type and there will be a type for every logical formula and then
 for each rule of the new logic for each derivation rule there should be
 a construct in the code that corresponds to it so that you could transform
 proofs in logic into code and code into proofs if you do that your language
 will be faithful to the scorecard correspondence you will be able to use
 logic to reason about your language and one important result at this level
 while we have seen that you can sometimes generate code that is maybe nice
 but a very important result is that if your logic is free of inconsistency
 it means that no program will ever be able to derive an inconsistent an
 inconsistent type means that you had a function that requires some type
 a but it was called with a different type beam which is incompatible and
 that basically crashes so in languages like C and C++ we have all kinds
 of crashes like a segmentation fault in Java the exceptions nullpointerexceptio
n or class cast exception which happens when you call a function on the
 wrong type of argument and that happens if your logic is inconsistent if
 your logic can derive incorrect statements from correct premises then if
 you translate that derivation into code and the that code will derive incompati
ble type at the wrong place and it will crash the crash will happen at runtime
 the compiler will not catch this inconsistency because the compiler only
 checks the logic of types and the logic checks out you have followed the
 rules of derivation of the logic the compiler can check out all these logical
 rules but the compiler does not know that your logic is inconsistent maybe
 and then it will deep have derived an inconsistent result falsehood from
 truth for example and that will crash at runtime now we know that crashing
 at runtime is not a good outcome so in fact languages like Oh camel have
 been studied and for other languages some subsets of Haskell I believe
 called safe Haskell have been studied and it has been shown that they cannot
 crash and they're the way to show it mathematically is to use the fact
 that they are based on a complete and consistent logic and then all you
 need to show is that your compiler does not have some critical bugs that
 allow it to oversee that you have not followed the derivation rules of
 the logic that is an extremely valuable feature of functional programming
 languages that are based on the Curie habit correspondence you can prove
 their safety at compile time or at least exclude a large number of possible
 bugs and errors certainly these languages are quite large and they include
 features that are not covered by the Carey Hart correspondence type constructor
s that I have not considered in this tutorial and those might may not be
 safe but at least the foundation of these languages the foundation of the
 type system will be safe so that is the final lesson from the great Howard
 correspondence this concludes the tutorial 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Parametricity theorem and naturality laws
\begin_inset CommandInset label
LatexCommand label
name "app:Proofs-of-naturality-parametricity"

\end_inset


\end_layout

\begin_layout Standard
Functional programming (FP) focuses on a small set of language features
 — the six type constructions and the nine code constructions
\begin_inset Index idx
status open

\begin_layout Plain Layout
nine code constructions
\end_layout

\end_inset

, introduced in Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Type-notation-and-standard-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

; see also Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Mathematical-notation-for-basic-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 These constructions create 
\series bold
fully parametric
\series default
 programs
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code
\end_layout

\end_inset

 and are sufficient to implement all design patterns of FP.
 At the same time, restricting programs to be fully parametric will enable
 several ways of mathematical reasoning about code.
 Examples of such reasoning are treating programs as mathematical values
 (referential transparency); deriving the most general type from code (type
 inference); and deriving code from type (code inference).
\end_layout

\begin_layout Standard
Another property of fully parametric code is automatic adherence to naturality
 laws.
 According to the 
\series bold
parametricity theorem
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
parametricity theorem|textit
\end_layout

\end_inset

, any fully parametric function will satisfy one naturality law for each
 type parameter.
 Not having to derive and verify naturality laws by hand saves a lot of
 time.
\end_layout

\begin_layout Standard
\begin_inset Wrap table
lines 0
placement l
overhang 0in
width "56col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset VSpace -20baselineskip%
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala example
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
unit or a 
\begin_inset Quotes eld
\end_inset

named unit
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
product type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
co-product type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
function type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[F[_]]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Fix}^{F^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!type constructions
\end_layout

\end_inset

The six type constructions of fully parametric programs.
\begin_inset CommandInset label
LatexCommand label
name "tab:six-pure-type-constructions"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -20baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Code construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala example
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Code notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1.
 Use unit value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2.
 Use given argument
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
3.
 Create function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => expression
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x\rightarrow expression$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
4.
 Use function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f(x)$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $x\triangleright f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
5.
 Create tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a\times b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
6.
 Use tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (a, b) => ...
 }
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a\times b\rightarrow...$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $p\triangleright\pi_{1}$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $p\triangleright\pi_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
7.
 Create disjunctive value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](a)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "19col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset VSpace 20baselineskip%
\end_inset


\begin_inset Formula $a^{:A}+\bbnum 0^{:B}$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Formula $\begin{array}{|cc|}
a & \bbnum 0\end{array}$
\end_inset


\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
8.
 Use disjunctive value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p match { case Left(a)   => f(a)            case Right(b)  => g(b)     
     }
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "23col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset VSpace 20baselineskip%
\end_inset


\begin_inset Formula $p\triangleright\,\begin{array}{|c||c|}
 & C\\
\hline A & f\\
B & g
\end{array}\,~\text{ or }~p\triangleright\,\begin{array}{||c|}
f\\
g
\end{array}$
\end_inset


\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
9.
 Recursive call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f(x) = { ...
 f(y) ...
 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x)\triangleq...~\overline{f}(y)~...$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code constructions
\end_layout

\end_inset

The nine code constructions of fully parametric programs.
\begin_inset CommandInset label
LatexCommand label
name "tab:nine-pure-code-constructions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Philip Wadler
\end_layout

\end_inset

P.
\begin_inset space ~
\end_inset

Wadler's paper 
\begin_inset Quotes eld
\end_inset


\emph on
Theorems for free
\emph default

\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps"

\end_inset


\family default
 and some further explanations in the blog posts 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://reasonablypolymorphic.com/blog/theorems-for-free/"

\end_inset


\family default
 and 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://bartoszmilewski.com/2014/09/22/"

\end_inset


\end_layout

\end_inset

 derives the parametricity theorem from J.
\begin_inset space ~
\end_inset

Reynolds's 
\begin_inset Quotes eld
\end_inset

abstraction theorem
\begin_inset Quotes erd
\end_inset

.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
John Reynolds
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See the 
\begin_inset CommandInset href
LatexCommand href
name "paper"
target "https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf"
literal "false"

\end_inset

 by J.
\begin_inset space ~
\end_inset

Reynolds, 
\begin_inset Quotes eld
\end_inset


\emph on
Types, abstraction, and parametric polymorphism
\emph default

\begin_inset Quotes erd
\end_inset

, Information Processing
\begin_inset space ~
\end_inset

83, p.
\begin_inset space ~
\end_inset

513 (1983).
\end_layout

\end_inset

 The Reynolds-Wadler approach is based on replacing functions by 
\begin_inset Quotes eld
\end_inset

relations
\begin_inset Quotes erd
\end_inset

 (both between types and between values).
 One first needs to learn the rules for working with relations.
\begin_inset Foot
status open

\begin_layout Plain Layout
Tutorials on that subject are rare; one is the 
\begin_inset CommandInset href
LatexCommand href
name "paper"
target "https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions"
literal "false"

\end_inset

 by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ronald Backhouse
\end_layout

\end_inset

R.
\begin_inset space ~
\end_inset

Backhouse, 
\begin_inset Quotes eld
\end_inset

On a relation on functions
\begin_inset Quotes erd
\end_inset

 (1990).
 See also the 
\begin_inset CommandInset href
LatexCommand href
name "book"
target "https://themattchan.com/docs/algprog.pdf"
literal "false"

\end_inset

 by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bird
\end_layout

\end_inset

R.
\begin_inset space ~
\end_inset

Bird and O.
\begin_inset space ~
\end_inset

de Moor, 
\begin_inset Quotes eld
\end_inset

The algebra of programming
\begin_inset Quotes erd
\end_inset

 (1997),
\begin_inset Note Note
status open

\begin_layout Plain Layout
Solutions to exercises are available here: 
\begin_inset CommandInset href
LatexCommand href
target "https://web.archive.org/web/19981205052219/http://www.comlab.ox.ac.uk/oucl/publications/books/algebra/book.html"

\end_inset


\end_layout

\end_inset

 and Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relations-between-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in this book.
\end_layout

\end_inset

 Then the parametricity theorem gives a statement about certain properties
 of relations.
 To derive a naturality law for functions, all relations must somehow be
 replaced by functions.
 
\end_layout

\begin_layout Standard
Adapting the parametricity theorem to the needs of FP practitioners, this
 Appendix derives the naturality laws and other properties of fully parametric
 code.
 In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Commutativity-laws-for-type-constructors"
plural "false"
caps "false"
noprefix "false"

\end_inset

, it is shown by a direct proof that fully parametric type constructors
 obey commutativity laws.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Naturality-laws-for-fully-parametric-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows, without using relations, that fully parametric functions satisfy
 dinaturality laws (a generalization of naturality laws to arbitrary type
 signatures).
 An important consequence, proved in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Uniqueness-of-functor-and-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

, is that there is a unique lawful code implementing the functor and contrafunct
or type classes.
 Finally, Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Parametricity-theorem-for-relations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 explains the relational approach to parametricity and proves the relational
 parametricity theorem.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Additional literature:
\end_layout

\begin_layout Plain Layout
[1]: Girard, J.-Y.; Scedrov, A.
 & Scott, P.
 J.
 Normal Forms and Cut-Free Proofs as Natural Transformations.
 Logic From Computer Science, Mathematical Science Research Institute Publicatio
ns 21, Springer-Verlag, 1992, 217-241.
 http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.811
\end_layout

\begin_layout Plain Layout
[2]: Bainbridge, E.
 S.; Freyd, P.
 J.; Scedrov, A.
 & Scott, P.
 J.
 Functorial polymorphism.
 Theoretical computer science, Elsevier, 1990, 70, 35-64.
 https://core.ac.uk/display/82270459
\end_layout

\begin_layout Plain Layout
[3]: De Lataillade, J.
 Dinatural Terms in System F.
 Logic in Computer Science, 24th Annual IEEE Symposium, 267-276, 2009.
 https://www.irif.fr/~delatail/dinat.pdf
\end_layout

\begin_layout Plain Layout
[4]: Pistone, P.
 On completeness and parametricity in the realizability semantics of System
 F.
 https://arxiv.org/abs/1802.05143
\end_layout

\begin_layout Plain Layout
See discussion here: https://cstheory.stackexchange.com/questions/42256/is-case-an
alysis-on-normal-forms-of-lambda-terms-sufficient-to-prove-parametrici
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The restriction to 
\emph on
fully parametric
\emph default
 programs
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!program
\end_layout

\end_inset

 is essential and excludes, for instance, any use of mutable variables,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 values, exceptions, run-time type identification, run-time code loading,
 or code defined in external libraries that are not known to be fully parametric.
 Code that use those features of Scala is not covered by the parametricity
 theorem and may violate naturality laws.
 An example of such code is the following function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def headOptBad[A]: List[A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case Nil                   => None
\end_layout

\begin_layout Plain Layout

  case (head: Int) :: tail   => Some((head + 100).asInstanceOf[A])
\end_layout

\begin_layout Plain Layout

  case head :: tail          => Some(head)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code has no side effects, is purely functional and referentially transparen
t.
 However, the code behaves differently when the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is set to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 than for all other types.
 So, the code does not work in the same way for all type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 This leads to a failure of the naturality law:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> headOptBad(  List(1, 2, 3).map(x => s"value = $x")  )
\end_layout

\begin_layout Plain Layout

res0: Option[String] = Some(value = 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> headOptBad(List(1, 2, 3)).map(x => s"value = $x")
\end_layout

\begin_layout Plain Layout

res1: Option[String] = Some(value = 101)
\end_layout

\end_inset

This shows that full parametricity is a stronger restriction on code than
 referential transparency.
\end_layout

\begin_layout Standard
Here is an example of fully parametric code that uses all nine constructions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = {      // 3
\end_layout

\begin_layout Plain Layout

   case Nil            => Nil
\end_layout

\begin_layout Plain Layout

//   8   1                1,7 
\end_layout

\begin_layout Plain Layout

   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
\end_layout

\begin_layout Plain Layout

//   8       6             2 4     6  5 2 4     6    7   9
\end_layout

\begin_layout Plain Layout

}  // This code uses each of the nine fully parametric constructions.
\end_layout

\end_inset

For instance, the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head :: tail
\end_layout

\end_inset

 is a tuple pattern that extracts the two parts of a tuple (construction
 6).
 The recursive call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(tail)
\end_layout

\end_inset

 corresponds to construction 9.
\end_layout

\begin_layout Section
Commutativity laws for profunctors and bifunctors
\begin_inset CommandInset label
LatexCommand label
name "sec:Commutativity-laws-for-type-constructors"

\end_inset


\end_layout

\begin_layout Standard
The bifunctor commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

) was introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Bifunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We will now prove that the commutativity law holds for any fully parametric
 bifunctors.
 The proof proceeds by induction on the type structure of a given bifunctor.
\begin_inset Foot
status open

\begin_layout Plain Layout
In the blog post 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://byorgey.wordpress.com/2018/03/30/"

\end_inset


\family default
, Brent Yorgey
\begin_inset Index idx
status open

\begin_layout Plain Layout
Brent Yorgey
\end_layout

\end_inset

 gave a proof of the commutativity law for bifunctors by using the Reynolds-Wadl
er relational parametricity theorem.
 The proof shown in the next section is direct and does not use relations.
\end_layout

\end_inset

 It turns out that the proof also requires the commutativity laws for type
 constructors with 
\emph on
contravariant
\emph default
 type parameters.
 All those proofs are completely analogous, so we will first prove the commutati
vity law for profunctors, which are type constructors with one contravariant
 and one covariant type parameter.
 The profunctor commutativity law will be important for the proof of the
 parametricity theorem via dinaturality (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Naturality-laws-for-fully-parametric-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsection
Proof of the profunctor commutativity law
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proof-of-the-profunctor-commutativity-law"

\end_inset


\end_layout

\begin_layout Standard
Given an arbitrary type constructor 
\begin_inset Formula $P^{A,B}$
\end_inset

 contravariant with respect to 
\begin_inset Formula $A$
\end_inset

 and covariant with respect to 
\begin_inset Formula $B$
\end_inset

, we formulate the profunctor 
\series bold
commutativity law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
commutativity law!of profunctors
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
profunctor!commutativity law
\end_layout

\end_inset

 by analogy with the bifunctor law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
\text{commutativity law of }P:\quad & \text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})\bef\text{fmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})=\text{fmap}_{P^{C,\bullet}}(g)\bef\text{cmap}_{P^{\bullet,D}}(f)\quad,\nonumber \\
\text{in a shorter notation}:\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.\label{eq:profunctor-commutativity-law}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "38col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -170baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{6.0pc}P^{C,B}\ar[r]\sp(0.55){\text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})~~~}\ar[d]\sb(0.45){\text{fmap}_{P^{C,\bullet}}(g)} & P^{A,B}\ar[d]\sb(0.45){\text{fmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})}\\
P^{C,D}\ar[r]\sb(0.45){~~~~\text{cmap}_{P^{\bullet,D}}(f)} & P^{A,D}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -170baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now prove that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for any 
\series bold
fully parametric profunctor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!profunctor
\end_layout

\end_inset

 
\begin_inset Formula $P^{A,B}$
\end_inset

, i.e., a profunctor defined via a combination of the six type constructions
 from Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We will assume that all contrafunctor liftings such as 
\begin_inset Formula $f^{\downarrow P^{\bullet,B}}$
\end_inset

 and all functor liftings such as 
\begin_inset Formula $g^{\uparrow P^{A,\bullet}}$
\end_inset

 are implemented as shown in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for functors and contrafunctors corresponding to each of the type constructions.
 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Uniqueness-of-functor-and-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show that the code from Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the only possible lawful implementation of the liftings.)
\end_layout

\begin_layout Standard
The proof goes by induction on the type structure of 
\begin_inset Formula $P^{A,B}$
\end_inset

.
 The base case contains the first two constructions (the unit type and the
 type parameter), which gives two possibilities: 
\begin_inset Formula $P^{A,B}\triangleq\bbnum 1$
\end_inset

 (constant profunctor) and 
\begin_inset Formula $P^{A,B}\triangleq B$
\end_inset

 (identity profunctor).
 The other possibility of using a type parameter, 
\begin_inset Formula $P^{A,B}\triangleq A$
\end_inset

, does not give a profunctor since 
\begin_inset Formula $P^{A,B}$
\end_inset

 must be contravariant in 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
The commutativity law holds for 
\begin_inset Formula $P^{A,B}\triangleq\bbnum 1$
\end_inset

 because all liftings are identity functions: 
\begin_inset Formula $\text{cmap}_{P^{\bullet,B}}(f)=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{P^{A,\bullet}}(g)=\text{id}$
\end_inset

.
 For the same reason, the law will also hold for the constant profunctor
 
\begin_inset Formula $P^{A,B}\triangleq Z$
\end_inset

 where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type (or a type parameter other than 
\begin_inset Formula $A$
\end_inset

 or 
\begin_inset Formula $B$
\end_inset

).
\end_layout

\begin_layout Standard
For the profunctor 
\begin_inset Formula $P^{A,B}\triangleq B$
\end_inset

, the law holds because 
\begin_inset Formula $\text{cmap}_{P^{\bullet,B}}(f)=\text{id}$
\end_inset

.
 So, the base case is proved.
\end_layout

\begin_layout Standard
The inductive step looks at the outer construction in the type expression
 of 
\begin_inset Formula $P^{A,B}$
\end_inset

, which must be one of product, co-product, function, or recursion.
 These constructions create larger type expressions out of smaller ones;
 for example, 
\begin_inset Formula $P^{A,B}\triangleq\left(A\rightarrow B\right)\times B$
\end_inset

 uses the product construction with sub-expressions 
\begin_inset Formula $A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, which can be viewed as profunctors 
\begin_inset Formula $R^{A,B}\triangleq A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $S^{A,B}\triangleq B$
\end_inset

.
 The inductive assumption is that the commutativity law is already proved
 for all sub-expression types (such as 
\begin_inset Formula $R^{A,B}$
\end_inset

 or 
\begin_inset Formula $S^{A,B}$
\end_inset

).
 We will then need to prove the law for the entire type expression 
\begin_inset Formula $P^{A,B}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Product type
\end_layout

\begin_layout Standard
If the outer level of 
\begin_inset Formula $P^{A,B}$
\end_inset

 is a product, we must have 
\begin_inset Formula $P^{A,B}=R^{A,B}\times S^{A,B}$
\end_inset

 where 
\begin_inset Formula $R^{A,B}$
\end_inset

 and 
\begin_inset Formula $S^{A,B}$
\end_inset

 are some profunctors.
 The code for liftings follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,B}}\triangleq f^{\downarrow R^{\bullet,B}}\boxtimes f^{\downarrow S^{\bullet,B}}\quad,\quad\quad g^{\uparrow P^{A,\bullet}}\triangleq g^{\uparrow R^{A,\bullet}}\boxtimes g^{\uparrow S^{A,\bullet}}\quad.
\]

\end_inset

By inductive assumption, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 already satisfy the commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we compute
\begin_inset Formula 
\begin{align*}
\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:\quad & \gunderline{f^{\downarrow P^{\bullet,B}}}\bef\gunderline{g^{\uparrow P^{A,\bullet}}}=\big(f^{\downarrow R^{\bullet,B}}\boxtimes f^{\downarrow S^{\bullet,B}}\big)\bef\big(g^{\uparrow R^{A,\bullet}}\boxtimes g^{\uparrow S^{A,\bullet}}\big)\\
\text{composition law~(\ref{eq:pair-product-composition-law})}:\quad & =\big(\gunderline{f^{\downarrow R^{\bullet,B}}\bef g^{\uparrow R^{A,\bullet}}}\big)\boxtimes\big(\gunderline{f^{\downarrow S^{\bullet,B}}\bef g^{\uparrow S^{A,\bullet}}}\big)\\
\text{inductive assumption}:\quad & =\big(g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}}\big)\boxtimes\big(g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}\big)\\
\text{composition law~(\ref{eq:pair-product-composition-law})}:\quad & =\big(\gunderline{g^{\uparrow R^{C,\bullet}}\boxtimes g^{\uparrow S^{C,\bullet}}}\big)\bef\big(\gunderline{f^{\downarrow R^{\bullet,D}}\boxtimes f^{\downarrow S^{\bullet,D}}}\big)=g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Co-product type
\end_layout

\begin_layout Standard
In this case, we must have 
\begin_inset Formula $P^{A,B}=R^{A,B}+S^{A,B}$
\end_inset

 where 
\begin_inset Formula $R^{A,B}$
\end_inset

 and 
\begin_inset Formula $S^{A,B}$
\end_inset

 are some profunctors.
 The code for liftings follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,B}}\triangleq\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,B}}
\end{array}\quad,\quad\quad g^{\uparrow P^{A,\bullet}}\triangleq\,\begin{array}{||cc|}
g^{\uparrow R^{A,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{A,\bullet}}
\end{array}\quad.
\]

\end_inset

By inductive assumption, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 already satisfy the commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we compute
\begin_inset Formula 
\begin{align*}
\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,B}}
\end{array}\,\bef\,\begin{array}{||cc|}
g^{\uparrow R^{A,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{A,\bullet}}
\end{array}\\
\text{matrix composition}:\quad & =\,\begin{array}{||cc|}
\gunderline{f^{\downarrow R^{\bullet,B}}\bef g^{\uparrow R^{A,\bullet}}} & \bbnum 0\\
\bbnum 0 & \gunderline{f^{\downarrow S^{\bullet,B}}\bef g^{\uparrow S^{A,\bullet}}}
\end{array}\\
\text{inductive assumption}:\quad & =\,\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}
\end{array}\quad.
\end{align*}

\end_inset

The right-hand side of the law, 
\begin_inset Formula $g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}$
\end_inset

, can be rewritten as
\begin_inset Formula 
\begin{align*}
 & g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}=\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}
\end{array}\,\bef\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,D}}
\end{array}\\
\text{matrix composition}:\quad & =\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}
\end{array}\quad.
\end{align*}

\end_inset

This now coincides with the left-hand side of the law.
\end_layout

\begin_layout Paragraph
Function type
\end_layout

\begin_layout Standard
The type expression 
\begin_inset Formula $P^{A,B}\triangleq R^{B,A}\rightarrow S^{A,B}$
\end_inset

 (note the swapped type parameters in 
\begin_inset Formula $R^{B,A}$
\end_inset

) is contravariant in 
\begin_inset Formula $A$
\end_inset

 and covariant in 
\begin_inset Formula $B$
\end_inset

 when 
\begin_inset Formula $R^{A,B}$
\end_inset

 and 
\begin_inset Formula $S^{A,B}$
\end_inset

 are any profunctors.
 The lifting code follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-contrafunctor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
(f^{:A\rightarrow C})^{\downarrow P^{\bullet,B}}\triangleq p^{:P^{C,B}}\rightarrow f^{\uparrow R^{B,\bullet}}\bef p\bef f^{\downarrow S^{\bullet,B}}\quad,\quad\quad(g^{:B\rightarrow D})^{\uparrow P^{A,\bullet}}\triangleq p^{:P^{A,B}}\rightarrow g^{\downarrow R^{\bullet,A}}\bef p\bef g^{\uparrow S^{A,\bullet}}\quad.
\]

\end_inset

By inductive assumption, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 satisfy the commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Omitting types, we compute
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & f^{\downarrow P}\bef g^{\uparrow P}=\big(p\rightarrow f^{\uparrow R}\bef p\bef f^{\downarrow S}\big)\bef\big(p\rightarrow g^{\downarrow R}\bef p\bef g^{\uparrow S}\big)\\
\text{compute composition}:\quad & =p\rightarrow\gunderline{g^{\downarrow R}\bef f^{\uparrow R}}\bef p\bef\gunderline{f^{\downarrow S}\bef g^{\uparrow S}}\\
\text{inductive assumption}:\quad & =p\rightarrow f^{\uparrow R}\bef g^{\downarrow R}\bef p\bef g^{\uparrow S}\bef f^{\downarrow S}\quad.
\end{align*}

\end_inset

The right-hand side of the law is then transformed to the same expression:
\begin_inset Formula 
\begin{align*}
 & g^{\uparrow P}\bef f^{\downarrow P}=\big(p\rightarrow g^{\downarrow R}\bef p\bef g^{\uparrow S}\big)\bef\big(p\rightarrow f^{\uparrow R}\bef p\bef f^{\downarrow S}\big)\\
\text{compute composition}:\quad & =p\rightarrow f^{\uparrow R}\bef g^{\downarrow R}\bef p\bef g^{\uparrow S}\bef f^{\downarrow S}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Recursive type
\end_layout

\begin_layout Standard
A recursive profunctor 
\begin_inset Formula $P$
\end_inset

 is defined using a type equation of the form
\begin_inset Formula 
\[
P^{A,B}\triangleq S^{A,B,P^{A,B}}\quad,\quad\text{equivalently denoted as}\quad P^{A,B}\triangleq\text{Fix}^{S^{A,B,\bullet}}\quad,
\]

\end_inset

where 
\begin_inset Formula $S^{A,B,R}$
\end_inset

 must be contravariant in 
\begin_inset Formula $A$
\end_inset

 but covariant in 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 The liftings are defined by
\begin_inset Formula 
\[
(f^{:A\rightarrow C})^{\downarrow P^{\bullet,B}}\triangleq f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,B,\bullet}}\quad,\quad\quad(g^{:B\rightarrow D})^{\uparrow P^{A,\bullet}}\triangleq g^{\uparrow S^{A,\bullet,P^{A,B}}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\quad.
\]

\end_inset

The inductive assumption is two-fold: first, that the recursively used lifting
 to 
\begin_inset Formula $P^{A,B}$
\end_inset

 already satisfies the commutativity law.
 Second, that the profunctor 
\begin_inset Formula $S^{A,B,R}$
\end_inset

 satisfies the commutativity law with respect to 
\emph on
any
\emph default
 two parameters (we will prove that law for covariant type parameters in
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proofs-of-commutativity-for-bifunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Both sides of the commutativity law are functions of type 
\begin_inset Formula $P^{C,B}\rightarrow P^{A,D}$
\end_inset

 or equivalently (if we expand the type recursion) as functions of type
 
\begin_inset Formula $S^{C,B,P^{C,B}}\rightarrow S^{A,D,P^{A,D}}$
\end_inset

.
 To avoid mistakes, we write out the type parameters in this computation:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef\gunderline{\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,B,\bullet}}\bef g^{\uparrow S^{A,\bullet,P^{A,B}}}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\\
^{B,R}\text{-commutativity of }S^{A,B,R}:\quad & =\gunderline{f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef g^{\uparrow S^{A,\bullet,P^{C,B}}}}\bef\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,D,\bullet}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\\
^{A,B}\text{-commutativity of }S^{A,B,R}:\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(\gunderline{f^{\overline{\downarrow P^{\bullet,B}}}\bef g^{\overline{\uparrow P^{A,\bullet}}}}\big)^{\uparrow S^{A,D,\bullet}}\\
\text{inductive assumption}:\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\bef f^{\overline{\downarrow P^{\bullet,D}}}\gunderline{\big)^{\uparrow S^{A,D,\bullet}}}\\
\text{composition under }^{\uparrow S^{A,D,\bullet}}:\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef\gunderline{f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}}\bef\big(f^{\overline{\downarrow P^{\bullet,D}}}\big)^{\uparrow S^{A,D,\bullet}}\\
^{A,R}\text{-commutativity of }S^{A,B,R}:\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\big)^{\uparrow S^{C,D,\bullet}}\bef f^{\downarrow S^{\bullet,D,P^{C,D}}}\bef\big(f^{\overline{\downarrow P^{\bullet,D}}}\big)^{\uparrow S^{A,D,\bullet}}\\
\text{definitions of liftings}:\quad & =g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This concludes the proof of the profunctor commutativity law.
\end_layout

\begin_layout Subsection
Commutativity laws for bifunctors and bi-contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proofs-of-commutativity-for-bifunctor"

\end_inset


\end_layout

\begin_layout Standard
A bi-contrafunctor 
\begin_inset Formula $P^{A,B}$
\end_inset

 is a type constructor contravariant with respect to both 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 The commutativity law for bi-contrafunctors is formulated as 
\begin_inset Formula 
\begin{align}
\text{commutativity law of }P:\quad & \text{cmap}_{P^{\bullet,D}}(f^{:A\rightarrow C})\bef\text{cmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})=\text{cmap}_{P^{C,\bullet}}(g)\bef\text{cmap}_{P^{\bullet,B}}(f)\quad.\nonumber \\
\text{shorter notation}:\quad & f^{\downarrow P^{\bullet,D}}\bef g^{\downarrow P^{A,\bullet}}=g^{\downarrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,B}}\quad.\label{eq:bi-contrafunctor-commutativity-law}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "43col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -170baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{6.0pc}P^{C,D}\ar[r]\sp(0.55){\text{cmap}_{P^{\bullet,D}}(f^{:A\rightarrow C})~~~}\ar[d]\sb(0.45){\text{cmap}_{P^{C,\bullet}}(g^{:B\rightarrow D})} & P^{A,D}\ar[d]\sb(0.45){\text{cmap}_{P^{A,\bullet}}(g)}\\
P^{C,B}\ar[r]\sb(0.45){~~~~\text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})} & P^{A,B}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -170baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Any bifunctor or bi-contrafunctor whose type expression is built up using
 the six type constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will satisfy its commutativity law.
 To prove that, we need to repeat the same calculations as for profunctors
 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proof-of-the-profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 except for changing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 or back when needed.
 We only need to check that the proof will still work after such changes.
 Looking over the proof in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proof-of-the-profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we find that we never used the functor or contrafunctor 
\emph on
composition law
\emph default
 for 
\begin_inset Formula $P$
\end_inset

.
 The only usage of the composition law was with respect to the type parameter
 
\begin_inset Formula $R$
\end_inset

 in the structure functor 
\begin_inset Formula $S^{A,B,R}$
\end_inset

 of the recursive type construction.
 However, in all cases 
\begin_inset Formula $S^{A,B,R}$
\end_inset

 needs to be 
\emph on
covariant
\emph default
 in 
\begin_inset Formula $R$
\end_inset

 because that is required by the recursive type equation.
 So, we are assured that the same proof with minor changes will work for
 bifunctors and bi-contrafunctors.
\end_layout

\begin_layout Standard
The same techniques and proofs apply to type constructors with more than
 two type parameters.
\end_layout

\begin_layout Section
Naturality laws for fully parametric functions
\begin_inset CommandInset label
LatexCommand label
name "sec:Naturality-laws-for-fully-parametric-functions"

\end_inset


\end_layout

\begin_layout Standard
The goal of this section is to derive and prove a naturality law for any
 function implemented via fully parametric code.
 Simple examples of such functions are the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 methods for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 functor, whose type signatures can be written as
\begin_inset Formula 
\begin{align*}
 & \text{fmap}_{\text{Opt}}^{A,B}:\left(A\rightarrow B\right)\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad,\\
 & \text{filt}_{\text{Opt}}^{A}:\left(A\rightarrow\bbnum 2\right)\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{A}\quad,\\
 & \text{fold}_{\text{Opt}}^{A,B}:B\times\left(A\times B\rightarrow B\right)\rightarrow\text{Opt}^{A}\rightarrow B\quad.
\end{align*}

\end_inset

These methods satisfy appropriate naturality laws — one law per type parameter.
 When a method's type signature is that of a natural transformation between
 functors (or between contrafunctors), the naturality laws have the form
 derived in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Naturality-laws-and-natural-transformations"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For instance, fixing the type parameter 
\begin_inset Formula $A$
\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method, we obtain a type signature of the form 
\begin_inset Formula $F^{B}\rightarrow G^{B}$
\end_inset

 where 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 are functors:
\begin_inset Formula 
\[
\text{fmap}_{\text{Opt}}^{B}:F^{B}\rightarrow G^{B}\quad,\quad\quad F^{B}\triangleq A\rightarrow B\quad,\quad\quad G^{B}\triangleq\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad.
\]

\end_inset

The corresponding naturality law (which is equivalent to the functor composition
 law) is
\begin_inset Formula 
\[
f^{\uparrow F}\bef\text{fmap}_{\text{Opt}}=\text{fmap}_{\text{Opt}}\bef f^{\uparrow G}\quad.
\]

\end_inset

However, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 is not of the form 
\begin_inset Formula $P^{B}\rightarrow Q^{B}$
\end_inset

 with any functors or contrafunctors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

.
 In general, it is not obvious how to write the naturality law for transformatio
ns with such type signatures.
 The parametricity theorem provides a recipe for writing naturality laws
 and also gives a proof that fully parametric functions always satisfy their
 naturality laws.
\end_layout

\begin_layout Standard
The key insight for deriving that theorem is that type signatures of a fully
 parametric function must always contain type parameters in either covariant
 or contravariant positions.
 So, any such type signature may be written as 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 using some 
\emph on
profunctors
\emph default
 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 For instance, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset Formula $B$
\end_inset

 (with the parameter 
\begin_inset Formula $A$
\end_inset

 fixed) is written as
\begin_inset Formula 
\begin{equation}
\text{fold}_{\text{Opt}}^{B}:P^{B,B}\rightarrow Q^{B,B}\quad,\quad\text{ where}\quad P^{X,Y}\triangleq Y\times\left(A\times X\rightarrow Y\right)\quad,\quad\quad Q^{X,Y}\triangleq\text{Opt}^{A}\rightarrow Y\quad.\label{eq:fold-type-signature-via-profunctors-derivation1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The next task is to motivate the naturality law for transformations having
 type 
\begin_inset Formula $\forall A.\,P^{A,A}\rightarrow Q^{A,A}$
\end_inset

, where the type parameters of the profunctors are set to be the same.
 Such transformations are called 
\begin_inset Quotes eld
\end_inset

dinatural
\begin_inset Quotes erd
\end_inset

.
 (
\emph on
Natural
\emph default
 transformations between profunctors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 have a different type signature, namely 
\begin_inset Formula $\forall(A,B).\,P^{A,B}\rightarrow Q^{A,B}$
\end_inset

, where the type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 must be independent).
\end_layout

\begin_layout Subsection
Dinatural transformations between profunctors
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
dinatural transformation
\end_layout

\end_inset

A 
\series bold
dinatural transformation
\series default
 is a function 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

, where 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 are profunctors contravariant in 
\begin_inset Formula $X$
\end_inset

 and covariant in 
\begin_inset Formula $Y$
\end_inset

.
 A dinatural transformation 
\begin_inset Formula $t$
\end_inset

 must satisfy the law
\begin_inset Formula 
\begin{equation}
(f^{:A\rightarrow B})^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.\label{eq:dinaturality-law-for-dinatural-transformations-of-profunctors}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "43col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{2.5pc} & P^{A,A}\ar[r]\sp(0.5){t} & Q^{A,A}\ar[rd]\sb(0.45){\text{xmap}_{Q}(\text{id})(f)}\\
P^{B,A}\ar[rd]\sp(0.55){\text{xmap}_{P}(\text{id})(f)}\ar[ru]\sb(0.55){\text{xmap}_{P}(f)(\text{id})} &  &  & Q^{A,B}\\
 & P^{B,B}\ar[r]\sp(0.5){t} & Q^{B,B}\ar[ru]\sp(0.45){\text{xmap}_{Q}(f)(\text{id})}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To build up intuition for that law (see diagram at left), compare the laws
 of natural transformations 
\begin_inset Formula $t^{A}:F^{A}\rightarrow G^{A}$
\end_inset

 when 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 are functors,
\begin_inset Formula 
\begin{equation}
t^{A}\bef(f^{:A\rightarrow B})^{\uparrow G}=(f^{:A\rightarrow B})^{\uparrow F}\bef t^{B}\quad,\label{eq:naturality-law-for-case-of-functors}
\end{equation}

\end_inset

and when 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}$
\end_inset

 are contrafunctors,
\begin_inset Formula 
\begin{equation}
(f^{:A\rightarrow B})^{\downarrow F}\bef t^{A}=t^{B}\bef(f^{:A\rightarrow B})^{\downarrow G}\quad.\label{eq:naturality-law-for-case-of-contrafunctors}
\end{equation}

\end_inset

We would obtain naturality laws of that form if we could fix the type parameter
 
\begin_inset Formula $A$
\end_inset

 and view the profunctors 
\begin_inset Formula $P^{A,B}$
\end_inset

 and 
\begin_inset Formula $Q^{A,B}$
\end_inset

 as functors with respect to the type parameter 
\begin_inset Formula $B$
\end_inset

.
 However, this requires us to have a function 
\begin_inset Formula $\tilde{t}:P^{A,B}\rightarrow Q^{A,B}$
\end_inset

 defined for arbitrary (not necessarily equal) type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 We do not have such a function: we are only given a transformation with
 the type signature 
\begin_inset Formula $t:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

.
 As a rule, we cannot extend the code of 
\begin_inset Formula $t$
\end_inset

 to some 
\begin_inset Formula $\tilde{t}$
\end_inset

 that works with arbitrary type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 and has type signature 
\begin_inset Formula $\tilde{t}:P^{A,B}\rightarrow Q^{A,B}$
\end_inset

.
 So, a naturality law for 
\begin_inset Formula $t$
\end_inset

 must be an equation that somehow transforms both type parameters of 
\begin_inset Formula $t$
\end_inset

 by using a lifted function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The
\begin_inset Index idx
status open

\begin_layout Plain Layout
dinatural transformation!dinaturality law
\end_layout

\end_inset

 
\series bold
dinaturality law
\series default

\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) combines the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-case-of-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-case-of-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) in the way required for all types to match.
 On the other hand, the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-case-of-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-case-of-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will follow from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) when 
\begin_inset Formula $P^{A,A}$
\end_inset

 and 
\begin_inset Formula $Q^{A,A}$
\end_inset

 are both functors or both contrafunctors in 
\begin_inset Formula $A$
\end_inset

.
 Another motivation for the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is that it yields the known forms of naturality laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 for arbitrary filterable or foldable functors 
\begin_inset Formula $F$
\end_inset

:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-derive-naturality-of-filter-from-dinaturality"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-derive-naturality-of-filter-from-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

)
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To derive the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

's type signature through profunctors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 as
\begin_inset Formula 
\[
\text{filt}_{F}^{A}:P^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad P^{X,Y}\triangleq(X\rightarrow\bbnum 2)\quad,\quad\quad Q^{X,Y}\triangleq F^{X}\rightarrow F^{Y}\quad,
\]

\end_inset

and then write the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

),
\begin_inset Formula 
\begin{equation}
f^{\downarrow P^{\bullet,A}}\bef\text{filt}_{F}^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{?}{=}f^{\uparrow P^{B,\bullet}}\bef\text{filt}_{F}^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.\label{eq:filter-law-via-dinatural-transformation-derivation1}
\end{equation}

\end_inset

It remains to substitute the code for the liftings using the specific types
 of 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\begin{align*}
(f^{:A\rightarrow B})^{\downarrow P^{\bullet,A}}=p^{:B\rightarrow\bbnum 2}\rightarrow f\bef p\quad, & \quad\quad f^{\uparrow P^{B,\bullet}}=\text{id}\quad,\\
(f^{:A\rightarrow B})^{\downarrow Q^{\bullet,B}}=q^{:F^{B}\rightarrow F^{B}}\rightarrow f^{\uparrow F}\bef q\quad, & \quad\quad f^{\uparrow Q^{A,\bullet}}=q^{:F^{A}\rightarrow F^{A}}\rightarrow q\bef f^{\uparrow F}\quad.
\end{align*}

\end_inset

Then we rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:filter-law-via-dinatural-transformation-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\[
(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\overset{?}{=}\text{id}\bef\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)\quad.
\]

\end_inset

To simplify the form of the naturality law, apply both sides to an arbitrary
 
\begin_inset Formula $p^{:P^{B,A}}=p^{:B\rightarrow\bbnum 2}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p\triangleright(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\\
\triangleright\text{-notation}:\quad & \quad=\gunderline{p\triangleright(p}\rightarrow f\bef p)\triangleright\text{filt}_{F}\triangleright(q\rightarrow q\bef f^{\uparrow F})\\
\text{apply functions}:\quad & \quad=\gunderline{(f\bef p)\triangleright\text{filt}_{F}}\triangleright(q\rightarrow q\bef f^{\uparrow F})=\gunderline{\text{filt}_{F}(f\bef p)\triangleright(q}\rightarrow q\bef f^{\uparrow F})=\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}\quad,\\
\text{right-hand side}:\quad & p\triangleright\gunderline{\text{id}\bef}\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)=p\triangleright\text{filt}_{F}\triangleright(q\rightarrow f^{\uparrow F}\bef q)\\
 & \quad=\gunderline{\text{filt}_{F}(p)\triangleright(q}\rightarrow f^{\uparrow F}\bef q)=f^{\uparrow F}\bef\text{filt}_{F}(p)\quad.
\end{align*}

\end_inset

So, we obtained the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-filter"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}=f^{\uparrow F}\bef\text{filt}_{F}(p)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-derive-naturality-of-fold-from-dinaturality"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-derive-naturality-of-fold-from-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

)
\end_layout

\begin_layout Standard
To derive the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset Formula $B$
\end_inset

, we begin with Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fold-type-signature-via-profunctors-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that shows the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 as a transformation of type 
\begin_inset Formula $P^{B,B}\rightarrow Q^{B,B}$
\end_inset

 between profunctors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

.
 Since the type parameter 
\begin_inset Formula $A$
\end_inset

 is fixed, the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) now involves an arbitrary function 
\begin_inset Formula $f^{:B\rightarrow C}$
\end_inset

,
\begin_inset Formula 
\begin{equation}
(f^{:B\rightarrow C})^{\downarrow P^{\bullet,B}}\bef\text{fold}_{F}^{B}\bef f^{\uparrow Q^{B,\bullet}}=f^{\uparrow P^{C,\bullet}}\bef\text{fold}_{F}^{C}\bef f^{\downarrow Q^{\bullet,C}}\quad.\label{eq:fold-naturality-from-profunctor-derivation2}
\end{equation}

\end_inset

The lifting code required for the profunctors 
\begin_inset Formula $P^{X,Y}\triangleq Y\times\left(A\times X\rightarrow Y\right)$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}\triangleq F^{A}\rightarrow Y$
\end_inset

 is
\begin_inset Formula 
\begin{align*}
(f^{:B\rightarrow C})^{\downarrow P^{\bullet,B}}=\text{id}^{B}\boxtimes(h^{:A\times C\rightarrow B}\rightarrow a^{:A}\times b^{:B}\rightarrow h(a\times f(b)))\quad, & \quad\quad f^{\uparrow P^{C,\bullet}}=f\boxtimes(h^{:A\times C\rightarrow B}\rightarrow h\bef f)\quad,\\
(f^{:B\rightarrow C})^{\downarrow Q^{\bullet,C}}=\text{id}\quad, & \quad\quad f^{\uparrow Q^{B,\bullet}}=q^{:F^{A}\rightarrow B}\rightarrow q\bef f\quad.
\end{align*}

\end_inset

Substituting this code into the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fold-naturality-from-profunctor-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and applying to an arbitrary 
\begin_inset Formula $p^{:P^{C,B}}=z^{:B}\times h^{:A\times C\rightarrow B}$
\end_inset

, we get
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (z\times h)\triangleright\gunderline{(f^{:B\rightarrow C})^{\downarrow P^{\bullet,B}}}\bef\text{fold}_{F}\bef\gunderline{f^{\uparrow Q^{B,\bullet}}}\\
\text{definitions of liftings}:\quad & \quad=(z\times h)\triangleright(\text{id}\boxtimes(h\rightarrow a\times b\rightarrow h(a\times f(b))))\gunderline{\bef}\text{fold}_{F}\gunderline{\bef}(q\rightarrow q\bef f)\\
\triangleright\text{-notation}:\quad & \quad=(z\times h)\triangleright(\text{id}\boxtimes(h\rightarrow a\times b\rightarrow h(a\times f(b))))\triangleright\text{fold}_{F}\triangleright(q\rightarrow q\bef f)\\
\text{apply functions}:\quad & \quad=\text{fold}_{F}(z\times(a\times b\rightarrow h(a\times f(b))))\bef f\quad,\\
\text{right-hand side}:\quad & (z\times h)\triangleright\gunderline{f^{\uparrow P^{C,\bullet}}}\bef\text{fold}_{F}\bef\gunderline{f^{\downarrow Q^{\bullet,C}}}=(z\times h)\triangleright(f\boxtimes(h^{:A\times C\rightarrow B}\rightarrow h\bef f))\bef\text{fold}_{F}\bef\text{id}\\
\text{apply functions}:\quad & \quad=\text{fold}_{F}(f(z)\times(h\bef f))\quad.
\end{align*}

\end_inset

We obtained a naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{fold}_{F}(f(z)\times(h\bef f))=\text{fold}_{F}(z\times(a\times b\rightarrow h(a\times f(b))))\bef f\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
These examples illustrate how we may derive the form of the naturality law
 for any type signature by specializing the general law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to specific profunctors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\begin_layout Standard
In the next subsections, we will prove
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The proof builds upon ideas from the paper by E.
\begin_inset space ~
\end_inset

S.
\begin_inset space ~
\end_inset

Bainbridge et al., 
\begin_inset Quotes eld
\end_inset

Functorial polymorphism
\begin_inset Quotes erd
\end_inset

 (Theor.
\begin_inset space ~
\end_inset

Comp.
\begin_inset space ~
\end_inset

Sci.
\begin_inset space ~
\end_inset

70, p.
\begin_inset space ~
\end_inset

35, 1990), see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.sciencedirect.com/science/article/pii/0304397590901517"

\end_inset


\end_layout

\end_inset

 that any fully parametric function 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 is dinatural, i.e., satisfies the dinaturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Since the form of the law depends only on the type signature, all functions
 
\begin_inset Formula $t^{A}$
\end_inset

 satisfy the same law.
\end_layout

\begin_layout Paragraph
Dinatural expressions
\end_layout

\begin_layout Standard
We note that the type constructor 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 is neither covariant nor contravariant in 
\begin_inset Formula $A$
\end_inset

, but it is itself a profunctor that we may denote by 
\begin_inset Formula $T^{A,A}$
\end_inset

.
 The naturality law is simpler when formulated via 
\begin_inset Formula $T$
\end_inset

:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-expression-wedge-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-expression-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
With the profunctor 
\begin_inset Formula $T^{X,Y}\triangleq P^{Y,X}\rightarrow Q^{X,Y}$
\end_inset

, the dinaturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is written as
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 9
placement l
overhang 0in
width "24col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{3.0pc} & T^{B,B}\ar[d]\sp(0.37){f^{\downarrow T^{\bullet,B}}}\\
T^{A,A}\ar[r]\sp(0.5){~~~f^{\uparrow T^{A,\bullet}}} & T^{A,B}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
t^{A}\triangleright f^{\uparrow T^{A,\bullet}}=t^{B}\triangleright f^{\downarrow T^{\bullet,B}}\quad,\label{eq:dinaturality-wedge-law}
\end{equation}

\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
where the transformation 
\begin_inset Formula $t$
\end_inset

 is viewed as a value of type 
\begin_inset Formula $\forall Z.\,T^{Z,Z}$
\end_inset

, while the function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is arbitrary.
 We will call Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) the 
\series bold
wedge law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
wedge law
\end_layout

\end_inset

 of 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The two liftings for 
\begin_inset Formula $T$
\end_inset

 are expressed as
\begin_inset Formula 
\begin{align*}
f^{\uparrow T^{A,\bullet}}:T^{A,A}\rightarrow T^{A,B}\quad, & \quad\quad t^{A}\triangleright f^{\uparrow T^{A,\bullet}}=p^{:P^{B,A}}\rightarrow t^{A}(p\triangleright f^{\downarrow P^{\bullet,A}})\triangleright f^{\uparrow Q^{A,\bullet}}=f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}\quad,\\
f^{\downarrow T^{\bullet,B}}:T^{B,B}\rightarrow T^{A,B}\quad, & \quad\quad t^{B}\triangleright f^{\uparrow T^{\bullet,B}}=p^{:P^{B,A}}\rightarrow t^{B}(p\triangleright f^{\uparrow P^{B,\bullet}})\triangleright f^{\downarrow Q^{\bullet,B}}=f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\end{align*}

\end_inset

It follows that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equivalent to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which proves the statement.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Expressions 
\begin_inset Formula $t$
\end_inset

 of type 
\begin_inset Formula $\forall Z.\,T^{Z,Z}$
\end_inset

 satisfying the wedge law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are called 
\series bold
dinatural expressions
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dinatural expression
\end_layout

\end_inset

.
 The wedge law formulates the dinaturality condition for any expression
 
\begin_inset Formula $t$
\end_inset

 with a type parameter, whether 
\begin_inset Formula $t$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

transformation
\begin_inset Quotes erd
\end_inset

 (i.e., a function) or not.
 Later we will prove that any fully parametric expression of type 
\begin_inset Formula $\forall Z.\,T^{Z,Z}$
\end_inset

 is dinatural.
\end_layout

\begin_layout Subsection
Composition properties of natural and dinatural transformations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Composition-properties-of-dinatural"

\end_inset


\end_layout

\begin_layout Standard
In the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-natural-transformations-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we derived the naturality law for the transformation 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 directly from the naturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 with no further assumptions.
 It turns out that the composition property for dinatural transformations
 
\emph on
cannot
\emph default
 be derived in the same way without the requirement of strong dinaturality.
 To see why, consider two dinatural transformations 
\begin_inset Formula $u:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A,A}\rightarrow R^{A,A}$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 are any profunctors.
 The naturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are:
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef f^{\uparrow Q^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad,\quad\quad f^{\downarrow Q^{\bullet,A}}\bef v^{A}\bef f^{\uparrow R^{A,\bullet}}=f^{\uparrow Q^{B,\bullet}}\bef v^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

 The composition 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 has type signature 
\begin_inset Formula $t:P^{A,A}\rightarrow R^{A,A}$
\end_inset

, and so its naturality law is
\begin_inset Formula 
\begin{equation}
f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow R^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-naturality-law-for-t-derivation1}
\end{equation}

\end_inset

Can we derive that law by combining the naturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

? Note that 
\emph on
both
\emph default
 sides of the laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 contain a lifting of 
\begin_inset Formula $f$
\end_inset

 to 
\begin_inset Formula $Q$
\end_inset

, while Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) does not contain that lifting.
 The function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 does not satisfy any known equations that we could use in the proof.
 So, we do not have any law that would allow us to eliminate 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

 or 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

 from the laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 (If, e.g., we knew that 
\begin_inset Formula $f$
\end_inset

 is invertible, we would use a function 
\begin_inset Formula $g^{:B\rightarrow A}$
\end_inset

 satisfying 
\begin_inset Formula $f\bef g=\text{id}$
\end_inset

 and 
\begin_inset Formula $g\bef f=\text{id}$
\end_inset

 and so eliminate 
\begin_inset Formula $f$
\end_inset

.
 But Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) must hold for arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.) No matter how we combine those laws, starting from one side or from the
 other, the resulting expressions will always contain 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

 and/or 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

.
 Similarly, starting from any side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we cannot 
\emph on
introduce
\emph default
 the function 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

 or 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

 into the expression.
 So, we are unable to obtain an expression in which we could use the laws
 of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 12
placement l
overhang 0in
width "55col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.3pc}\xyScaleX{2.3pc} & P^{A,A}\ar[r]\sp(0.5){u} & Q^{A,A}\ar[r]\sp(0.5){v}\ar[rd]\sb(0.45){f^{\uparrow Q^{A,\bullet}}\negthickspace\negthickspace} & R^{A,A}\ar[rd]\sp(0.45){f^{\uparrow R^{A,\bullet}}}\\
P^{B,A}\ar[ru]\sp(0.5){f^{\downarrow P^{\bullet,A}}\negthickspace\negthickspace\negthickspace\negthickspace}\ar[rd]\sb(0.5){f^{\uparrow P^{B,\bullet}}\negthickspace\negthickspace} & Q^{B,A}\ar[ru]\sb(0.55){\negthickspace\negthickspace f^{\downarrow Q^{\bullet,A}}}\ar[rd]\sp(0.5){f^{\uparrow Q^{B,\bullet}}\negthickspace\negthickspace} &  & Q^{A,B} & R^{A,B}\\
 & P^{B,B}\ar[r]\sp(0.5){u} & Q^{B,B}\ar[r]\sp(0.5){v}\ar[ru]\sp(0.5){f^{\downarrow Q^{\bullet,B}}\negthickspace\negthickspace\negthickspace} & R^{B,B}\ar[ru]\sb(0.55){\negthickspace\negthickspace f^{\downarrow R^{\bullet,B}}}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -110baselineskip%
\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Composition of dinatural transformations.
\begin_inset CommandInset label
LatexCommand label
name "fig:Type-diagram-for-composition-of-dinatural-transformations"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -140baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{1.8pc} & P^{A,A}\ar[r]\sp(0.5){u} & Q^{A,A}\ar[r]\sp(0.5){v}\ar[rd]\sb(0.45){f^{\uparrow Q^{A,\bullet}}\negthickspace\negthickspace} & R^{A,A}\ar[rd]\sp(0.45){f^{\uparrow R^{A,\bullet}}}\\
P^{B,A}\ar[ru]\sp(0.5){f^{\downarrow P^{\bullet,A}}\negthickspace\negthickspace\negthickspace\negthickspace}\ar[rd]\sb(0.5){f^{\uparrow P^{B,\bullet}}\negthickspace\negthickspace} & Q^{B,A}\ar[ru]\sb(0.55){\negthickspace\negthickspace f^{\downarrow Q^{\bullet,A}}}\ar[rd]\sp(0.5){f^{\uparrow Q^{B,\bullet}}\negthickspace\negthickspace} &  & Q^{A,B} & R^{A,B}\\
 & P^{B,B}\ar[r]\sp(0.5){u} & Q^{B,B}\ar[r]\sp(0.5){v}\ar[ru]\sp(0.5){f^{\downarrow Q^{\bullet,B}}\negthickspace\negthickspace\negthickspace} & R^{B,B}\ar[ru]\sb(0.55){\negthickspace\negthickspace f^{\downarrow R^{\bullet,B}}}
}
\]

\end_inset


\begin_inset VSpace -140baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The type diagram at left combines the diagrams for the laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 in an attempt to derive the law of 
\begin_inset Formula $t$
\end_inset

.
 We can see a value of type 
\begin_inset Formula $Q^{B,A}$
\end_inset

 acting as a 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Quotes erd
\end_inset

 of some arrows.
 It means that we are required to have a value of type 
\begin_inset Formula $Q^{B,A}$
\end_inset

 in order for the complete diagram to commute.
 But we are given only an arbitrary value 
\begin_inset Formula $p:P^{B,A}$
\end_inset

, and we are required to fill out the remainder of the diagram starting
 from that value.
 We cannot compute a value of type 
\begin_inset Formula $Q^{B,A}$
\end_inset

 from 
\begin_inset Formula $p:P^{B,A}$
\end_inset

 because we are given only a 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 transformation 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and not a function of type 
\begin_inset Formula $P^{X,Y}\rightarrow Q^{X,Y}$
\end_inset

 with arbitrary type parameters 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

.
 So, we cannot prove in this way that the diagram commutes.
 
\end_layout

\begin_layout Standard
Nevertheless, it is true that the composition of dinatural transformations
 is dinatural — as long as the code is fully parametric.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-transformation-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given any profunctors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 and any two fully parametric dinatural transformations 
\begin_inset Formula $u:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A,A}\rightarrow R^{A,A}$
\end_inset

, the transformation 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 is also dinatural.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to show that the naturality law holds for 
\begin_inset Formula $t$
\end_inset

: for any 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\begin{align}
 &  & p\triangleright f^{\downarrow P^{\bullet,A}}\bef\gunderline{t^{A}}\bef f^{\uparrow R^{A,\bullet}} & \overset{?}{=}p\triangleright f^{\uparrow P^{B,\bullet}}\bef\gunderline{t^{B}}\bef f^{\downarrow R^{\bullet,B}}\quad.\nonumber \\
 & \text{substitute }t\triangleq u\bef v:\quad & p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef v^{A}\bef f^{\uparrow R^{A,\bullet}} & \overset{?}{=}p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef v^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-composition-derivation1}
\end{align}

\end_inset

It is given that the naturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 both hold: for any 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 and 
\begin_inset Formula $q^{:Q^{B,A}}$
\end_inset

,
\begin_inset Formula 
\[
p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef f^{\uparrow Q^{A,\bullet}}=p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad,\quad\quad q\triangleright f^{\downarrow Q^{\bullet,A}}\bef v^{A}\bef f^{\uparrow R^{A,\bullet}}=q\triangleright f^{\uparrow Q^{B,\bullet}}\bef v^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

We will be able to establish Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-composition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) only if we find a suitable value 
\begin_inset Formula $q:Q^{B,A}$
\end_inset

 that correctly fits the inner square of the type diagram in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Type-diagram-for-composition-of-dinatural-transformations"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which can be written as the equation
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "32col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.3pc}\xyScaleX{2.6pc} & Q^{A,A}\ar[rd]\sb(0.45){f^{\uparrow Q^{A,\bullet}}\negthickspace\negthickspace}\\
Q^{B,A}\ar[ru]\sb(0.55){\negthickspace\negthickspace f^{\downarrow Q^{\bullet,A}}}\ar[rd]\sp(0.5){f^{\uparrow Q^{B,\bullet}}\negthickspace\negthickspace} &  & Q^{A,B}\\
 & Q^{B,B}\ar[ru]\sp(0.5){f^{\downarrow Q^{\bullet,B}}\negthickspace\negthickspace\negthickspace}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Formula 
\[
q\triangleright f^{\downarrow Q^{\bullet,A}}\bef f^{\uparrow Q^{A,\bullet}}=q\triangleright f^{\uparrow Q^{B,\bullet}}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
By the commutativity law of the profunctor 
\begin_inset Formula $Q$
\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proof-of-the-profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), this equation holds for 
\emph on
any
\emph default
 value 
\begin_inset Formula $q^{:Q^{B,A}}$
\end_inset

.
 It remains to show that a suitable value 
\begin_inset Formula $q$
\end_inset

 can be found such that we may replace 
\begin_inset Formula $p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}$
\end_inset

 by 
\begin_inset Formula $q\triangleright f^{\downarrow Q^{\bullet,A}}$
\end_inset

 and 
\begin_inset Formula $p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}$
\end_inset

 by 
\begin_inset Formula $q\triangleright f^{\uparrow Q^{B,\bullet}}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-composition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In other words, 
\begin_inset Formula $q$
\end_inset

 must satisfy the equations
\begin_inset Formula 
\begin{equation}
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad q\triangleright f^{\downarrow Q^{\bullet,A}}=p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\quad,\quad\quad q\triangleright f^{\uparrow Q^{B,\bullet}}=p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\quad.\label{eq:dinaturality-conditions-on-q-derivation1}
\end{equation}

\end_inset

We will complete the proof of law if we are able to compute a suitable value
 
\begin_inset Formula $q$
\end_inset

 for 
\emph on
any
\emph default
 given 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

, and 
\begin_inset Formula $u^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

.
 However, such 
\begin_inset Formula $q$
\end_inset

 does not always exist without further assumptions.
 A simple counterexample is found by choosing the profunctor 
\begin_inset Formula $Q^{X,Y}\triangleq X\rightarrow Y$
\end_inset

 and setting
\begin_inset Formula 
\[
u^{A}\triangleq\_^{:P^{A,A}}\rightarrow\text{id}^{:A\rightarrow A}\quad.
\]

\end_inset

With this choice of 
\begin_inset Formula $u$
\end_inset

, the value 
\begin_inset Formula $p$
\end_inset

 is ignored, and so we can simplify Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-conditions-on-q-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to
\begin_inset Formula 
\[
f^{:A\rightarrow B}\bef q^{:B\rightarrow A}=\text{id}^{:A\rightarrow A}\quad,\quad\quad q^{:B\rightarrow A}\bef f^{:A\rightarrow B}=\text{id}^{:B\rightarrow B}\quad.
\]

\end_inset

This is possible only if the function 
\begin_inset Formula $q^{:B\rightarrow A}$
\end_inset

 is the inverse of 
\begin_inset Formula $f$
\end_inset

; but, of course, not all functions 
\begin_inset Formula $f$
\end_inset

 are invertible.
 Also, the existence of an inverse for a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 means that the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are 
\emph on
equivalent
\emph default
 (
\begin_inset Formula $A\cong B$
\end_inset

) due to the isomorphism 
\begin_inset Formula $f$
\end_inset

, which is clearly not true for arbitrary types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
To proceed with the proof, we use a trick: we first prove the naturality
 law of 
\begin_inset Formula $t$
\end_inset

 when restricted to isomorphic types 
\begin_inset Formula $A\cong B$
\end_inset

 and to invertible functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Then we use the fact that a fully parametric function 
\begin_inset Formula $t$
\end_inset

 cannot use any type information about 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 or any information about the function 
\begin_inset Formula $f$
\end_inset

, and so the naturality law must actually hold for all types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 and for all 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
\end_layout

\begin_layout Standard
When the function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 has an inverse 
\begin_inset Formula $g^{:B\rightarrow A}$
\end_inset

, we may define 
\begin_inset Formula $q$
\end_inset

 according to
\begin_inset Formula 
\[
q^{:Q^{B,A}}\triangleq p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef g^{\downarrow Q^{\bullet,A}}\quad.
\]

\end_inset

This will satisfy the first requirement in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-conditions-on-q-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) because
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}:\quad & q\triangleright f^{\downarrow Q^{\bullet,A}}=p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef\gunderline{g^{\downarrow Q^{\bullet,A}}\bef f^{\downarrow Q^{\bullet,A}}}\\
\text{composition under lifting}:\quad & =p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef(\gunderline{g\bef f})^{\downarrow Q^{\bullet,A}}\\
\text{use }g\bef f=\text{id}:\quad & =p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\quad.
\end{align*}

\end_inset

The second of the requirements in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-conditions-on-q-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is then also satisfied:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}:\quad & q\triangleright f^{\uparrow Q^{B,\bullet}}=p^{:P^{B,A}}\triangleright f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef g^{\downarrow Q^{\bullet,A}}\bef f^{\uparrow Q^{B,\bullet}}\\
\text{commutativity law of }Q:\quad & =p^{:P^{B,A}}\triangleright\gunderline{f^{\downarrow P^{\bullet,A}}\bef u^{A}\bef f^{\uparrow Q^{A,\bullet}}}\bef g^{\downarrow Q^{\bullet,B}}\\
\text{naturality law of }u:\quad & =p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef\gunderline{f^{\downarrow Q^{\bullet,B}}\bef g^{\downarrow Q^{\bullet,B}}}\\
\text{composition under lifting}:\quad & =p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\bef(\gunderline{f\bef g})^{\downarrow Q^{\bullet,B}}=p\triangleright f^{\uparrow P^{B,\bullet}}\bef u^{B}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We can now substitute Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-conditions-on-q-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-composition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and obtain
\begin_inset Formula 
\[
q\triangleright f^{\downarrow Q^{\bullet,A}}\bef v^{A}\bef f^{\uparrow R^{A,\bullet}}\overset{?}{=}q\triangleright f^{\uparrow Q^{B,\bullet}}\bef v^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

This holds due to the given naturality law of 
\begin_inset Formula $v$
\end_inset

.
 So, we have shown that the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $t$
\end_inset

 is satisfied for 
\emph on
invertible
\emph default
 functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
\end_layout

\begin_layout Standard
It remains to remove the assumption of invertibility of 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 At this point, we need to use the fact that the code of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 is fully parametric.
 Then so is the code of 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

.
 The naturality law of 
\begin_inset Formula $t$
\end_inset

 has the form of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Both sides of that equation can be written out as some code that combines
 the code of 
\begin_inset Formula $t$
\end_inset

 and the code of the required liftings of 
\begin_inset Formula $f$
\end_inset

.
 As we have seen in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and in the proof of the profunctor commutativity law (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proof-of-the-profunctor-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), all lifting code is fully parametric and uses the arbitrary function
 
\begin_inset Formula $f$
\end_inset

 only by applying 
\begin_inset Formula $f$
\end_inset

 to some arguments.
 So, the code corresponding to both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-naturality-law-for-t-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is fully parametric and involves the function 
\begin_inset Formula $f$
\end_inset

 as an unevaluated value (a 
\begin_inset Quotes eld
\end_inset

free variable
\begin_inset Index idx
status open

\begin_layout Plain Layout
free variable
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

).
 We can symbolically write that code as the equation 
\begin_inset Formula 
\[
a(f)=b(f)\quad,
\]

\end_inset

where 
\begin_inset Formula $a(f)$
\end_inset

 and 
\begin_inset Formula $b(f)$
\end_inset

 are some expressions of type 
\begin_inset Formula $P^{B,A}\rightarrow R^{A,B}$
\end_inset

 that are built up from the nine code constructions from Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It follows that the code of 
\begin_inset Formula $a(f)$
\end_inset

 and 
\begin_inset Formula $b(f)$
\end_inset

 may apply the given function 
\begin_inset Formula $f$
\end_inset

 but cannot use the inverse function 
\begin_inset Formula $g$
\end_inset

 assumed in the proof above.
 So, the only possibility for the equation 
\begin_inset Formula $a(f)=b(f)$
\end_inset

 to hold is when the programs 
\begin_inset Formula $a(f)$
\end_inset

 and 
\begin_inset Formula $b(f)$
\end_inset

 are 
\emph on
equal
\emph default
 
\emph on
as symbolic expressions
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
This step in the proof seems plausible but is not rigorously derived in
 the present version of this book.
\end_layout

\end_inset

 up to equivalence transformations 
\begin_inset Formula $g=x\rightarrow g(x)$
\end_inset

 and 
\begin_inset Formula $y\triangleright(x\rightarrow g(x))=g(y)$
\end_inset

.
 So, the equation 
\begin_inset Formula $a(f)=b(f)$
\end_inset

 must hold for arbitrary functions 
\begin_inset Formula $f$
\end_inset

 and for arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 
\end_layout

\begin_layout Standard
This concludes the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsection
Proof of the parametricity theorem via dinaturality
\end_layout

\begin_layout Standard
The parametricity theorem states that a fully parametric function with type
 signature of the form 
\begin_inset Formula $\forall A.\,P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 is a dinatural transformation.
 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-parametricity-theorem-via-dinaturality"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-parametricity-theorem-via-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (parametricity theorem)
\end_layout

\begin_layout Standard
For any profunctors 
\begin_inset Formula $P^{X,Y}$
\end_inset

and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

, any fully parametric function 
\begin_inset Formula $t^{A}$
\end_inset

 defined by 
\begin_inset Formula 
\[
t^{A}:P^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad t\triangleq p^{:P^{A,A}}\rightarrow{\scriptstyle \mathtt{expression}}\quad,
\]

\end_inset

will satisfy the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We assume that the function body (denoted by 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) must be some fully parametric code built up from the nine code constructions
 listed in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof 
\end_layout

\begin_layout Standard
We use induction on the structure of 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 whose top-level operation must be one of the nine fully parametric code
 constructions.
 The base case contains the first two constructions (
\begin_inset Quotes eld
\end_inset

use unit value
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

use argument
\begin_inset Quotes erd
\end_inset

) since those constructions do not assume any previous code.
 We will need to prove that the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds in those cases.
 The inductive step covers the remaining seven constructions, which create
 larger code expressions from smaller sub-expressions.
 We will need to prove that the code for 
\begin_inset Formula $t$
\end_inset

 satisfies the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) under the inductive assumption that all previous sub-expressions already
 satisfy their versions of that law.
\end_layout

\begin_layout Standard
For example, the product construction (
\begin_inset Quotes eld
\end_inset

create tuple
\begin_inset Quotes erd
\end_inset

) combines two previously available code expressions (
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

) into a tuple 
\begin_inset Formula $a\times b$
\end_inset

.
 The corresponding transformations are 
\begin_inset Formula $p\rightarrow a$
\end_inset

, 
\begin_inset Formula $p\rightarrow b$
\end_inset

, and 
\begin_inset Formula $p\rightarrow a\times b$
\end_inset

.
 So, we need to prove that the function 
\begin_inset Formula $p\rightarrow a\times b$
\end_inset

 is dinatural if strong already holds for the functions 
\begin_inset Formula $p\rightarrow a$
\end_inset

 and 
\begin_inset Formula $p\rightarrow b$
\end_inset

.
 Note that the laws have different forms for each of the transformations
 
\begin_inset Formula $p\rightarrow a$
\end_inset

, 
\begin_inset Formula $p\rightarrow b$
\end_inset

, and 
\begin_inset Formula $p\rightarrow a\times b$
\end_inset

 because those functions have different types.
 (The proof is in item 5 below.)
\end_layout

\begin_layout Standard
We will now write the proofs for each of the nine code constructions.
 In each case, 
\begin_inset Formula $t$
\end_inset

 has type 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 with suitably chosen profunctors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
In some cases, we will prove strong dinaturality (from which dinaturality
 follows).
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
1) Use unit value
\end_layout

\begin_layout Standard
Here 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is just the unit value (
\begin_inset Formula $1$
\end_inset

), and 
\begin_inset Formula $t$
\end_inset

 is a constant function that always returns that value: 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow1$
\end_inset

.
 This is a natural transformation 
\begin_inset Formula $\_\rightarrow1$
\end_inset

 with substituted type parameters.
 So, 
\begin_inset Formula $t$
\end_inset

 is dinatural due to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $G^{A}\triangleq A$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Paragraph
2) Use argument 
\end_layout

\begin_layout Standard
Here 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is just the given argument of the function 
\begin_inset Formula $t$
\end_inset

.
 So, the code of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $t\triangleq p\rightarrow p$
\end_inset

.
 The type of 
\begin_inset Formula $t$
\end_inset

 must be 
\begin_inset Formula $P^{A,A}\rightarrow P^{A,A}$
\end_inset

, meaning that we must have 
\begin_inset Formula $P=Q$
\end_inset

.
 The dinaturality of 
\begin_inset Formula $t$
\end_inset

 follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $G^{A}\triangleq H^{A}\triangleq A$
\end_inset

 and the natural transformation 
\begin_inset Formula $\text{id}:G^{A}\rightarrow H^{A}$
\end_inset

.
\end_layout

\begin_layout Paragraph
3) Create function
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a nameless function 
\begin_inset Formula $z\rightarrow r$
\end_inset

, so 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow z\rightarrow r$
\end_inset

, where the sub-expression 
\begin_inset Formula $r$
\end_inset

 may use both 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 as bound variables.
 Since the code of 
\begin_inset Formula $r$
\end_inset

 is fully parametric, the types of 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 must be expressible as 
\begin_inset Formula $R^{A,A}$
\end_inset

 and 
\begin_inset Formula $Z^{A,A}$
\end_inset

, where 
\begin_inset Formula $R^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Z^{X,Y}$
\end_inset

 are some profunctors.
 The form of 
\begin_inset Formula $t$
\end_inset

 implies that 
\begin_inset Formula $Q^{X,Y}\triangleq Z^{Y,X}\rightarrow R^{X,Y}$
\end_inset

 (note the reverse order of parameters in 
\begin_inset Formula $Z^{Y,X}$
\end_inset

).
 The inductive assumption says that the naturality law is already satisfied
 by 
\emph on
any
\emph default
 transformation whose 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is just 
\begin_inset Formula $r$
\end_inset

.
 Such a transformation must have code of the form 
\begin_inset Formula $u\triangleq s\rightarrow r$
\end_inset

, where the type of the argument 
\begin_inset Formula $s$
\end_inset

 must contain the bound variables 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 that may be used in 
\begin_inset Formula $r$
\end_inset

.
 So, we set 
\begin_inset Formula $s=p\times z$
\end_inset

 and write the code of 
\begin_inset Formula $u$
\end_inset

 as 
\begin_inset Formula $u=p^{:P^{A,A}}\times z^{:Z^{A,A}}\rightarrow r$
\end_inset

.
 We then have
\begin_inset Formula 
\begin{equation}
t=p^{:P^{A,A}}\rightarrow z^{:Z^{A,A}}\rightarrow u(p\times z)\quad,\quad\quad u=p^{:P^{A,A}}\times z^{:Z^{A,A}}\rightarrow t(p)(z)\quad.\label{eq:dinaturality-u-function-type-derivation0-2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Denoting the profunctor 
\begin_inset Formula $U^{X,Y}\triangleq P^{X,Y}\times Z^{X,Y}$
\end_inset

, we write the naturality law for 
\begin_inset Formula $u:U^{A,A}\rightarrow R^{A,A}$
\end_inset

 as
\begin_inset Formula 
\begin{equation}
f^{\downarrow U^{\bullet,A}}\bef u^{A}\bef f^{\uparrow R^{A,\bullet}}=f^{\uparrow U^{B,\bullet}}\bef u^{B}\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-u-function-type-derivation1-1}
\end{equation}

\end_inset

This equation holds by the inductive assumption.
 We will derive the dinaturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $t$
\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-u-function-type-derivation1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by using the type definitions 
\begin_inset Formula $U^{X,Y}\triangleq P^{X,Y}\times Z^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}\triangleq Z^{Y,X}\rightarrow R^{X,Y}$
\end_inset

 to express the liftings of 
\begin_inset Formula $U$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 through the liftings of 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

, and 
\begin_inset Formula $Z$
\end_inset

 via the standard functor/contrafunctor codes:
\begin_inset Formula 
\begin{align}
f^{\downarrow U^{\bullet,A}}=f^{\downarrow P^{\bullet,A}}\boxtimes f^{\downarrow Z^{\bullet,A}}\quad, & \quad\quad f^{\uparrow U^{B,\bullet}}=f^{\uparrow P^{B,\bullet}}\boxtimes f^{\uparrow Z^{B,\bullet}}\quad,\label{eq:dinaturality-u-function-type-derivation2-2}\\
f^{\uparrow Q^{A,\bullet}}=q^{:Q^{A,A}}\rightarrow f^{\downarrow Z^{\bullet,A}}\bef q\bef f^{\uparrow R^{A,\bullet}}\quad, & \quad\quad f^{\downarrow Q^{\bullet,B}}=q^{:Q^{B,B}}\rightarrow f^{\uparrow Z^{B,\bullet}}\bef q\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-u-function-type-derivation3-2}
\end{align}

\end_inset

Substituting the relevant formulas into the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and applying to 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

, we find
\begin_inset Formula 
\begin{align*}
\text{Eq.~(\ref{eq:dinaturality-u-function-type-derivation0-2})}:\quad & p\triangleright f^{\downarrow P^{\bullet,A}}\bef\gunderline t\bef\gunderline{f^{\uparrow Q^{A,\bullet}}}=p\triangleright f^{\downarrow P^{\bullet,A}}\,\gunderline{\triangleright\big(p}\rightarrow z\rightarrow u(p\times z)\big)\,\gunderline{\triangleright\big(q^{:Q^{A,A}}}\rightarrow f^{\downarrow Z^{\bullet,A}}\bef q\bef f^{\uparrow R^{A,\bullet}}\big)\\
 & =\gunderline{f^{\downarrow Z^{\bullet,A}}\bef\big(}z\rightarrow u((p\triangleright f^{\downarrow P^{\bullet,A}})\times\gunderline z)\big)\bef f^{\uparrow R^{A,\bullet}}=z\rightarrow u\big(\gunderline{(p\triangleright f^{\downarrow P^{\bullet,A}})\times(z\triangleright f^{\downarrow Z^{\bullet,A}})}\big)\triangleright f^{\uparrow R^{A,\bullet}}\\
 & =z\rightarrow\gunderline{u\big(}(p\times z)\triangleright\big(f^{\downarrow P^{\bullet,A}}\boxtimes f^{\downarrow Z^{\bullet,A}}\big)\gunderline{\big)}\triangleright f^{\uparrow R^{A,\bullet}}=z\rightarrow(p\times z)\triangleright\big(\gunderline{f^{\downarrow P^{\bullet,A}}\boxtimes f^{\downarrow Z^{\bullet,A}}}\big)\triangleright u\triangleright f^{\uparrow R^{A,\bullet}}\\
\text{Eq.~(\ref{eq:dinaturality-u-function-type-derivation2-2})}:\quad & =z\rightarrow(p\times z)\triangleright\gunderline{f^{\downarrow U^{\bullet,A}}\bef u\bef f^{\uparrow R^{A,\bullet}}}\\
\text{Eq.~(\ref{eq:dinaturality-u-function-type-derivation1-1})}:\quad & =z\rightarrow(p\times z)\triangleright\gunderline{f^{\uparrow U^{B,\bullet}}}\bef\gunderline u\bef f^{\downarrow R^{\bullet,B}}\\
\text{Eq.~(\ref{eq:dinaturality-u-function-type-derivation2-2})}:\quad & =z\rightarrow\gunderline{(p\times z)\triangleright\big(}f^{\uparrow P^{B,\bullet}}\boxtimes f^{\uparrow Z^{B,\bullet}}\big)\triangleright\big(p\times z\rightarrow t(p)(z)\big)\triangleright f^{\downarrow R^{\bullet,B}}\\
 & =z\rightarrow t\big(p\triangleright f^{\uparrow P^{B,\bullet}}\big)\big(z\triangleright f^{\uparrow Z^{B,\bullet}}\big)\triangleright f^{\downarrow R^{\bullet,B}}.
\end{align*}

\end_inset

Now apply the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to the same value 
\begin_inset Formula $p$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{use Eq.~(\ref{eq:dinaturality-u-function-type-derivation3-2})}:\quad & p\triangleright f^{\uparrow P^{B,\bullet}}\bef t\bef\gunderline{f^{\downarrow Q^{\bullet,B}}}=\gunderline{p\triangleright f^{\uparrow P^{B,\bullet}}\triangleright t\triangleright\big(}q^{:Q^{B,B}}\rightarrow f^{\uparrow Z^{B,\bullet}}\bef q\bef f^{\downarrow R^{\bullet,B}}\big)\\
 & =f^{\uparrow Z^{B,\bullet}}\bef t(p\triangleright f^{\uparrow P^{B,\bullet}})\bef f^{\downarrow R^{\bullet,B}}=z\rightarrow z\triangleright f^{\uparrow Z^{B,\bullet}}\triangleright t(p\triangleright f^{\uparrow P^{B,\bullet}})\triangleright f^{\downarrow R^{\bullet,B}}\\
 & =z\rightarrow t\big(p\triangleright f^{\uparrow P^{B,\bullet}}\big)\big(z\triangleright f^{\uparrow Z^{B,\bullet}}\big)\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\end{align*}

\end_inset

We obtain the same expression as for the left-hand side, which proves that
 the law holds.
\end_layout

\begin_layout Standard
The proof does not assume that the expression 
\begin_inset Formula $t(p)(r)$
\end_inset

 actually uses both arguments 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

.
 So, the law holds also for functions that ignore some of their arguments.
\end_layout

\begin_layout Paragraph
4) Use function 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a function application such as 
\begin_inset Formula $f(z)$
\end_inset

.
 Then we may write the code of 
\begin_inset Formula $t$
\end_inset

 as 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow f(z)$
\end_inset

, where 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are some other expressions.
 Since these expressions are parts of the code 
\begin_inset Formula $p\rightarrow f(z)$
\end_inset

, it must be possible to compute 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 separately, given 
\begin_inset Formula $p$
\end_inset

.
 So, we can write fully parametric code for the two transformations 
\begin_inset Formula $u\triangleq p\rightarrow f$
\end_inset

 and 
\begin_inset Formula $v\triangleq p\rightarrow z$
\end_inset

.
 The inductive assumption is that the naturality law holds for any transformatio
ns whose code contains 
\begin_inset Formula $f$
\end_inset

 or 
\begin_inset Formula $z$
\end_inset

 as the function body.
 So, we may use the naturality laws for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Standard
What are the possible types of 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

? Since 
\begin_inset Formula $z$
\end_inset

 is computed by fully parametric code, the type of 
\begin_inset Formula $z$
\end_inset

 can be expressed as 
\begin_inset Formula $z^{:Z^{A,A}}$
\end_inset

 via some profunctor 
\begin_inset Formula $Z^{X,Y}$
\end_inset

.
 To match the types, the function 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $Z^{A,A}\rightarrow Q^{A,A}$
\end_inset

.
 It will be convenient to express 
\begin_inset Formula $t$
\end_inset

 as a composition of two transformations: the first, denoted by 
\begin_inset Formula $s$
\end_inset

, simply gathers 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 in a tuple,
\begin_inset Formula 
\[
s:P^{A,A}\rightarrow(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\quad,\quad\quad s\triangleq p\rightarrow u(p)\times v(p)\quad.
\]

\end_inset

The second, denoted 
\begin_inset Formula $w$
\end_inset

, applies the function:
\begin_inset Formula 
\[
w:(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad w\triangleq f\times z\rightarrow f(z)\quad.
\]

\end_inset

The functions 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are dinatural due to Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-product-of-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a) and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinaturality-of-function-application"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b).
 Then, by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the function composition 
\begin_inset Formula $t=s\bef w$
\end_inset

 is also dinatural.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
We will show separately that 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are dinatural.
 Since both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are implemented via fully parametric code, it will follow by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the composition 
\begin_inset Formula $t=s\bef w$
\end_inset

 is also dinatural.
\end_layout

\begin_layout Plain Layout
Defining the profunctor 
\begin_inset Formula $G^{X,Y}\triangleq Z^{Y,X}\rightarrow Q^{X,Y}$
\end_inset

, we write the type signatures of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 as 
\begin_inset Formula 
\[
u:P^{A,A}\rightarrow G^{A,A}\quad,\quad\quad v:P^{A,A}\rightarrow Z^{A,A}\quad.
\]

\end_inset

Since 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are dinatural, we may apply the derivation in item 5 below (which does
 not use any other assumptions) with 
\begin_inset Formula $R\triangleq G$
\end_inset

 and 
\begin_inset Formula $S\triangleq Z$
\end_inset

 to show that the transformation 
\begin_inset Formula $s\triangleq p\rightarrow u(p)\times v(p)$
\end_inset

 of type 
\begin_inset Formula $P^{A,A}\rightarrow G^{A,A}\times Z^{A,A}$
\end_inset

 is also dinatural.
\end_layout

\begin_layout Plain Layout
It remains to show that the transformation 
\begin_inset Formula $w\triangleq g\times z\rightarrow z\triangleright g$
\end_inset

 is dinatural.
 For brevity, we will omit type annotations and write 
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 instead of 
\begin_inset Formula $f^{\uparrow G^{X,\bullet}}$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow G}$
\end_inset

 instead of 
\begin_inset Formula $f^{\downarrow G^{\bullet,Y}}$
\end_inset

, with 
\begin_inset Formula $G$
\end_inset

 and other profunctors.
 Since profunctors have one contravariant and one covariant type parameter,
 the choice of the type parameter in a lifting will remain unambiguous.
 The naturality law is then written as
\begin_inset Formula 
\begin{equation}
(f^{\downarrow G}\boxtimes f^{\downarrow Z})\bef w\bef f^{\uparrow Q}\overset{?}{=}(f^{\uparrow G}\boxtimes f^{\uparrow Z})\bef w\bef f^{\downarrow Q}\quad.\label{eq:dinaturality-law-application-derivation1-1}
\end{equation}

\end_inset

It helps to write out the liftings to 
\begin_inset Formula $G$
\end_inset

.
 For arbitrary 
\begin_inset Formula $g^{:G^{B,A}}$
\end_inset

 and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, we have 
\begin_inset Formula $g\triangleright f^{\downarrow G^{\bullet,A}}$
\end_inset

 of type 
\begin_inset Formula $G^{A,A}=Z^{A,A}\rightarrow Q^{A,A}$
\end_inset

, so
\begin_inset Formula 
\begin{align*}
g^{:G^{B,A}}\triangleright f^{\downarrow G} & =z^{:Z^{A,A}}\rightarrow(z\triangleright f^{\uparrow Z})\triangleright g\bef f^{\downarrow Q}=f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset

Similarly
\begin_inset Formula 
\[
g^{:G^{B,A}}\triangleright f^{\uparrow G}=z^{:Z^{B,B}}\rightarrow(z\triangleright f^{\downarrow Z})\triangleright g\bef f^{\uparrow Q}=f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\quad.
\]

\end_inset

Now apply the left-hand side of the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to an arbitrary 
\begin_inset Formula $g^{:G^{B,A}}\times z^{:Z^{B,A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{definitions of }\boxtimes\text{ and }w:\quad & (g^{:G^{B,A}}\times z^{:Z^{B,A}})\triangleright(f^{\downarrow G}\boxtimes f^{\downarrow Z})\bef w\bef f^{\uparrow Q}=(z\triangleright f^{\downarrow Z})\triangleright(\gunderline{g\triangleright f^{\downarrow G}})\bef f^{\uparrow Q}\\
\text{definition of }g\triangleright f^{\downarrow G}:\quad & =(z\triangleright f^{\downarrow Z})\triangleright f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}=z\triangleright f^{\downarrow Z}\bef f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}\quad.
\end{align*}

\end_inset

Applying the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $g\times z$
\end_inset

 gives similarly
\begin_inset Formula 
\begin{align*}
\text{definitions of }\boxtimes\text{ and }w:\quad & (g^{:G^{B,A}}\times z^{:Z^{B,A}})\triangleright(f^{\uparrow G}\boxtimes f^{\uparrow Z})\bef w\bef f^{\downarrow Q}=(z\triangleright f^{\uparrow Z})\triangleright(\gunderline{g\triangleright f^{\uparrow G}})\bef f^{\downarrow Q}\\
\text{definition of }g\triangleright f^{\uparrow G}:\quad & =(z\triangleright f^{\uparrow Z})\triangleright f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}=z\triangleright f^{\uparrow Z}\bef f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset

The two sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) now differ only by the order of application of lifted functions 
\begin_inset Formula $f^{\uparrow Z}$
\end_inset

, 
\begin_inset Formula $f^{\downarrow Z}$
\end_inset

, 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

, and 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

.
 These applications commute by the profunctor commutativity laws of 
\begin_inset Formula $Z$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow Z}\bef f^{\uparrow Z}=f^{\uparrow Z}\bef f^{\downarrow Z}\quad,\quad\quad f^{\downarrow Q}\bef f^{\uparrow Q}=f^{\uparrow Q}\bef f^{\downarrow Q}\quad.
\]

\end_inset

This concludes the proof of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and so proves the entire item 4.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
5) Create tuple 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a tuple, so the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow r\times s$
\end_inset

 where 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 are some expressions.
 In general, the types of 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 will be given by some profunctors 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, so that 
\begin_inset Formula $Q^{X,Y}=R^{X,Y}\times S^{X,Y}$
\end_inset

.
 Since the code of 
\begin_inset Formula $t$
\end_inset

 computes 
\begin_inset Formula $r\times s$
\end_inset

 from 
\begin_inset Formula $p$
\end_inset

, we should be able to compute 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 separately from 
\begin_inset Formula $p$
\end_inset

.
 It means that we have well-defined transformations 
\begin_inset Formula $u\triangleq p\rightarrow r$
\end_inset

 and 
\begin_inset Formula $v\triangleq p\rightarrow s$
\end_inset

 having types 
\begin_inset Formula $u:P^{A.A}\rightarrow R^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:P^{A,A}\rightarrow S^{A,A}$
\end_inset

.
 The inductive assumption is that the dinaturality laws already hold for
 any transformations whose function body is 
\begin_inset Formula $r$
\end_inset

 or 
\begin_inset Formula $s$
\end_inset

.
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-product-of-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a), the dinaturality law then holds for 
\begin_inset Formula $t$
\end_inset

.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
So, we may assume that the law holds separately for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow P}\bef u\bef f^{\uparrow R}=f^{\uparrow P}\bef u\bef f^{\downarrow R}\quad,\quad\quad f^{\downarrow P}\bef v\bef f^{\uparrow S}=f^{\uparrow P}\bef v\bef f^{\downarrow S}\quad.
\]

\end_inset

The lifting for 
\begin_inset Formula $Q$
\end_inset

 is expressed through the liftings for 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 as
\begin_inset Formula 
\[
f^{\uparrow Q}=f^{\uparrow R}\boxtimes f^{\uparrow S}\quad,\quad\quad f^{\downarrow Q}=f^{\downarrow R}\boxtimes f^{\downarrow S}\quad.
\]

\end_inset

We can now verify the naturality law of 
\begin_inset Formula $t$
\end_inset

 by expressing 
\begin_inset Formula $t=p\rightarrow u(p)\times v(p)=\Delta\bef(u\boxtimes v)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect }f^{\uparrow P}\bef t\bef f^{\downarrow Q}:\quad & f^{\downarrow P}\bef\gunderline t\bef\gunderline{f^{\uparrow Q}}=\gunderline{f^{\downarrow P}\bef\Delta}\bef(u\boxtimes v)\bef\big(f^{\uparrow R}\boxtimes f^{\uparrow S}\big)\\
\text{naturality of }\Delta:\quad & =\Delta\bef(f^{\downarrow P}\boxtimes f^{\downarrow P})\bef(u\boxtimes v)\bef\big(f^{\uparrow R}\boxtimes f^{\uparrow S}\big)=\Delta\bef\big(\gunderline{f^{\downarrow P}\bef u\bef f^{\uparrow R}}\big)\boxtimes\big(\gunderline{f^{\downarrow P}\bef v\bef f^{\uparrow S}}\big)\\
\text{inductive assumption}:\quad & =\Delta\bef\big(f^{\uparrow P}\bef u\bef f^{\downarrow R}\big)\boxtimes\big(f^{\uparrow P}\bef v\bef f^{\downarrow S}\big)=\gunderline{\Delta\bef\big(f^{\uparrow P}\boxtimes f^{\uparrow P}\big)}\bef(u\boxtimes v)\bef\big(\gunderline{f^{\downarrow R}\boxtimes f^{\downarrow S}}\big)\\
\text{naturality of }\Delta:\quad & =f^{\uparrow P}\bef\gunderline{\Delta\bef(u\boxtimes v)}\bef f^{\downarrow Q}=f^{\uparrow P}\bef t\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
6) Use tuple 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 contains a tuple accessor, such as 
\begin_inset Formula $\pi_{1}$
\end_inset

.
 It is sufficient to prove the law for 
\begin_inset Formula $\pi_{1}$
\end_inset

, since all tuple accessors work similarly.
 So, we assume that the type 
\begin_inset Formula $P$
\end_inset

 is a product, 
\begin_inset Formula $P^{X,Y}\triangleq Q^{X,Y}\times R^{X,Y}$
\end_inset

, and that the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq\pi_{1}=p^{:Q^{A,A}\times R^{A,A}}\rightarrow p\triangleright\pi_{1}$
\end_inset

.
 This is just the natural transformation 
\begin_inset Formula $\pi_{1}$
\end_inset

 with substituted type parameters, so the dinaturality of 
\begin_inset Formula $t$
\end_inset

 follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinatural-substitute-profunctor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $G^{X,Y}\triangleq X\times Y$
\end_inset

, 
\begin_inset Formula $H^{X,Y}\triangleq X$
\end_inset

, 
\begin_inset Formula $P\triangleq Q$
\end_inset

, and 
\begin_inset Formula $Q\triangleq R$
\end_inset

.
\end_layout

\begin_layout Paragraph
7) Create disjunction
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 contains a case class constructor such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some
\end_layout

\end_inset

.
 We may assume that 
\begin_inset Formula $Q^{X,Y}=R^{X,Y}+S^{X,Y}$
\end_inset

 for some profunctors 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

, and that the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow r^{:R^{A,A}}+\bbnum 0^{:S^{A,A}}$
\end_inset

 where 
\begin_inset Formula $r$
\end_inset

 is some expression of type 
\begin_inset Formula $R^{A,A}$
\end_inset

.
 It is sufficient to prove the law for 
\begin_inset Formula $t=p\rightarrow r+\bbnum 0$
\end_inset

, because all other disjunctive cases such as 
\begin_inset Formula $t=p\rightarrow\bbnum 0+s$
\end_inset

 work analogously.
\end_layout

\begin_layout Standard
Since the code of 
\begin_inset Formula $t$
\end_inset

 is fully parametric, the value 
\begin_inset Formula $r$
\end_inset

 can be also computed from 
\begin_inset Formula $p$
\end_inset

 using fully parametric code.
 So the inductive assumption is that the transformation 
\begin_inset Formula $u\triangleq p\rightarrow r$
\end_inset

 is already known to be dinatural, with the law
\begin_inset Formula 
\[
f^{\downarrow P}\bef u\bef f^{\uparrow R}=f^{\uparrow P}\bef u\bef f^{\downarrow R}\quad.
\]

\end_inset

 The naturality law for 
\begin_inset Formula $t$
\end_inset

 is
\begin_inset Formula 
\[
f^{\downarrow P}\bef t\bef f^{\uparrow Q}\overset{?}{=}f^{\uparrow P}\bef t\bef f^{\downarrow Q}\quad.
\]

\end_inset

The liftings to 
\begin_inset Formula $Q$
\end_inset

 are disjunctive functions written in the matrix notation as
\begin_inset Formula 
\[
f^{\uparrow Q^{B,\bullet}}=\,\begin{array}{|c||cc|}
 & R^{B,B} & S^{B,B}\\
\hline R^{B,A} & f^{\uparrow R^{B,\bullet}} & \bbnum 0\\
S^{B,A} & \bbnum 0 & f^{\uparrow S^{B,\bullet}}
\end{array}\quad,\quad\quad f^{\downarrow Q^{\bullet,A}}=\,\begin{array}{|c||cc|}
 & R^{A,A} & S^{A,A}\\
\hline R^{B,A} & f^{\downarrow R^{\bullet,A}} & \bbnum 0\\
S^{B,A} & \bbnum 0 & f^{\downarrow S^{\bullet,A}}
\end{array}\quad.
\]

\end_inset

Omitting type annotations, we apply the naturality law to a value 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 and get
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p\triangleright f^{\downarrow P}\bef t\bef f^{\uparrow Q}=\big((p\triangleright f^{\downarrow P}\triangleright u)+\bbnum 0\big)\triangleright\,\begin{array}{||cc|}
f^{\uparrow R} & \bbnum 0\\
\bbnum 0 & f^{\uparrow S}
\end{array}\\
\text{apply disjunctive function}:\quad & \quad=p\triangleright f^{\downarrow P}\bef u\bef f^{\uparrow R}\quad.\\
\text{right-hand side}:\quad & p\triangleright f^{\uparrow P}\bef t\bef f^{\downarrow Q}=\big((p\triangleright f^{\uparrow P}\triangleright u)+\bbnum 0\big)\triangleright\,\begin{array}{||cc|}
f^{\downarrow R} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S}
\end{array}\\
\text{apply disjunctive function}:\quad & \quad=p\triangleright\gunderline{f^{\uparrow P}\bef u\bef f^{\downarrow R}}\\
\text{dinaturality of }u:\quad & \quad=p\triangleright f^{\downarrow P}\bef u\bef f^{\uparrow R}\quad.
\end{align*}

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Paragraph
8) Use disjunction
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a pattern match, so the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula 
\[
t\triangleq p^{:P^{A,A}}\rightarrow\,\begin{array}{||c|}
g\\
h
\end{array}\quad,
\]

\end_inset

where 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 are known functions.
 The expressions 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 are part of the code, and so they must be both fully parametric and computable
 from 
\begin_inset Formula $p$
\end_inset

.
 We then choose the inductive assumption that the transformations 
\begin_inset Formula $p\rightarrow g$
\end_inset

 and 
\begin_inset Formula $p\rightarrow h$
\end_inset

 are dinatural.
 Then 
\begin_inset Formula $t$
\end_inset

 is dinatural due to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-product-of-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b).
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
As in item 4, we can represent 
\begin_inset Formula $t$
\end_inset

 as a composition of two transformations, 
\begin_inset Formula 
\[
t=u\bef v\quad,\quad\quad u\triangleq p\rightarrow e\times g\times h\quad,\quad\quad v\triangleq e\times g\times h\rightarrow e\triangleright\,\begin{array}{||c|}
g\\
h
\end{array}\quad.
\]

\end_inset

To show that the transformation 
\begin_inset Formula $u$
\end_inset

 is dinatural, we apply the argument in item 5 twice.
 It remains to show that 
\begin_inset Formula $v$
\end_inset

 is dinatural.
 Since the code of 
\begin_inset Formula $v$
\end_inset

 is fully parametric, it will follow by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the composition 
\begin_inset Formula $t=u\bef v$
\end_inset

 is dinatural.
\end_layout

\begin_layout Plain Layout
Assume that the types of 
\begin_inset Formula $e$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

 are 
\begin_inset Formula $e:R^{A,A}+S^{A,A}$
\end_inset

, 
\begin_inset Formula $g:R^{A,A}\rightarrow Q^{A,A}$
\end_inset

, and 
\begin_inset Formula $h:S^{A,A}\rightarrow Q^{A,A}$
\end_inset

, where 
\begin_inset Formula $R^{X,Y}$
\end_inset

 and 
\begin_inset Formula $S^{X,Y}$
\end_inset

 are some profunctors.
 For convenience, let us define the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 by
\begin_inset Formula 
\[
K^{X,Y}\triangleq R^{Y,X}\rightarrow Q^{X,Y}\quad,\quad\quad L^{X,Y}\triangleq S^{Y,X}\rightarrow Q^{X,Y}\quad.
\]

\end_inset

The type of 
\begin_inset Formula $v$
\end_inset

 is then 
\begin_inset Formula $v^{A}:(R^{A,A}+S^{A,A})\times K^{A,A}\times L^{A,A}\rightarrow Q^{A,A}$
\end_inset

, so its naturality law is 
\begin_inset Formula 
\[
\big(f^{\downarrow(R+S)}\boxtimes f^{\downarrow K}\boxtimes f^{\downarrow L}\big)\bef v\bef f^{\uparrow Q}\overset{?}{=}\big(f^{\uparrow(R+S)}\boxtimes f^{\uparrow K}\boxtimes f^{\uparrow L}\big)\bef v\bef f^{\downarrow Q}\quad.
\]

\end_inset

The code of the required liftings is defined by
\begin_inset Formula 
\begin{align*}
f^{\downarrow(R+S)}=\,\begin{array}{||cc|}
f^{\downarrow R} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S}
\end{array}\quad, & \quad\quad f^{\uparrow(R+S)}=\,\begin{array}{||cc|}
f^{\uparrow R} & \bbnum 0\\
\bbnum 0 & f^{\uparrow S}
\end{array}\quad,\\
g\triangleright f^{\downarrow K}=f^{\uparrow R}\bef g\bef f^{\downarrow Q}\quad, & \quad\quad g\triangleright f^{\uparrow K}=f^{\downarrow R}\bef g\bef f^{\uparrow Q}\quad,\\
h\triangleright f^{\downarrow L}=f^{\uparrow S}\bef h\bef f^{\downarrow Q}\quad, & \quad\quad h\triangleright f^{\uparrow L}=f^{\downarrow S}\bef h\bef f^{\uparrow Q}\quad.
\end{align*}

\end_inset

Apply the left-hand side of the naturality law to a value 
\begin_inset Formula $e^{:R^{B,A}+S^{B,A}}\times g^{:R^{A,B}\rightarrow Q^{B,A}}\times h^{:S^{A,B}\rightarrow Q^{B,A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expand }\boxtimes:\quad & \gunderline{e\times g\times h\triangleright\big(}f^{\downarrow(R+S)}\boxtimes f^{\downarrow K}\boxtimes f^{\downarrow L}\big)\bef v\bef f^{\uparrow Q}=(e\triangleright f^{\downarrow(R+S)})\times(\gunderline{g\triangleright f^{\downarrow K}})\times(\gunderline{h\triangleright f^{\downarrow L}})\triangleright v\bef f^{\uparrow Q}\\
\text{definition of }v:\quad & =e\triangleright\,\begin{array}{||cc|}
f^{\downarrow R} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S}
\end{array}\,\bef\,\begin{array}{||c|}
g\triangleright f^{\downarrow K}\\
h\triangleright f^{\downarrow L}
\end{array}\,\bef f^{\uparrow Q}\\
\text{composition}:\quad & =e\triangleright\,\begin{array}{||c|}
f^{\downarrow R}\bef f^{\uparrow R}\bef g\bef f^{\downarrow Q}\\
f^{\downarrow S}\bef f^{\uparrow S}\bef h\bef f^{\downarrow Q}
\end{array}\,\bef f^{\uparrow Q}=e\triangleright\,\begin{array}{||c|}
f^{\downarrow R}\bef f^{\uparrow R}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}\\
f^{\downarrow S}\bef f^{\uparrow S}\bef h\bef f^{\downarrow Q}\bef f^{\uparrow Q}
\end{array}\quad.
\end{align*}

\end_inset

Apply the right-hand side to the same value:
\begin_inset Formula 
\begin{align*}
\text{expand }\boxtimes:\quad & \gunderline{e\times g\times h\triangleright\big(}f^{\uparrow(R+S)}\boxtimes f^{\uparrow K}\boxtimes f^{\uparrow L}\big)\bef v\bef f^{\downarrow Q}=(e\triangleright f^{\uparrow(R+S)})\times(\gunderline{g\triangleright f^{\uparrow K}})\times(\gunderline{h\triangleright f^{\uparrow L}})\triangleright v\bef f^{\downarrow Q}\\
\text{definition of }v:\quad & =e\triangleright\,\begin{array}{||cc|}
f^{\uparrow R} & \bbnum 0\\
\bbnum 0 & f^{\uparrow S}
\end{array}\,\bef\,\begin{array}{||c|}
g\triangleright f^{\uparrow K}\\
h\triangleright f^{\uparrow L}
\end{array}\,\bef f^{\downarrow Q}\\
\text{composition}:\quad & =e\triangleright\,\begin{array}{||c|}
f^{\uparrow R}\bef f^{\downarrow R}\bef g\bef f^{\uparrow Q}\\
f^{\uparrow S}\bef f^{\downarrow S}\bef h\bef f^{\uparrow Q}
\end{array}\,\bef f^{\downarrow Q}=e\triangleright\,\begin{array}{||c|}
f^{\uparrow R}\bef f^{\downarrow R}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}\\
f^{\uparrow S}\bef f^{\downarrow S}\bef h\bef f^{\uparrow Q}\bef f^{\downarrow Q}
\end{array}\quad.
\end{align*}

\end_inset

The two sides of the naturality law now differ only by the application order
 of lifted functions 
\begin_inset Formula $f$
\end_inset

.
 Applying the profunctor commutativity law of 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

, and 
\begin_inset Formula $Q$
\end_inset

, we find that the two sides of the naturality law are equal.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
9) Use recursion
\end_layout

\begin_layout Standard
Here the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is the value of the function 
\begin_inset Formula $t$
\end_inset

 itself, so the code of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow\overline{t}$
\end_inset

 (the overline in 
\begin_inset Formula $\overline{t}$
\end_inset

 denotes the recursive use of 
\begin_inset Formula $t$
\end_inset

).
 We treat 
\begin_inset Formula $\overline{t}$
\end_inset

 as just code for some function that is already known (by the inductive
 assumption) to obey its naturality law.
 Assume that the type of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

; then the recursive invocation 
\begin_inset Formula $\overline{t}$
\end_inset

 has the type 
\begin_inset Formula $Q^{A,A}$
\end_inset

 (which is a recursive type assumed to be equivalent to 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

).
 The naturality law of 
\begin_inset Formula $t$
\end_inset

 applied to an arbitrary 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 is
\begin_inset Formula 
\[
p\triangleright f^{\downarrow P}\bef t\bef f^{\uparrow Q}\overset{?}{=}p\triangleright f^{\uparrow P}\bef t\bef f^{\downarrow Q}\quad.
\]

\end_inset

Substituting 
\begin_inset Formula $t=p\rightarrow\overline{t}$
\end_inset

, we find
\begin_inset Formula 
\[
p\triangleright f^{\downarrow P}\triangleright(p\rightarrow\overline{t})\triangleright f^{\uparrow Q}=\overline{t}\triangleright f^{\uparrow Q}\overset{?}{=}p\triangleright f^{\uparrow P}\triangleright(p\rightarrow\overline{t})\triangleright f^{\downarrow Q}=\overline{t}\triangleright f^{\downarrow Q}\quad.
\]

\end_inset

It remains to show that 
\begin_inset Formula 
\[
\overline{t}\triangleright f^{\uparrow Q}\overset{?}{=}\overline{t}\triangleright f^{\downarrow Q}\quad.
\]

\end_inset

This is the 
\begin_inset Quotes eld
\end_inset

wedge law
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Formula $\overline{t}$
\end_inset

, which follows from the assumed dinaturality of 
\begin_inset Formula $\overline{t}$
\end_inset

 by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-expression-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
This concludes the proof of the parametricity theorem for dinatural transformati
ons: Any fully parametric function with a type parameter will automatically
 satisfy a dinaturality law.
 For functions having several type parameters, we can fix all the type parameter
s except one and apply the parametricity theorem separately, obtaining one
 dinaturality law per type parameter.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
3) Create function
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a nameless function 
\begin_inset Formula $z\rightarrow r$
\end_inset

, so 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow z\rightarrow r$
\end_inset

, where the sub-expression 
\begin_inset Formula $r$
\end_inset

 may use both 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 as bound variables.
 Since the code of 
\begin_inset Formula $r$
\end_inset

 is fully parametric, the types of 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 must be expressible as 
\begin_inset Formula $R^{A,A}$
\end_inset

 and 
\begin_inset Formula $Z^{A,A}$
\end_inset

, where 
\begin_inset Formula $R^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Z^{X,Y}$
\end_inset

 are some profunctors.
 The form of 
\begin_inset Formula $t$
\end_inset

 implies that 
\begin_inset Formula $Q^{A,A}=Z^{A,A}\rightarrow R^{A,A}$
\end_inset

, so we need to define the profunctor 
\begin_inset Formula $Q$
\end_inset

 as 
\begin_inset Formula $Q^{X,Y}\triangleq Z^{Y,X}\rightarrow R^{X,Y}$
\end_inset

 (note the reverse order of parameters in 
\begin_inset Formula $Z^{Y,X}$
\end_inset

).
 The inductive assumption says that the strong dinaturality law is already
 satisfied by 
\emph on
every
\emph default
 function whose body (
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) is just 
\begin_inset Formula $r$
\end_inset

.
 Such a function must have code of the form 
\begin_inset Formula $u\triangleq s\rightarrow r$
\end_inset

, where the type of the argument 
\begin_inset Formula $s$
\end_inset

 must contain the bound variables 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 that may be used in 
\begin_inset Formula $r$
\end_inset

.
 So, we define 
\begin_inset Formula $s\triangleq p\times z$
\end_inset

 and write the code of 
\begin_inset Formula $u$
\end_inset

 as 
\begin_inset Formula $u=p^{:P^{A,A}}\times z^{:Z^{A,A}}\rightarrow r$
\end_inset

.
 We then have:
\begin_inset Formula 
\begin{equation}
t=p^{:P^{A,A}}\rightarrow z^{:Z^{A,A}}\rightarrow u(p\times z)\quad,\quad\quad u=p^{:P^{A,A}}\times z^{:Z^{A,A}}\rightarrow t(p)(z)\quad.\label{eq:dinaturality-u-function-type-derivation0}
\end{equation}

\end_inset

We need to prove that the strong dinaturality law holds for 
\begin_inset Formula $t$
\end_inset

 assuming that it holds for 
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Define the profunctor 
\begin_inset Formula $U^{X,Y}\triangleq P^{X,Y}\times Z^{X,Y}$
\end_inset

 and write the type of 
\begin_inset Formula $u$
\end_inset

 as 
\begin_inset Formula $u:U^{A,A}\rightarrow R^{A,A}$
\end_inset

.
 Use the definitions 
\begin_inset Formula $U^{X,Y}\triangleq P^{X,Y}\times Z^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}\triangleq Z^{Y,X}\rightarrow R^{X,Y}$
\end_inset

 to express the liftings to 
\begin_inset Formula $U$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 through the liftings to 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

, and 
\begin_inset Formula $Z$
\end_inset

 via the standard functor and contrafunctor codes:
\begin_inset Formula 
\begin{align}
f^{\downarrow U^{\bullet,B}}=f^{\downarrow P^{\bullet,B}}\boxtimes f^{\downarrow Z^{\bullet,B}}\quad, & \quad\quad f^{\uparrow U^{A,\bullet}}=f^{\uparrow P^{A,\bullet}}\boxtimes f^{\uparrow Z^{A,\bullet}}\quad,\label{eq:dinaturality-u-function-type-derivation2}\\
f^{\uparrow Q^{A,\bullet}}=q^{:Q^{A,A}}\rightarrow f^{\downarrow Z^{\bullet,A}}\bef q\bef f^{\uparrow R^{A,\bullet}}\quad, & \quad\quad f^{\downarrow Q^{\bullet,B}}=q^{:Q^{B,B}}\rightarrow f^{\uparrow Z^{B,\bullet}}\bef q\bef f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-u-function-type-derivation3}
\end{align}

\end_inset


\end_layout

\begin_layout Plain Layout
We need to derive the strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

: for any 
\begin_inset Formula $x^{:P^{A,A}}$
\end_inset

, 
\begin_inset Formula $y^{:P^{B,B}}$
\end_inset

, and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
\text{when }\quad x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then }\quad x\triangleright t^{A}\triangleright f^{\uparrow Q^{A,\bullet}}\overset{?}{=}y\triangleright t^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad.
\]

\end_inset

Substituting Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-u-function-type-derivation0"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-u-function-type-derivation3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the equation above, we rewrite it as an equality between functions
 of type 
\begin_inset Formula $Z^{B,A}\rightarrow R^{A,B}$
\end_inset

.
\begin_inset Formula 
\begin{align*}
 & x\triangleright t^{A}\triangleright f^{\uparrow Q^{A,\bullet}}=(z^{:Z^{A,A}}\rightarrow u^{A}(x\times z))\triangleright f^{\uparrow Q^{A,\bullet}}=f^{\downarrow Z^{\bullet,A}}\bef(z^{:Z^{A,A}}\rightarrow u^{A}(x\times z))\bef f^{\uparrow R^{A,\bullet}}\\
 & \overset{?}{=}y\triangleright t^{B}\triangleright f^{\downarrow Q^{\bullet,B}}=(z^{:Z^{B,B}}\rightarrow u^{B}(y\times z))\triangleright f^{\downarrow Q^{\bullet,B}}=f^{\uparrow Z^{B,\bullet}}\bef(z^{:Z^{B,B}}\rightarrow u^{B}(y\times z))\bef f^{\downarrow R^{\bullet,B}}\quad.
\end{align*}

\end_inset

This is equivalent to
\begin_inset Formula 
\begin{equation}
z^{:Z^{B,A}}\rightarrow\big(x\times(z\triangleright f^{\downarrow Z^{\bullet,A}})\big)\triangleright u^{A}\triangleright f^{\uparrow R^{A,\bullet}}\overset{?}{=}z^{:Z^{B,A}}\rightarrow\big(y\times(z\triangleright f^{\uparrow Z^{B,\bullet}})\big)\triangleright u^{B}\triangleright f^{\downarrow R^{\bullet,B}}\quad.\label{eq:dinaturality-u-function-type-derivation4}
\end{equation}

\end_inset

The strong dinaturality law of 
\begin_inset Formula $u$
\end_inset

 says that for any 
\begin_inset Formula $r^{:U^{A,A}}$
\end_inset

, 
\begin_inset Formula $s^{:U^{B,B}}$
\end_inset

, and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
\text{when }\quad r\triangleright f^{\uparrow U^{A,\bullet}}=s\triangleright f^{\downarrow U^{\bullet,B}}\quad\text{ then }\quad r\triangleright u^{A}\triangleright f^{\uparrow R^{A,\bullet}}=s\triangleright u^{B}\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

We can now prove Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-u-function-type-derivation4"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by setting 
\begin_inset Formula $r\triangleq x\times(z\triangleright f^{\downarrow Z^{\bullet,A}})$
\end_inset

 and 
\begin_inset Formula $s\triangleq y\times(z\triangleright f^{\uparrow Z^{B,\bullet}})$
\end_inset

 as long as we prove the precondition of the strong dinaturality law of
 
\begin_inset Formula $u$
\end_inset

.
 Substituting Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-u-function-type-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into that assumption, we write it as:
\begin_inset Formula 
\begin{align*}
 & r\triangleright f^{\uparrow U^{A,\bullet}}=\big(x\times(z\triangleright f^{\downarrow Z^{\bullet,A}})\big)\triangleright(f^{\uparrow P^{A,\bullet}}\boxtimes f^{\uparrow Z^{A,\bullet}})=(x\triangleright f^{\uparrow P^{A,\bullet}})\times(z\triangleright f^{\downarrow Z^{\bullet,A}}\bef f^{\uparrow Z^{A,\bullet}})\\
 & \overset{?}{=}s\triangleright f^{\downarrow U^{\bullet,B}}=\big(y\times(z\triangleright f^{\uparrow Z^{B,\bullet}})\big)\triangleright(f^{\downarrow P^{\bullet,B}}\boxtimes f^{\downarrow Z^{\bullet,B}})=(y\triangleright f^{\downarrow P^{\bullet,B}})\times(z\triangleright f^{\uparrow Z^{B,\bullet}}\bef f^{\downarrow Z^{\bullet,B}})\quad.
\end{align*}

\end_inset

The last equation holds due to the given assumption 
\begin_inset Formula $x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$
\end_inset

 and the commutativity law of the (fully parametric) profunctor 
\begin_inset Formula $Z$
\end_inset

, namely 
\begin_inset Formula $f^{\downarrow Z^{\bullet,A}}\bef f^{\uparrow Z^{A,\bullet}}=f^{\uparrow Z^{B,\bullet}}\bef f^{\downarrow Z^{\bullet,B}}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Plain Layout
The proof does not assume that the expression 
\begin_inset Formula $t(z)(r)$
\end_inset

 actually uses its arguments 
\begin_inset Formula $z$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

.
 So, the law holds also for functions that ignore some (or all) of their
 arguments.
\end_layout

\begin_layout Paragraph
4) Use function 
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a function application such as 
\begin_inset Formula $g(z)$
\end_inset

.
 Then the code of 
\begin_inset Formula $t$
\end_inset

 must be 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow g(z)$
\end_inset

, where 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are some sub-expressions in the code of 
\begin_inset Formula $t$
\end_inset

.
 So, it must be possible to compute 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 separately, given 
\begin_inset Formula $p$
\end_inset

, via fully parametric functions 
\begin_inset Formula $u\triangleq p\rightarrow g$
\end_inset

 and 
\begin_inset Formula $v\triangleq p\rightarrow z$
\end_inset

.
 The inductive assumption is that the strong dinaturality law holds for
 any fully parametric functions whose body is 
\begin_inset Formula $g$
\end_inset

 or 
\begin_inset Formula $z$
\end_inset

.
 So, we need to prove that the strong dinaturality law holds for 
\begin_inset Formula $t=p\rightarrow v(p)\triangleright u(p)$
\end_inset

 given that it holds for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Plain Layout
What are the possible types of 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

? Since 
\begin_inset Formula $z$
\end_inset

 is computed by fully parametric code, the type of 
\begin_inset Formula $z$
\end_inset

 can be expressed as 
\begin_inset Formula $Z^{A,A}$
\end_inset

 via some profunctor 
\begin_inset Formula $Z^{X,Y}$
\end_inset

.
 To match the types, the function 
\begin_inset Formula $g$
\end_inset

 must have type 
\begin_inset Formula $Z^{A,A}\rightarrow Q^{A,A}$
\end_inset

.
 So, let us for convenience define the profunctor 
\begin_inset Formula $G^{X,Y}\triangleq Z^{Y,X}\rightarrow Q^{X,Y}$
\end_inset

 and write the type signatures of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 as
\begin_inset Formula 
\[
u:P^{A,A}\rightarrow G^{A,A}\quad,\quad\quad v:P^{A,A}\rightarrow Z^{A,A}\quad.
\]

\end_inset


\end_layout

\begin_layout Plain Layout
It seems to be impossible to prove the strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

 directly as a consequence of the assumed laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 Instead, we will express 
\begin_inset Formula $t$
\end_inset

 as a composition of two transformations: the first, denoted by 
\begin_inset Formula $s$
\end_inset

, simply gathers 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 in a tuple:
\begin_inset Formula 
\[
s:P^{A,A}\rightarrow(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\quad,\quad\quad s\triangleq p\rightarrow u(p)\times v(p)\quad.
\]

\end_inset

The second, denoted by 
\begin_inset Formula $w$
\end_inset

, applies a function to an argument:
\begin_inset Formula 
\[
w:(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad w\triangleq g\times z\rightarrow g(z)\quad.
\]

\end_inset

The functions 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are strongly dinatural due to Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strongly-dinatural-product-of-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a) and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinaturality-of-function-application"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Then it follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strongly-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the function composition 
\begin_inset Formula $t=s\bef w$
\end_inset

 is also strongly dinatural.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
A failed attempt to derive the strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

 from that of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

: 
\end_layout

\begin_layout Plain Layout
The strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

 says that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
\text{when}\quad x^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=y^{:P^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\text{ then}\quad x\triangleright t\triangleright f^{\uparrow Q^{A,\bullet}}\overset{?}{=}y\triangleright t\triangleright f^{\downarrow Q^{\bullet,B}}\quad.
\]

\end_inset

Substituting the definition 
\begin_inset Formula $t\triangleq p\rightarrow v(p)\triangleright u(p)$
\end_inset

 and dropping some type annotations, we rewrite it as
\begin_inset Formula 
\[
\text{when}\quad x^{:P^{A,A}}\triangleright f^{\uparrow P}=y^{:P^{B,B}}\triangleright f^{\downarrow P}\text{ then}\quad v(x)\triangleright u(x)\bef f^{\uparrow Q}\overset{?}{=}v(y)\triangleright u(y)\bef f^{\downarrow Q}\quad.
\]

\end_inset

The preconditions of the strong dinaturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are the same, and their conclusions are
\begin_inset Formula 
\[
v(x)\triangleright f^{\uparrow Z}\overset{!}{=}v(y)\triangleright f^{\downarrow Z}\quad\text{ and }\quad u(x)\triangleright f^{\uparrow G}\overset{!}{=}u(y)\triangleright f^{\downarrow G}\quad.
\]

\end_inset

We used the symbol 
\begin_inset Formula $\overset{!}{=}$
\end_inset

 since these laws are assumed to hold.
 With the code for liftings to 
\begin_inset Formula $G$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow G}=q^{:G^{A,A}}\rightarrow f^{\downarrow Z}\bef q\bef f^{\uparrow Q}\quad,\quad\quad f^{\downarrow G}=q^{:G^{B,B}}\rightarrow f^{\uparrow Z}\bef q\bef f^{\downarrow Q}\quad,
\]

\end_inset

we rewrite the conclusion of the strong dinaturality law of 
\begin_inset Formula $u$
\end_inset

 as
\begin_inset Formula 
\[
u(x)\triangleright f^{\uparrow G}=f^{\downarrow Z}\bef u(x)\bef f^{\uparrow Q}\overset{!}{=}u(y)\triangleright f^{\downarrow G}=f^{\uparrow Z}\bef u(y)\bef f^{\downarrow Q}\quad.
\]

\end_inset

Now we are ready to start with the left-hand side of the strong dinaturality
 law of 
\begin_inset Formula $t$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \quad v(x)\triangleright u(x)\bef f^{\uparrow Q}=
\end{align*}

\end_inset

We cannot insert 
\begin_inset Formula $f^{\uparrow Z}$
\end_inset

 or 
\begin_inset Formula $f^{\downarrow Z}$
\end_inset

 into this expression, so we can't use the assumptions about 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
It will be convenient to express 
\begin_inset Formula $t$
\end_inset

 as a composition of two transformations: the first, denoted by 
\begin_inset Formula $s$
\end_inset

, simply gathers 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 in a tuple,
\begin_inset Formula 
\[
s:P^{A,A}\rightarrow(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\quad,\quad\quad s\triangleq p\rightarrow u(p)\times v(p)\quad.
\]

\end_inset

The second, denoted 
\begin_inset Formula $w$
\end_inset

, applies the function:
\begin_inset Formula 
\[
w:(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad w\triangleq f\times z\rightarrow f(z)\quad.
\]

\end_inset

We will show separately that 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are dinatural.
 Since both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 are implemented via fully parametric code, it will follow by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the composition 
\begin_inset Formula $t=s\bef w$
\end_inset

 is also dinatural.
\end_layout

\begin_layout Plain Layout
Since 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are dinatural, we may apply the derivation in item 5 below (which does
 not use any other assumptions) with 
\begin_inset Formula $R\triangleq G$
\end_inset

 and 
\begin_inset Formula $S\triangleq Z$
\end_inset

 to show that the transformation 
\begin_inset Formula $s\triangleq p\rightarrow u(p)\times v(p)$
\end_inset

 of type 
\begin_inset Formula $P^{A,A}\rightarrow G^{A,A}\times Z^{A,A}$
\end_inset

 is also dinatural.
\end_layout

\begin_layout Plain Layout
It remains to show that the transformation 
\begin_inset Formula $w\triangleq g\times z\rightarrow z\triangleright g$
\end_inset

 is dinatural.
 For brevity, we will omit type annotations and write 
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 instead of 
\begin_inset Formula $f^{\uparrow G^{X,\bullet}}$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow G}$
\end_inset

 instead of 
\begin_inset Formula $f^{\downarrow G^{\bullet,Y}}$
\end_inset

, with 
\begin_inset Formula $G$
\end_inset

 and other profunctors.
 Since profunctors have one contravariant and one covariant type parameter,
 the choice of the type parameter in a lifting will remain unambiguous.
 The naturality law is then written as
\begin_inset Formula 
\begin{equation}
(f^{\downarrow G}\boxtimes f^{\downarrow Z})\bef w\bef f^{\uparrow Q}\overset{?}{=}(f^{\uparrow G}\boxtimes f^{\uparrow Z})\bef w\bef f^{\downarrow Q}\quad.\label{eq:dinaturality-law-application-derivation1}
\end{equation}

\end_inset

It helps to write out the liftings to 
\begin_inset Formula $G$
\end_inset

.
 For arbitrary 
\begin_inset Formula $g^{:G^{B,A}}$
\end_inset

 and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, we have 
\begin_inset Formula $g\triangleright f^{\downarrow G^{\bullet,A}}$
\end_inset

 of type 
\begin_inset Formula $G^{A,A}=Z^{A,A}\rightarrow Q^{A,A}$
\end_inset

, so
\begin_inset Formula 
\begin{align*}
g^{:G^{B,A}}\triangleright f^{\downarrow G} & =z^{:Z^{A,A}}\rightarrow(z\triangleright f^{\uparrow Z})\triangleright g\bef f^{\downarrow Q}=f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset

Similarly
\begin_inset Formula 
\[
g^{:G^{B,A}}\triangleright f^{\uparrow G}=z^{:Z^{B,B}}\rightarrow(z\triangleright f^{\downarrow Z})\triangleright g\bef f^{\uparrow Q}=f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\quad.
\]

\end_inset

Now apply the left-hand side of the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to an arbitrary 
\begin_inset Formula $g^{:G^{B,A}}\times z^{:Z^{B,A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{definitions of }\boxtimes\text{ and }w:\quad & (g^{:G^{B,A}}\times z^{:Z^{B,A}})\triangleright(f^{\downarrow G}\boxtimes f^{\downarrow Z})\bef w\bef f^{\uparrow Q}=(z\triangleright f^{\downarrow Z})\triangleright(\gunderline{g\triangleright f^{\downarrow G}})\bef f^{\uparrow Q}\\
\text{definition of }g\triangleright f^{\downarrow G}:\quad & =(z\triangleright f^{\downarrow Z})\triangleright f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}=z\triangleright f^{\downarrow Z}\bef f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}\quad.
\end{align*}

\end_inset

Applying the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $g\times z$
\end_inset

 gives similarly
\begin_inset Formula 
\begin{align*}
\text{definitions of }\boxtimes\text{ and }w:\quad & (g^{:G^{B,A}}\times z^{:Z^{B,A}})\triangleright(f^{\uparrow G}\boxtimes f^{\uparrow Z})\bef w\bef f^{\downarrow Q}=(z\triangleright f^{\uparrow Z})\triangleright(\gunderline{g\triangleright f^{\uparrow G}})\bef f^{\downarrow Q}\\
\text{definition of }g\triangleright f^{\uparrow G}:\quad & =(z\triangleright f^{\uparrow Z})\triangleright f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}=z\triangleright f^{\uparrow Z}\bef f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset

The two sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) now differ only by the order of application of lifted functions 
\begin_inset Formula $f^{\uparrow Z}$
\end_inset

, 
\begin_inset Formula $f^{\downarrow Z}$
\end_inset

, 
\begin_inset Formula $f^{\uparrow Q}$
\end_inset

, and 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

.
 These applications commute by the profunctor commutativity laws of 
\begin_inset Formula $Z$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow Z}\bef f^{\uparrow Z}=f^{\uparrow Z}\bef f^{\downarrow Z}\quad,\quad\quad f^{\downarrow Q}\bef f^{\uparrow Q}=f^{\uparrow Q}\bef f^{\downarrow Q}\quad.
\]

\end_inset

This concludes the proof of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-application-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and so proves the entire item 4.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Paragraph
5) Create tuple 
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a tuple, so the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow r\times s$
\end_inset

, where the sub-expressions 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 must have types given by some profunctors 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

.
 So, we have 
\begin_inset Formula $Q^{X,Y}=R^{X,Y}\times S^{X,Y}$
\end_inset

.
 Since the code of 
\begin_inset Formula $t$
\end_inset

 computes 
\begin_inset Formula $r\times s$
\end_inset

 from 
\begin_inset Formula $p$
\end_inset

, we should be able to compute 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 separately from 
\begin_inset Formula $p$
\end_inset

.
 It means that we have fully parametric functions 
\begin_inset Formula $u\triangleq p\rightarrow r$
\end_inset

 and 
\begin_inset Formula $v\triangleq p\rightarrow s$
\end_inset

 having types 
\begin_inset Formula $u:P^{A,A}\rightarrow R^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:P^{A,A}\rightarrow S^{A,A}$
\end_inset

.
 The inductive assumption is that the strong dinaturality law already holds
 for any function whose body is 
\begin_inset Formula $r$
\end_inset

 or 
\begin_inset Formula $s$
\end_inset

.
 So, we may assume that the law holds for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 The function 
\begin_inset Formula $t$
\end_inset

 can be expressed as
\begin_inset Formula 
\[
t=(p^{:P^{A,A}}\rightarrow p\times p)\bef(p^{:P^{A,A}}\times p^{:P^{A,A}}\rightarrow u(p)\times v(p))=\Delta^{P^{A,A}}\bef(u\boxtimes v)\quad.
\]

\end_inset

Note that 
\begin_inset Formula $\Delta^{A}:A\rightarrow A\times A$
\end_inset

 is a natural transformation (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Deriving-laws-for-functions-"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

, setting the type parameter of 
\begin_inset Formula $\Delta$
\end_inset

 to 
\begin_inset Formula $P^{A,A}$
\end_inset

 yields a strongly dinatural transformation (
\begin_inset Formula $\Delta^{P^{A,A}}$
\end_inset

).
 The pair product 
\begin_inset Formula $u\boxtimes v$
\end_inset

 is strongly dinatural by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-coproduct-dinatural"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a).
 The composition 
\begin_inset Formula $\Delta\bef(u\boxtimes v)$
\end_inset

 is strongly dinatural by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strongly-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 So, we have proved that 
\begin_inset Formula $t$
\end_inset

 is strongly dinatural.
\end_layout

\begin_layout Paragraph
6) Use tuple 
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 contains a tuple accessor, such as 
\begin_inset Formula $\pi_{1}$
\end_inset

.
 It is sufficient to prove the law for 
\begin_inset Formula $\pi_{1}$
\end_inset

, since all tuple accessors work similarly.
 So, we assume that the type 
\begin_inset Formula $P$
\end_inset

 is a product, 
\begin_inset Formula $P^{X,Y}\triangleq Q^{X,Y}\times R^{X,Y}$
\end_inset

, and that the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq\pi_{1}=p^{:Q^{A,A}\times R^{A,A}}\rightarrow p\triangleright\pi_{1}$
\end_inset

.
 This is just the natural transformation 
\begin_inset Formula $\pi_{1}:A\times B\rightarrow A$
\end_inset

 with substituted type parameters.
 So, the strong dinaturality of 
\begin_inset Formula $t$
\end_inset

 follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinatural-substitute-profunctor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $G^{X,Y}\triangleq X\times Y$
\end_inset

, 
\begin_inset Formula $H^{X,Y}\triangleq X$
\end_inset

, 
\begin_inset Formula $P\triangleq Q$
\end_inset

, and 
\begin_inset Formula $Q\triangleq R$
\end_inset

.
\end_layout

\begin_layout Paragraph
7) Create disjunctive value 
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a case class value (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some
\end_layout

\end_inset

, etc.).
 We may assume that 
\begin_inset Formula $Q^{X,Y}=R^{X,Y}+S^{X,Y}$
\end_inset

 for some profunctors 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

, and that the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow r^{:R^{A,A}}+\bbnum 0^{:S^{A,A}}$
\end_inset

, where 
\begin_inset Formula $r$
\end_inset

 is some expression of type 
\begin_inset Formula $R^{A,A}$
\end_inset

.
 It is sufficient to prove the law for 
\begin_inset Formula $t=p\rightarrow r+\bbnum 0$
\end_inset

, because other disjunctive functions such as 
\begin_inset Formula $t=p\rightarrow\bbnum 0+s$
\end_inset

 work analogously.
\end_layout

\begin_layout Plain Layout
Since the code of 
\begin_inset Formula $t$
\end_inset

 is fully parametric, the value 
\begin_inset Formula $r$
\end_inset

 can be also computed from 
\begin_inset Formula $p$
\end_inset

 using fully parametric code.
 So the inductive assumption is that the transformation 
\begin_inset Formula $u\triangleq p\rightarrow r$
\end_inset

 is already known to be strongly dinatural, with the law***
\begin_inset Formula 
\[
f^{\downarrow P}\bef u\bef f^{\uparrow R}=f^{\uparrow P}\bef u\bef f^{\downarrow R}\quad.
\]

\end_inset

 The naturality law for 
\begin_inset Formula $t$
\end_inset

 is
\begin_inset Formula 
\[
f^{\downarrow P}\bef t\bef f^{\uparrow Q}\overset{?}{=}f^{\uparrow P}\bef t\bef f^{\downarrow Q}\quad.
\]

\end_inset

The liftings to 
\begin_inset Formula $Q$
\end_inset

 are disjunctive functions written in the matrix notation as
\begin_inset Formula 
\[
f^{\uparrow Q^{B,\bullet}}=\,\begin{array}{|c||cc|}
 & R^{B,B} & S^{B,B}\\
\hline R^{B,A} & f^{\uparrow R^{B,\bullet}} & \bbnum 0\\
S^{B,A} & \bbnum 0 & f^{\uparrow S^{B,\bullet}}
\end{array}\quad,\quad\quad f^{\downarrow Q^{\bullet,A}}=\,\begin{array}{|c||cc|}
 & R^{A,A} & S^{A,A}\\
\hline R^{B,A} & f^{\downarrow R^{\bullet,A}} & \bbnum 0\\
S^{B,A} & \bbnum 0 & f^{\downarrow S^{\bullet,A}}
\end{array}\quad.
\]

\end_inset

Omitting type annotations, we apply the naturality law to a value 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 and get
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p\triangleright f^{\downarrow P}\bef t\bef f^{\uparrow Q}=\big((p\triangleright f^{\downarrow P}\triangleright u)+\bbnum 0\big)\triangleright\,\begin{array}{||cc|}
f^{\uparrow R} & \bbnum 0\\
\bbnum 0 & f^{\uparrow S}
\end{array}\\
\text{apply disjunctive function}:\quad & \quad=p\triangleright f^{\downarrow P}\bef u\bef f^{\uparrow R}\quad.\\
\text{right-hand side}:\quad & p\triangleright f^{\uparrow P}\bef t\bef f^{\downarrow Q}=\big((p\triangleright f^{\uparrow P}\triangleright u)+\bbnum 0\big)\triangleright\,\begin{array}{||cc|}
f^{\downarrow R} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S}
\end{array}\\
\text{apply disjunctive function}:\quad & \quad=p\triangleright\gunderline{f^{\uparrow P}\bef u\bef f^{\downarrow R}}\\
\text{dinaturality of }u:\quad & \quad=p\triangleright f^{\downarrow P}\bef u\bef f^{\uparrow R}\quad.
\end{align*}

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Paragraph
8) Use disjunctive value 
\end_layout

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a pattern-matching function, so the code of 
\begin_inset Formula $t$
\end_inset

 is of the form 
\begin_inset Formula 
\[
t\triangleq p^{:P^{A,A}}\rightarrow p\triangleright\,\begin{array}{||c|}
g\\
h
\end{array}\quad,
\]

\end_inset

where 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 are known functions.
 The expressions 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 are used as part of the code, and so they must be all fully parametric
 and computable from 
\begin_inset Formula $p$
\end_inset

.
 We may use the inductive assumption that the transformations 
\begin_inset Formula $p\rightarrow g$
\end_inset

 and 
\begin_inset Formula $p\rightarrow h$
\end_inset

 are strongly dinatural.
\end_layout

\begin_layout Plain Layout
Since 
\begin_inset Formula $P^{A,A}$
\end_inset

 must be a disjunctive type, assume that 
\begin_inset Formula $P^{X,Y}=R^{X,Y}+S^{X,Y}$
\end_inset

 with some profunctors 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

.
 The code of 
\begin_inset Formula $t$
\end_inset

 can then be written in matrix notation:
\begin_inset Formula 
\[
t=\begin{array}{|c||c|}
 & Q^{A,A}\\
\hline R^{A,A} & g\\
S^{A,A} & h
\end{array}
\]

\end_inset

*** 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset

 is 
\end_layout

\begin_layout Plain Layout
See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Working-with-disjunctive-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a derivation of the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

.*** 
\end_layout

\begin_layout Paragraph
9) Use recursion
\end_layout

\begin_layout Plain Layout
Here the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expression
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is the value of the function 
\begin_inset Formula $t$
\end_inset

 itself, so the code of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $t\triangleq p^{:P^{A,A}}\rightarrow\overline{t}$
\end_inset

 (the overline in 
\begin_inset Formula $\overline{t}$
\end_inset

 denotes the recursive use of 
\begin_inset Formula $t$
\end_inset

).
 We treat 
\begin_inset Formula $\overline{t}$
\end_inset

 as just code for some function that is already known (by the inductive
 assumption) to obey its naturality law.
 Assume that the type of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

; then the recursive invocation 
\begin_inset Formula $\overline{t}$
\end_inset

 has the type 
\begin_inset Formula $Q^{A,A}$
\end_inset

 (which is a recursive type assumed to be equivalent to 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

).
 The naturality law of 
\begin_inset Formula $t$
\end_inset

 applied to an arbitrary 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 is
\begin_inset Formula 
\[
p\triangleright f^{\downarrow P}\bef t\bef f^{\uparrow Q}\overset{?}{=}p\triangleright f^{\uparrow P}\bef t\bef f^{\downarrow Q}\quad.
\]

\end_inset

Substituting 
\begin_inset Formula $t=p\rightarrow\overline{t}$
\end_inset

, we find
\begin_inset Formula 
\[
p\triangleright f^{\downarrow P}\triangleright(p\rightarrow\overline{t})\triangleright f^{\uparrow Q}=\overline{t}\triangleright f^{\uparrow Q}\overset{?}{=}p\triangleright f^{\uparrow P}\triangleright(p\rightarrow\overline{t})\triangleright f^{\downarrow Q}=\overline{t}\triangleright f^{\downarrow Q}\quad.
\]

\end_inset

It remains to show that 
\begin_inset Formula 
\[
\overline{t}\triangleright f^{\uparrow Q}\overset{?}{=}\overline{t}\triangleright f^{\downarrow Q}\quad.
\]

\end_inset

This is the 
\begin_inset Quotes eld
\end_inset

wedge law
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Formula $\overline{t}$
\end_inset

, which follows from the assumed dinaturality of 
\begin_inset Formula $\overline{t}$
\end_inset

 by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-expression-wedge-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
This concludes the proof of what is commonly known as 
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

 parametricity theorem: Any fully parametric function with a type parameter
 will automatically satisfy a naturality law.
 For functions having several type parameters, we can fix all the type parameter
s except one and apply the parametricity theorem to obtain a separate naturality
 law for each type parameter.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we will derive some results that are used in the main proof.
 
\end_layout

\begin_layout Standard
The proof of the main parametricity theorem is made shorter if we use the
 following property: If the type parameters of a natural transformation
 are substituted by some profunctors, we will obtain a dinatural transformation.
 Two versions of this property are proved next.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-substitute-functor-in-natural"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $u^{A}:G^{A}\rightarrow H^{A}$
\end_inset

 is a natural transformation, and suppose 
\begin_inset Formula $P^{X,Y}$
\end_inset

 is some fully parametric profunctor.
 Define the transformation
\begin_inset Formula 
\[
t^{A}:G^{P^{A,A}}\rightarrow H^{P^{A,A}}\quad,\quad\quad t^{A}\triangleq u^{P^{A,A}}\quad,
\]

\end_inset

by using the unmodified code of the function 
\begin_inset Formula $u^{A}$
\end_inset

 with a substituted type parameter, 
\begin_inset Formula $P^{A,A}$
\end_inset

 instead of 
\begin_inset Formula $A$
\end_inset

.
 Then 
\begin_inset Formula $t$
\end_inset

 is a dinatural transformation between profunctors 
\begin_inset Formula $G^{P^{A,A}}$
\end_inset

 and 
\begin_inset Formula $H^{P^{A,A}}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
By assumption, the naturality law of 
\begin_inset Formula $u$
\end_inset

 holds for any 
\begin_inset Formula $k^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
k^{\uparrow G}\bef u^{B}=u^{A}\bef k^{\uparrow H}\quad.
\]

\end_inset

The naturality law of 
\begin_inset Formula $t$
\end_inset

 is an equality of functions of type 
\begin_inset Formula $G^{P^{B,A}}\rightarrow H^{P^{A,B}}$
\end_inset

 for an arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\[
\big(f^{\downarrow P^{\bullet,A}}\big)^{\uparrow G}\bef t^{A}\bef\big(f^{\uparrow P^{\bullet,A}}\big)^{\uparrow H}\overset{?}{=}\big(f^{\uparrow P^{B,\bullet}}\big)^{\uparrow G}\bef t^{B}\bef\big(f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}\quad.
\]

\end_inset

Begin the calculation with the left-hand side of that law:
\begin_inset Formula 
\begin{align*}
\text{use }t^{A}=u^{P^{A,A}}:\quad & \big(f^{\downarrow P^{\bullet,A}}\big)^{\uparrow G}\bef\underline{t^{A}}\bef\big(f^{\uparrow P^{A,\bullet}}\big)^{\uparrow H}=\gunderline{\big(f^{\downarrow P^{\bullet,A}}\big)^{\uparrow G}\bef u^{P^{A,A}}}\bef\big(f^{\uparrow P^{A,\bullet}}\big)^{\uparrow H}\\
\text{naturality of }u:\quad & =u^{P^{B,A}}\bef\gunderline{\big(f^{\downarrow P^{\bullet,A}}\big)^{\uparrow H}\bef\big(f^{\uparrow P^{A,\bullet}}\big)^{\uparrow H}}=u^{P^{B,A}}\bef\big(f^{\downarrow P^{\bullet,A}}\bef f^{\uparrow P^{A,\bullet}}\big)^{\uparrow H}\quad.
\end{align*}

\end_inset

Now write the right-hand side:
\begin_inset Formula 
\begin{align*}
\text{use }t^{B}=u^{P^{B,B}}:\quad & \big(f^{\uparrow P^{B,\bullet}}\big)^{\uparrow G}\bef\gunderline{t^{B}}\bef\big(f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}=\gunderline{\big(f^{\uparrow P^{B,\bullet}}\big)^{\uparrow G}\bef u^{P^{B,B}}}\bef\big(f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}\\
\text{naturality of }u:\quad & =u^{P^{B,A}}\bef\gunderline{\big(f^{\uparrow P^{B,\bullet}}\big)^{\uparrow H}\bef\big(f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}}=u^{P^{B,A}}\bef\big(f^{\uparrow P^{B,\bullet}}\bef f^{\downarrow P^{\bullet,B}}\big)^{\uparrow H}\quad.
\end{align*}

\end_inset

The difference between the left-hand side and the right-hand side is now
 only in the order of applying lifted functions 
\begin_inset Formula $f$
\end_inset

.
 By the profunctor commutativity law of 
\begin_inset Formula $P$
\end_inset

, we have
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,A}}\bef f^{\uparrow P^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef f^{\downarrow P^{\bullet,B}}\quad,
\]

\end_inset

which completes the proof.
\end_layout

\begin_layout Standard
The following more general version of the same property will be also useful.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-substitute-profunctor-in-natural"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-substitute-profunctor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $G^{X,Y}$
\end_inset

 and 
\begin_inset Formula $H^{X,Y}$
\end_inset

 are some bifunctors, 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 are some profunctors, all fully parametric, and 
\begin_inset Formula $u^{A,B}:G^{A,B}\rightarrow H^{A,B}$
\end_inset

 is a natural transformation separately in the type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 Define the transformation 
\begin_inset Formula 
\[
t^{A}:G^{P^{A,A},Q^{A,A}}\rightarrow H^{P^{A,A},Q^{A,A}}\quad,\quad\quad t\triangleq u^{P^{A,A,},Q^{A,A}}\quad,
\]

\end_inset

by using the unmodified code of 
\begin_inset Formula $u^{A,B}$
\end_inset

 with substituted type parameters, 
\begin_inset Formula $P^{A,A}$
\end_inset

 and 
\begin_inset Formula $Q^{A,A}$
\end_inset

 instead of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 Then 
\begin_inset Formula $t$
\end_inset

 is a dinatural transformation between profunctors 
\begin_inset Formula $G^{P^{A,A},Q^{A,A}}$
\end_inset

 and 
\begin_inset Formula $H^{P^{A,A},Q^{A,A}}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The assumed naturality law of 
\begin_inset Formula $u$
\end_inset

 holds separately with respect to both type parameters,
\begin_inset Formula 
\[
f^{\uparrow G^{\bullet,B}}\bef u^{B,B}=u^{A,B}\bef f^{\uparrow H^{\bullet,B}}\quad,\quad\quad f^{\uparrow G^{A,\bullet}}\bef u^{A,B}=u^{A,A}\bef f^{\uparrow H^{A,\bullet}}\quad.
\]

\end_inset

 The naturality law of 
\begin_inset Formula $t$
\end_inset

 is written, after substituting 
\begin_inset Formula $t=u$
\end_inset

, as
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (f^{\downarrow P})^{\uparrow G^{\bullet,Q^{B,A}}}\bef(f^{\downarrow Q})^{\uparrow G^{P^{A,A},\bullet}}\bef u^{P^{A,A},Q^{A,A}}\bef(f^{\uparrow P})^{\uparrow H^{\bullet,Q^{A,A}}}\bef(f^{\uparrow Q})^{\uparrow H^{P^{A,B},\bullet}}\\
\text{right-hand side}:\quad & \quad\overset{?}{=}(f^{\uparrow P})^{\uparrow G^{\bullet,Q^{B,A}}}\bef(f^{\uparrow Q})^{\uparrow G^{P^{B,B},\bullet}}\bef u^{P^{B,B},Q^{B,B}}\bef(f^{\downarrow P})^{\uparrow H^{\bullet,Q^{B,B}}}\bef(f^{\downarrow Q})^{\uparrow H^{P^{A,B},\bullet}}\quad.
\end{align*}

\end_inset

The naturality law of 
\begin_inset Formula $u$
\end_inset

 allows us to move all 
\begin_inset Formula $G$
\end_inset

-lifted functions to the right of 
\begin_inset Formula $u$
\end_inset

, where they become 
\begin_inset Formula $H$
\end_inset

-lifted.
 The law becomes
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & u^{P^{B,A},Q^{B,A}}\bef(f^{\downarrow P})^{\uparrow H^{\bullet,Q^{B,A}}}\bef(f^{\downarrow Q})^{\uparrow H^{P^{A,A},\bullet}}\bef(f^{\uparrow P})^{\uparrow H^{\bullet,Q^{A,A}}}\bef(f^{\uparrow Q})^{\uparrow H^{P^{A,B},\bullet}}\\
\text{right-hand side}:\quad & \quad\overset{?}{=}u^{P^{B,A},Q^{B,A}}\bef(f^{\uparrow P})^{\uparrow H^{\bullet,Q^{B,A}}}\bef(f^{\uparrow Q})^{\uparrow H^{P^{B,B},\bullet}}\bef(f^{\downarrow P})^{\uparrow H^{\bullet,Q^{B,B}}}\bef(f^{\downarrow Q})^{\uparrow H^{P^{A,B},\bullet}}\quad.
\end{align*}

\end_inset

The remaining difference between the two sides is only in the application
 order of lifted functions 
\begin_inset Formula $f$
\end_inset

.
 All those liftings commute due to the profunctor and bifunctor commutativity
 laws.
\end_layout

\begin_layout Standard
We have seen in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that pair products and pair co-products of natural transformations are
 again natural.
 The same holds for dinatural and strongly dinatural transformations:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-pair-product-coproduct-dinatural"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-coproduct-dinatural"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given two dinatural transformations 
\begin_inset Formula $u^{:P^{A,A}\rightarrow R^{A,A}}$
\end_inset

 and 
\begin_inset Formula $v^{:Q^{A,A}\rightarrow S^{A,A}}$
\end_inset

:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The pair product 
\begin_inset Formula $t\triangleq u\boxtimes v$
\end_inset

 (of type 
\begin_inset Formula $P^{A,A}\times Q^{A,A}\rightarrow R^{A,A}\times S^{A,A}$
\end_inset

) is dinatural.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The pair co-product
\begin_inset Index idx
status open

\begin_layout Plain Layout
pair co-product of functions
\end_layout

\end_inset

 
\begin_inset Formula $t\triangleq u\boxplus v$
\end_inset

 (of type 
\begin_inset Formula $P^{A,A}+Q^{A,A}\rightarrow R^{A,A}+S^{A,A}$
\end_inset

) is dinatural.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The naturality law of 
\begin_inset Formula $t\triangleq u\boxtimes v$
\end_inset

 says that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\[
(f^{\downarrow P}\boxtimes f^{\downarrow Q})\bef(u\boxtimes v)\bef(f^{\uparrow R}\boxtimes f^{\uparrow S})\overset{?}{=}(f^{\uparrow P}\boxtimes f^{\uparrow Q})\bef(u\boxtimes v)\bef(f^{\downarrow R}\boxtimes f^{\downarrow S})\quad.
\]

\end_inset

Compute the function compositions with the definition of the pair product
 (
\begin_inset Formula $\boxtimes$
\end_inset

):
\begin_inset Formula 
\[
\big(f^{\downarrow P}\bef u\bef f^{\uparrow R}\big)\boxtimes\big(f^{\downarrow Q}\bef v\bef f^{\uparrow S}\big)\overset{?}{=}\big(f^{\uparrow P}\bef u\bef f^{\downarrow R}\big)\boxtimes\big(f^{\uparrow Q}\bef v\bef f^{\downarrow S}\big)\quad.
\]

\end_inset

The last equation holds due to the dinaturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The naturality law of 
\begin_inset Formula $t\triangleq u\boxplus v$
\end_inset

 says that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \begin{array}{|c||cc|}
 & P^{A,A} & Q^{A,A}\\
\hline P^{B,A} & f^{\downarrow P} & \bbnum 0\\
Q^{B,A} & \bbnum 0 & f^{\downarrow Q}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & R^{A,A} & S^{A,A}\\
\hline P^{A,A} & u & \bbnum 0\\
Q^{A,A} & \bbnum 0 & v
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline R^{A,A} & f^{\uparrow R} & \bbnum 0\\
S^{A,A} & \bbnum 0 & f^{\uparrow S}
\end{array}\\
 & \overset{?}{=}\,\begin{array}{|c||cc|}
 & P^{B,B} & Q^{B,B}\\
\hline P^{B,A} & f^{\uparrow P} & \bbnum 0\\
Q^{B,A} & \bbnum 0 & f^{\uparrow Q}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & R^{B,B} & S^{B,B}\\
\hline P^{B,B} & u & \bbnum 0\\
Q^{B,B} & \bbnum 0 & v
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline R^{B,B} & f^{\downarrow R} & \bbnum 0\\
S^{B,B} & \bbnum 0 & f^{\downarrow S}
\end{array}\quad.
\end{align*}

\end_inset

Compute the matrix compositions to rewrite this equation as
\begin_inset Formula 
\[
\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline P^{B,A} & f^{\downarrow P}\bef u\bef f^{\uparrow R} & \bbnum 0\\
Q^{B,A} & \bbnum 0 & f^{\downarrow Q}\bef v\bef f^{\uparrow S}
\end{array}\,\overset{?}{=}\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline P^{B,A} & f^{\uparrow P}\bef u\bef f^{\downarrow R} & \bbnum 0\\
Q^{B,A} & \bbnum 0 & f^{\uparrow Q}\bef v\bef f^{\downarrow S}
\end{array}\quad.
\]

\end_inset

The last equation holds due to the dinaturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-dinatural-product-of-functions"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-product-of-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If both 
\begin_inset Formula $u:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:P^{A,A}\rightarrow R^{A,A}$
\end_inset

 are dinatural then 
\begin_inset Formula 
\[
t:P^{A,A}\rightarrow Q^{A,A}\times R^{A,A}\quad,\quad\quad t\triangleq p^{:P^{A,A}}\rightarrow u(p)\times v(p)
\]

\end_inset

is also dinatural.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If both 
\begin_inset Formula $u:P^{A,A}\rightarrow R^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A,A}\rightarrow R^{A,A}$
\end_inset

 are dinatural then
\begin_inset Formula 
\[
t:P^{A,A}+Q^{A,A}\rightarrow R^{A,A}\quad,\quad\quad t\triangleq\,\begin{array}{|c||c|}
 & R^{A,A}\\
\hline P^{A,A} & u\\
Q^{A,A} & v
\end{array}
\]

\end_inset

is also dinatural.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The dinaturality law of 
\begin_inset Formula $t$
\end_inset

 is written as
\begin_inset Formula 
\[
f^{\uparrow P}\bef t\bef(f^{\downarrow Q}\boxtimes f^{\downarrow R})\overset{?}{=}f^{\downarrow P}\bef t\bef(f^{\uparrow Q}\boxtimes f^{\uparrow R})\quad.
\]

\end_inset

Substituting the definition 
\begin_inset Formula $t\triangleq p\rightarrow u(p)\times v(p)$
\end_inset

, we rewrite that law as
\begin_inset Formula 
\[
\big(p\rightarrow(p\triangleright f^{\uparrow P}\triangleright u)\times(p\triangleright f^{\uparrow P}\triangleright v)\big)\bef(f^{\downarrow Q}\boxtimes f^{\downarrow R})\overset{?}{=}\big(p\rightarrow(p\triangleright f^{\downarrow P}\triangleright u)\times(p\triangleright f^{\downarrow P}\triangleright v)\big)\big)\bef(f^{\uparrow Q}\boxtimes f^{\uparrow R})\quad.
\]

\end_inset

Expand the composition with the pair product:
\begin_inset Formula 
\[
p\rightarrow(p\triangleright f^{\uparrow P}\bef u\bef f^{\downarrow Q})\times(p\triangleright f^{\uparrow P}\bef v\bef f^{\downarrow R})\overset{?}{=}p\rightarrow(p\triangleright f^{\downarrow P}\bef u\bef f^{\uparrow Q})\times(p\triangleright f^{\downarrow P}\bef v\bef f^{\uparrow R})\quad.
\]

\end_inset

The last equation holds due to the dinaturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The naturality law of 
\begin_inset Formula $t$
\end_inset

 is written as
\begin_inset Formula 
\[
\begin{array}{|c||cc|}
 & P^{A,A} & Q^{A,A}\\
\hline P^{B,A} & f^{\downarrow P} & \bbnum 0\\
Q^{B,A} & \bbnum 0 & f^{\downarrow Q}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & R^{A,A}\\
\hline P^{A,A} & u\\
Q^{A,A} & v
\end{array}\,\bef f^{\uparrow R}\overset{?}{=}\,\begin{array}{|c||cc|}
 & P^{B,B} & Q^{B,B}\\
\hline P^{B,A} & f^{\uparrow P} & \bbnum 0\\
Q^{B,A} & \bbnum 0 & f^{\uparrow Q}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & R^{B,B}\\
\hline P^{B,B} & u\\
Q^{B,B} & v
\end{array}\,\bef f^{\downarrow R}\quad.
\]

\end_inset

Compute the matrix compositions:
\begin_inset Formula 
\[
\begin{array}{|c||c|}
 & R^{A,B}\\
\hline P^{B,A} & f^{\downarrow P}\bef u\bef f^{\uparrow R}\\
Q^{B,A} & f^{\downarrow Q}\bef v\bef f^{\uparrow R}
\end{array}\,\overset{?}{=}\,\begin{array}{|c||c|}
 & P^{B,B}\\
\hline P^{B,A} & f^{\uparrow P}\bef u\bef f^{\downarrow R}\\
Q^{B,A} & f^{\uparrow Q}\bef v\bef f^{\downarrow R}
\end{array}\quad.
\]

\end_inset

The last equation holds due to the dinaturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Subsection
Uniqueness of functor and contrafunctor typeclass instances
\begin_inset CommandInset label
LatexCommand label
name "sec:Uniqueness-of-functor-and-contrafunctor"

\end_inset


\end_layout

\begin_layout Standard
An important consequence of the parametricity theorem is the fact that functors
 and contrafunctors can be implemented in only one way.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-functor-is-unique"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-functor-is-unique"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!functor
\end_layout

\end_inset


\series bold
fully parametric functor
\series default
, i.e., a functor 
\begin_inset Formula $F$
\end_inset

 whose type is a combination of the constructions of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, has a unique lawful and fully parametric implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 derived lawful and fully parametric implementations of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method for all functors 
\begin_inset Formula $F$
\end_inset

 build up from the six type constructions.
 The naturality laws obtained from the parametricity theorem must use precisely
 those 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, because the proof of the parametricity theorem significantly depends on
 the code of those implementations.
 Throughout this book, the standard lifting code is denoted by 
\begin_inset Formula $\text{fmap}_{F}(f)$
\end_inset

 or by 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

.
 Now suppose that there exists 
\emph on
another
\emph default
 lawful and fully parametric implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for 
\begin_inset Formula $F$
\end_inset

, denoted by 
\begin_inset Formula $\text{fmap}_{F}^{\prime}(f)$
\end_inset

:
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}\quad,\quad\quad\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B})=\text{???}^{:F^{A}\rightarrow F^{B}}\quad.
\]

\end_inset

We will now show that 
\begin_inset Formula $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$
\end_inset

.
 Let us fix the type parameter 
\begin_inset Formula $A$
\end_inset

 and apply the parametricity theorem to 
\begin_inset Formula $\text{fmap}_{F}^{\prime}$
\end_inset

 with respect to 
\begin_inset Formula $B$
\end_inset

.
 The resulting naturality law involves an arbitrary 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

:
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]

\end_inset

Within the naturality law, the lifting 
\begin_inset Formula $g^{\uparrow F}$
\end_inset

 must use the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 lifting code 
\begin_inset Formula $g^{\uparrow F}\triangleq\text{fmap}_{F}(g)$
\end_inset

.
 By assumption, 
\begin_inset Formula $\text{fmap}_{F}^{\prime}$
\end_inset

 is lawful, so we may use its composition law and write
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(f\bef g)=\text{fmap}_{F}^{\prime}(f)\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]

\end_inset

Since 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is arbitrary, we can choose 
\begin_inset Formula $A=B$
\end_inset

 and 
\begin_inset Formula $f=\text{id}^{:B\rightarrow B}$
\end_inset

 to obtain
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(\text{id})\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(\text{id})\bef g^{\uparrow F}\quad.
\]

\end_inset

The identity law for 
\begin_inset Formula $\text{fmap}_{F}^{\prime}$
\end_inset

 gives 
\begin_inset Formula $\text{fmap}_{F}^{\prime}(\text{id})=\text{id}$
\end_inset

, so we can simplify the last equation to
\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(g)\overset{!}{=}g^{\uparrow F}=\text{fmap}_{F}(g)\quad.
\]

\end_inset

This must hold for arbitrary 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, which proves that 
\begin_inset Formula $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-contrafunctor-is-unique"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-contrafunctor-is-unique"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A contrafunctor 
\begin_inset Formula $H$
\end_inset

 whose type expression is a combination of the six type constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) has a unique fully parametric implementation of a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 method.
 
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We use similar arguments as in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-functor-is-unique"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For any lawful, fully parametric alternative implementation 
\begin_inset Formula $\text{cmap}_{H}^{\prime}$
\end_inset

, the parametricity theorem gives the naturality law
\begin_inset Formula 
\[
\text{cmap}_{H}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}(g^{:B\rightarrow C})^{\downarrow H}\bef\text{cmap}_{H}^{\prime}(f)\quad.
\]

\end_inset

By assumption, the identity and composition law hold for 
\begin_inset Formula $\text{cmap}_{H}^{\prime}$
\end_inset

.
 Setting 
\begin_inset Formula $f=\text{id}^{:B\rightarrow B}$
\end_inset

, we get
\begin_inset Formula 
\[
\text{cmap}_{H}^{\prime}(\text{id}\bef g)=\text{cmap}_{H}^{\prime}(g)\overset{!}{=}g^{\downarrow H}\bef\text{cmap}_{H}^{\prime}(\text{id})=g^{\downarrow H}\quad.
\]

\end_inset

This must hold for arbitrary 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, which shows that 
\begin_inset Formula $\text{cmap}_{H}^{\prime}(g)=g^{\downarrow H}=\text{cmap}_{H}(g)$
\end_inset

 as required.
\end_layout

\begin_layout Section
Parametricity theorem formulated via relations
\begin_inset CommandInset label
LatexCommand label
name "sec:Parametricity-theorem-for-relations"

\end_inset


\end_layout

\begin_layout Standard
Naturality laws are formulated using arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 between arbitrary types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 Typically, a naturality law is an equation that involves the function 
\begin_inset Formula $f$
\end_inset

 lifted to some functors.
 For instance, 
\begin_inset Formula $f^{\uparrow G}\bef t=t\bef f^{\uparrow H}$
\end_inset

 is the naturality law for a natural transformation 
\begin_inset Formula $t:\forall A.\,G^{A}\rightarrow H^{A}$
\end_inset

, where 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are some functors.
\end_layout

\begin_layout Standard
To prove that naturality laws hold for any fully parametric transformation
 
\begin_inset Formula $t$
\end_inset

, we need to use induction in the structure of the code of 
\begin_inset Formula $t$
\end_inset

.
 The proof will decompose 
\begin_inset Formula $t$
\end_inset

 into smaller sub-expressions for which the naturality law should hold by
 the inductive assumption.
 Some of those sub-expressions will have types that are no longer of the
 form 
\begin_inset Formula $\forall A.\,G^{A}\rightarrow H^{A}$
\end_inset

.
 So, we are confronted with the need to generalize naturality laws to arbitrary
 type signatures of exponential-polynomial form 
\begin_inset Formula $\forall A.\,P^{A,A}$
\end_inset

, where 
\begin_inset Formula $P^{X,Y}$
\end_inset

 is an arbitrary profunctor (contravariant in 
\begin_inset Formula $X$
\end_inset

 and covariant in 
\begin_inset Formula $Y$
\end_inset

).
 
\end_layout

\begin_layout Standard
It is not possible to lift an arbitrary function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 to a function of type 
\begin_inset Formula $P^{A,A}\rightarrow P^{B,B}$
\end_inset

; for that, we would need also a function of type 
\begin_inset Formula $B\rightarrow A$
\end_inset

.
 The Reynolds-Wadler approach solves this difficulty by replacing functions
 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 by arbitrary 
\emph on
relations
\emph default
 between types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 It turns out that relations 
\emph on
can
\emph default
 be lifted to any exponential-polynomial profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

.
 In this section, we will prove the 
\begin_inset Quotes eld
\end_inset

relational parametricity theorem
\begin_inset Quotes erd
\end_inset

: any fully parametric code expression (not necessarily a function) of type
 
\begin_inset Formula $\forall A.\,P^{A,A}$
\end_inset

 satisfies a specially formulated naturality law involving relations.
\end_layout

\begin_layout Subsection
Relations between types.
 Relational lifting
\begin_inset CommandInset label
LatexCommand label
name "subsec:Relations-between-types"

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
relation
\series default
 between
\begin_inset Index idx
status open

\begin_layout Plain Layout
parametricity theorem!relation between types
\end_layout

\end_inset

 types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 is a function 
\begin_inset Formula $r:A\times B\rightarrow\bbnum 2$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The Scala definition is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Rel[A, B](r: (A, B) => Boolean)
\end_layout

\end_inset


\end_layout

\end_inset

The function 
\begin_inset Formula $r$
\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 when the relation holds between given values 
\begin_inset Formula $a^{:A}$
\end_inset

 and 
\begin_inset Formula $b^{:B}$
\end_inset

.
\end_layout

\begin_layout Standard
Functions of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 are viewed as many-to-one relations between types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

: one or more values of type 
\begin_inset Formula $A$
\end_inset

 may be related to a single value of type 
\begin_inset Formula $B$
\end_inset

.
 Similarly, functions of type 
\begin_inset Formula $B\rightarrow A$
\end_inset

 are viewed as one-to-many relations between types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 We will denote relations by 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

, indicating that relations are more general than functions of types 
\begin_inset Formula $A\rightarrow B$
\end_inset

 or 
\begin_inset Formula $B\rightarrow A$
\end_inset

.
\end_layout

\begin_layout Standard
If values 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are in a relation 
\begin_inset Formula $r$
\end_inset

, we will write 
\begin_inset Formula $(x,y)\in r$
\end_inset

.
 This suggests viewing a relation as a subset of the type 
\begin_inset Formula $A\times B$
\end_inset

.
 The condition 
\begin_inset Formula $(x,y)\in r$
\end_inset

 is equivalent to the condition 
\begin_inset Formula $r(x,y)=\text{true}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Here is some Scala code for converting functions to relations:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fun2relAB[A, B](f: A => B): Rel[A, B] = Rel { (a, b) => b == f(a) }
\end_layout

\begin_layout Plain Layout

def fun2relBA[A, B](f: B => A): Rel[A, B] = Rel { (a, b) => a == f(b) }
\end_layout

\end_inset

An example of a many-to-many relation that is 
\emph on
not
\emph default
 equivalent to a function of type 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val r: Rel[Int, Int] = Rel { (x, y) => x % 2 == y % 3 }
\end_layout

\end_inset


\end_layout

\end_inset

To use the parametricity theorem, we will need to convert functions into
 relations.
 We will denote by 
\begin_inset Formula $\left<f\right>$
\end_inset

 the relation of type 
\begin_inset Formula $A\leftrightarrow B$
\end_inset

 obtained from a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 The definition of the relation 
\begin_inset Formula $\left<f\right>$
\end_inset

 is:
\begin_inset Formula 
\[
(a^{:A},b^{:B})\in\left<f\right>\text{ means }b=f(a)\quad\text{or equivalently}:\quad a\triangleright f=b\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Like functions, relations can be composed when their types match: 
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-composition-of-relations"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-composition-of-relations"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
composition
\series default
 of relations 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 and 
\begin_inset Formula $s^{:B\leftrightarrow C}$
\end_inset

 is a relation 
\begin_inset Formula $r\circ s$
\end_inset

 of type 
\begin_inset Formula $A\leftrightarrow C$
\end_inset

:
\begin_inset Formula 
\[
(r\circ s):A\leftrightarrow C\quad,\quad\quad(a^{:A},c^{:C})\in r\circ s\quad\text{ means }\quad\exists b^{:B}\text{ such that }(a,b)\in r\text{ and }(b,c)\in s\quad.
\]

\end_inset

The 
\series bold
identity
\series default
 relation (
\begin_inset Formula $\text{id}^{:A\leftrightarrow A}$
\end_inset

) means that two values of type 
\begin_inset Formula $A$
\end_inset

 must be equal:
\begin_inset Formula 
\[
(x^{:A},y^{:A})\in\text{id}^{:A\leftrightarrow A}\quad\text{ means }\quad x=y\quad.
\]

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We cannot implement a Scala function composing two arbitrary relations:
 the code would have to enumerate all possible values of type 
\begin_inset Formula $B$
\end_inset

 in order to check whether a value 
\begin_inset Formula $b^{:B}$
\end_inset

 exists such that 
\begin_inset Formula $(a,b)\in r$
\end_inset

 and 
\begin_inset Formula $(b,c)\in s$
\end_inset

.
 (This computation is guaranteed to terminate only of the type 
\begin_inset Formula $B$
\end_inset

 has a finite number of distinct values.)
\end_layout

\begin_layout Standard
The definition of relational composition is compatible with the composition
 of functions:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-function-composition-relation"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-function-composition-relation"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 An identity function is converted into an identity relation.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The composition of functions is converted into the composition of relations.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The relation 
\begin_inset Formula $\left<\text{id}\right>$
\end_inset

 corresponding to an identity function 
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

 is defined by
\begin_inset Formula 
\[
(x^{:A},y^{:A})\in\left<\text{id}\right>\text{ means }x\triangleright\text{id}=y\quad\text{or equivalently}:\quad x=y\quad.
\]

\end_inset

This is the same as the identity relation 
\begin_inset Formula $\text{id}^{:A\leftrightarrow A}$
\end_inset

.
 We can write the result as 
\begin_inset Formula $\left<\text{id}\right>=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Consider two functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

.
 The relation 
\begin_inset Formula $\left<f\bef g\right>$
\end_inset

 is defined by
\begin_inset Formula 
\[
(a^{:A},c^{:C})\in\left<f\bef g\right>\text{ means }a\triangleright f\bef g=c\quad\text{or equivalently}:\quad c=g(f(a))\quad.
\]

\end_inset

Now write out the definitions of the relations 
\begin_inset Formula $\left<f\right>$
\end_inset

, 
\begin_inset Formula $\left<g\right>$
\end_inset

, and 
\begin_inset Formula $\left<f\right>\circ\left<g\right>$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (a^{:A},b^{:B})\in\left<f\right>\text{ means }b=f(a)\quad,\quad\quad(b^{:B},c^{:C})\in\left<g\right>\text{ means }c=g(b)\quad,\\
 & (a^{:A},c^{:C})\in\left<f\right>\circ\left<g\right>\text{ means }\exists b^{:B}\text{ such that }(a,b)\in\left<f\right>\text{ and }(b,c)\in\left<g\right>\quad,\\
 & \quad\quad\text{or equivalently}:\quad\exists b^{:B}\text{ such that }b=f(a)\text{ and }c=g(b)\quad.
\end{align*}

\end_inset

Now, since the function 
\begin_inset Formula $f$
\end_inset

 is given, 
\begin_inset Formula $b=f(a)$
\end_inset

 always exists.
 So,
\begin_inset Formula 
\[
(a^{:A},c^{:C})\in\left<f\right>\circ\left<g\right>\text{ means }c=g(f(a))\quad.
\]

\end_inset

This is the same as the definition of the relation 
\begin_inset Formula $\left<f\bef g\right>$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
For relations, there is no difference between forward and backward composition.
 Also note that relations of types 
\begin_inset Formula $r:A\leftrightarrow B$
\end_inset

 and 
\begin_inset Formula $r^{\prime}:B\leftrightarrow A$
\end_inset

 are equivalent: we can simply swap the order of 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 in the predicate 
\begin_inset Formula $(x,y)\in r$
\end_inset

 and obtain an equivalent relation 
\begin_inset Formula $(y,x)\in r^{\prime}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-composition-of-relations"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-composition-of-relations"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The composition of relations satisfies the identity and associativity laws:
\begin_inset Formula 
\[
r^{:A\leftrightarrow B}\circ\text{id}^{:B\leftrightarrow B}=r\quad,\quad\quad\text{id}^{:A\leftrightarrow A}\circ r^{:A\leftrightarrow B}=r\quad,\quad(r^{:A\leftrightarrow B}\circ s^{:B\leftrightarrow C})\circ t^{:C\leftrightarrow D}=r\circ(s\circ t)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
To verify the right identity law, assume an arbitrary relation 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 and write the condition for some values 
\begin_inset Formula $x^{:A}$
\end_inset

 and 
\begin_inset Formula $y^{:B}$
\end_inset

 to be in the relation 
\begin_inset Formula $r\circ\text{id}$
\end_inset

:
\begin_inset Formula 
\[
(x,y)\in r\circ\text{id}\text{ means }\exists b^{:B}\text{ such that }(x,b)\in r\text{ and }(b,y)\in\text{id}\quad.
\]

\end_inset

By definition of the identity relation (
\begin_inset Formula $\text{id}^{:B\leftrightarrow B}$
\end_inset

), the condition 
\begin_inset Formula $(b,y)\in\text{id}$
\end_inset

 means 
\begin_inset Formula $b=y$
\end_inset

.
 So, the condition 
\begin_inset Formula $(x,y)\in r\circ\text{id}$
\end_inset

 is the same as 
\begin_inset Formula $(x,y)\in r$
\end_inset

.
 This means 
\begin_inset Formula $r\circ\text{id}=r$
\end_inset

.
\end_layout

\begin_layout Standard
Similarly, we verify the left identity law:
\begin_inset Formula 
\[
(x,y)\in\text{id}\circ r\text{ means }\exists a^{:A}\text{ such that }(x,a)\in\text{id}\text{ and }(a,y)\in r\quad.
\]

\end_inset

By definition of 
\begin_inset Formula $\text{id}^{:A\leftrightarrow A}$
\end_inset

, we have 
\begin_inset Formula $x=a$
\end_inset

, and so the conditions 
\begin_inset Formula $(x,y)\in\text{id}\circ r$
\end_inset

 and 
\begin_inset Formula $(x,y)\in r$
\end_inset

 are equivalent.
 This means 
\begin_inset Formula $\text{id}\circ r=r$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the associativity law, write the definitions of relational composition
:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & (x,y)\in r\circ(s\circ t)\\
\text{is equivalent to}:\quad & \exists b^{:B}\text{ such that }(x,b)\in r\text{ and }(b,y)\in s\circ t\\
\text{is equivalent to}:\quad & \exists b^{:B}\text{ such that }(x,b)\in r\text{ and }\exists c^{:C}\text{ such that }(b,c)\in s\text{ and }(c,y)\in t\quad.
\end{align*}

\end_inset

The right-hand side of the associativity law is rewritten similarly:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (x,y)\in(r\circ s)\circ t\\
\text{is equivalent to}:\quad & \exists c^{:C}\text{ such that }(x,c)\in r\circ s\text{ and }(c,y)\in t\\
\text{is equivalent to}:\quad & \exists c^{:C}\text{ such that }\exists b^{:B}\text{ such that }(x,b)\in r\text{ and }(b,c)\in s\text{ and }(c,y)\in t\quad.
\end{align*}

\end_inset

The two sides are now equal because we may move the quantifiers 
\begin_inset Formula $\exists b^{:B}\exists c^{:C}$
\end_inset

 together.
\end_layout

\begin_layout Standard
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Naturality laws usually involve arbitrary functions lifted to some functors
 or contrafunctors.
 Lifting a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 to a functor 
\begin_inset Formula $G$
\end_inset

 yields a function 
\begin_inset Formula $f^{\uparrow G}:G^{A}\rightarrow G^{B}$
\end_inset

.
 Lifting 
\begin_inset Formula $f$
\end_inset

 to a contrafunctor 
\begin_inset Formula $H$
\end_inset

 yields a function 
\begin_inset Formula $f^{\downarrow H}:H^{B}\rightarrow H^{A}$
\end_inset

.
 We would like to figure out how to lift an arbitrary relation 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 to any functor, contrafunctor, or profunctor, and how to write naturality
 laws for relations.
 Lifting a relation 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 to a type constructor 
\begin_inset Formula $G^{\bullet}$
\end_inset

 should produce a relation between 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $G^{B}$
\end_inset

.
 We will denote the relational lifting by 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

.
\end_layout

\begin_layout Standard
To get more insight, let us formulate the known naturality laws in terms
 of relations.
 Consider a natural transformation 
\begin_inset Formula $t:G\leadsto H$
\end_inset

 with its naturality law 
\begin_inset Formula $f^{\uparrow G}\bef t=t\bef f^{\uparrow H}$
\end_inset

.
 To obtain a relational formulation of that law, we need to apply both sides
 to an arbitrary value 
\begin_inset Formula $p^{:G^{A}}$
\end_inset

,
\begin_inset Formula 
\[
p\triangleright f^{\uparrow G}\triangleright t=p\triangleright t\triangleright f^{\uparrow H}\quad,\quad\quad\text{or equivalently}:\quad t(p\triangleright f^{\uparrow G})=t(p)\triangleright f^{\uparrow H}\quad,
\]

\end_inset

and define for convenience the value 
\begin_inset Formula $q^{:G^{B}}\triangleq p\triangleright f^{\uparrow G}$
\end_inset

.
 This definition of 
\begin_inset Formula $q$
\end_inset

 is equivalent to the condition 
\begin_inset Formula $(p,q)\in\langle f^{\uparrow G}\rangle$
\end_inset

.
 Now we can rewrite the naturality law as the statement that for any function
 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and any values 
\begin_inset Formula $p^{:G^{A}}$
\end_inset

and 
\begin_inset Formula $q^{:G^{B}}$
\end_inset

,
\begin_inset Formula 
\[
\text{when}\quad(p,q)\in\langle f^{\uparrow G}\rangle\quad\quad\text{then}\quad(t(p),t(q))\in\langle f^{\uparrow H}\rangle\quad.
\]

\end_inset

It appears reasonable to define the relation 
\begin_inset Formula $\left<f\right>$
\end_inset

 lifted to 
\begin_inset Formula $G$
\end_inset

 as 
\begin_inset Formula 
\[
\left<f\right>^{\updownarrow G}\triangleq\langle f^{\uparrow G}\rangle\quad.
\]

\end_inset

With this definition, we write the relational formulation of the naturality
 law as
\begin_inset Formula 
\[
\text{when}\quad(p,q)\in\langle f\rangle^{\uparrow G}\quad\quad\text{then}\quad(t(p),t(q))\in\langle f\rangle^{\uparrow H}\quad.
\]

\end_inset

We now replace 
\begin_inset Formula $\left<f\right>$
\end_inset

 by an arbitrary relation 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 and write the naturality law as:
\begin_inset Formula 
\[
\text{for any relation }\quad r^{:A\leftrightarrow B}\quad,\quad\text{when}\quad(p,q)\in r^{\updownarrow G}\quad\quad\text{then}\quad(t(p),t(q))\in r^{\updownarrow H}\quad.
\]

\end_inset

This is a generalization of the naturality law from functions to relations.
 
\end_layout

\begin_layout Standard
It remains to define the liftings 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow H}$
\end_inset

.
 We cannot use 
\begin_inset Formula $r^{\uparrow G}$
\end_inset

 to define 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

: by definition, 
\begin_inset Formula $r$
\end_inset

 is a function with type signature 
\begin_inset Formula $A\times B\rightarrow\bbnum 2$
\end_inset

.
 So, the function 
\begin_inset Formula $r^{\uparrow G}$
\end_inset

 has type 
\begin_inset Formula $G^{A\times B}\rightarrow G^{\bbnum 2}$
\end_inset

 instead of the required type 
\begin_inset Formula $G^{A}\times G^{B}\rightarrow\bbnum 2$
\end_inset

, and 
\begin_inset Formula $r^{\uparrow G}$
\end_inset

 does not define a relation between 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $G^{B}$
\end_inset

, which we would need in order to define 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We already know that the lifted relation 
\begin_inset Formula $\left<f\right>$
\end_inset

 is expressed as 
\begin_inset Formula 
\[
\left<f\right>^{\updownarrow G}\triangleq\langle f^{\uparrow G}\rangle\quad,\quad\quad\left<f\right>^{\updownarrow H}\triangleq\langle f^{\downarrow H}\rangle\quad,
\]

\end_inset

for any functors 
\begin_inset Formula $G$
\end_inset

 and contrafunctors 
\begin_inset Formula $H$
\end_inset

.
 For example, if 
\begin_inset Formula $G^{A}\triangleq A\times A\times\text{Int}$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq(A\rightarrow\text{Int})\times\text{Int}$
\end_inset

, we have:
\begin_inset Formula 
\begin{align*}
 & (p^{:G^{A}},q^{:G^{B}})\in\left<f\right>^{\updownarrow G}\text{ when }p=a_{1}^{:A}\times a_{2}^{:A}\times z^{:\text{Int}}\quad\text{ and }\quad q=f(a_{1})\times f(a_{2})\times z\quad,\\
 & (p^{:H^{A}},q^{:H^{B}})\in\left<f\right>^{\updownarrow H}\text{ when }p=(f^{:A\rightarrow B}\bef h^{:B\rightarrow\text{Int}})\times z^{:\text{Int}}\quad\text{ and }\quad q=h^{:B\rightarrow\text{Int}}\times z\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Motivated by these examples, we formulate the definition of 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

:
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-relational-lifting"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (relational lifting)
\end_layout

\begin_layout Standard
Given a relation 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 implemented as a function 
\begin_inset Formula $r^{:A\times B\rightarrow\bbnum 2}$
\end_inset

, a type constructor 
\begin_inset Formula $G^{A}$
\end_inset

, and values 
\begin_inset Formula $x^{:G^{A}}$
\end_inset

 and 
\begin_inset Formula $y^{:G^{B}}$
\end_inset

, the lifting 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

 is defined by induction on the structure of 
\begin_inset Formula $G$
\end_inset

:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If 
\begin_inset Formula $G^{A}\triangleq Z$
\end_inset

 with a fixed type 
\begin_inset Formula $Z$
\end_inset

, we define 
\begin_inset Formula $(x^{:G^{A}},y^{:G^{B}})\in r^{\updownarrow G}$
\end_inset

 to mean 
\begin_inset Formula $x^{:Z}=y^{:Z}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If 
\begin_inset Formula $G=\text{Id}$
\end_inset

 (that is, 
\begin_inset Formula $G^{A}\triangleq A$
\end_inset

), we define 
\begin_inset Formula $r^{\updownarrow\text{Id}}\triangleq r$
\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 If 
\begin_inset Formula $G^{A}\triangleq K^{A}\times L^{A}$
\end_inset

 (where 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are any type constructors), we define 
\begin_inset Formula $r^{\updownarrow G}\triangleq m^{:K^{A}}\times n^{:L^{A}}\times p^{:K^{B}}\times q^{:L^{B}}\rightarrow r^{\updownarrow K}(m,p)\wedge r^{\updownarrow K}(n,q)$
\end_inset

.
 In other words, 
\begin_inset Formula $(m\times n,p\times q)\in r^{\updownarrow G}$
\end_inset

 means 
\begin_inset Formula $(m,p)\in r^{\updownarrow K}$
\end_inset

 and 
\begin_inset Formula $(n,q)\in r^{\updownarrow L}$
\end_inset

.
 The inductive assumption is that the liftings 
\begin_inset Formula $r^{\updownarrow K}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow L}$
\end_inset

 are already defined.
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 If 
\begin_inset Formula $G^{A}\triangleq K^{A}+L^{A}$
\end_inset

, we define 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

 as a function of type 
\begin_inset Formula $(K^{A}+L^{A})\times(K^{B}+L^{B})\rightarrow\bbnum 2$
\end_inset

 by
\begin_inset Formula 
\[
r^{\updownarrow G}\triangleq\,\begin{array}{|c||c|}
 & \bbnum 2\\
\hline K^{A}\times K^{B} & r^{\updownarrow K}\\
K^{A}\times L^{B} & \_\rightarrow\text{false}\\
L^{A}\times K^{B} & \_\rightarrow\text{false}\\
L^{A}\times L^{B} & r^{\updownarrow L}
\end{array}\quad.
\]

\end_inset

Equivalently, 
\begin_inset Formula $(x^{:G^{A}},y^{:G^{B}})\in r^{\updownarrow G}$
\end_inset

 means that either 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are both in the left part of the disjunction, 
\begin_inset Formula $x=m^{:K^{A}}+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $y=p^{:K^{B}}+\bbnum 0$
\end_inset

 with 
\begin_inset Formula $(m,p)\in r^{\updownarrow K}$
\end_inset

, or 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are both in the right part, 
\begin_inset Formula $x=\bbnum 0+n^{:L^{A}}$
\end_inset

 and 
\begin_inset Formula $y=\bbnum 0+q^{:L^{B}}$
\end_inset

 with 
\begin_inset Formula $(n,q)\in r^{\updownarrow L}$
\end_inset

.
 The inductive assumption is that the liftings 
\begin_inset Formula $r^{\updownarrow K}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow L}$
\end_inset

 are defined.
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 If 
\begin_inset Formula $G^{A}\triangleq K^{A}\rightarrow L^{A}$
\end_inset

, we define 
\begin_inset Formula $(p^{:K^{A}\rightarrow L^{A}},q^{:K^{B}\rightarrow L^{B}})\in r^{\updownarrow G}$
\end_inset

 to mean the following conditional statement: if any values 
\begin_inset Formula $x^{:K^{A}}$
\end_inset

 and 
\begin_inset Formula $y^{:K^{B}}$
\end_inset

 are in the relation 
\begin_inset Formula $r^{\updownarrow K}$
\end_inset

 then the values 
\begin_inset Formula $p(x)$
\end_inset

 and 
\begin_inset Formula $q(y)$
\end_inset

 are in the relation 
\begin_inset Formula $r^{\updownarrow L}$
\end_inset

.
 Written more concisely:
\begin_inset Formula 
\[
(p^{:K^{A}\rightarrow L^{A}},q^{:K^{B}\rightarrow L^{B}})\in r^{\updownarrow G}\text{ means that if }(x^{:K^{A}},y^{:K^{A}})\in r^{\updownarrow K}\text{ then }(p(x),q(y))\in r^{\updownarrow L}\quad.
\]

\end_inset

The inductive assumption is that the liftings 
\begin_inset Formula $r^{\updownarrow K}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow L}$
\end_inset

 are already defined.
\end_layout

\begin_layout Standard

\series bold
(f)
\series default
 If 
\begin_inset Formula $G^{A}\triangleq S^{A,G^{A}}$
\end_inset

 is a recursive type constructor, we define 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

 recursively by
\begin_inset Formula 
\[
r^{\updownarrow G}=r^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\quad.
\]

\end_inset

More verbosely: we use the recursive call 
\begin_inset Formula $\overline{r^{\updownarrow G}}$
\end_inset

 and define 
\begin_inset Formula $(g_{1}^{:S^{A,G^{A}}},g_{2}^{:S^{B,G^{B}}})\in r^{\updownarrow G}$
\end_inset

 as:
\begin_inset Formula 
\[
\exists p^{:S^{B,G^{A}}}\text{ such that }(g_{1},p)\in r^{\updownarrow S^{\bullet,G^{A}}}\text{ and }(p,g_{2})\in\big(\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\quad.
\]

\end_inset

The inductive assumption is that the liftings 
\begin_inset Formula $r^{\updownarrow S^{\bullet,Q}}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow S^{P,\bullet}}$
\end_inset

 are already defined.
 
\end_layout

\begin_layout Standard

\series bold
(g)
\series default
 If 
\begin_inset Formula $G^{A}\triangleq\forall X.\,H^{X,A}$
\end_inset

, we define 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

 of type 
\begin_inset Formula $\forall X.\,H^{X,A}\leftrightarrow\forall Y.\,H^{Y,B}$
\end_inset

 by
\begin_inset Formula 
\[
(p^{:\forall X.\,H^{X,A}},q^{:\forall X.\,H^{X,B}})\in r^{\updownarrow\forall X.\,H^{X,\bullet}}\quad\text{if}\quad\forall(X,Y).\,\forall s^{X\leftrightarrow Y}.\,(p^{X},g^{Y})\in s^{\updownarrow H^{\bullet,A}}\circ r^{\updownarrow H^{Y,\bullet}}\quad.
\]

\end_inset

The inductive assumption is that the liftings 
\begin_inset Formula $r^{\updownarrow H^{\bullet,A}}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow H^{Y,\bullet}}$
\end_inset

 are already defined.
\end_layout

\begin_layout Standard

\series bold
(h)
\series default
 If 
\begin_inset Formula $G^{A}\triangleq K^{L^{A}}$
\end_inset

, we define 
\begin_inset Formula $r^{\updownarrow G}\triangleq(r^{\updownarrow L})^{\updownarrow K}$
\end_inset

.
 The inductive assumption is that the liftings 
\begin_inset Formula $r^{\updownarrow K}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow L}$
\end_inset

 are already defined.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
??? How can we compute 
\begin_inset Formula $\forall X$
\end_inset

 of a boolean value? 
\begin_inset Formula 
\[
r^{\updownarrow G}\triangleq p^{:\forall X.\,H^{X,A}}\times q^{:\forall Y.\,H^{Y,B}}\rightarrow\forall X.\,(p^{X},q^{X})\in r^{\updownarrow H^{X,\bullet}}\quad.
\]

\end_inset


\end_layout

\begin_layout Plain Layout
If 
\begin_inset Formula $G^{A}\triangleq\forall X.\,H^{X,A}$
\end_inset

, we define 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

 as the function
\begin_inset Formula 
\[
r^{\updownarrow G}\triangleq p^{:\forall X.\,H^{X,A}}\times q^{:\forall Y.\,H^{Y,B}}\rightarrow\forall X.\,(p^{X},q^{X})\in r^{\updownarrow H^{X,\bullet}}\quad.
\]

\end_inset

Note that 
\begin_inset Formula $p^{:\forall X.\,H^{X,A}}$
\end_inset

 is assumed to satisfy the relational parametricity property: for any 
\begin_inset Formula $s^{:X\leftrightarrow Y}$
\end_inset

 we have 
\begin_inset Formula $(p^{X},p^{Y})\in s^{\updownarrow H^{\bullet,A}}$
\end_inset

 and similarly for 
\begin_inset Formula $q$
\end_inset

.
 Suppose we have a fully parametric function 
\begin_inset Formula $\phi:H^{X,A}\times H^{X,B}\rightarrow\bbnum 2$
\end_inset

, and suppose we apply that function only to arguments 
\begin_inset Formula $p^{X}$
\end_inset

 and 
\begin_inset Formula $q^{X}$
\end_inset

 that are fully parametric.
 Can we show that 
\begin_inset Formula $\phi$
\end_inset

 is independent of its type parameter 
\begin_inset Formula $X$
\end_inset

?
\end_layout

\begin_layout Plain Layout
Try using a functional relation 
\begin_inset Formula $r$
\end_inset

?
\end_layout

\begin_layout Plain Layout
According to Vene's slides:
\end_layout

\begin_layout Plain Layout
For any relation 
\begin_inset Formula $H^{X,A}\leftrightarrow H^{X,B}$
\end_inset

, such as 
\begin_inset Formula $r^{\updownarrow H^{X,\bullet}}$
\end_inset

, the relation 
\begin_inset Formula $r^{\updownarrow\forall X.\,H^{X,\bullet}}$
\end_inset

 is defined by:
\begin_inset Formula 
\[
(p^{:\forall X.\,H^{X,A}},q^{:\forall X.\,H^{X,B}})\in r^{\updownarrow\forall X.\,H^{X,\bullet}}\quad\text{if}\quad(p^{X},g^{Y})\in s^{\updownarrow H^{\bullet,A}}\circ r^{\updownarrow H^{X,\bullet}}???
\]

\end_inset


\end_layout

\end_inset

Note that 
\begin_inset Formula $K^{A}$
\end_inset

, 
\begin_inset Formula $L^{A}$
\end_inset

, 
\begin_inset Formula $H^{X,A}$
\end_inset

, and 
\begin_inset Formula $S^{A,R}$
\end_inset

 are not assumed to be covariant or contravariant; they can be any exponential-p
olynomial type constructors.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-relational-lifting"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 gives rise to a relation 
\begin_inset Formula $\left<f\right>:A\leftrightarrow B$
\end_inset

.
 Use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to compute the lifting of the relation 
\begin_inset Formula $\left<f\right>$
\end_inset

 to type constructors 
\begin_inset Formula $P^{\bullet}$
\end_inset

 defined as: 
\series bold
(a)
\series default
 
\begin_inset Formula $P^{A}\triangleq A+A\times A$
\end_inset

.
 
\series bold
(b)
\series default
 
\begin_inset Formula $P^{A}\triangleq(R\rightarrow A)\times(A\rightarrow S)$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 are fixed types.
 
\series bold
(c)
\series default
 
\begin_inset Formula $P^{A}\triangleq A\rightarrow A$
\end_inset

.
 
\series bold
(d)
\series default
 
\begin_inset Formula $P^{A}\triangleq A\rightarrow\left(A\rightarrow R\right)\rightarrow R$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

 is a fixed type.
 
\series bold
(e)
\series default
 
\begin_inset Formula $P^{A}\triangleq\left(A\rightarrow A\right)\rightarrow A\rightarrow A$
\end_inset

.
\end_layout

\begin_layout Standard
In each case, express 
\begin_inset Formula $P^{A}$
\end_inset

 as 
\begin_inset Formula $P^{A}\triangleq N^{A,A}$
\end_inset

 where 
\begin_inset Formula $N^{X,Y}$
\end_inset

 is a profunctor, and compare the relation 
\begin_inset Formula $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$
\end_inset

 with the wedge condition 
\begin_inset Formula $p_{1}\triangleright f^{\uparrow N}=p_{2}\triangleright f^{\downarrow N}$
\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
In all cases, the lifted relation 
\begin_inset Formula $\left<f\right>^{\updownarrow P}$
\end_inset

 has type 
\begin_inset Formula $P^{A}\leftrightarrow P^{B}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 At the top level, 
\begin_inset Formula $P^{A}$
\end_inset

 is a disjunction: 
\begin_inset Formula $P^{A}=\text{Id}^{A}+H^{A}$
\end_inset

 where 
\begin_inset Formula $H^{A}\triangleq A\times A$
\end_inset

.
 So, we use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(d) to get the condition for some values 
\begin_inset Formula $(x^{:P^{A}},y^{:P^{B}})$
\end_inset

 to be in the relation 
\begin_inset Formula $\left<f\right>^{\updownarrow P}$
\end_inset

:
\begin_inset Formula 
\[
(x,y)\in\left<f\right>^{\updownarrow P}\text{ if }x=x_{1}+\bbnum 0,\,y=y_{1}+\bbnum 0,\,(x_{1},y_{1})\in\left<f\right>^{\updownarrow\text{Id}}\text{ or }x=\bbnum 0+x_{2},\,y=\bbnum 0+y_{2},\,(x_{2},y_{2})\in\left<f\right>^{\updownarrow H}\quad.
\]

\end_inset

By Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b), we have 
\begin_inset Formula $\left<f\right>^{\updownarrow\text{Id}}=\left<f\right>$
\end_inset

.
 The condition 
\begin_inset Formula $(x_{1},y_{1})\in\left<f\right>^{\updownarrow\text{Id}}$
\end_inset

 is then simplified to 
\begin_inset Formula $f(x_{1})=y_{1}$
\end_inset

.
 Finally, we use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c) with 
\begin_inset Formula $H^{A}=\text{Id}^{A}\times\text{Id}^{A}$
\end_inset

 to obtain the lifting 
\begin_inset Formula $\left<f\right>^{\updownarrow H}$
\end_inset

:
\begin_inset Formula 
\[
(a_{1}^{:A}\times a_{2}^{:A},b_{1}^{:B}\times b_{2}^{:B})\in\left<f\right>^{\updownarrow H}\text{ if }(a_{1},b_{1})\in\left<f\right>^{\updownarrow\text{Id}}\text{ and }(a_{2},b_{2})\in\left<f\right>^{\updownarrow\text{Id}}\quad.
\]

\end_inset

The last condition is simplified to
\begin_inset Formula 
\[
(a_{1}^{:A}\times a_{2}^{:A},b_{1}^{:B}\times b_{2}^{:B})\in\left<f\right>^{\updownarrow H}\text{ if }f(a_{1})=b_{1}\text{ and }f(a_{2})=b_{2}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Putting the pieces together, we obtain the following definition of the relation
 
\begin_inset Formula $\left<f\right>^{\updownarrow P}$
\end_inset

:
\begin_inset Formula 
\[
(x^{:P^{A}},y^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ if }x=x_{1}+\bbnum 0,\,y=f(x_{1})+\bbnum 0,\text{ or }x=\bbnum 0+a_{1}\times a_{2},\,y=\bbnum 0+f(a_{1})\times f(a_{2})\quad.
\]

\end_inset

We note that this condition is equivalent to applying 
\begin_inset Formula $f^{\uparrow P}$
\end_inset

:
\begin_inset Formula 
\[
(x^{:P^{A}},y^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ if }x\triangleright f^{\uparrow P}=y\quad,\text{ or more concisely}:\quad\quad\left<f\right>^{\updownarrow P}=\langle f^{\uparrow P}\rangle\quad.
\]

\end_inset

We will see below (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that this property holds for all functors 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
With 
\begin_inset Formula $N^{X,Y}\triangleq P^{Y}$
\end_inset

, the wedge condition is equivalent to the equation 
\begin_inset Formula $x\triangleright f^{\uparrow P}=y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 At the top level, 
\begin_inset Formula $P^{A}$
\end_inset

 is a product: 
\begin_inset Formula $P^{A}=G^{A}\times H^{A}$
\end_inset

 where 
\begin_inset Formula $G^{A}\triangleq R\rightarrow A$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq A\rightarrow S$
\end_inset

.
 By Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c), we get
\begin_inset Formula 
\[
(g_{1}^{:G^{A}}\times h_{1}^{:H^{A}},g_{2}^{:G^{B}}\times h_{2}^{:H^{B}})\in\left<f\right>^{\updownarrow P}\text{ if }(g_{1},g_{2})\in\left<f\right>^{\updownarrow G}\text{ and }(h_{1},h_{2})\in\left<f\right>^{\updownarrow H}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The condition 
\begin_inset Formula $(g_{1},g_{2})\in\left<f\right>^{\updownarrow G}$
\end_inset

 is rewritten using Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a), (b), and (e):
\begin_inset Formula 
\[
(g_{1}^{:R\rightarrow A},g_{2}^{:R\rightarrow B})\in\left<f\right>^{\updownarrow G}\text{ means if }(r_{1}^{:R},r_{2}^{:R})\in\text{id}^{R}\text{ then }(g_{1}(r_{1}),g_{2}(r_{2}))\in\left<f\right>^{\updownarrow\text{Id}}\quad.
\]

\end_inset

We have 
\begin_inset Formula $\left<f\right>^{\updownarrow\text{Id}}=\left<f\right>$
\end_inset

.
 The identity relation (
\begin_inset Formula $\text{id}^{R}$
\end_inset

) between 
\begin_inset Formula $r_{1}$
\end_inset

 and 
\begin_inset Formula $r_{2}$
\end_inset

 holds only if 
\begin_inset Formula $r_{1}=r_{2}$
\end_inset

.
 We find:
\begin_inset Formula 
\[
(g_{1}^{:R\rightarrow A},g_{2}^{:R\rightarrow B})\in\left<f\right>^{\updownarrow G}\text{ means }\forall r^{:R}.\,f(g_{1}(r))=g_{2}(r)\quad\text{or equivalently}:\quad g_{1}\bef f=g_{2}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The condition 
\begin_inset Formula $(h_{1},h_{2})\in\left<f\right>^{\updownarrow H}$
\end_inset

 is rewritten using the same definitions:
\begin_inset Formula 
\[
(h_{1}^{:A\rightarrow S},h_{2}^{:B\rightarrow S})\in\left<f\right>^{\updownarrow H}\text{ means if }(a^{:A},b^{:B})\in\left<f\right>^{\updownarrow\text{Id}}\text{ then }(h_{1}(a),h_{2}(b))\in\text{id}\quad.
\]

\end_inset

We simplify this to:
\begin_inset Formula 
\[
(h_{1}^{:A\rightarrow S},h_{2}^{:B\rightarrow S})\in\left<f\right>^{\updownarrow H}\text{ means }h_{1}(a)=h_{2}(f(a))\quad\text{or equivalently}:\quad h_{1}=f\bef h_{2}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Finally, the lifted relation is expressed by
\begin_inset Formula 
\[
(g_{1}\times h_{1},g_{2}\times h_{2})\in\left<f\right>^{\updownarrow P}\text{ if }g_{1}\bef f=g_{2}\text{ and }h_{1}=f\bef h_{2}\quad.
\]

\end_inset

Defining the profunctor 
\begin_inset Formula $P^{X,Y}\triangleq G^{Y}\times H^{X}$
\end_inset

, we find that 
\begin_inset Formula $g_{1}\times h_{1}$
\end_inset

 has type 
\begin_inset Formula $P^{A,A}$
\end_inset

 and 
\begin_inset Formula $g_{2}\times h_{2}$
\end_inset

 has type 
\begin_inset Formula $P^{B,B}$
\end_inset

.
 Then the condition 
\begin_inset Formula $(g_{1}\times h_{1},g_{2}\times h_{2})\in\left<f\right>^{\updownarrow P}$
\end_inset

 is equivalent to the wedge condition with 
\begin_inset Formula $N^{X,Y}\triangleq\left(R\rightarrow Y\right)\times\left(X\rightarrow S\right)$
\end_inset

:
\begin_inset Formula 
\[
(g_{1}\times h_{1})\triangleright f^{\uparrow N}=(g_{2}\times h_{2})\triangleright f^{\downarrow N}\quad.
\]

\end_inset

In this way, we can express the lifted relation by a single equation.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Using Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) and (e), we get:
\begin_inset Formula 
\[
(p_{1}^{:A\rightarrow A},p_{2}^{:B\rightarrow B})\in\left<f\right>^{\updownarrow P}\text{ means if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(p_{1}(a),p_{2}(b))\in\left<f\right>\quad.
\]

\end_inset

The condition can be rewritten as a single equation,
\begin_inset Formula 
\[
(p_{1}^{:A\rightarrow A},p_{2}^{:B\rightarrow B})\in\left<f\right>^{\updownarrow P}\text{ means }f(p_{1}(a))=p_{2}(f(a))\quad\text{or equivalently}:\quad p_{1}\bef f=f\bef p_{2}\quad.
\]

\end_inset

This is now the same as the wedge condition 
\begin_inset Formula $p_{1}\triangleright f^{\uparrow N}=p_{2}\triangleright f^{\downarrow N}$
\end_inset

 with the profunctor 
\begin_inset Formula $N^{X,Y}\triangleq X\rightarrow Y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 Since 
\begin_inset Formula $P^{A}\triangleq A\rightarrow Q^{A}$
\end_inset

 is a function type (with 
\begin_inset Formula $Q^{A}\triangleq\left(A\rightarrow R\right)\rightarrow R$
\end_inset

), we use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(e):
\begin_inset Formula 
\[
(p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ means if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(p_{1}(a),p_{2}(b))\in\left<f\right>^{\updownarrow Q}\quad.
\]

\end_inset

The definition of 
\begin_inset Formula $\left<f\right>^{\updownarrow Q}$
\end_inset

 is obtained similarly if we define 
\begin_inset Formula $K^{A}\triangleq A\rightarrow R$
\end_inset

:
\begin_inset Formula 
\[
(q_{1}^{:Q^{A}},q_{2}^{:Q^{B}})\in\left<f\right>^{\updownarrow Q}\text{ means if }(k_{1}^{:A\rightarrow R},k_{2}^{:B\rightarrow R})\in\left<f\right>^{\updownarrow K}\text{ then }(q_{1}(k_{1}),q_{2}(k_{2}))\in\text{id}^{R}\quad.
\]

\end_inset

Expanding the definition of 
\begin_inset Formula $\left<f\right>^{\updownarrow K}$
\end_inset

 as we did in part 
\series bold
(b)
\series default
 of this example, we get:
\begin_inset Formula 
\[
(q_{1},q_{2})\in\left<f\right>^{\updownarrow Q}\text{ means if }b=f(a)\text{ and }k_{1}(a)=k_{2}(b)\text{ then }q_{1}(k_{1})=q_{2}(k_{2})\quad.
\]

\end_inset

This means 
\begin_inset Formula $k_{1}(a)=k_{2}(f(a))$
\end_inset

, or 
\begin_inset Formula $k_{1}=f\bef k_{2}$
\end_inset

.
 So, we finally express 
\begin_inset Formula $\left<f\right>^{\updownarrow Q}$
\end_inset

 and 
\begin_inset Formula $\left<f\right>^{\updownarrow P}$
\end_inset

 as:
\begin_inset Formula 
\begin{align*}
 & (q_{1}^{:Q^{A}},q_{2}^{:Q^{B}})\in\left<f\right>^{\updownarrow Q}\text{ means }(k\rightarrow f\bef k)\bef q_{1}=q_{2}\quad,\\
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ means }a\rightarrow\big((k\rightarrow f\bef k)\bef p_{1}(a)\big)=f\bef p_{2}\quad.
\end{align*}

\end_inset

Defining 
\begin_inset Formula $N^{X,Y}\triangleq X\rightarrow\left(Y\rightarrow R\right)\rightarrow R$
\end_inset

, we find that the last formula is equivalent to the wedge condition for
 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

:
\begin_inset Formula 
\[
p_{1}\triangleright f^{\uparrow N}=p_{1}\bef(q\rightarrow(k\rightarrow f\bef k)\bef q)\quad,\quad\quad p_{2}\triangleright f^{\downarrow N}=f\bef p_{2}\quad.
\]

\end_inset

 
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 Since 
\begin_inset Formula $P^{A}=Q^{A}\rightarrow Q^{A}$
\end_inset

 with 
\begin_inset Formula $Q^{A}\triangleq A\rightarrow A$
\end_inset

, we use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(e):
\begin_inset Formula 
\begin{align*}
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ means if }(q_{1}^{:A\rightarrow A},q_{2}^{:B\rightarrow B})\in\left<f\right>^{\updownarrow Q}\text{ then }(p_{1}(q_{1}),p_{2}(q_{2}))\in\left<f\right>^{\updownarrow Q}\quad.\\
 & (q_{1}^{:A\rightarrow A},q_{2}^{:B\rightarrow B})\in\left<f\right>^{\updownarrow Q}\text{ means if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(q_{1}(a),q_{2}(b))\in\left<f\right>\quad.
\end{align*}

\end_inset

Simplifying these conditions, we get:
\begin_inset Formula 
\begin{align*}
 & (q_{1},q_{2})\in\left<f\right>^{\updownarrow Q}\text{ means }q_{1}\bef f=f\bef q_{2}\quad,\\
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ means if }q_{1}\bef f=f\bef q_{2}\text{ then }p_{1}(q_{1})\bef f=f\bef p_{2}(q_{2})\quad.
\end{align*}

\end_inset

The condition for 
\begin_inset Formula $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$
\end_inset

 
\emph on
cannot
\emph default
 be written as a single equation involving 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

 because we cannot express 
\begin_inset Formula $q_{1}$
\end_inset

 through 
\begin_inset Formula $q_{2}$
\end_inset

 or vice versa.
 (The relation between 
\begin_inset Formula $q_{1}$
\end_inset

 and 
\begin_inset Formula $q_{2}$
\end_inset

 is many-to-many and is not equivalent to a function.)
\end_layout

\begin_layout Standard
Let us define 
\begin_inset Formula $N^{X,Y}\triangleq\left(Y\rightarrow X\right)\rightarrow X\rightarrow Y$
\end_inset

 and write the wedge condition for 
\begin_inset Formula $p_{1}^{:N^{A,A}}$
\end_inset

 and 
\begin_inset Formula $p_{2}^{:N^{B,B}}$
\end_inset

:
\begin_inset Formula 
\[
k^{:B\rightarrow A}\triangleright(p_{1}\triangleright f^{\uparrow N})=k\triangleright(p_{2}\triangleright f^{\downarrow N})\quad\text{or equivalently}:\quad p_{1}(f\bef k)\bef f=f\bef p_{2}(k\bef f)\quad.
\]

\end_inset

We notice the similarity between the wedge condition and the relation 
\begin_inset Formula $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$
\end_inset

: if we set 
\begin_inset Formula $q_{1}\triangleq f\bef k$
\end_inset

 and 
\begin_inset Formula $q_{2}\triangleq k\bef f$
\end_inset

 then the precondition 
\begin_inset Formula $q_{1}\bef f=f\bef q_{2}$
\end_inset

 will be satisfied.
 It shows that the wedge condition as a 
\emph on
consequence
\emph default
 of the relation 
\begin_inset Formula $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$
\end_inset

.
 However, if we have some functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $q_{1}$
\end_inset

, and 
\begin_inset Formula $q_{2}$
\end_inset

 such that the precondition 
\begin_inset Formula $q_{1}\bef f=f\bef q_{2}$
\end_inset

 holds, it does not follow that there exists some function 
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula $q_{1}=f\bef k$
\end_inset

 and 
\begin_inset Formula $q_{2}=k\bef f$
\end_inset

.
 So, the wedge condition is weaker than the relation.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-lifting-relation-covariant"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Lifting a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 to a fully parametric functor or a contrafunctor 
\begin_inset Formula $G$
\end_inset

 corresponds to lifting the corresponding relation 
\begin_inset Formula $\left<f\right>$
\end_inset

.
 So, we can write 
\begin_inset Formula $\left<f\right>^{\updownarrow G}=\langle f^{\uparrow G}\rangle$
\end_inset

 if 
\begin_inset Formula $G$
\end_inset

 is a functor and 
\begin_inset Formula $\left<f\right>^{\updownarrow G}=\langle f^{\downarrow G}\rangle$
\end_inset

 if 
\begin_inset Formula $G$
\end_inset

 is a contrafunctor.
 More verbosely:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If 
\begin_inset Formula $G$
\end_inset

 is a fully parametric functor then 
\begin_inset Formula $(x^{:G^{A}},y^{:G^{B}})\in\left<f\right>^{\updownarrow G}$
\end_inset

 means 
\begin_inset Formula $x\triangleright f^{\uparrow G}=y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If 
\begin_inset Formula $G$
\end_inset

 is a fully parametric contrafunctor then 
\begin_inset Formula $(x^{:G^{A}},y^{:G^{B}})\in\left<f\right>^{\updownarrow G}$
\end_inset

 means 
\begin_inset Formula $y\triangleright f^{\downarrow G}=x$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We proceed by induction on the structure of the functor 
\begin_inset Formula $G$
\end_inset

.
 In each case, we use the corresponding part of Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to obtain 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Constant type
\end_layout

\begin_layout Standard
For 
\begin_inset Formula $G^{A}\triangleq Z$
\end_inset

 where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type, we have 
\begin_inset Formula $f^{\uparrow G}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\left<f\right>^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}$
\end_inset

.
 So, 
\begin_inset Formula $(x,y)\in\left<f\right>^{\updownarrow G}$
\end_inset

 when 
\begin_inset Formula $x=y$
\end_inset

, which is the same as 
\begin_inset Formula $x\triangleright f^{\uparrow G}=y$
\end_inset

.
\end_layout

\begin_layout Paragraph
Type parameter
\end_layout

\begin_layout Standard
For 
\begin_inset Formula $G^{A}\triangleq A$
\end_inset

, we have 
\begin_inset Formula $f^{\uparrow G}=f$
\end_inset

 and 
\begin_inset Formula $\left<f\right>^{\updownarrow G}=\left<f\right>$
\end_inset

.
 So, the condition 
\begin_inset Formula $(x,y)\in\left<f\right>$
\end_inset

 is the same as 
\begin_inset Formula $x\triangleright f=y$
\end_inset

 and the same as 
\begin_inset Formula $x\triangleright f^{\uparrow G}=y$
\end_inset

.
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
Here, we have 
\begin_inset Formula $G^{A}\triangleq K^{A}\times L^{A}$
\end_inset

 where 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are some functors.
 For the product type,
\begin_inset Formula 
\[
(k_{1}^{:K^{A}}\times l_{1}^{:L^{A}},k_{2}^{:K^{B}}\times l_{2}^{:L^{B}})\in\left<f\right>^{\updownarrow G}\text{ when }(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\text{ and }\quad(l_{1},l_{2})\in\left<f\right>^{\updownarrow L}\quad.
\]

\end_inset

By the inductive assumption, 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 already satisfy Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

, so
\begin_inset Formula 
\[
(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\text{ means }k_{1}\triangleright f^{\uparrow K}=k_{2}\quad,\quad\quad(l_{1},l_{2})\in\left<f\right>^{\updownarrow L}\text{ means }l_{1}\triangleright f^{\uparrow L}=l_{2}\quad.
\]

\end_inset

So, the condition for 
\begin_inset Formula $(k_{1}\times l_{1},k_{2}\times l_{2})\in\left<f\right>^{\updownarrow G}$
\end_inset

 is equivalent to
\begin_inset Formula 
\[
k_{1}\triangleright f^{\uparrow K}=k_{2}\text{ and }l_{1}\triangleright f^{\uparrow L}=l_{2}\quad.
\]

\end_inset

By definition of 
\begin_inset Formula $f^{\uparrow(K\times L)}$
\end_inset

, we have 
\begin_inset Formula 
\[
(k\times l)\triangleright f^{\uparrow(K\times L)}=(k\triangleright f^{\uparrow K})\times(l\triangleright f^{\uparrow L})\quad.
\]

\end_inset

It follows that
\begin_inset Formula 
\[
(k_{1}\times l_{1},k_{2}\times l_{2})\in\left<f\right>^{\updownarrow G}\text{ when }(k_{1}\times l_{1})\triangleright f^{\uparrow G}=k_{2}\times l_{2}\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
Here, we have 
\begin_inset Formula $G^{A}\triangleq K^{A}+L^{A}$
\end_inset

 where 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are some functors.
 For the co-product type, two values of types 
\begin_inset Formula $K^{A}+L^{A}$
\end_inset

 and 
\begin_inset Formula $K^{B}+L^{B}$
\end_inset

 are in the relation 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

 if
\begin_inset Formula 
\begin{align*}
\text{either}:\quad & (k_{1}^{:K^{A}}+\bbnum 0,k_{2}^{:K^{B}}+\bbnum 0)\in\left<f\right>^{\updownarrow G}\text{ when }(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\quad,\\
\text{or}:\quad & (\bbnum 0+l_{1}^{:L^{A}},\bbnum 0+l_{2}^{:L^{B}})\in\left<f\right>^{\updownarrow G}\text{ when }(l_{1},l_{2})\in\left<f\right>^{\updownarrow L}\quad.
\end{align*}

\end_inset

By the inductive assumption, 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 already satisfy Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

, so the above becomes:
\begin_inset Formula 
\begin{align*}
\text{either}:\quad & (k_{1}^{:K^{A}}+\bbnum 0,k_{2}^{:K^{B}}+\bbnum 0)\in\left<f\right>^{\updownarrow G}\text{ when }k_{1}\triangleright f^{\uparrow K}=k_{2}\quad,\\
\text{or}:\quad & (\bbnum 0+l_{1}^{:L^{A}},\bbnum 0+l_{2}^{:L^{B}})\in\left<f\right>^{\updownarrow G}\text{ when }l_{1}\triangleright f^{\uparrow L}=l_{2}\quad.
\end{align*}

\end_inset

By definition of 
\begin_inset Formula $f^{\uparrow(K+L)}$
\end_inset

, we have 
\begin_inset Formula 
\[
(k^{:K^{A}}+\bbnum 0)\triangleright f^{\uparrow(K+L)}\triangleq(k\triangleright f^{\uparrow K})+\bbnum 0\quad,\quad\quad(\bbnum 0+l^{:L^{A}})\triangleright f^{\uparrow(K+L)}\triangleq\bbnum 0+(l\triangleright f^{\uparrow L})\quad.
\]

\end_inset

So, the condition for 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

 becomes
\begin_inset Formula 
\begin{align*}
\text{either}:\quad & (k_{1}^{:K^{A}}+\bbnum 0,k_{2}^{:K^{B}}+\bbnum 0)\in\left<f\right>^{\updownarrow G}\text{ when }(k_{1}+\bbnum 0)\triangleright f^{\uparrow(K+L)}=k_{2}+\bbnum 0\quad,\\
\text{or}:\quad & (\bbnum 0+l_{1}^{:L^{A}},\bbnum 0+l_{2}^{:L^{B}})\in\left<f\right>^{\updownarrow G}\text{ when }(\bbnum 0+l_{1})\triangleright f^{\uparrow(K+L)}=\bbnum 0+l_{2}\quad,
\end{align*}

\end_inset

which verifies the statement in the case of co-products.
\end_layout

\begin_layout Paragraph
Function type
\end_layout

\begin_layout Standard
Here, we have 
\begin_inset Formula $G^{A}\triangleq K^{A}\rightarrow L^{A}$
\end_inset

 where 
\begin_inset Formula $K$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $L$
\end_inset

 is a functor.
 For the function type, the relation 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

 is defined by
\begin_inset Formula 
\[
(g_{1}^{:K^{A}\rightarrow L^{A}},g_{2}^{:K^{B}\rightarrow L^{B}})\in\left<f\right>^{\updownarrow G}\text{ means if }(k_{1}^{:K^{A}},k_{2}^{:K^{B}})\in\left<f\right>^{\updownarrow K}\text{ then }(g_{1}(k_{1}),g_{2}(k_{2}))\in\left<f\right>^{\updownarrow L}\quad.
\]

\end_inset

By the inductive assumption, 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 already satisfy Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

, so the above becomes:
\begin_inset Formula 
\[
(g_{1},g_{2})\in\left<f\right>^{\updownarrow G}\text{ means }g_{1}(k_{2}\triangleright f^{\downarrow K})\triangleright f^{\uparrow L}=g_{2}(k_{2})\quad\text{or equivalently}:\quad f^{\downarrow K}\bef g_{1}\bef f^{\uparrow L}=g_{2}\quad.
\]

\end_inset

The last condition is the same as 
\begin_inset Formula $g_{1}\triangleright f^{\uparrow G}=g_{2}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Recursive type
\end_layout

\begin_layout Standard
For 
\begin_inset Formula $G^{A}\triangleq S^{A,G^{A}}$
\end_inset

 where 
\begin_inset Formula $S^{A,R}$
\end_inset

 is covariant in 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

, the relation 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

 is defined by
\begin_inset Formula 
\[
\left<f\right>^{\updownarrow G}=\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{\left<f\right>^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\quad.
\]

\end_inset

We need to prove that 
\begin_inset Formula $\left<f\right>^{\updownarrow G}\overset{?}{=}\langle f^{\uparrow G}\rangle$
\end_inset

.
 The inductive assumptions are that Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

 already holds for the recursive call 
\begin_inset Formula $\overline{\left<f\right>^{\updownarrow G}}$
\end_inset

:
\begin_inset Formula 
\[
(p^{:G^{A}},q^{:G^{B}})\in\overline{\left<f\right>^{\updownarrow G}}\text{ means }p\triangleright f^{\uparrow G}=q\quad,\quad\quad\text{ or equivalently}:\quad\overline{\left<f\right>^{\updownarrow G}}=\langle f^{\uparrow G}\rangle\quad,
\]

\end_inset

and that Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

 already holds for 
\begin_inset Formula $S$
\end_inset

, so that the liftings 
\begin_inset Formula $\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}$
\end_inset

 and 
\begin_inset Formula $\left<f^{\uparrow G}\right>^{\updownarrow S^{B,\bullet}}$
\end_inset

 satisfy
\begin_inset Formula 
\[
\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}=\langle f^{\uparrow S^{\bullet,G^{A}}}\rangle\quad,\quad\quad\langle f^{\uparrow G}\rangle^{\updownarrow S^{B,\bullet}}=\langle f^{\uparrow G\uparrow S^{B,\bullet}}\rangle\quad.
\]

\end_inset

To prove that 
\begin_inset Formula $\left<f\right>^{\updownarrow G}\overset{?}{=}\langle f^{\uparrow G}\rangle$
\end_inset

, write out the lifting 
\begin_inset Formula $f^{\uparrow G}$
\end_inset

 for a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow G}=f^{\uparrow S^{\bullet,G^{A}}}\bef\big(\overline{f^{\uparrow G}}\big)^{\uparrow S^{B,\bullet}}\quad,
\]

\end_inset

and simplify 
\begin_inset Formula $\langle f^{\uparrow G}\rangle$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \left<f\right>^{\updownarrow G}\overset{?}{=}\langle f^{\uparrow G}\rangle=\big\langle f^{\uparrow S^{\bullet,G^{A}}}\bef\big(\overline{f^{\uparrow G}}\big)^{\uparrow S^{B,\bullet}}\big\rangle\\
\text{use Statement~\ref{subsec:Statement-function-composition-relation}}:\quad & =\big\langle f^{\uparrow S^{\bullet,G^{A}}}\big\rangle\circ\big\langle\big(\overline{f^{\uparrow G}}\big)^{\uparrow S^{B,\bullet}}\big\rangle\\
\text{use the inductive assumptions}:\quad & =\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}\circ\langle\overline{f^{\uparrow G}}\rangle^{\updownarrow S^{B,\bullet}}=\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{\left<f\right>^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\quad.
\end{align*}

\end_inset

The last expression is equal to the definition of 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

, which is what we needed to show.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We proceed by induction on the structure of the contrafunctor 
\begin_inset Formula $G$
\end_inset

.
 In each case, we use the corresponding part of Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to obtain 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Constant type
\end_layout

\begin_layout Standard
In part 
\series bold
(a)
\series default
, we already proved the case 
\begin_inset Formula $G^{A}\triangleq Z$
\end_inset

 (with a fixed type 
\begin_inset Formula $Z$
\end_inset

).
\end_layout

\begin_layout Paragraph
Type parameter
\end_layout

\begin_layout Standard
Nothing to prove, since 
\begin_inset Formula $G^{A}\triangleq A$
\end_inset

 is not a contrafunctor.
\end_layout

\begin_layout Paragraph
Product and co-product types
\end_layout

\begin_layout Standard
The proof is analogous to that in part 
\series bold
(a)
\series default
 except that the relations 
\begin_inset Formula $\left<f\right>^{\updownarrow K}$
\end_inset

 and 
\begin_inset Formula $\left<f\right>^{\updownarrow L}$
\end_inset

 are defined in the opposite direction (e.g., 
\begin_inset Formula $(k_{1},k_{2})\in\left<f\right>^{\downarrow K}$
\end_inset

 when 
\begin_inset Formula $k_{1}=k_{2}\triangleright f^{\downarrow K}$
\end_inset

).
\end_layout

\begin_layout Paragraph
Function type
\end_layout

\begin_layout Standard
Here, we have 
\begin_inset Formula $G^{A}\triangleq K^{A}\rightarrow L^{A}$
\end_inset

 where 
\begin_inset Formula $K$
\end_inset

 is a functor and 
\begin_inset Formula $L$
\end_inset

 is a contrafunctor.
 For the function type, the relation 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

 is defined by
\begin_inset Formula 
\[
(g_{1}^{:K^{A}\rightarrow L^{A}},g_{2}^{:K^{B}\rightarrow L^{B}})\in\left<f\right>^{\updownarrow G}\text{ means if }(k_{1}^{:K^{A}},k_{2}^{:K^{B}})\in\left<f\right>^{\updownarrow K}\text{ then }(g_{1}(k_{1}),g_{2}(k_{2}))\in\left<f\right>^{\updownarrow L}\quad.
\]

\end_inset

By the inductive assumption, 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 already satisfy Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

, so the above becomes:
\begin_inset Formula 
\[
(g_{1},g_{2})\in\left<f\right>^{\updownarrow G}\text{ means }g_{1}(k_{1})=g_{2}(k_{1}\triangleright f^{\uparrow K})\triangleright f^{\downarrow L}\quad\text{or equivalently}:\quad g_{1}=f^{\uparrow K}\bef g_{2}\bef f^{\downarrow L}\quad.
\]

\end_inset

The last condition is the same as 
\begin_inset Formula $g_{1}=g_{2}\triangleright f^{\downarrow G}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Recursive type
\end_layout

\begin_layout Standard
Here, the contrafunctor 
\begin_inset Formula $G$
\end_inset

 is defined recursively by 
\begin_inset Formula $G^{A}\triangleq S^{A,G^{A}}$
\end_inset

, where 
\begin_inset Formula $S^{A,R}$
\end_inset

 is a profunctor (contravariant in 
\begin_inset Formula $A$
\end_inset

 and covariant in 
\begin_inset Formula $R$
\end_inset

).
 We need to prove that 
\begin_inset Formula $\left<f\right>^{\updownarrow G}\overset{?}{=}\langle f^{\downarrow G}\rangle$
\end_inset

.
 The relation 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

 is defined by
\begin_inset Formula 
\[
\left<f\right>^{\updownarrow G}=\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{\left<f\right>^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\quad.
\]

\end_inset

The inductive assumptions are that Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

 already holds for the recursive call 
\begin_inset Formula $\overline{\left<f\right>^{\updownarrow G}}$
\end_inset

:
\begin_inset Formula 
\[
(p^{:G^{A}},q^{:G^{B}})\in\overline{\left<f\right>^{\updownarrow G}}\text{ means }p=q\triangleright f^{\downarrow G}\quad,\quad\quad\text{ or equivalently}:\quad\overline{\left<f\right>^{\updownarrow G}}=\langle f^{\downarrow G}\rangle\quad,
\]

\end_inset

and that Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

 already holds for 
\begin_inset Formula $S$
\end_inset

, so that the liftings 
\begin_inset Formula $\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}$
\end_inset

 and 
\begin_inset Formula $\left<f^{\uparrow G}\right>^{\updownarrow S^{B,\bullet}}$
\end_inset

 satisfy
\begin_inset Formula 
\[
\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}=\langle f^{\downarrow S^{\bullet,G^{A}}}\rangle\quad,\quad\quad\langle f^{\downarrow G}\rangle^{\updownarrow S^{B,\bullet}}=\langle f^{\downarrow G\uparrow S^{B,\bullet}}\rangle\quad.
\]

\end_inset

To prove that 
\begin_inset Formula $\left<f\right>^{\updownarrow G}\overset{?}{=}\langle f^{\downarrow G}\rangle$
\end_inset

, write out the lifting 
\begin_inset Formula $f^{\downarrow G}$
\end_inset

 for a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
f^{\downarrow G}=f^{\downarrow S^{\bullet,G^{A}}}\bef\big(\overline{f^{\downarrow G}}\big)^{\uparrow S^{B,\bullet}}\quad,
\]

\end_inset

and simplify 
\begin_inset Formula $\langle f^{\downarrow G}\rangle$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \left<f\right>^{\updownarrow G}\overset{?}{=}\langle f^{\uparrow G}\rangle=\big\langle f^{\downarrow S^{\bullet,G^{A}}}\bef\big(\overline{f^{\downarrow G}}\big)^{\uparrow S^{B,\bullet}}\big\rangle\\
\text{use Statement~\ref{subsec:Statement-function-composition-relation}}:\quad & =\big\langle f^{\downarrow S^{\bullet,G^{A}}}\big\rangle\circ\big\langle\big(\overline{f^{\downarrow G}}\big)^{\uparrow S^{B,\bullet}}\big\rangle\\
\text{use the inductive assumptions}:\quad & =\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}\circ\langle\overline{f^{\downarrow G}}\rangle^{\updownarrow S^{B,\bullet}}=\left<f\right>^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{\left<f\right>^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\quad.
\end{align*}

\end_inset

The last expression is equal to the definition of 
\begin_inset Formula $\left<f\right>^{\updownarrow G}$
\end_inset

, which is what we needed to show.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-lifting-relation-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any fully parametric type constructor 
\begin_inset Formula $G^{\bullet}$
\end_inset

, the relational lifting obeys:
\begin_inset Formula 
\begin{align*}
\text{the identity law}:\quad & (\text{id}^{:A\leftrightarrow A})^{\updownarrow G}=\text{id}^{:G^{A}\leftrightarrow G^{A}}\quad,\\
\text{the composition law}:\quad & \text{for any }r^{:A\leftrightarrow B}\text{ and }s^{:B\leftrightarrow C}\quad:\quad r^{\updownarrow G}\circ s^{\updownarrow G}=(r\circ s)^{\updownarrow G}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We use induction in the structure of the type constructor 
\begin_inset Formula $G$
\end_inset

.
 The proof goes over each of the constructions in Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Constant type
\end_layout

\begin_layout Standard
Here, 
\begin_inset Formula $G^{A}\triangleq Z$
\end_inset

 (with a fixed type 
\begin_inset Formula $Z$
\end_inset

).
 The lifting of any relation 
\begin_inset Formula $r$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset

 always produces an identity relation (of type 
\begin_inset Formula $Z\leftrightarrow Z$
\end_inset

).
 The composition of two identity relations is again an identity relation
 because 
\begin_inset Formula $x=y$
\end_inset

 and 
\begin_inset Formula $y=z$
\end_inset

 entail 
\begin_inset Formula $x=z$
\end_inset

.
\end_layout

\begin_layout Paragraph
Type parameter
\end_layout

\begin_layout Standard
Here, 
\begin_inset Formula $G^{A}\triangleq A$
\end_inset

, so for any relation 
\begin_inset Formula $r$
\end_inset

 we have 
\begin_inset Formula $r^{\updownarrow G}=r$
\end_inset

.
 Then the identity and composition laws are automatically satisfied.
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
Here, we have 
\begin_inset Formula $G^{A}\triangleq K^{A}\times L^{A}$
\end_inset

.
 By the inductive assumptions, the identity and composition laws already
 hold for 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

.
 The lifting of a relation 
\begin_inset Formula $r$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset

 is defined as
\begin_inset Formula 
\[
(k_{1}^{:K^{A}}\times l_{1}^{:L^{A}},k_{2}^{:K^{B}}\times l_{2}^{:L^{B}})\in r^{\updownarrow G}\text{ means }(k_{1},k_{2})\in r^{\updownarrow K}\text{ and }(l_{1},l_{2})\in r^{\updownarrow L}\quad.
\]

\end_inset

To verify the identity law, set 
\begin_inset Formula $r\triangleq\text{id}^{:A\leftrightarrow A}$
\end_inset

 and use the inductive assumptions, 
\begin_inset Formula $\text{id}^{\updownarrow K}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{id}^{\updownarrow L}=\text{id}$
\end_inset

:
\begin_inset Formula 
\[
(k_{1}\times l_{1},k_{2}\times l_{2})\in\text{id}^{\updownarrow G}\text{ means }(k_{1},k_{2})\in\text{id}\text{ and }(l_{1},l_{2})\in\text{id}\quad\text{or equivalently}:\quad k_{1}=k_{2}\text{ and }l_{1}=l_{2}\quad.
\]

\end_inset

The last condition is equivalent to 
\begin_inset Formula $k_{1}\times l_{1}=k_{2}\times l_{2}$
\end_inset

, which means 
\begin_inset Formula $(k_{1}\times l_{1},k_{2}\times l_{2})\in\text{id}^{:K^{A}\times L^{A}\leftrightarrow K^{A}\times L^{A}}$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the composition law, write its two sides separately:
\begin_inset Formula 
\begin{align*}
 & (k_{1}\times l_{1},k_{3}\times l_{3})\in r^{\updownarrow G}\circ s^{\updownarrow G}\text{ means }\exists k_{2},l_{2}\text{ such that }(k_{1}\times l_{1},k_{2}\times l_{2})\in r^{\updownarrow G}\text{ and }(k_{2}\times l_{2},k_{3}\times l_{3})\in s^{\updownarrow G}\quad,\\
 & (k_{1}\times l_{1},k_{3}\times l_{3})\in(r\circ s)^{\updownarrow G}\text{ means }(k_{1},k_{3})\in(r\circ s)^{\updownarrow K}\text{ and }(l_{1},l_{3})\in(r\circ s)^{\updownarrow L}\quad.
\end{align*}

\end_inset

The inductive assumptions 
\begin_inset Formula $(r\circ s)^{\updownarrow K}=r^{\updownarrow K}\circ s^{\updownarrow K}$
\end_inset

 and 
\begin_inset Formula $(r\circ s)^{\updownarrow L}=r^{\updownarrow L}\circ s^{\updownarrow L}$
\end_inset

 give for the right-hand side:
\begin_inset Formula 
\[
(k_{1}\times l_{1},k_{3}\times l_{3})\in(r\circ s)^{\updownarrow G}\text{ means }(k_{1},k_{3})\in r^{\updownarrow K}\circ s^{\updownarrow K}\text{ and }(l_{1},l_{3})\in r^{\updownarrow L}\circ s^{\updownarrow L}\quad.
\]

\end_inset

By definition of the relational composition, the right-hand side condition
 is equivalent to
\begin_inset Formula 
\[
\exists k_{2},l_{2}\text{ such that }(k_{1},k_{2})\in r^{\updownarrow K}\quad,\quad(k_{2},k_{3})\in s^{\updownarrow K}\quad,\quad(l_{1},l_{2})\in r^{\updownarrow L}\quad,\quad(l_{2},l_{3})\in s^{\updownarrow L}\quad,
\]

\end_inset

which means the same as the left-hand side condition, 
\begin_inset Formula $(k_{1}\times l_{1},k_{2}\times l_{2})\in r^{\updownarrow G}$
\end_inset

 and 
\begin_inset Formula $(k_{2}\times l_{2},k_{3}\times l_{3})\in s^{\updownarrow G}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
Here, we have 
\begin_inset Formula $G^{A}\triangleq K^{A}+L^{A}$
\end_inset

.
 By the inductive assumptions, the identity and composition laws already
 hold for 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

.
 The lifting of a relation 
\begin_inset Formula $r$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset

 is defined as
\begin_inset Formula 
\[
(k_{1}^{:K^{A}}+\bbnum 0,k_{2}^{:K^{B}}+\bbnum 0)\in r^{\updownarrow G}\text{ if }(k_{1},k_{2})\in r^{\updownarrow K}\text{ or }(\bbnum 0+l_{1}^{:L^{A}},\bbnum 0+l_{2}^{:L^{B}})\in r^{\updownarrow G}\text{ if }(l_{1},l_{2})\in r^{\updownarrow L}\quad.
\]

\end_inset

To verify the identity law, set 
\begin_inset Formula $r\triangleq\text{id}^{:A\leftrightarrow A}$
\end_inset

 and use the inductive assumptions, 
\begin_inset Formula $\text{id}^{\updownarrow K}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{id}^{\updownarrow L}=\text{id}$
\end_inset

:
\begin_inset Formula 
\[
(k_{1}^{:K^{A}}+\bbnum 0,k_{2}^{:K^{B}}+\bbnum 0)\in\text{id}^{\updownarrow G}\text{ if }k_{1}=k_{2}\text{ or }(\bbnum 0+l_{1}^{:L^{A}},\bbnum 0+l_{2}^{:L^{B}})\in r^{\updownarrow G}\text{ if }l_{1}=l_{2}\quad.
\]

\end_inset

To summarize, 
\begin_inset Formula $(g_{1}^{:K^{A}+L^{A}},g_{2}^{:K^{A}+L^{A}})\in\text{id}^{\updownarrow G}$
\end_inset

 only if 
\begin_inset Formula $g_{1}=g_{2}$
\end_inset

.
 So, 
\begin_inset Formula $\text{id}^{\updownarrow G}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the composition law, begin with the left-hand side and notice
 that relations lifted to the disjunctive type 
\begin_inset Formula $K^{\bullet}+L^{\bullet}$
\end_inset

 hold only if both sides are either in the left or in the right part of
 the disjunction:
\begin_inset Formula 
\begin{align*}
 & (k_{1}^{:K^{A}}+\bbnum 0,k_{3}^{:K^{C}}+\bbnum 0)\in r^{\updownarrow G}\circ s^{\updownarrow G}\text{ means }\exists k_{2}^{:K^{B}}\text{ such that }(k_{1},k_{2})\in r^{\updownarrow K}\text{ and }(k_{2},k_{3})\in s^{\updownarrow K}\quad,\\
 & (\bbnum 0+l_{1}^{:L^{A}},\bbnum 0+l_{3}^{:L^{C}})\in r^{\updownarrow G}\circ s^{\updownarrow G}\text{ means }\exists l_{2}^{:L^{B}}\text{ such that }(l_{1},l_{2})\in r^{\updownarrow L}\text{ and }(l_{2},l_{3})\in s^{\updownarrow L}\quad.
\end{align*}

\end_inset

The simplification is possible because values such as 
\begin_inset Formula $(k+\bbnum 0,\bbnum 0+l)$
\end_inset

 are never in any of the relations lifted to 
\begin_inset Formula $G$
\end_inset

.
 Now we note that the conditions involving 
\begin_inset Formula $\exists k_{2}$
\end_inset

 and 
\begin_inset Formula $\exists l_{2}$
\end_inset

 are the same as in the definition of relational composition.
 So, we can rewrite the above conditions as:
\begin_inset Formula 
\begin{align*}
 & (k_{1}^{:K^{A}}+\bbnum 0,k_{3}^{:K^{C}}+\bbnum 0)\in r^{\updownarrow G}\circ s^{\updownarrow G}\text{ means }(k_{1},k_{3})\in r^{\updownarrow K}\circ s^{\updownarrow K}\quad,\\
 & (\bbnum 0+l_{1}^{:L^{A}},\bbnum 0+l_{3}^{:L^{C}})\in r^{\updownarrow G}\circ s^{\updownarrow G}\text{ means }(l_{1},l_{3})\in r^{\updownarrow L}\circ s^{\updownarrow L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Now we write the right-hand side of the composition law:
\begin_inset Formula 
\[
(k_{1}+\bbnum 0,k_{3}+\bbnum 0)\in(r\circ s)^{\updownarrow G}\text{ if }(k_{1},k_{3})\in(r\circ s)^{\updownarrow K}\text{ or }(\bbnum 0+l_{1},\bbnum 0+l_{3})\in(r\circ s)^{\updownarrow G}\text{ if }(l_{1},l_{3})\in(r\circ s)^{\updownarrow L}\quad.
\]

\end_inset

This is the same as the above conditions because the inductive assuptions
 say that 
\begin_inset Formula $r^{\updownarrow K}\circ s^{\updownarrow K}=(r\circ s)^{\updownarrow K}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow L}\circ s^{\updownarrow L}=(r\circ s)^{\updownarrow L}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Function type
\end_layout

\begin_layout Standard
Here, we have 
\begin_inset Formula $G^{A}\triangleq K^{A}\rightarrow L^{A}$
\end_inset

.
 By the inductive assumptions, the identity and composition laws already
 hold for 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the identity law, we need to show that 
\begin_inset Formula $\text{id}^{\updownarrow G}=\text{id}$
\end_inset

.
 Write the definition of 
\begin_inset Formula $\text{id}^{\updownarrow G}$
\end_inset

:
\begin_inset Formula 
\[
(g_{1}^{:K^{A}\rightarrow L^{A}},g_{2}^{:K^{A}\rightarrow L^{A}})\in\text{id}^{\updownarrow G}\text{ means: if }(k_{1},k_{2})\in\text{id}^{\updownarrow K}\text{ then }(g_{1}(k_{1}),g_{2}(k_{2}))\in\text{id}^{\updownarrow L}\quad.
\]

\end_inset

By the inductive assumptions, 
\begin_inset Formula $\text{id}^{\updownarrow K}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{id}^{\updownarrow L}=\text{id}$
\end_inset

, so the condition above becomes:
\begin_inset Formula 
\[
(g_{1}^{:K^{A}\rightarrow L^{A}},g_{2}^{:K^{A}\rightarrow L^{A}})\in\text{id}^{\updownarrow G}\text{ means if }k_{1}=k_{2}\text{ then }g_{1}(k_{1})=g_{2}(k_{2})\quad.
\]

\end_inset

The last condition is the definition of equality between functions 
\begin_inset Formula $g_{1}$
\end_inset

 and 
\begin_inset Formula $g_{2}$
\end_inset

 (they must give equal results when applied to equal arguments).
 So, 
\begin_inset Formula $(g_{1},g_{2})\in\text{id}^{\updownarrow G}$
\end_inset

 holds when 
\begin_inset Formula $g_{1}=g_{2}$
\end_inset

, which is the same as 
\begin_inset Formula $(g_{1},g_{2})\in\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the composition law, write the definitions of 
\begin_inset Formula $r^{\updownarrow G}\circ s^{\updownarrow G}$
\end_inset

 and 
\begin_inset Formula $(r\circ s)^{\updownarrow G}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (g_{1}^{:K^{A}\rightarrow L^{A}},g_{3}^{:K^{C}\rightarrow L^{C}})\in r^{\updownarrow G}\circ s^{\updownarrow G}\text{ means }\exists g_{2}^{:K^{B}\rightarrow L^{B}}\text{ such that }(g_{1},g_{2})\in r^{\updownarrow G}\text{ and }(g_{2},g_{3})\in s^{\updownarrow G}\quad,\\
 & (g_{1}^{:K^{A}\rightarrow L^{A}},g_{3}^{:K^{C}\rightarrow L^{C}})\in(r\circ s)^{\updownarrow G}\text{ means if }(k_{1}^{:K^{A}},k_{3}^{:K^{C}})\in(r\circ s)^{\updownarrow K}\text{ then }(g_{1}(k_{1}),g_{3}(k_{3}))\in(r\circ s)^{\updownarrow L}\quad.
\end{align*}

\end_inset

 Writing out the definitions of 
\begin_inset Formula $r^{\updownarrow G}$
\end_inset

, 
\begin_inset Formula $s^{\updownarrow G}$
\end_inset

, and using the inductive assumptions for 
\begin_inset Formula $(r\circ s)^{\updownarrow K}$
\end_inset

, and 
\begin_inset Formula $(r\circ s)^{\updownarrow L}$
\end_inset

, we get:
\begin_inset Formula 
\begin{align*}
 & (g_{1},g_{2})\in r^{\updownarrow G}\text{ means if }(k_{1}^{:K^{A}},k_{2}^{:K^{B}})\in r^{\updownarrow K}\text{ then }(g_{1}(k_{1}),g_{2}(k_{2}))\in r^{\updownarrow L}\quad,\\
 & (g_{2},g_{3})\in s^{\updownarrow G}\text{ means if }(k_{2}^{:K^{B}},k_{3}^{:K^{C}})\in s^{\updownarrow K}\text{ then }(g_{2}(k_{2}),g_{3}(k_{3}))\in s^{\updownarrow L}\quad,\\
 & (k_{1},k_{3})\in(r\circ s)^{\updownarrow K}\text{ means }\exists k_{2}^{:K^{B}}\text{ such that }(k_{1},k_{2})\in r^{\updownarrow K}\text{ and }(k_{2},k_{3})\in s^{\updownarrow K}\quad,\\
 & (g_{1}(k_{1}),g_{3}(k_{3}))\in(r\circ s)^{\updownarrow L}\text{ means }\exists l_{2}^{:L^{B}}\text{ such that }(g_{1}(k_{1}),l_{2})\in r^{\updownarrow L}\text{ and }(l_{2},g_{3}(k_{3}))\in s^{\updownarrow L}\quad.
\end{align*}

\end_inset

Using these definitions, we write the left-hand side of the composition
 law as:
\begin_inset Formula 
\begin{align*}
 & (g_{1},g_{3})\in r^{\updownarrow G}\circ s^{\updownarrow G}\text{ means }\exists g_{2}\text{ such that if }(k_{1},k_{2})\in r^{\updownarrow K}\text{ and }(k_{2},k_{3})\in s^{\updownarrow K}\\
 & \quad\quad\text{ then }(g_{1}(k_{1}),g_{2}(k_{2}))\in r^{\updownarrow L}\text{ and }(g_{2}(k_{2}),g_{3}(k_{3}))\in s^{\updownarrow L}\quad.
\end{align*}

\end_inset

The right-hand side of the composition law is:
\begin_inset Formula 
\begin{align*}
 & (g_{1},g_{3})\in(r\circ s)^{\updownarrow G}\text{ means if }\exists k_{1},k_{2},k_{3}\text{ such that }(k_{1},k_{2})\in r^{\updownarrow K}\text{ and }(k_{2},k_{3})\in s^{\updownarrow K}\\
 & \quad\quad\text{ then }\exists l_{2}\text{ such that }(g_{1}(k_{1}),l_{2})\in r^{\updownarrow L}\text{ and }(l_{2},g_{3}(k_{3}))\in s^{\updownarrow L}\quad.
\end{align*}

\end_inset

The two sides become equivalent if we define 
\begin_inset Formula $g_{2}$
\end_inset

 in the left-hand side and 
\begin_inset Formula $l_{2}$
\end_inset

 in the right-hand side to satisfy 
\begin_inset Formula $l_{2}=g_{2}(k_{2})$
\end_inset

.
\end_layout

\begin_layout Paragraph
Recursive type
\end_layout

\begin_layout Standard
Here, 
\begin_inset Formula $G$
\end_inset

 is defined recursively by 
\begin_inset Formula $G^{A}\triangleq S^{A,G^{A}}$
\end_inset

, where 
\begin_inset Formula $S^{A,R}$
\end_inset

 is covariant in 
\begin_inset Formula $R$
\end_inset

.
 The inductive assumptions say that the identity and composition laws already
 hold for liftings to 
\begin_inset Formula $S^{A,R}$
\end_inset

 (with respect to both its type parameters).
\end_layout

\begin_layout Standard
To verify the identity law of 
\begin_inset Formula $G$
\end_inset

, write:
\begin_inset Formula 
\begin{align*}
 & \text{id}^{\updownarrow G}=\text{id}^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{\text{id}^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\\
\text{inductive assumptions}:\quad & =\text{id}\circ\text{id}^{\updownarrow S^{B,\bullet}}=\text{id}\circ\text{id}\\
\text{composition of relations}:\quad & =\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law of 
\begin_inset Formula $G$
\end_inset

, write its two sides:
\begin_inset Formula 
\begin{align*}
 & r^{\updownarrow G}\circ s^{\updownarrow G}=r^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\circ s^{\updownarrow S^{\bullet,G^{B}}}\circ\big(\overline{s^{\updownarrow G}}\big)^{\updownarrow S^{C,\bullet}}\quad,\\
 & (r\circ s)^{\updownarrow G}=(r\circ s)^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{(r\circ s)^{\updownarrow G}}\big)^{\updownarrow S^{C,\bullet}}\\
\text{inductive assumptions}:\quad & \quad=r^{\updownarrow S^{\bullet,G^{A}}}\circ s^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{r^{\updownarrow G}}\circ\overline{s^{\updownarrow G}}\big)^{\updownarrow S^{C,\bullet}}=r^{\updownarrow S^{\bullet,G^{A}}}\circ s^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{C,\bullet}}\circ\big(\overline{s^{\updownarrow G}}\big)^{\updownarrow S^{C,\bullet}}\quad.
\end{align*}

\end_inset

The remaining difference between the two sides is
\begin_inset Formula 
\[
\big(\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{B,\bullet}}\circ s^{\updownarrow S^{\bullet,G^{B}}}\overset{?}{=}s^{\updownarrow S^{\bullet,G^{A}}}\circ\big(\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{C,\bullet}}\quad.
\]

\end_inset

This equation holds due to the commutativity law (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
\end_layout

\begin_layout Standard
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Various recursive constructions shown above require us to lift two relations
 simultaneously with respect to two type parameters.
 For instance, Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(f) produces a relation between 
\begin_inset Formula $S^{A,G^{A}}$
\end_inset

 and 
\begin_inset Formula $S^{B,G^{B}}$
\end_inset

 by lifting the relations 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 and 
\begin_inset Formula $r^{\updownarrow G}:G^{A}\leftrightarrow G^{B}$
\end_inset

 with respect to the two type parameters of the bifunctor 
\begin_inset Formula $S^{A,R}$
\end_inset

.
\end_layout

\begin_layout Standard
The simultaneous lifting of two relations 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 and 
\begin_inset Formula $s^{:X\leftrightarrow Y}$
\end_inset

 to a type constructor 
\begin_inset Formula $P^{\bullet,\bullet}$
\end_inset

 can be defined by first lifting 
\begin_inset Formula $r$
\end_inset

 to 
\begin_inset Formula $r^{\updownarrow P^{\bullet,X}}:P^{A,X}\leftrightarrow P^{B,X}$
\end_inset

 and then lifting 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s^{\updownarrow P^{B,\bullet}}:P^{B,X}\leftrightarrow P^{B,Y}$
\end_inset

.
 The two lifted relations can be composed and yield a relation 
\begin_inset Formula $r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}$
\end_inset

 of type 
\begin_inset Formula $P^{A,X}\leftrightarrow P^{B,Y}$
\end_inset

.
 However, the liftings may be performed in a different order, composing
 
\begin_inset Formula $s^{\updownarrow P^{A,\bullet}}:P^{A,X}\leftrightarrow P^{A,Y}$
\end_inset

 with 
\begin_inset Formula $r^{\updownarrow P^{\bullet,Y}}:P^{A,Y}\leftrightarrow P^{B,Y}$
\end_inset

.
 We may expect the results to be independent of the order of liftings.
 This is analogous to the commutativity laws for bifunctors, proved in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Commutativity-laws-for-type-constructors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Indeed, relations can be lifted simultaneously with respect to several
 type parameters without ambiguity in the order of liftings:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-lifting-relation-commutativity-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-commutativity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given
\begin_inset Index idx
status open

\begin_layout Plain Layout
commutativity law!of relational liftings
\end_layout

\end_inset

 a fully parametric type constructor 
\begin_inset Formula $P^{A,X}$
\end_inset

, the lifting of any two relations 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 and
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "30col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.3pc}\xyScaleX{2.6pc}P^{A,X}\ar@{<->}[d]\sb(0.45){r^{\updownarrow P^{\bullet,X}}}\ar@{<->}[r]\sp(0.55){s^{\updownarrow P^{A,\bullet}}}\ar@{<->}[rd]{} & P^{A,Y}\ar@{<->}[d]\sp(0.45){r^{\updownarrow P^{\bullet,Y}}}\\
P^{B,X}\ar@{<->}[r]\sp(0.5){s^{\updownarrow P^{B,\bullet}}} & P^{B,Y}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula $s^{:X\leftrightarrow Y}$
\end_inset

 yields the same result (a relation of type 
\begin_inset Formula $P^{A,X}\leftrightarrow P^{B,Y}$
\end_inset

) independently of the order of composition:
\begin_inset Formula 
\begin{align*}
\text{relational commutativity law}:\quad & r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}=s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We use induction in the structure of the type constructor 
\begin_inset Formula $P^{\bullet,\bullet}$
\end_inset

, which must be built up from the six type constructions of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Paragraph
Base cases
\end_layout

\begin_layout Standard
These are 
\begin_inset Formula $P^{A,X}\triangleq Z$
\end_inset

 (a fixed type), 
\begin_inset Formula $P^{A,X}\triangleq A$
\end_inset

, and 
\begin_inset Formula $P^{A,X}\triangleq X$
\end_inset

.
 To cover all these cases at once, we will prove that 
\begin_inset Formula $P$
\end_inset

 satisfies the relational commutativity law if 
\begin_inset Formula $P^{A,X}$
\end_inset

 is independent of one of its type parameters:
\begin_inset Formula 
\begin{align*}
\text{if }P^{A,X}=G^{A}:\quad & r^{\updownarrow P^{\bullet,X}}=r^{\updownarrow P^{\bullet,Y}}\quad,\quad s^{\updownarrow P^{A,\bullet}}=s^{\updownarrow P^{B,\bullet}}=\text{id}\quad,\quad\text{ so }\quad r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}=s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}\quad;\\
\text{if }P^{A,X}=H^{X}:\quad & r^{\updownarrow P^{\bullet,X}}=r^{\updownarrow P^{\bullet,Y}}=\text{id}\quad,\quad s^{\updownarrow P^{A,\bullet}}=s^{\updownarrow P^{B,\bullet}}\quad,\quad\text{ so }\quad r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}=s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $P^{A,X}\triangleq Q^{A,X}\times R^{A,X}$
\end_inset

, and the law already holds for 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 To verify the law for 
\begin_inset Formula $P$
\end_inset

, write the condition for some 
\begin_inset Formula $p_{1}^{:P^{A,X}}$
\end_inset

 and 
\begin_inset Formula $p_{2}^{:P^{B,Y}}$
\end_inset

 to be in the relations 
\begin_inset Formula $r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}$
\end_inset

 and 
\begin_inset Formula $s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (q_{1}^{:Q^{A,X}}\times u_{1}^{:R^{A,X}},q_{2}^{:Q^{B,Y}}\times u_{2}^{:R^{B,Y}})\in r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}\text{ means }\exists p_{3}=q_{3}^{:Q^{B,X}}\times u_{3}^{:R^{B,X}}\text{ such that }\\
 & \quad(q_{1},q_{3})\in r^{\updownarrow Q^{\bullet,X}}\quad,\quad(u_{1},u_{3})\in r^{\updownarrow R^{\bullet,X}}\quad,\quad(q_{3},q_{2})\in s^{\updownarrow Q^{B,\bullet}}\quad,\quad(u_{3},u_{2})\in s^{\updownarrow R^{B,\bullet}}\quad;\\
 & (q_{1}^{:Q^{A,X}}\times u_{1}^{:R^{A,X}},q_{2}^{:Q^{B,Y}}\times u_{2}^{:R^{B,Y}})\in s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}\text{ means }\exists p_{4}=q_{4}^{:Q^{B,X}}\times u_{4}^{:R^{B,X}}\text{ such that }\\
 & \quad(q_{1},q_{4})\in s^{\updownarrow Q^{A,\bullet}}\quad,\quad(u_{1},u_{4})\in s^{\updownarrow R^{A,\bullet}}\quad,\quad(q_{4},q_{2})\in r^{\updownarrow Q^{\bullet,Y}}\quad,\quad(u_{4},u_{2})\in r^{\updownarrow R^{\bullet,Y}}\quad.
\end{align*}

\end_inset

These conditions can be simplified using the definition of the relational
 composition: 
\begin_inset Formula 
\begin{align*}
 & (q_{1}\times u_{1},q_{2}\times u_{2})\in r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}\text{ means }(q_{1},q_{2})\in r^{\updownarrow Q^{\bullet,X}}\circ s^{\updownarrow Q^{B,\bullet}}\text{ and }(u_{1},u_{2})\in r^{\updownarrow R^{\bullet,X}}\circ s^{\updownarrow R^{B,\bullet}}\quad;\\
 & (q_{1}\times u_{1},q_{2}\times u_{2})\in s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}\text{ means }(q_{1},q_{2})\in s^{\updownarrow Q^{A,\bullet}}\circ r^{\updownarrow Q^{\bullet,Y}}\text{ and }(u_{1},u_{2})\in s^{\updownarrow R^{A,\bullet}}\circ r^{\updownarrow R^{\bullet,Y}}\quad.
\end{align*}

\end_inset

The remaining differences vanish due to the inductive assumptions (the law
 holds for 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

).
\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
We have 
\begin_inset Formula $P^{A,X}\triangleq Q^{A,X}+R^{A,X}$
\end_inset

, and the law already holds for 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 We note that any two values 
\begin_inset Formula $p_{1}^{:P^{A,X}}$
\end_inset

 and 
\begin_inset Formula $p_{2}^{:P^{B,Y}}$
\end_inset

 can be in the relation 
\begin_inset Formula $r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}$
\end_inset

 only if both 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

 are in the same part of the disjunctive type 
\begin_inset Formula $Q+R$
\end_inset

.
 To see why, write:
\begin_inset Formula 
\[
(p_{1}^{:P^{A,X}},p_{2}^{:P^{B,Y}})\in r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}\text{ means }\exists p_{3}^{:P^{B,X}}\text{ such that }(p_{1},p_{3})\in r^{\updownarrow P^{\bullet,X}}\text{ and }(p_{3},p_{2})\in s^{\updownarrow P^{B,\bullet}}\quad.
\]

\end_inset

By definition of the lifted relation 
\begin_inset Formula $r^{\updownarrow(Q^{\bullet,X}+R^{\bullet,X})}$
\end_inset

, the values 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $p_{3}$
\end_inset

 must be in the same part of the disjunction; also, 
\begin_inset Formula $p_{3}$
\end_inset

 and 
\begin_inset Formula $p_{2}$
\end_inset

 must be in the same part.
 So, we must have either 
\begin_inset Formula $p_{1}=q_{1}^{:Q^{A,X}}+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $p_{2}=q_{2}^{:Q^{B,Y}}+\bbnum 0$
\end_inset

 with 
\begin_inset Formula $(q_{1},q_{2})\in r^{\updownarrow Q^{\bullet,X}}\circ s^{\updownarrow Q^{B,\bullet}}$
\end_inset

; or 
\begin_inset Formula $p_{1}=\bbnum 0+u_{1}^{:R^{A,X}}$
\end_inset

 and 
\begin_inset Formula $p_{2}=\bbnum 0+u_{2}^{:R^{B,Y}}$
\end_inset

 with 
\begin_inset Formula $(u_{1},u_{2})\in r^{\updownarrow R^{\bullet,X}}\circ s^{\updownarrow R^{B,\bullet}}$
\end_inset

.
 The same holds for the relation 
\begin_inset Formula $s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}$
\end_inset

 except that we must have either 
\begin_inset Formula $(q_{1},q_{2})\in s^{\updownarrow Q^{A,\bullet}}\circ r^{\updownarrow Q^{\bullet,Y}}$
\end_inset

 or 
\begin_inset Formula $(u_{1},u_{2})\in s^{\updownarrow R^{A,\bullet}}\circ r^{\updownarrow R^{\bullet,Y}}$
\end_inset

.
 So, the relational commutativity law of 
\begin_inset Formula $P$
\end_inset

 when applied to 
\begin_inset Formula $\left(p_{1},p_{2}\right)$
\end_inset

 reduces either to the law of 
\begin_inset Formula $Q$
\end_inset

 or to the law of 
\begin_inset Formula $R$
\end_inset

, which already hold due to the inductive assumptions.
\end_layout

\begin_layout Paragraph
Function type
\end_layout

\begin_layout Standard
We have 
\begin_inset Formula $P^{A,X}\triangleq Q^{A,X}\rightarrow R^{A,X}$
\end_inset

, and the law already holds for 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 To verify the law for 
\begin_inset Formula $P$
\end_inset

, we need to write the condition for some 
\begin_inset Formula $p_{1}^{:P^{A,X}}$
\end_inset

 and 
\begin_inset Formula $p_{2}^{:P^{B,Y}}$
\end_inset

 to be in the relations 
\begin_inset Formula $r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}$
\end_inset

 and 
\begin_inset Formula $s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}$
\end_inset

.
 Since 
\begin_inset Formula $P$
\end_inset

 has a function type, we need to use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(e); for instance, we find:
\begin_inset Formula 
\begin{align*}
 & (a^{:P^{A,X}},b^{:P^{B,X}})\in r^{\updownarrow P^{\bullet,X}}\text{ means if }(q_{1}^{:Q^{A,X}},q_{2}^{:Q^{B,X}})\in r^{\updownarrow Q^{\bullet,X}}\text{ then }(a(q_{1}),b(q_{2}))\in r^{\updownarrow R^{\bullet,X}}\quad,\\
 & (b^{:P^{B,X}},c^{:P^{B,Y}})\in s^{\updownarrow P^{B,\bullet}}\text{ means if }(q_{2}^{:Q^{B,X}},q_{3}^{:Q^{B,Y}})\in s^{\updownarrow Q^{B,\bullet}}\text{ then }(b(q_{2}),c(q_{3}))\in s^{\updownarrow R^{B,\bullet}}\quad.
\end{align*}

\end_inset

So ***
\begin_inset Formula 
\begin{align*}
 & (p_{1},p_{2})\in r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}\text{ means }\exists p_{3}^{:P^{B,X}}\text{ such that }(p_{1},p***\\
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Paragraph
Recursive type
\end_layout

\begin_layout Standard
We have a recursive definition 
\begin_inset Formula $P^{X,Y}\triangleq S^{X,Y,P^{X,Y}}$
\end_inset

, and the law already holds for liftings to 
\begin_inset Formula $S^{X,Y,R}$
\end_inset

 with respect to any of its type parameters.
 To verify the law for 
\begin_inset Formula $P$
\end_inset

, write the condition for some 
\begin_inset Formula $p_{1}^{:P^{A,X}}$
\end_inset

 and 
\begin_inset Formula $p_{2}^{:P^{B,Y}}$
\end_inset

 to be in the relations 
\begin_inset Formula $r^{\updownarrow P^{\bullet,X}}\circ s^{\updownarrow P^{B,\bullet}}$
\end_inset

 and 
\begin_inset Formula $s^{\updownarrow P^{A,\bullet}}\circ r^{\updownarrow P^{\bullet,Y}}$
\end_inset

:
\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Proof of the relational parametricity theorem
\end_layout

\begin_layout Standard
The theorem says that any fully parametric function 
\begin_inset Formula $t:\forall A.\,P^{A}\rightarrow Q^{A}$
\end_inset

 obeys the relational law:
\begin_inset Formula 
\[
\forall A,B.\,\forall r^{:A\leftrightarrow B}.\,\forall x^{:P^{A}},y^{:P^{B}}.\,\text{ if }(x,y)\in r^{\updownarrow P}\text{ then }(t^{A}(x),t^{B}(y))\in r^{\updownarrow Q}\quad.
\]

\end_inset

The proof goes by induction on the structure of the code of the function
 
\begin_inset Formula $t$
\end_inset

.
 That code is built from smaller sub-expressions using the nine code constructio
ns of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The inductive assumption is that all sub-expressions already satisfy the
 relational law.
\end_layout

\begin_layout Standard
Before proceeding to the proof, we need a more general formulation of the
 relational law.
 This is necessary because some of the sub-expressions of 
\begin_inset Formula $t$
\end_inset

 will not have a function's type signature and will contain free variables.
 For instance, one of the nine constructions (
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

) allows 
\begin_inset Formula $t$
\end_inset

 to be of the form 
\begin_inset Formula $t=z^{:P^{A}}\rightarrow\text{expr}(z)$
\end_inset

, where 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr(z)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is an expression describing a function body.
 However, the function 
\emph on
body
\emph default
 itself does not necessarily have a type signature of the form 
\begin_inset Formula $K^{A}\rightarrow L^{A}$
\end_inset

 (i.e., the type signature of a function).
 Also, 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr(z)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 may contain 
\begin_inset Formula $z$
\end_inset

 as a free variable (defined outside 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr(z)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

), and the type of 
\begin_inset Formula $z$
\end_inset

 may depend on the type parameter 
\begin_inset Formula $A$
\end_inset

.
 So, we need to reformulate the relational naturality law to describe also
 function 
\emph on
bodies
\emph default
 (i.e., arbitrary expressions containing a free variable) instead of functions:
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-(relational-naturality"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-(relational-naturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (relational naturality law)
\end_layout

\begin_layout Standard
For an expression 
\begin_inset Formula $t(h):\forall A.\,Q^{A}$
\end_inset

 containing a free variable 
\begin_inset Formula $h^{:H^{A}}$
\end_inset

 (where 
\begin_inset Formula $H$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are some type constructors), the relational naturality law is written as:
\begin_inset Formula 
\begin{equation}
\forall(A,B).\,\forall(r^{:A\leftrightarrow B},h_{1}^{:H^{A}},h_{2}^{:H^{B}}).\,\text{ if }(h_{1},h_{2})\in r^{\updownarrow H}\text{ then }(t^{A}(h_{1}),t^{B}(h_{2}))\in r^{\updownarrow Q}\quad.\label{eq:relational-naturality-law}
\end{equation}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $t$
\end_inset

 contains no free variables, we may still write 
\begin_inset Formula $t$
\end_inset

 as 
\begin_inset Formula $t(h)$
\end_inset

 even though it does not depend on 
\begin_inset Formula $h$
\end_inset

.
 In that case, the condition for 
\begin_inset Formula $h_{1}$
\end_inset

 and 
\begin_inset Formula $h_{2}$
\end_inset

 becomes irrelevant in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and the law is simplified to
\begin_inset Formula 
\[
\forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,(t^{A},t^{B})\in r^{\updownarrow Q}\quad.
\]

\end_inset

However, we will keep using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and writing 
\begin_inset Formula $t(h)$
\end_inset

 even in this case.
\end_layout

\begin_layout Standard
When an expression contains more than one free variable, we can gather all
 the free variables into a tuple.
 This creates an 
\emph on
equivalent
\emph default
 expression with just one free variable:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement--relational-naturality-tuple"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement--relational-naturality-tuple"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
The relational naturality law for an expression 
\begin_inset Formula $t(z_{1},z_{2})$
\end_inset

 containing 
\emph on
two
\emph default
 free variables 
\begin_inset Formula $z_{1}^{:K^{A}}$
\end_inset

 and 
\begin_inset Formula $z_{2}^{:L^{A}}$
\end_inset

 is equivalent to the relational naturality law for the expression 
\begin_inset Formula $u(z)$
\end_inset

 with 
\emph on
one
\emph default
 free variable 
\begin_inset Formula $z$
\end_inset

, defined as
\begin_inset Formula 
\[
z^{:K^{A}\times L^{A}}\triangleq z_{1}\times z_{2}\quad,\quad\quad u(z)\triangleq t(z\triangleright\pi_{1},z\triangleright\pi_{2})\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The relational naturality laws for 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 say that, for all types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \forall r^{:A\leftrightarrow B},x_{1}^{:K^{A}},x_{2}^{:L^{A}},y_{1}^{:K^{B}},y_{2}^{:L^{B}}:\,\text{ if }(x_{1},y_{1})\in r^{\updownarrow K}\text{ and }(x_{2},y_{2})\in r^{\updownarrow L}\text{ then }(t(x_{1},x_{2}),t(y_{1},y_{2}))\in r^{\updownarrow Q}\quad.\\
 & \forall r^{:A\leftrightarrow B},\,\forall z^{:K^{A}\times L^{A}},w^{:K^{B}\times L^{B}}:\,\text{ if }(z,w)\in r^{\updownarrow(K\times L)}\text{ then }(u(z),u(w))\in r^{\updownarrow Q}\quad.
\end{align*}

\end_inset

By Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c), the lifting 
\begin_inset Formula $r^{\updownarrow(K\times L)}$
\end_inset

 is defined via projections: 
\begin_inset Formula 
\[
(z,w)\in r^{\updownarrow(K\times L)}\text{ if }(z\triangleright\pi_{1},w\triangleright\pi_{1})\in r^{\updownarrow K}\text{ and }(z\triangleright\pi_{2},w\triangleright\pi_{2})\in r^{\updownarrow L}\quad.
\]

\end_inset

Setting 
\begin_inset Formula $z=x_{1}\times x_{2}$
\end_inset

 and 
\begin_inset Formula $w=y_{1}\times y_{2}$
\end_inset

, we find that 
\begin_inset Formula $u(z)=t(x_{1},x_{2})$
\end_inset

 and 
\begin_inset Formula $u(w)=t(y_{1},y_{2})$
\end_inset

.
 It follows that the naturality laws for 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 are equivalent.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Due to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement--relational-naturality-tuple"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we are allowed to assume that the expression 
\begin_inset Formula $t$
\end_inset

 always has a 
\emph on
single
\emph default
 free variable.
 This simplifies the formulation of the relational parametricity theorem:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-main-relational-parametricity"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-main-relational-parametricity"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (relational parametricity)
\end_layout

\begin_layout Standard
Any fully parametric expression 
\begin_inset Formula $t(z):\forall A.\,Q^{A}$
\end_inset

 containing a single free variable 
\begin_inset Formula $z^{:P^{A}}$
\end_inset

 (where 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are fully parametric, exponential-polynomial type constructors) satisfies
 the relational naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof 
\end_layout

\begin_layout Standard
By assumption, 
\begin_inset Formula $t$
\end_inset

 is built up from the nine constructions of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 So, the code of 
\begin_inset Formula $t$
\end_inset

 has one of these nine constructions as the top-level expression.
 We will go through them one by one and prove that 
\begin_inset Formula $t$
\end_inset

 satisfies Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as long as all its sub-expressions do.
 Throughout the proof, all relational naturality laws involve an arbitrary
 relation 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 between arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Paragraph
Use unit value
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t\triangleq1$
\end_inset

 and has the unit type (
\begin_inset Formula $Q^{A}\triangleq\bbnum 1$
\end_inset

).
 Since 
\begin_inset Formula $t$
\end_inset

 contains no bound variables, the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes simply
\begin_inset Formula 
\[
(1,1)\in r^{\updownarrow Q}\quad.
\]

\end_inset

By Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a), the relation 
\begin_inset Formula $r^{\updownarrow\bbnum 1}$
\end_inset

 between values 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 holds for all 
\begin_inset Formula $r$
\end_inset

.
\end_layout

\begin_layout Paragraph
Use argument
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t\triangleq h$
\end_inset

 where 
\begin_inset Formula $h^{:H^{A}}$
\end_inset

 is a bound variable (the argument of the function whose body is 
\begin_inset Formula $t$
\end_inset

).
 So, we must have 
\begin_inset Formula $Q=H$
\end_inset

.
 The law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is then written as
\begin_inset Formula 
\[
\forall h_{1}^{:H^{A}},h_{2}^{:H^{B}}.\,\text{ if }(h_{1},h_{2})\in r^{\updownarrow H}\text{ then }(h_{1},h_{2})\in r^{\updownarrow H}\quad.
\]

\end_inset

This condition is trivially satisfied.
\end_layout

\begin_layout Paragraph
Create function
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t(h)\triangleq p^{:P^{A}}\rightarrow g(h,p)$
\end_inset

 where the expression 
\begin_inset Formula $g^{:G^{A}}$
\end_inset

 contains a free variable 
\begin_inset Formula $h^{:H^{A}}$
\end_inset

 in addition to the free variable 
\begin_inset Formula $p$
\end_inset

.
 The inductive assumption is that 
\begin_inset Formula $g$
\end_inset

 already satisfies the relational naturality law, which we can adapt to
 two free variables (referring to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement--relational-naturality-tuple"
plural "false"
caps "false"
noprefix "false"

\end_inset

) writing 
\begin_inset Formula $g\triangleq g(h,p)$
\end_inset

 as:
\begin_inset Formula 
\[
\forall(p_{1}^{:P^{A}},p_{2}^{:P^{B}},h_{1}^{:H^{A}},h_{2}^{:H^{B}}).\,\text{ if }(p_{1},p_{2})\in r^{\updownarrow P}\text{ and }(h_{1},h_{2})\in r^{\updownarrow H}\text{ then }(g(h_{1},p_{1}),g(h_{2},p_{2}))\in r^{\updownarrow G}\quad.
\]

\end_inset

We need to show that the relational naturality law of 
\begin_inset Formula $t$
\end_inset

 holds.
 That law involves the lifting 
\begin_inset Formula $r^{\updownarrow Q}$
\end_inset

, where 
\begin_inset Formula $Q^{A}\triangleq P^{A}\rightarrow G^{A}$
\end_inset

 is the type of 
\begin_inset Formula $t$
\end_inset

.
 Since it is a function type, we need to use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(e) to define 
\begin_inset Formula $r^{\updownarrow Q}$
\end_inset

:
\begin_inset Formula 
\[
(u^{:P^{A}\rightarrow G^{A}},v^{:P^{B}\rightarrow G^{B}})\in r^{\updownarrow Q}\text{ means: if }(p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in r^{\updownarrow P}\text{ then }(u(p_{1}),v(p_{2}))\in r^{\updownarrow G}\quad.
\]

\end_inset

The law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $t$
\end_inset

 is then rewritten as
\begin_inset Formula 
\[
\forall(h_{1}^{:H^{A}},h_{2}^{:H^{B}}).\,\text{ if }(h_{1},h_{2})\in r^{\updownarrow H}\text{ then if }(p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in r^{\updownarrow P}\text{ then }(g(h_{1},p_{1}),g(h_{2},p_{2}))\in r^{\updownarrow G}\quad.
\]

\end_inset

This is equivalent to the inductive assumption for 
\begin_inset Formula $g$
\end_inset

, which proves the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Use function
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t(h)\triangleq g(p)$
\end_inset

 where 
\begin_inset Formula $g^{:P^{A}\rightarrow Q^{A}}$
\end_inset

 and 
\begin_inset Formula $p^{:P^{A}}$
\end_inset

 are some sub-expressions.
 Both 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

 contain 
\begin_inset Formula $h$
\end_inset

 as a bound variable, which we indicate more verbosely by writing 
\begin_inset Formula $g(h)$
\end_inset

 and 
\begin_inset Formula $p(h)$
\end_inset

.
 The inductive assumption is that the relational naturality law already
 holds for both 
\begin_inset Formula $g(h)$
\end_inset

 and 
\begin_inset Formula $p(h)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then if }(p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in r^{\updownarrow P}\text{ then }(g(h_{1})(p_{1}),g(h_{2})(p_{2}))\in r^{\updownarrow Q}\quad,\\
 & \text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(p_{1}(h_{1}),p_{2}(h_{2}))\in r^{\updownarrow P}\quad.
\end{align*}

\end_inset

Substituting the condition 
\begin_inset Formula $(p_{1}(h_{1}),p_{2}(h_{2}))\in r^{\updownarrow P}$
\end_inset

 into the first line, we get:
\begin_inset Formula 
\[
\text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(g(h_{1})(p_{1}(h_{1})),g(h_{2})(p_{2}(h_{2})))=(t(h_{1}),t(h_{2}))\in r^{\updownarrow Q}\quad.
\]

\end_inset

This is exactly the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $t$
\end_inset

 because 
\begin_inset Formula $t(h)=g(h)(p(h))$
\end_inset

.
\end_layout

\begin_layout Paragraph
Create tuple
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t(h)\triangleq k^{:K^{A}}\times l^{:L^{A}}$
\end_inset

, where the sub-expressions 
\begin_inset Formula $k(h)$
\end_inset

 and 
\begin_inset Formula $l(h)$
\end_inset

 contain the bound variable 
\begin_inset Formula $h^{:H^{A}}$
\end_inset

.
 We have 
\begin_inset Formula $Q^{A}\triangleq K^{A}\times L^{A}$
\end_inset

, so we use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c) for the lifting 
\begin_inset Formula $r^{\updownarrow Q}$
\end_inset

:
\begin_inset Formula 
\[
(q_{1}^{:Q^{A}},q_{2}^{:Q^{B}})\in r^{\updownarrow Q}\text{ means }(q_{1}\triangleright\pi_{1},q_{2}\triangleright\pi_{1})\in r^{\updownarrow K}\text{ and }(q_{1}\triangleright\pi_{2},q_{2}\triangleright\pi_{2})\in r^{\updownarrow L}\quad.
\]

\end_inset

The relational naturality laws of 
\begin_inset Formula $k(h)$
\end_inset

 and 
\begin_inset Formula $l(h)$
\end_inset

 are written as
\begin_inset Formula 
\begin{align*}
 & \text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(k^{A}(h_{1}),k^{B}(h_{2}))\in r^{\updownarrow K}\quad,\\
 & \text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(l^{A}(h_{1}),l^{B}(h_{2}))\in r^{\updownarrow L}\quad.
\end{align*}

\end_inset

It remains to define 
\begin_inset Formula $q_{1}\triangleq k^{A}(h_{1})\times l^{A}(h_{1})$
\end_inset

 and 
\begin_inset Formula $q_{2}\triangleq k^{B}(h_{2})\times l^{B}(h_{2})$
\end_inset

 to verify the law of 
\begin_inset Formula $t(h)$
\end_inset

:
\begin_inset Formula 
\[
\text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(t^{A}(h_{1}),t^{B}(h_{2}))\in r^{\updownarrow Q}\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
Use tuple
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t(h)\triangleq\pi_{1}(g)$
\end_inset

 where 
\begin_inset Formula $g^{:Q^{A}\times L^{A}}$
\end_inset

 is a sub-expression that contains the bound variable 
\begin_inset Formula $h^{:H^{A}}$
\end_inset

.
 We need to prove that 
\begin_inset Formula $t(h)$
\end_inset

 satisfies the relational naturality law if 
\begin_inset Formula $g(h)$
\end_inset

 does.
\end_layout

\begin_layout Standard
The relational naturality law of 
\begin_inset Formula $g(h)$
\end_inset

, which holds by the inductive assumption, is:
\begin_inset Formula 
\[
\text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(g^{A}(h_{1}),g^{B}(h_{2}))\in r^{\updownarrow(Q\times L)}\quad.
\]

\end_inset

By Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c) for the lifting 
\begin_inset Formula $r^{\updownarrow(Q\times L)}$
\end_inset

, we have:
\begin_inset Formula 
\[
(g^{A}(h_{1}),g^{B}(h_{2}))\in r^{\updownarrow(Q\times L)}\text{ means }\big(g^{A}(h_{1})\triangleright\pi_{1},g^{B}(h_{2})\triangleright\pi_{1}\big)\in r^{\updownarrow Q}\text{ and }\big(g^{A}(h_{1})\triangleright\pi_{2},g^{B}(h_{2})\triangleright\pi_{2}\big)\in r^{\updownarrow L}\quad.
\]

\end_inset

Taking the condition 
\begin_inset Formula $(g^{A}(h_{1})\triangleright\pi_{1},g^{B}(h_{2})\triangleright\pi_{1})\in r^{\updownarrow Q}$
\end_inset

 and ignoring the similar condition that involves 
\begin_inset Formula $r^{\updownarrow L}$
\end_inset

, we get the relational naturality law of 
\begin_inset Formula $\pi_{1}(g)$
\end_inset

:
\begin_inset Formula 
\[
\text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(g^{A}(h_{1})\triangleright\pi_{1},g^{B}(h_{2})\triangleright\pi_{1})\in r^{\updownarrow Q}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The proof for 
\begin_inset Formula $\pi_{2}(g)$
\end_inset

 is similar: we need to ignore the condition that involves 
\begin_inset Formula $r^{\updownarrow Q}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Create disjunction
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t(h)\triangleq g(h)+\bbnum 0$
\end_inset

 where 
\begin_inset Formula $Q^{A}\triangleq K^{A}+L^{A}$
\end_inset

 and 
\begin_inset Formula $g^{:K^{A}}$
\end_inset

 is a sub-expression that contains a bound variable 
\begin_inset Formula $h^{:H^{A}}$
\end_inset

.
 The inductive assumption is that 
\begin_inset Formula $g(h)$
\end_inset

 satisfies its relational naturality law:
\begin_inset Formula 
\[
\text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(g^{A}(h_{1}),g^{B}(h_{2}))\in r^{\updownarrow K}\quad.
\]

\end_inset

By Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(d) for the lifting 
\begin_inset Formula $r^{\updownarrow(K+L)}$
\end_inset

, we have:
\begin_inset Formula 
\[
(g^{A}(h_{1})+\bbnum 0,g^{B}(h_{2})+\bbnum 0)\in r^{\updownarrow(K+L)}\text{ means }(g^{A}(h_{1}),g^{B}(h_{2}))\in r^{\updownarrow K}\quad,
\]

\end_inset

because both values 
\begin_inset Formula $g(h_{1})+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $g(h_{2})+\bbnum 0$
\end_inset

 belong to the same part of the disjunction.
 It follows that the relational naturality law of 
\begin_inset Formula $t(h)$
\end_inset

 holds:
\begin_inset Formula 
\[
\text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ then }(t^{A}(h_{1}),t^{B}(h_{2}))\in r^{\updownarrow(K+L)}\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
Use disjunction
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t(h)\triangleq\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p(h)\\
L^{A} & q(h)
\end{array}\:$
\end_inset

 is a pattern-matching function.
 We assume that 
\begin_inset Formula $Q^{A}\triangleq K^{A}+L^{A}\rightarrow G^{A}$
\end_inset

 and that the sub-expressions 
\begin_inset Formula $p^{:K^{A}\rightarrow G^{A}}$
\end_inset

 and 
\begin_inset Formula $q^{:L^{A}\rightarrow G^{A}}$
\end_inset

 contain the bound variable 
\begin_inset Formula $h^{:H^{A}}$
\end_inset

.
 By the inductive assumption, the relational naturality law already holds
 for 
\begin_inset Formula $p(h)$
\end_inset

 and 
\begin_inset Formula $q(h)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ and }(k_{1}^{:K^{A}},k_{2}^{:K^{B}})\in r^{\updownarrow K}\text{ then }\big(p^{A}(h_{1})(k_{1}),p^{B}(h_{2})(k_{2})\big)\in r^{\updownarrow G}\quad,\\
 & \text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ and }(l_{1}^{:L^{A}},l_{2}^{:L^{B}})\in r^{\updownarrow L}\text{ then }\big(q^{A}(h_{1})(l_{1}),q^{B}(h_{2})(l_{2})\big)\in r^{\updownarrow G}\quad.
\end{align*}

\end_inset

To derive the specific form of the law for 
\begin_inset Formula $t(h)$
\end_inset

, we use Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(e) for the lifting 
\begin_inset Formula $r^{\updownarrow Q}$
\end_inset

:
\begin_inset Formula 
\[
\text{if }(h_{1}^{:H^{A}},h_{2}^{:H^{B}})\in r^{\updownarrow H}\text{ and }(x_{1}^{:K^{A}+L^{A}},x_{2}^{:K^{B}+L^{B}})\in r^{\updownarrow(K+L)}\text{ then }\big(t(h_{1})(x_{1}),t(h_{2})(x_{2})\big)\in r^{\updownarrow G}\quad.
\]

\end_inset

By Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-relational-lifting"
plural "false"
caps "false"
noprefix "false"

\end_inset

(d), the values 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 are in relation 
\begin_inset Formula $r^{\updownarrow(K+L)}$
\end_inset

 only if both 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 are in the same part of the disjunction (
\begin_inset Formula $K+L$
\end_inset

).
 We consider separately the case when they are in the left part or in the
 right part.
\end_layout

\begin_layout Standard
If both 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 in the left part, we can write 
\begin_inset Formula $x_{1}=k_{1}^{:K^{A}}+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $x_{2}=k_{2}^{:K^{B}}+\bbnum 0$
\end_inset

 with some 
\begin_inset Formula $k_{1}$
\end_inset

 and 
\begin_inset Formula $k_{2}$
\end_inset

.
 Then the condition 
\begin_inset Formula $(x_{1},x_{2})\in r^{\updownarrow(K+L)}$
\end_inset

 is equivalent to 
\begin_inset Formula $(k_{1},k_{2})\in r^{\updownarrow K}$
\end_inset

, while the values 
\begin_inset Formula $t(h_{1})(x_{1})$
\end_inset

 and 
\begin_inset Formula $t(h_{2})(x_{2})$
\end_inset

 are expressed as
\begin_inset Formula 
\[
t(h_{1})(x_{1})=(k_{1}+\bbnum 0)\triangleright\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p(h)\\
L^{A} & q(h)
\end{array}\,=p(h_{1})(k_{1})\quad,\quad\quad t(h_{2})(x_{2})=(k_{2}+\bbnum 0)\triangleright\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p(h)\\
L^{A} & q(h)
\end{array}\,=p(h_{2})(k_{2})\quad.
\]

\end_inset

So, the conclusion of the relational naturality law of 
\begin_inset Formula $t(h)$
\end_inset

 becomes:
\begin_inset Formula 
\[
\big(t(h_{1})(x_{1}),t(h_{2})(x_{2})\big)=\big(p^{A}(h_{1})(k_{1}),p^{B}(h_{2})(k_{2})\big)\in r^{\updownarrow G}\quad.
\]

\end_inset

This conclusion holds due to the relational naturality law of 
\begin_inset Formula $p(h)$
\end_inset

.
\end_layout

\begin_layout Standard
A similar argument proves the law for the case when both 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 in the right part.
 We write 
\begin_inset Formula $x_{1}=\bbnum 0+l_{1}^{:L^{A}}$
\end_inset

 and 
\begin_inset Formula $x_{2}=\bbnum 0+l_{2}^{:L^{B}}$
\end_inset

 and reduce the relational naturality law of 
\begin_inset Formula $t(h)$
\end_inset

 to that of 
\begin_inset Formula $q(h)$
\end_inset

, which holds by the inductive assumption.
\end_layout

\begin_layout Paragraph
Recursive call
\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $t\triangleq g$
\end_inset

 where 
\begin_inset Formula $g$
\end_inset

 is a recursive call to a function (possibly defined outside that expression).
 When proving a law of a recursively defined function, we may assume that
 the law holds for recursive calls to that function.
 So, the inductive assumption says that 
\begin_inset Formula $g$
\end_inset

 is some expression for which the relational naturality law already holds.
 It then holds for 
\begin_inset Formula $t$
\end_inset

 since 
\begin_inset Formula $t=g$
\end_inset

.
\end_layout

\begin_layout Standard
This completes the proof of the relational parametricity theorem.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
This formulation of parametricity is the most general (and the most complicated).
 In practice, naturality laws of fully parametric functions can be derived
 using only the dinaturality property.
\end_layout

\begin_layout Subsection
Strong dinaturality: definition and general properties
\begin_inset CommandInset label
LatexCommand label
name "subsec:Strong-dinaturality.-General-properties"

\end_inset


\end_layout

\begin_layout Standard
While all fully parametric functions satisfy the dinaturality law, the relationa
l parametricity theorem gives a stronger property for a certain subset of
 functions.
 That property is called the 
\begin_inset Quotes eld
\end_inset

strong dinaturality
\begin_inset Quotes erd
\end_inset

 law.
\begin_inset Foot
status open

\begin_layout Plain Layout
In this book, strong dinaturality is only used to prove Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-Church-encoding-recursive-type-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinaturality-property-of-fix"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A function 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 is 
\series bold
strongly dinatural
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
strong dinaturality law
\end_layout

\end_inset

if for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $x^{:P^{A,A}}$
\end_inset

, and 
\begin_inset Formula $y^{:P^{B,B}}$
\end_inset

 the following property holds:
\begin_inset Formula 
\begin{equation}
\text{when}\quad x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright t^{A}\triangleright f^{\uparrow Q^{A,\bullet}}=y\triangleright t^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad.\label{eq:strong-dinaturality-law}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "32col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -250baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{1.0pc}P^{A,A}\ar[rd]\sb(0.35){f^{\uparrow P^{A,\bullet}}\!\!\!}\ar[rr]\sp(0.5){t^{A}} &  & Q^{A,A}\ar[rd]\sp(0.5){f^{\uparrow Q^{A,\bullet}}}\\
 & P^{A,B} & (\Rightarrow) & Q^{A,B}\\
P^{B,B}\ar[ru]\sp(0.5){f^{\downarrow P^{\bullet,B}}\!\!\!}\ar[rr]\sp(0.5){t^{B}} &  & Q^{B,B}\ar[ru]\sb(0.65){\!\!\!f^{\downarrow Q^{\bullet,B}}}
}
\]

\end_inset


\begin_inset VSpace -200baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The strong dinaturality law has an unusual form: it is an equation (the
 
\begin_inset Quotes eld
\end_inset

conclusion
\begin_inset Quotes erd
\end_inset

) that is required to hold only when some values satisfy another equation
 (the law's 
\begin_inset Quotes eld
\end_inset

precondition
\begin_inset Quotes erd
\end_inset

).
 The type diagram for that law, shown at left, is a truncated form of the
 type diagram for Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The implication symbol (
\begin_inset Formula $\Rightarrow$
\end_inset

) means that the left part of the diagram is an assumption required by the
 rest of the diagram.
 
\end_layout

\begin_layout Standard
Strongly dinatural transformations are always dinatural:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-strong-dinaturality-entails-dinaturality"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinaturality-entails-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Any function 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 satisfying Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will also satisfy Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 A natural transformation 
\begin_inset Formula $t^{A}:F^{A}\rightarrow G^{A}$
\end_inset

 (where 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are both functors or both contrafunctors) is strongly dinatural.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 A natural transformation 
\begin_inset Formula $t^{X,Y}:P^{X,Y}\rightarrow Q^{X,Y}$
\end_inset

 between profunctors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 gives a strongly dinatural transformation 
\begin_inset Formula $t^{A,A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 when we set 
\begin_inset Formula $X\triangleq A$
\end_inset

 and 
\begin_inset Formula $Y\triangleq A$
\end_inset

 in 
\begin_inset Formula $t^{X,Y}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is an equality of functions of type 
\begin_inset Formula $P^{B,A}\rightarrow Q^{A,B}$
\end_inset

.
 We will now show that those functions will give equal results when applied
 to an arbitrary value 
\begin_inset Formula $p:P^{B,A}$
\end_inset

.
 Choose 
\begin_inset Formula $x\triangleq p\triangleright f^{\downarrow P^{\bullet,A}}$
\end_inset

 and 
\begin_inset Formula $y\triangleq p\triangleright f^{\uparrow P^{B,\bullet}}$
\end_inset

.
 The precondition in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is satisfied with these 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(y\triangleright f^{\downarrow P^{\bullet,B}}):\quad & x\triangleright f^{\uparrow P^{A,\bullet}}=p\triangleright f^{\downarrow P^{\bullet,A}}\triangleright f^{\uparrow P^{A,\bullet}}\\
\text{profunctor commutativity law of }P:\quad & =p\triangleright f^{\uparrow P^{B,\bullet}}\triangleright f^{\downarrow P^{\bullet,B}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad.
\end{align*}

\end_inset

So, we can use the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

)'s conclusion and obtain Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) applied to 
\begin_inset Formula $p$
\end_inset

, completing the proof:
\begin_inset Formula 
\begin{align*}
 & \gunderline x\triangleright t^{A}\triangleright f^{\uparrow Q^{A,\bullet}}\overset{!}{=}\gunderline y\triangleright t^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad,\\
\text{definitions of }x,y:\quad & p\triangleright f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{!}{=}p\triangleright f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Consider the case where 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are both functors.
 We may view 
\begin_inset Formula $t:F^{A}\rightarrow G^{A}$
\end_inset

 as a function with the type signature 
\begin_inset Formula $t:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 if we define the profunctors 
\begin_inset Formula $P^{X,Y}\triangleq F^{Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}\triangleq G^{Y}$
\end_inset

.
 Since 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 ignore the type parameter 
\begin_inset Formula $X$
\end_inset

, we have the liftings 
\begin_inset Formula $f^{\uparrow P}=f^{\uparrow F}$
\end_inset

, 
\begin_inset Formula $f^{\downarrow P}=\text{id}$
\end_inset

, 
\begin_inset Formula $f^{\uparrow Q}=f^{\uparrow G}$
\end_inset

, and 
\begin_inset Formula $f^{\downarrow Q}=\text{id}$
\end_inset

.
 The strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

 is then written as
\begin_inset Formula 
\[
\text{when}\quad x^{:F^{A}}\triangleright f^{\uparrow F}=y^{:F^{B}}\quad\text{ then}\quad x\triangleright t\triangleright f^{\uparrow G}\overset{?}{=}y\triangleright t\quad.
\]

\end_inset

This is equivalent to 
\begin_inset Formula $x\triangleright t\bef f^{\uparrow G}\overset{?}{=}x\triangleright f^{\uparrow F}\bef t$
\end_inset

, which holds by the assumed naturality of 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard
A similar proof works for the case where 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are both contrafunctors.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 A natural transformation 
\begin_inset Formula $t^{X,Y}:P^{X,Y}\rightarrow Q^{X,Y}$
\end_inset

 needs to satisfy naturality laws separately with respect to the type parameters
 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

: for all 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow P^{X,\bullet}}\bef t^{X,B}=t^{X,A}\bef f^{\uparrow Q^{X,\bullet}}\quad,\quad\quad f^{\downarrow P^{\bullet,Y}}\bef t^{A,Y}=t^{B,Y}\bef f^{\downarrow Q^{\bullet,Y}}\quad.
\]

\end_inset

The strong naturality law of 
\begin_inset Formula $t^{A,A}$
\end_inset

 says that
\begin_inset Formula 
\[
\text{when}\quad x^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=y^{:P^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright t^{A,A}\bef f^{\uparrow Q^{A,\bullet}}\overset{?}{=}y\triangleright t^{B,B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\]

\end_inset

Using the precondition of that law and the naturality laws of 
\begin_inset Formula $t^{X,Y}$
\end_inset

, rewrite the conclusion of that law:
\begin_inset Formula 
\begin{align*}
 & x\triangleright\gunderline{t^{A,A}\bef f^{\uparrow Q^{A,\bullet}}}=\gunderline{x\triangleright f^{\uparrow P^{A,\bullet}}}\bef t^{A,B}=y\triangleright f^{\downarrow P^{\bullet,B}}\bef t^{A,B}\\
 & \overset{?}{=}y\triangleright\gunderline{t^{B,B}\bef f^{\downarrow Q^{\bullet,B}}}=y\triangleright f^{\downarrow P^{\bullet,B}}\bef t^{A,B}\quad.
\end{align*}

\end_inset

The two sides of the strong dinaturality law are now equal.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Strongly dinatural transformations compose, just as natural transformations
 do.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-natural-transformations-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-natural-transformations-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any functors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 and natural transformations 
\begin_inset Formula $u:P^{A}\rightarrow Q^{A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A}\rightarrow R^{A}$
\end_inset

, the composition 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 is a natural transformation (of type 
\begin_inset Formula $P^{A}\rightarrow R^{A}$
\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The naturality laws for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are written with an arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 as
\begin_inset Formula 
\[
f^{\uparrow P}\bef u=u\bef f^{\uparrow Q}\quad,\quad\quad f^{\uparrow Q}\bef v=v\bef f^{\uparrow R}\quad.
\]

\end_inset

The required naturality law for 
\begin_inset Formula $t$
\end_inset

 is derived by a direct calculation:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "30col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{2.0pc}P^{A}\ar[d]\sp(0.45){f^{\uparrow P}}\ar[r]\sp(0.5){u} & Q^{A}\ar[d]\sp(0.45){f^{\uparrow Q}}\ar[r]\sp(0.5){v} & R^{A}\ar[d]\sp(0.45){f^{\uparrow R}}\\
P^{B}\ar[r]\sp(0.5){u} & Q^{B}\ar[r]\sp(0.5){v} & R^{B}
}
\]

\end_inset


\begin_inset VSpace -280baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset Formula 
\begin{align*}
\text{expect to equal }t\bef f^{\uparrow R}:\quad & f^{\uparrow P}\bef\gunderline t=\gunderline{f^{\uparrow P}\bef u}\bef v\\
\text{naturality of }u:\quad & =u\bef\gunderline{f^{\uparrow Q}\bef v}\\
\text{naturality of }v:\quad & =\gunderline{u\bef v}\bef f^{\uparrow R}=t\bef f^{\uparrow R}\quad.
\end{align*}

\end_inset

This calculation shows that the above type diagram commutes.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
While a direct proof fails for the composition of dinatural transformations
 (as we have seen in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Composition-properties-of-dinatural"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the additional requirement of 
\emph on
strong
\emph default
 dinaturality makes the composition property straightforward to prove:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-strongly-dinatural-transformation-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strongly-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any profunctors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 and any two strongly dinatural transformations 
\begin_inset Formula $u:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A,A}\rightarrow R^{A,A}$
\end_inset

, the transformation 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

 is also strongly dinatural.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We assume that the strong dinaturality law holds for 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

: given 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
 & \text{for }x^{:P^{A,A}}\text{ and }y^{:P^{B,B}}:\quad\text{ when}\quad x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright u^{A}\triangleright f^{\uparrow Q^{A,\bullet}}=y\triangleright u^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad,\\
 & \text{for }m^{:Q^{A,A}}\text{ and }n^{:Q^{B,B}}:\quad\text{ when}\quad m\triangleright f^{\uparrow Q^{A,\bullet}}=n\triangleright f^{\downarrow Q^{\bullet,B}}\quad\text{ then}\quad m\triangleright v^{A}\triangleright f^{\uparrow R^{A,\bullet}}=n\triangleright v^{B}\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\end{align*}

\end_inset

We need to show that the strong naturality law holds for 
\begin_inset Formula $t\triangleq u\bef v$
\end_inset

: 
\begin_inset Formula 
\[
\text{when}\quad x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright u^{A}\triangleright v^{A}\triangleright f^{\uparrow R^{A,\bullet}}\overset{?}{=}y\triangleright u^{B}\triangleright v^{B}\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

For any 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 satisfying the above assumption, let 
\begin_inset Formula $m\triangleq x\triangleright u^{A}$
\end_inset

 and 
\begin_inset Formula $n\triangleq y\triangleright u^{B}$
\end_inset

.
 Then the precondition of the strong dinaturality law of 
\begin_inset Formula $v$
\end_inset

 is fulfilled due to the strong dinaturality law of 
\begin_inset Formula $u$
\end_inset

:
\begin_inset Formula 
\[
m\triangleright f^{\uparrow Q^{A,\bullet}}=x\triangleright u^{A}\triangleright f^{\uparrow Q^{A,\bullet}}=y\triangleright u^{B}\triangleright f^{\downarrow Q^{\bullet,B}}=n\triangleright f^{\downarrow Q^{\bullet,B}}\quad.
\]

\end_inset

So, we can use the conclusion of the strong dinaturality law of 
\begin_inset Formula $v$
\end_inset

 with these 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

:
\begin_inset Formula 
\[
x\triangleright u^{A}\triangleright v^{A}\triangleright f^{\uparrow R^{A,\bullet}}=m\triangleright v^{A}\triangleright f^{\uparrow R^{A,\bullet}}\overset{!}{=}n\triangleright v^{B}\triangleright f^{\downarrow R^{\bullet,B}}=y\triangleright u^{B}\triangleright v^{B}\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\]

\end_inset

This is the same as the conclusion of the strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
It turns out that the type parameters of a natural transformation can be
 substituted by some profunctors to obtain a strongly dinatural transformation.
 Two versions of this result are proved next.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-strong-dinatural-substitute-functor-in-natural"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $u^{A}:G^{A}\rightarrow H^{A}$
\end_inset

 is a natural transformation, and suppose 
\begin_inset Formula $P^{X,Y}$
\end_inset

 is some fully parametric profunctor.
 Define the function 
\begin_inset Formula $t$
\end_inset

 by
\begin_inset Formula 
\[
t^{A}:G^{P^{A,A}}\rightarrow H^{P^{A,A}}\quad,\quad\quad t^{A}\triangleq u^{P^{A,A}}\quad,
\]

\end_inset

i.e., as the unmodified code of the function 
\begin_inset Formula $u^{A}$
\end_inset

 with a substituted type parameter (
\begin_inset Formula $P^{A,A}$
\end_inset

 instead of 
\begin_inset Formula $A$
\end_inset

).
 Then 
\begin_inset Formula $t$
\end_inset

 is a strongly dinatural transformation between profunctors 
\begin_inset Formula $G^{P^{A,A}}$
\end_inset

 and 
\begin_inset Formula $H^{P^{A,A}}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
By assumption, the naturality law of 
\begin_inset Formula $u$
\end_inset

 holds for any 
\begin_inset Formula $k^{:R\rightarrow S}$
\end_inset

 and says that
\begin_inset Formula 
\[
k^{\uparrow G}\bef u^{S}=u^{R}\bef k^{\uparrow H}\quad.
\]

\end_inset

The strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

 says that for arbitrary 
\begin_inset Formula $x^{:G^{P^{A,A}}}$
\end_inset

, 
\begin_inset Formula $y^{:G^{P^{B,B}}}$
\end_inset

, and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
\text{ assuming}\quad x\triangleright f^{\uparrow P^{A,\bullet}\uparrow G}=y\triangleright f^{\downarrow P^{\bullet,B}\uparrow G}\quad\text{ then}\quad x\triangleright t^{A}\triangleright f^{\uparrow P^{A,\bullet}\uparrow H}\overset{?}{=}y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H}\quad.
\]

\end_inset

Substitute 
\begin_inset Formula $t^{A}\triangleq u^{P^{A,A}}$
\end_inset

 into the above equation and use the naturality law of 
\begin_inset Formula $u$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H}):\quad & x\triangleright\gunderline{t^{A}}\triangleright f^{\uparrow P^{A,\bullet}\uparrow H}=x\triangleright\gunderline{u^{P^{A,A}}\bef f^{\uparrow P^{A,\bullet}\uparrow H}}\\
\text{naturality law of }u\text{ with }R\triangleq P^{A,A}\text{ and }S\triangleq P^{A,B}:\quad & =\gunderline{x\triangleright f^{\uparrow P^{A,\bullet}\uparrow G}}\bef u^{P^{A,B}}\\
\text{assumption }(x\triangleright f^{\uparrow\uparrow}=y\triangleright f^{\downarrow\uparrow}):\quad & =y\triangleright\gunderline{f^{\downarrow P^{\bullet,B}\uparrow G}\bef u^{P^{A,B}}}\\
\text{naturality law of }u\text{ with }R\triangleq P^{B,B}\text{ and }S\triangleq P^{A,B}:\quad & =y\triangleright u^{P^{B,B}}\bef f^{\downarrow P^{\bullet,B}\uparrow H}=y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-strong-dinatural-substitute-profunctor-in-natural"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinatural-substitute-profunctor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume that 
\begin_inset Formula $G^{X,Y}$
\end_inset

 and 
\begin_inset Formula $H^{X,Y}$
\end_inset

 are bifunctors, 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 are profunctors, and 
\begin_inset Formula $u^{A,B}:G^{A,B}\rightarrow H^{A,B}$
\end_inset

 is a natural transformation (separately with respect to the type parameters
 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

).
 Assume that 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 satisfy their commutativity laws, and define the function 
\begin_inset Formula $t$
\end_inset

 by
\begin_inset Formula 
\[
t^{A}:G^{P^{A,A},Q^{A,A}}\rightarrow H^{P^{A,A},Q^{A,A}}\quad,\quad\quad t\triangleq u^{P^{A,A},Q^{A,A}}\quad,
\]

\end_inset

i.e., as the unmodified code of 
\begin_inset Formula $u^{A,B}$
\end_inset

 with substituted type parameters (
\begin_inset Formula $P^{A,A}$
\end_inset

 and 
\begin_inset Formula $Q^{A,A}$
\end_inset

 instead of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

).
 Then 
\begin_inset Formula $t$
\end_inset

 is a strongly dinatural transformation between profunctors 
\begin_inset Formula $G^{P^{A,A},Q^{A,A}}$
\end_inset

 and 
\begin_inset Formula $H^{P^{A,A},Q^{A,A}}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The assumed naturality law of 
\begin_inset Formula $u$
\end_inset

 holds separately with respect to each type parameter:
\begin_inset Formula 
\[
f^{\uparrow G^{\bullet,B}}\bef u^{B,B}=u^{A,B}\bef f^{\uparrow H^{\bullet,B}}\quad,\quad\quad f^{\uparrow G^{A,\bullet}}\bef u^{A,B}=u^{A,A}\bef f^{\uparrow H^{A,\bullet}}\quad.
\]

\end_inset

To formulate the strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

, we need to start with arbitrary 
\begin_inset Formula $x^{:G^{P^{A,A}}}$
\end_inset

, 
\begin_inset Formula $y^{:G^{P^{B,B}}}$
\end_inset

, and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and lift 
\begin_inset Formula $f$
\end_inset

 to functors such as 
\begin_inset Formula $G^{P^{A,\bullet},Q^{A,\bullet}}$
\end_inset

.
 Since, by assumption, 
\begin_inset Formula $G$
\end_inset

 obeys the commutativity law, we may lift 
\begin_inset Formula $f$
\end_inset

 to 
\begin_inset Formula $G^{P^{A,\bullet},Q^{A,\bullet}}$
\end_inset

 via a composition of liftings with respect to 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 in any order, for example 
\begin_inset Formula $x\triangleright f^{\uparrow P^{A,\bullet}\uparrow G^{\bullet,Q}}\triangleright f^{\uparrow Q^{A,\bullet}\uparrow G^{P,\bullet}}$
\end_inset

.
 We handle the lifting to the contrafunctor 
\begin_inset Formula $G^{P^{\bullet,A},Q^{\bullet,A}}$
\end_inset

 similarly.
 So, let us write the strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

: 
\begin_inset Formula 
\begin{align*}
 & \text{when}\quad x\triangleright f^{\uparrow P^{A,\bullet}\uparrow G^{\bullet,Q}}\triangleright f^{\uparrow Q^{A,\bullet}\uparrow G^{P,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}\uparrow G^{\bullet,Q}}\triangleright f^{\downarrow Q^{\bullet,B}\uparrow G^{P,\bullet}}\\
 & \quad\text{then}\quad x\triangleright t^{A}\triangleright f^{\uparrow P^{A,\bullet}\uparrow H^{\bullet,Q}}\triangleright f^{\uparrow Q^{A,\bullet}\uparrow H^{P,\bullet}}\overset{?}{=}y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H^{\bullet,Q}}\triangleright f^{\downarrow Q^{\bullet,B}\uparrow H^{P,\bullet}}\quad.
\end{align*}

\end_inset

Substitute 
\begin_inset Formula $t\triangleq u^{P^{A,A},Q^{A,A}}$
\end_inset

 into the above equation and use the naturality laws of 
\begin_inset Formula $u$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & x\triangleright t^{A}\triangleright f^{\uparrow P^{A,\bullet}\uparrow H^{\bullet,Q}}\triangleright f^{\uparrow Q^{A,\bullet}\uparrow H^{P,\bullet}}=x\triangleright\gunderline{u\bef f^{\uparrow P\uparrow H}\bef}f^{\uparrow Q\uparrow H}=x\triangleright f^{\uparrow P\uparrow G}\bef\gunderline{u\bef f^{\uparrow Q\uparrow H}}=\gunderline{x\triangleright f^{\uparrow P\uparrow G}\triangleright f^{\uparrow Q\uparrow G}}\bef u\\
 & =y\triangleright f^{\downarrow P\uparrow G}\bef\gunderline{f^{\downarrow Q\uparrow G}\bef u}=y\triangleright\gunderline{f^{\downarrow P\uparrow G}\bef u}\bef f^{\downarrow Q\uparrow H}=y\triangleright u\bef f^{\downarrow P\uparrow H}\bef f^{\downarrow Q\uparrow H}\\
 & =y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H^{\bullet,Q}}\triangleright f^{\downarrow Q^{\bullet,B}\uparrow H^{P,\bullet}}\quad.
\end{align*}

\end_inset

Here, we omitted the full type annotations for brevity, since we already
 checked that types match.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-pair-product-coproduct-strongly-dinatural"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-coproduct-strongly-dinatural"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given two strongly dinatural transformations 
\begin_inset Formula $u^{:P^{A,A}\rightarrow R^{A,A}}$
\end_inset

 and 
\begin_inset Formula $v^{:Q^{A,A}\rightarrow S^{A,A}}$
\end_inset

:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The pair product 
\begin_inset Formula $t\triangleq u\boxtimes v$
\end_inset

 (of type 
\begin_inset Formula $P^{A,A}\times Q^{A,A}\rightarrow R^{A,A}\times S^{A,A}$
\end_inset

) is strongly dinatural.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The pair co-product
\begin_inset Index idx
status open

\begin_layout Plain Layout
pair co-product of functions
\end_layout

\end_inset

 
\begin_inset Formula $t\triangleq u\boxplus v$
\end_inset

 (of type 
\begin_inset Formula $P^{A,A}+Q^{A,A}\rightarrow R^{A,A}+S^{A,A}$
\end_inset

) is strongly dinatural.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The strong dinaturality law of 
\begin_inset Formula $t\triangleq u\boxtimes v$
\end_inset

 says that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{when}\quad(x_{1}^{:P^{A,A}}\times y_{1}^{:Q^{A,A}})\triangleright f^{\uparrow(P^{A,\bullet}\times Q^{A,\bullet})}=(x_{2}^{:P^{B,B}}\times y_{2}^{:Q^{B,B}})\triangleright f^{\downarrow(P^{\bullet,B}\times Q^{\bullet,B})}\\
 & \quad\text{then}\quad(x_{1}\times y_{1})\triangleright t\triangleright f^{\uparrow(R^{A,\bullet}\times S^{A,\bullet})}=(x_{2}\times y_{2})\triangleright t\triangleright f^{\downarrow(R^{\bullet,B}\times S^{\bullet,B})}\quad.
\end{align*}

\end_inset

Substituting the definitions of liftings to 
\begin_inset Formula $P\times Q$
\end_inset

 and 
\begin_inset Formula $R\times S$
\end_inset

, as well as the definition 
\begin_inset Formula $t\triangleq u\boxtimes v$
\end_inset

, we get:
\begin_inset Formula 
\begin{align*}
 & \text{when}\quad(x_{1}\triangleright f^{\uparrow P^{A,\bullet}})\times(y_{1}\triangleright f^{\uparrow Q^{A,\bullet}})=(x_{2}\triangleright f^{\downarrow P^{\bullet,B}})\times(y_{2}\triangleright f^{\downarrow Q^{\bullet,B}})\\
 & \quad\text{then}\quad(x_{1}\triangleright u\bef f^{\uparrow R^{A,\bullet}})\times(y_{1}\triangleright v\bef f^{\uparrow S^{A,\bullet}})=(x_{2}\triangleright u\bef f^{\downarrow R^{\bullet,B}})\times(y_{2}\triangleright v\bef f^{\downarrow S^{\bullet,B}})\quad.
\end{align*}

\end_inset

An equality between pairs is the same as two equalities for the elements
 of the pairs.
 So, the strong naturality law of 
\begin_inset Formula $t$
\end_inset

 is the same as the following statement:
\begin_inset Formula 
\begin{align*}
 & \text{when}\quad x_{1}^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=x_{1}^{:P^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ and }\quad y_{1}^{:Q^{A,A}}\triangleright f^{\uparrow Q^{A,\bullet}}=y_{2}^{:Q^{B,B}}\triangleright f^{\downarrow Q^{\bullet,B}}\\
 & \quad\text{then}\quad x_{1}\triangleright u\bef f^{\uparrow R^{A,\bullet}}=x_{2}\triangleright u\bef f^{\downarrow R^{\bullet,B}}\quad\text{ and }\quad y_{1}\triangleright v\bef f^{\uparrow S^{A,\bullet}}=y_{2}\triangleright v\bef f^{\downarrow S^{\bullet,B}}\quad.
\end{align*}

\end_inset

These are exactly the preconditions and the conclusions of the strong naturality
 laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The strong dinaturality law of 
\begin_inset Formula $t\triangleq u\boxplus v$
\end_inset

 says that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{when}\quad x^{:P^{A,A}+Q^{A,A}}\triangleright f^{\uparrow(P^{A,\bullet}+Q^{A,\bullet})}=y^{:P^{B,B}+Q^{B,B}}\triangleright f^{\downarrow(P^{\bullet,B}+Q^{\bullet,B})}\\
 & \quad\text{then}\quad x\triangleright t\triangleright f^{\uparrow(R^{A,\bullet}+S^{A,\bullet})}=y\triangleright t\triangleright f^{\downarrow(R^{\bullet,B}+S^{\bullet,B})}\quad.
\end{align*}

\end_inset

Substituting the definitions of liftings to 
\begin_inset Formula $P+Q$
\end_inset

 and 
\begin_inset Formula $R+S$
\end_inset

, as well as the definition 
\begin_inset Formula $t\triangleq u\boxplus v$
\end_inset

, we get:
\begin_inset Formula 
\begin{align*}
 & \text{when}\quad x^{:P^{A,A}+Q^{A,A}}\triangleright\,\begin{array}{|c||cc|}
 & P^{A,B} & Q^{A,B}\\
\hline P^{A,A} & f^{\uparrow P^{A,\bullet}} & \bbnum 0\\
Q^{A,A} & \bbnum 0 & f^{\uparrow Q^{A,\bullet}}
\end{array}\,=y^{:P^{B,B}+Q^{B,B}}\triangleright\,\begin{array}{|c||cc|}
 & P^{A,B} & Q^{A,B}\\
\hline P^{B,B} & f^{\downarrow P^{\bullet,B}} & \bbnum 0\\
Q^{B,B} & \bbnum 0 & f^{\downarrow Q^{\bullet,B}}
\end{array}\,\quad\text{ then}\\
 & x\triangleright\,\begin{array}{|c||cc|}
 & R^{A,A} & S^{A,A}\\
\hline P^{A,A} & u & \bbnum 0\\
Q^{A,A} & \bbnum 0 & v
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline R^{A,A} & f^{\uparrow R^{A,\bullet}} & \bbnum 0\\
S^{A,A} & \bbnum 0 & f^{\uparrow S^{A,\bullet}}
\end{array}\,=y\triangleright\,\begin{array}{|c||cc|}
 & R^{B,B} & S^{B,B}\\
\hline P^{B,B} & u & \bbnum 0\\
Q^{B,B} & \bbnum 0 & v
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline R^{B,B} & f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
S^{B,B} & \bbnum 0 & f^{\downarrow S^{\bullet,B}}
\end{array}
\end{align*}

\end_inset

or, simplifying the matrix composition:
\begin_inset Formula 
\[
x\triangleright\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline P^{A,A} & u\bef f^{\uparrow R^{A,\bullet}} & \bbnum 0\\
Q^{A,A} & \bbnum 0 & v\bef f^{\uparrow S^{A,\bullet}}
\end{array}\,=y\triangleright\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline P^{B,B} & u\bef f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
Q^{B,B} & \bbnum 0 & v\bef f^{\downarrow S^{\bullet,B}}
\end{array}\quad.
\]

\end_inset

The precondition of the strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

 is an equality between values of disjunctive type 
\begin_inset Formula $P^{A,B}+Q^{A,B}$
\end_inset

 computed by applying some diagonal code matrices to 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

.
 So, the precondition can hold only if both 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are in the same part of the disjunction.
 We must have either 
\begin_inset Formula $x=p_{1}^{:P^{A,A}}+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $y=p_{2}^{:P^{B,B}}+\bbnum 0$
\end_inset

, or 
\begin_inset Formula $x=\bbnum 0+q_{1}^{:Q^{A,A}}$
\end_inset

 and 
\begin_inset Formula $y=\bbnum 0+q_{2}^{:Q^{B,B}}$
\end_inset

.
 In the first case, we can simplify the strong dinaturality law of 
\begin_inset Formula $t$
\end_inset

 to
\begin_inset Formula 
\[
\text{when }\quad p_{1}^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=p_{2}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then }\quad p_{1}\triangleright u\bef f^{\uparrow R^{A,\bullet}}=p_{2}\triangleright u\bef f^{\downarrow R^{\bullet,B}}\quad,
\]

\end_inset

and in the second case, to 
\begin_inset Formula 
\[
\text{when }\quad q_{1}^{:P^{A,A}}\triangleright f^{\uparrow Q^{A,\bullet}}=q_{2}\triangleright f^{\downarrow Q^{\bullet,B}}\quad\text{ then }\quad q_{1}\triangleright v\bef f^{\uparrow S^{A,\bullet}}=q_{2}\triangleright v\bef f^{\downarrow S^{\bullet,B}}\quad.
\]

\end_inset

These are exactly the statements of the strong dinaturality laws of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-strongly-dinatural-product-of-functions"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strongly-dinatural-product-of-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If both 
\begin_inset Formula $u:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:P^{A,A}\rightarrow R^{A,A}$
\end_inset

 are strongly dinatural then 
\begin_inset Formula 
\[
t:P^{A,A}\rightarrow Q^{A,A}\times R^{A,A}\quad,\quad\quad t\triangleq p^{:P^{A,A}}\rightarrow u(p)\times v(p)
\]

\end_inset

is also strongly dinatural.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If both 
\begin_inset Formula $u:P^{A,A}\rightarrow R^{A,A}$
\end_inset

 and 
\begin_inset Formula $v:Q^{A,A}\rightarrow R^{A,A}$
\end_inset

 are strongly dinatural then
\begin_inset Formula 
\[
t:P^{A,A}+Q^{A,A}\rightarrow R^{A,A}\quad,\quad\quad t\triangleq\,\begin{array}{|c||c|}
 & R^{A,A}\\
\hline P^{A,A} & u\\
Q^{A,A} & v
\end{array}
\]

\end_inset

is also strongly dinatural.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The transformation 
\begin_inset Formula $t$
\end_inset

 can be expressed as
\begin_inset Formula 
\[
t=(p^{:P^{A,A}}\rightarrow p\times p)\bef\big(p^{:P^{A,A}}\times p^{:P^{A,A}}\rightarrow u(p)\times v(p)\big)=\Delta^{P^{A,A}}\bef(u\boxtimes v)\quad.
\]

\end_inset

Note that 
\begin_inset Formula $\Delta^{A}:A\rightarrow A\times A$
\end_inset

 is a natural transformation (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Deriving-laws-for-functions-"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

, setting the type parameter of 
\begin_inset Formula $\Delta$
\end_inset

 to 
\begin_inset Formula $P^{A,A}$
\end_inset

 yields a strongly dinatural transformation (
\begin_inset Formula $\Delta^{P^{A,A}}$
\end_inset

).
 The pair product 
\begin_inset Formula $u\boxtimes v$
\end_inset

 is strongly dinatural by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-coproduct-dinatural"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a).
 Finally, the composition 
\begin_inset Formula $\Delta\bef(u\boxtimes v)$
\end_inset

 is strongly dinatural by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strongly-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The transformation 
\begin_inset Formula $t$
\end_inset

 can be expressed as
\begin_inset Formula 
\[
t=\,\begin{array}{|c||cc|}
 & R^{A,A} & R^{A,A}\\
\hline P^{A,A} & u & \bbnum 0\\
Q^{A,A} & \bbnum 0 & v
\end{array}\,\bef\,\begin{array}{|c||c|}
 & R^{A,A}\\
\hline R^{A,A} & \text{id}\\
R^{A,A} & \text{id}
\end{array}\,=(u\boxplus v)\bef\text{merge}^{R^{A,A}}\quad,
\]

\end_inset

using the natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Working-with-disjunctive-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The pair co-product (
\begin_inset Formula $u\boxplus v$
\end_inset

) is strongly dinatural by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-coproduct-dinatural"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b).
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 with a substituted type parameter (
\begin_inset Formula $R^{A,A}$
\end_inset

) is strongly dinatural by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinatural-substitute-functor-in-natural"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Finally, the composition 
\begin_inset Formula $(u\boxplus v)\bef\text{merge}$
\end_inset

 is strongly dinatural by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strongly-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-strong-dinaturality-of-function-application"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinaturality-of-function-application"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the (fully parametric) function 
\begin_inset Formula $w\triangleq q\times z\rightarrow q(z)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The most general type signature for 
\begin_inset Formula $w$
\end_inset

 is 
\begin_inset Formula $w^{Q,Z}:(Z\rightarrow Q)\times Z\rightarrow Q$
\end_inset

 with two type parameters (
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $Z$
\end_inset

).
 With this type signature, 
\begin_inset Formula $w$
\end_inset

 is strongly dinatural with respect to both 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If we substitute the types 
\begin_inset Formula $Q^{A,A}$
\end_inset

 and 
\begin_inset Formula $Z^{A,A}$
\end_inset

 instead of 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

, where 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Z^{X,Y}$
\end_inset

 are some profunctors obeying their commutativity laws, we obtain the function
\begin_inset Formula 
\[
w:\forall A.\,(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad w^{A}\triangleq q^{:Z^{A,A}\rightarrow Q^{A,A}}\times z^{:Z^{A,A}}\rightarrow q(z)\quad.
\]

\end_inset

Then the function 
\begin_inset Formula $w$
\end_inset

 is a dinatural transformation.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Under the same assumptions as in 
\series bold
(b)
\series default
, the function 
\begin_inset Formula $w$
\end_inset

 is strongly dinatural if the profunctor
\begin_inset Formula $Z^{X,Y}$
\end_inset

 has the 
\begin_inset Quotes eld
\end_inset

weak pullback property
\begin_inset Quotes erd
\end_inset

 (see Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-weak-pullback-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-weak-pullback-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Otherwise, 
\begin_inset Formula $w$
\end_inset

 is 
\emph on
not
\emph default
 necessarily strongly dinatural.
 — not clear if we can show a counterexample
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The type signature 
\begin_inset Formula $\forall(Q,Z).\,(Z\rightarrow Q)\times Z\rightarrow Q$
\end_inset

 has the form of a natural transformation with respect to the parameter
 
\begin_inset Formula $Q$
\end_inset

 (but not with respect to 
\begin_inset Formula $Z$
\end_inset

).
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-strong-dinaturality-entails-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b), strong dinaturality holds with respect to 
\begin_inset Formula $Q$
\end_inset

.
 
\end_layout

\begin_layout Standard
The strong dinaturality law of 
\begin_inset Formula $w$
\end_inset

 with respect to 
\begin_inset Formula $Z$
\end_inset

 needs to be checked directly.
 For convenience, define the profunctors 
\begin_inset Formula $P^{X,Y}\triangleq(X\rightarrow Q)\times Y$
\end_inset

 and 
\begin_inset Formula $R^{X,Y}\triangleq Q$
\end_inset

, so that 
\begin_inset Formula $w$
\end_inset

 has the type signature 
\begin_inset Formula $P^{Z,Z}\rightarrow R^{Z,Z}$
\end_inset

.
 We need to prove that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
\text{when}\quad x^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=y^{:P^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright w\triangleright f^{\uparrow R}\overset{?}{=}y\triangleright w\triangleright f^{\downarrow R}\quad.
\]

\end_inset

Since 
\begin_inset Formula $R^{X,Y}$
\end_inset

 is a constant profunctor, we have 
\begin_inset Formula $f^{\uparrow R}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow R}=\text{id}$
\end_inset

.
 Defining 
\begin_inset Formula $g^{:A\rightarrow Q}\times a^{:A}\triangleq x^{:P^{A,A}}$
\end_inset

 and 
\begin_inset Formula $h^{:B\rightarrow Q}\times b^{:B}\triangleq y^{:P^{B,B}}$
\end_inset

, and using the liftings 
\begin_inset Formula 
\[
f^{\uparrow P^{A,\bullet}}=\text{id}^{A\rightarrow Q}\boxtimes f\quad,\quad\quad f^{\downarrow P^{\bullet,B}}=(g^{:B\rightarrow Q}\rightarrow f\bef g)\boxtimes\text{id}^{B}\quad,
\]

\end_inset

we can rewrite the law as
\begin_inset Formula 
\[
\text{when}\quad g^{:A\rightarrow Q}\times f(a^{:A})=(f\bef h^{:B\rightarrow Q})\times b^{:B}\quad\text{ then}\quad g(a)\overset{?}{=}h(b)\quad.
\]

\end_inset

Since we must have 
\begin_inset Formula $b=f(a)$
\end_inset

 and 
\begin_inset Formula $g=f\bef h$
\end_inset

, the law holds:
\begin_inset Formula 
\[
g(a)=h(f(a))=h(b).
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Define the profunctor 
\begin_inset Formula $P^{X,Y}\triangleq(Z^{Y,X}\rightarrow Q^{X,Y})\times Z^{X,Y}$
\end_inset

 (note the reverse order of type parameters in 
\begin_inset Formula $Z^{Y,X}$
\end_inset

).
 Then 
\begin_inset Formula $w^{A}$
\end_inset

 has type signature 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

, and the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is
\begin_inset Formula 
\[
f^{\downarrow P}\bef w\bef f^{\uparrow Q}\overset{?}{=}f^{\uparrow P}\bef w\bef f^{\downarrow Q}\quad.
\]

\end_inset

It helps to write out the code for the liftings to 
\begin_inset Formula $P$
\end_inset

.
 For arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
 & (g^{:Z^{Y,B}\rightarrow Q^{B,Y}}\times a^{:Z^{B,Y}})\triangleright f^{\downarrow P^{\bullet,Y}}=\big(f^{\uparrow Z^{Y,\bullet}}\bef g\bef f^{\downarrow Q^{\bullet,Y}}\big)\times(a\triangleright f^{\downarrow Z^{\bullet,Y}})\quad,\\
 & (g^{:Z^{A,X}\rightarrow Q^{X,A}}\times a^{:Z^{X,A}})\triangleright f^{\uparrow P^{X,\bullet}}=\big(f^{\downarrow Z^{\bullet,X}}\bef g\bef f^{\uparrow Q^{X,\bullet}}\big)\times(a\triangleright f^{\uparrow Z^{X,\bullet}})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The naturality law of 
\begin_inset Formula $w$
\end_inset

 is written as an equation between functions of type 
\begin_inset Formula $P^{B,A}\rightarrow Q^{A,B}$
\end_inset

:
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,A}}\bef w^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{?}{=}f^{\uparrow P^{B,\bullet}}\bef w^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\]

\end_inset

Apply both sides of the law to an arbitrary value 
\begin_inset Formula $g\times a:P^{B,A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (g^{:Z^{A,B}\rightarrow Q^{B,A}}\times a^{:Z^{B,A}})\,\gunderline{\triangleright f^{\downarrow P}}\bef w\bef f^{\uparrow Q}=\big((f^{\uparrow Z}\bef g\bef f^{\downarrow Q})\times(a\triangleright f^{\downarrow Z})\big)\triangleright w\triangleright f^{\uparrow Q}\\
\text{definition of }w:\quad & \quad=(a\triangleright f^{\downarrow Z})\triangleright(f^{\uparrow Z}\bef g\bef f^{\downarrow Q})\triangleright f^{\uparrow Q}=a\triangleright f^{\downarrow Z}\bef f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}\\
\text{right-hand side}:\quad & \overset{?}{=}(g\times a)\,\gunderline{\triangleright f^{\uparrow P}}\bef w\bef f^{\downarrow Q}=\big((f^{\downarrow Z}\bef g\bef f^{\uparrow Q})\times(a\triangleright f^{\uparrow Z})\big)\triangleright w\triangleright f^{\downarrow Q}\\
\text{definition of }w:\quad & \quad=(a\triangleright f^{\uparrow Z})\triangleright(f^{\downarrow Z}\bef g\bef f^{\uparrow Q})\triangleright f^{\downarrow Q}=a\triangleright f^{\uparrow Z}\bef f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}\quad.
\end{align*}

\end_inset

The remaining difference between two sides disappears due to the commutativity
 laws of 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 (namely 
\begin_inset Formula $f^{\uparrow Q}\bef f^{\downarrow Q}=f^{\downarrow Q}\bef f^{\uparrow Q}$
\end_inset

 and 
\begin_inset Formula $f^{\uparrow Z}\bef f^{\downarrow Z}=f^{\downarrow Z}\bef f^{\uparrow Z}$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The strong dinaturality of 
\begin_inset Formula $w$
\end_inset

 says that, for arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
\text{when}\quad x^{:G^{A,A}\times Z^{A,A}}\triangleright f^{\uparrow(G\times Z)}=y^{:G^{B,B}\times Z^{B,B}}\triangleright f^{\downarrow(G\times Z)}\quad\text{ then}\quad x\triangleright w\triangleright f^{\uparrow Q}\overset{?}{=}y\triangleright w\triangleright f^{\downarrow Q}\quad.
\]

\end_inset

Since 
\begin_inset Formula $f^{\uparrow(G\times Z)}=f^{\uparrow G}\boxtimes f^{\uparrow Z}$
\end_inset

, the precondition of the law splits into two equations:
\begin_inset Formula 
\begin{align*}
\text{defining }g_{1},z_{1},g_{2},z_{2}:\quad & g_{1}^{:G^{A,A}}\times z_{1}^{:Z^{A,A}}\triangleq x\quad,\quad\quad g_{2}^{:G^{B,B}}\times z_{2}^{:Z^{B,B}}\triangleq y\quad,\\
\text{the precondition is equivalent to}:\quad & g_{1}\triangleright f^{\uparrow G}=g_{2}\triangleright f^{\downarrow G}\quad\text{ and }\quad z_{1}\triangleright f^{\uparrow Z}=z_{2}\triangleright f^{\downarrow Z}\quad.
\end{align*}

\end_inset

The precondition 
\begin_inset Formula $g_{1}\triangleright f^{\uparrow G}=g_{2}\triangleright f^{\downarrow G}$
\end_inset

 is equivalent to
\begin_inset Formula 
\begin{equation}
f^{\downarrow Z}\bef g_{1}\bef f^{\uparrow Q}=f^{\uparrow Z}\bef g_{2}\bef f^{\downarrow Q}\quad.\label{eq:strong-dinaturality-precondition-derivation1}
\end{equation}

\end_inset

Now we express the conclusion of the law via the new variables:
\begin_inset Formula 
\begin{equation}
x\triangleright w\triangleright f^{\uparrow Q}=z_{1}\triangleright g_{1}\bef f^{\uparrow Q}\overset{?}{=}y\triangleright w\triangleright f^{\downarrow Q}=z_{2}\triangleright g_{2}\bef f^{\downarrow Q}\quad.\label{eq:strong-dinaturality-conclusion-derivation1}
\end{equation}

\end_inset

From here, the proof cannot proceed without more information.
 We need to show that 
\begin_inset Formula $z_{1}\triangleright g_{1}\bef f^{\uparrow Q}\overset{?}{=}z_{2}\triangleright g_{2}\bef f^{\downarrow Q}$
\end_inset

, but we do not have any equations relating 
\begin_inset Formula $g_{1}\bef f^{\uparrow Q}$
\end_inset

 to 
\begin_inset Formula $g_{2}\bef f^{\downarrow Q}$
\end_inset

.
 We cannot use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-precondition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) because it contains additional lifted functions 
\begin_inset Formula $f^{\downarrow Z}$
\end_inset

 and 
\begin_inset Formula $f^{\uparrow Z}$
\end_inset

 that we cannot insert into the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-conclusion-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), given that 
\begin_inset Formula $z_{1}$
\end_inset

 and 
\begin_inset Formula $z_{2}$
\end_inset

 are unknown.
 
\end_layout

\begin_layout Standard
If the profunctor 
\begin_inset Formula $Z$
\end_inset

 has the weak pullback property, we can use the wedge precondition 
\begin_inset Formula $z_{1}\triangleright f^{\uparrow Z}=z_{2}\triangleright f^{\downarrow Z}$
\end_inset

 to find a value 
\begin_inset Formula $u^{:Z^{B,A}}$
\end_inset

 such that 
\begin_inset Formula $z_{1}=u\triangleright f^{\downarrow Z}$
\end_inset

 and 
\begin_inset Formula $z_{2}=u\triangleright f^{\uparrow Z}$
\end_inset

.
 Then the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-conclusion-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes
\begin_inset Formula 
\[
z_{1}\triangleright g_{1}\bef f^{\uparrow Q}=u\triangleright f^{\downarrow Z}\bef g_{1}\bef f^{\uparrow Q}\overset{?}{=}z_{2}\triangleright g_{2}\bef f^{\downarrow Q}=u\triangleright f^{\uparrow Z}\bef g_{2}\bef f^{\downarrow Q}\quad.
\]

\end_inset

Both sides are now equal due to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-precondition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Getting stuck in a proof without the weak pullback property is not sufficient;
 we need to show a counterexample.
 For that, let us choose a profunctor 
\begin_inset Formula $Z$
\end_inset

 that does 
\emph on
not
\emph default
 have the weak pullback property, and show that the corresponding 
\begin_inset Formula $w$
\end_inset

 is not strongly dinatural.
 By Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-weak-pullback-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

, a suitable profunctor is 
\begin_inset Formula $Z^{X,Y}\triangleq X\rightarrow Y$
\end_inset

.
\end_layout

\begin_layout Plain Layout
***It seems that this profunctor does not give a clear counterexample...
\end_layout

\begin_layout Plain Layout
For simplicity, choose 
\begin_inset Formula $Q^{X,Y}\triangleq X\rightarrow Y$
\end_inset

 to be the same profunctor.
 The corresponding function 
\begin_inset Formula $w$
\end_inset

 is
\begin_inset Formula 
\[
w\triangleq q^{:(A\rightarrow A)\rightarrow A\rightarrow A}\times z^{:A\rightarrow A}\rightarrow q(z)\quad.
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Using the specific code for function liftings to 
\begin_inset Formula $Z$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow Z}=u\rightarrow u\bef f\quad,\quad\quad f^{\downarrow Z}=v\rightarrow f\bef v\quad,\quad\quad f^{\uparrow Q}=u\rightarrow u\bef f\quad,\quad\quad f^{\downarrow Q}=v\rightarrow f\bef v\quad,
\]

\end_inset

we can write the strong dinaturality law of 
\begin_inset Formula $w$
\end_inset

: for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $z_{1}^{:A\rightarrow A}$
\end_inset

, 
\begin_inset Formula $z_{2}^{:B\rightarrow B}$
\end_inset

, 
\begin_inset Formula $g_{1}^{:(A\rightarrow A)\rightarrow A\rightarrow A}$
\end_inset

, 
\begin_inset Formula $g_{2}^{:(B\rightarrow B)\rightarrow B\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{precondition}:\quad & \text{when}\quad(u\rightarrow f\bef u)\bef g_{1}\bef(v\rightarrow v\bef f)=(u\rightarrow u\bef f)\bef g_{2}\bef(v\rightarrow f\bef v)\text{ and }z_{1}\bef f=f\bef z_{2}\\
\text{conclusion}:\quad & \text{then}\quad z_{1}\triangleright g_{1}\bef(u\rightarrow u\bef f)\overset{?}{=}z_{2}\triangleright g_{2}\bef(v\rightarrow f\bef v)\quad.
\end{align*}

\end_inset

The precondition is simplified (by applying to an arbitrary value 
\begin_inset Formula $u^{:B\rightarrow A}$
\end_inset

) to:
\begin_inset Formula 
\[
\forall u^{:B\rightarrow A}.\,g_{1}(f\bef u)\bef f=f\bef g_{2}(u\bef f)\text{ and }z_{1}\bef f=f\bef z_{2}\quad.
\]

\end_inset

Choose 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 as a constant function 
\begin_inset Formula $f\triangleq\_^{:A}\rightarrow b_{0}$
\end_inset

 with a fixed value 
\begin_inset Formula $b_{0}^{:B}$
\end_inset

.
 The law becomes:
\begin_inset Formula 
\[
\text{when}\quad b_{0}=b_{0}\triangleright g_{2}(\_\rightarrow b_{0})\text{ and }b_{0}=z_{2}(b_{0})\quad\text{then}\quad b_{0}\overset{?}{=}b_{0}\triangleright g_{2}(z_{2})\quad.
\]

\end_inset

To find a counterexample, we need to show that, with suitable functions
 
\begin_inset Formula $z_{2}$
\end_inset

 and 
\begin_inset Formula $g_{2}$
\end_inset

, the precondition holds but the conclusion fails to hold.
 We may choose for simplicity 
\begin_inset Formula $g_{2}^{:(B\rightarrow B)\rightarrow B\rightarrow B}=\text{id}^{B\rightarrow B}$
\end_inset

.
 It remains to find a function 
\begin_inset Formula $z_{2}^{:B\rightarrow B}$
\end_inset

 such that 
\begin_inset Formula $z_{2}(b_{0})=b_{0}$
\end_inset

 and 
\begin_inset Formula $ $
\end_inset

,
\begin_inset Formula 
\begin{align*}
 & b_{0}=b_{0}\triangleright g_{2}(\_\rightarrow b_{0})\\
 & b_{0}=z_{2}(b_{0})\\
 & b_{0}\neq b_{0}\triangleright g_{2}(z_{2})
\end{align*}

\end_inset

To get a counterexample, we just need to find 
\begin_inset Formula $g_{2}$
\end_inset

 such that 
\begin_inset Formula $g_{2}(\_\rightarrow b_{0})\neq g_{2}(z_{2})$
\end_inset

 for some function 
\begin_inset Formula $z_{2}^{:B\rightarrow B}$
\end_inset

 that is not constant but satisfies 
\begin_inset Formula $z_{2}(b_{0})=b_{0}$
\end_inset

.
 We could even have 
\begin_inset Formula $g_{2}=\text{id}$
\end_inset

 and this will work.
\end_layout

\begin_layout Plain Layout
***
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now formulate the weak pullback property used in the previous statement.
 
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-weak-pullback-property"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-weak-pullback-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (weak pullback property)
\end_layout

\begin_layout Standard
A profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

 (contravariant in 
\begin_inset Formula $X$
\end_inset

 and covariant
\begin_inset Note Comment
status open

\begin_layout Plain Layout
empty arrow
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "41col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.3pc}\xyScaleX{1.5pc} & P^{A,A}\ar[d]\sb(0.5){f^{\uparrow P^{A,\bullet}}} & \ar@{}[d]\sb(0.5){\displaystyle \Rightarrow} & P^{B,A}\ar[r]\sp(0.55){f^{\downarrow P^{\bullet,A}}}\ar[d]\sb(0.5){f^{\uparrow P^{B,\bullet}}} & P^{A,A}\ar[d]\sb(0.5){f^{\uparrow P^{A,\bullet}}}\\
P^{B,B}\ar[r]\sb(0.5){f^{\downarrow P^{\bullet,B}}} & P^{A,B} &  & P^{B,B}\ar[r]\sb(0.5){f^{\downarrow P^{\bullet,B}}} & P^{A,B}
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
in 
\begin_inset Formula $Y$
\end_inset

) has the 
\series bold
weak pullback property
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
weak pullback property of profunctors
\end_layout

\end_inset

 if for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and any values 
\begin_inset Formula $x^{:P^{A,A}}$
\end_inset

 and 
\begin_inset Formula $y^{:P^{B,B}}$
\end_inset

 obeying the 
\begin_inset Quotes eld
\end_inset

wedge
\begin_inset Quotes erd
\end_inset

 condition 
\begin_inset Formula $x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$
\end_inset

, we can compute a value 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 such that 
\begin_inset Formula $x=p\triangleright f^{\downarrow P^{\bullet,A}}$
\end_inset

 and 
\begin_inset Formula $y=p\triangleright f^{\uparrow P^{B,\bullet}}$
\end_inset

.
 The type diagram means that a wedge starting with 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 can be always completed to a commuting square.
\end_layout

\begin_layout Standard
Note that the function 
\begin_inset Formula $f$
\end_inset

 in this definition does not need to be invertible.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-weak-pullback-property-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-weak-pullback-property-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Suppose a profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

 does not depend on the type parameter 
\begin_inset Formula $X$
\end_inset

 (so, 
\begin_inset Formula $P^{X,Y}\triangleq G^{Y}$
\end_inset

 with some functor 
\begin_inset Formula $G$
\end_inset

).
 Then 
\begin_inset Formula $P$
\end_inset

 has the weak pullback property.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The weak pullback property holds for profunctors 
\begin_inset Formula $P^{X,Y}\triangleq H^{X}$
\end_inset

, where 
\begin_inset Formula $H$
\end_inset

 is a contrafunctor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 With the choice 
\begin_inset Formula $P^{X,Y}\triangleq G^{Y}$
\end_inset

, we have the liftings 
\begin_inset Formula $f^{\uparrow P}=f^{\uparrow G}$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow P}=f$
\end_inset

.
 The weak pullback property of 
\begin_inset Formula $P^{X,Y}$
\end_inset

 says that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $x^{:G^{A}}$
\end_inset

, 
\begin_inset Formula $y^{:G^{B}}$
\end_inset

:
\begin_inset Formula 
\[
\text{when}\quad x\triangleright f^{\uparrow G}=y\quad\text{ then }\exists p^{:G^{A}}\text{ such that }x=p\text{ and }y=p\triangleright f^{\uparrow G}\quad.
\]

\end_inset

This property is satisfied by choosing 
\begin_inset Formula $p\triangleq x$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 With the choice 
\begin_inset Formula $P^{X,Y}\triangleq H^{X}$
\end_inset

, we have the liftings 
\begin_inset Formula $f^{\uparrow P}=f$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow P}=f^{\downarrow H}$
\end_inset

.
 The weak pullback property of 
\begin_inset Formula $P^{X,Y}$
\end_inset

 says that, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $x^{:H^{A}}$
\end_inset

, 
\begin_inset Formula $y^{:H^{B}}$
\end_inset

:
\begin_inset Formula 
\[
\text{when}\quad x=y\triangleright f^{\downarrow H}\quad\text{ then }\exists p^{:H^{A}}\text{ such that }x=p\triangleright f^{\downarrow H}\text{ and }y=p\quad.
\]

\end_inset

This property is satisfied by choosing 
\begin_inset Formula $p\triangleq y$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-weak-pullback-property"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-weak-pullback-property"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The profunctor 
\begin_inset Formula $P^{X,Y}\triangleq X\rightarrow Y$
\end_inset

 does 
\emph on
not
\emph default
 have the weak pullback property.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
With 
\begin_inset Formula $P^{X,Y}\triangleq X\rightarrow Y$
\end_inset

, we rewrite the wedge condition (
\begin_inset Formula $x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$
\end_inset

) for arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $x^{:A\rightarrow A}$
\end_inset

, and 
\begin_inset Formula $y^{:B\rightarrow B}$
\end_inset

 as:
\begin_inset Formula 
\[
x\bef f=f\bef y\quad.
\]

\end_inset

A commuting square diagram requires to find a value 
\begin_inset Formula $p^{:B\rightarrow A}$
\end_inset

 such that 
\begin_inset Formula $x=f\bef p$
\end_inset

 and 
\begin_inset Formula $y=p\bef f$
\end_inset

.
 Choose 
\begin_inset Formula $f$
\end_inset

 as a constant function (
\begin_inset Formula $f\triangleq\_\rightarrow b_{0}$
\end_inset

 with a fixed value 
\begin_inset Formula $b_{0}^{:B}$
\end_inset

).
 The wedge condition applied to an arbitrary value 
\begin_inset Formula $a^{:A}$
\end_inset

 gives
\begin_inset Formula 
\[
a\triangleright x\bef f=b_{0}\overset{!}{=}a\triangleright f\bef y=y(b_{0})\quad.
\]

\end_inset

So, the wedge condition will hold for any 
\begin_inset Formula $x^{:A\rightarrow A}$
\end_inset

 and for any function 
\begin_inset Formula $y^{:B\rightarrow B}$
\end_inset

 such that 
\begin_inset Formula $y(b_{0})=b_{0}$
\end_inset

.
 In particular, 
\begin_inset Formula $y$
\end_inset

 is not necessarily a constant function.
 But the condition 
\begin_inset Formula $y=p\bef f=\_\rightarrow b_{0}$
\end_inset

 can be satisfied only if 
\begin_inset Formula $y$
\end_inset

 is a constant function.
 So, we are unable to find 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset

 that completes the square diagram.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We can perform structural analysis to discover profunctors that have the
 weak pullback property:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-weak-pullback-property"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-weak-pullback-property"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

 (contravariant in 
\begin_inset Formula $X$
\end_inset

 and covariant in 
\begin_inset Formula $Y$
\end_inset

) has the weak pullback property if:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $P^{X,Y}=F^{Y}$
\end_inset

 with some (covariant) functor 
\begin_inset Formula $F$
\end_inset

,
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $P^{X,Y}=G^{X}$
\end_inset

 with some contrafunctor 
\begin_inset Formula $G$
\end_inset

,
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $P^{X,Y}=Z\rightarrow Q^{X,Y}$
\end_inset

 with a fixed type 
\begin_inset Formula $Z$
\end_inset

 and a profunctor 
\begin_inset Formula $Q$
\end_inset

 that has the weak pullback property,
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $P^{X,Y}=Q^{X,Y}\times R^{X,Y}$
\end_inset

 with profunctors 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 that both have the weak pullback property,
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 
\begin_inset Formula $P^{X,Y}=Q^{X,Y}+R^{X,Y}$
\end_inset

 with profunctors 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 that both have the weak pullback property.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Consider some values 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $x^{:P^{A,A}}$
\end_inset

, and 
\begin_inset Formula $y^{:P^{B,B}}$
\end_inset

, for which the wedge condition holds:
\begin_inset Formula 
\[
x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If 
\begin_inset Formula $P^{X,Y}=F^{Y}$
\end_inset

 with a functor 
\begin_inset Formula $F$
\end_inset

, the wedge condition is simplified to 
\begin_inset Formula $x\triangleright f^{\uparrow F}=y$
\end_inset

 with 
\begin_inset Formula $x^{:F^{A}}$
\end_inset

 and 
\begin_inset Formula $y^{:F^{B}}$
\end_inset

, and we need to find 
\begin_inset Formula $p^{:F^{A}}$
\end_inset

 such that 
\begin_inset Formula $x=p$
\end_inset

 and 
\begin_inset Formula $y=x\triangleright f^{\uparrow F}$
\end_inset

.
 So, we define 
\begin_inset Formula $p\triangleq x$
\end_inset

 and complete the commuting square.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If 
\begin_inset Formula $P^{X,Y}=G^{X}$
\end_inset

 with a contrafunctor 
\begin_inset Formula $G$
\end_inset

, the wedge condition is simplified to 
\begin_inset Formula $x=y\triangleright f^{\downarrow G}$
\end_inset

 with 
\begin_inset Formula $x^{:G^{A}}$
\end_inset

 and 
\begin_inset Formula $y^{:G^{B}}$
\end_inset

, and we need to find 
\begin_inset Formula $p^{:G^{B}}$
\end_inset

 such that 
\begin_inset Formula $x=p\triangleright f^{\downarrow G}$
\end_inset

 and 
\begin_inset Formula $y=p$
\end_inset

.
 So, we define 
\begin_inset Formula $p\triangleq y$
\end_inset

 and complete the commuting square.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 If 
\begin_inset Formula $P^{X,Y}=Z\rightarrow Q^{X,Y}$
\end_inset

 with a fixed type 
\begin_inset Formula $Z$
\end_inset

 and a profunctor 
\begin_inset Formula $Q$
\end_inset

 that has the weak pullback property, the wedge condition is rewritten,
 with 
\begin_inset Formula $x^{:Z\rightarrow Q^{A,A}}$
\end_inset

 and 
\begin_inset Formula $y^{:Z\rightarrow Q^{B,B}}$
\end_inset

, applied to an arbitrary 
\begin_inset Formula $z^{:Z}$
\end_inset

, as:
\begin_inset Formula 
\[
z\triangleright x\triangleright f^{\uparrow Q^{A,\bullet}}=z\triangleright y\triangleright f^{\downarrow Q^{\bullet,B}}\quad.
\]

\end_inset

Note that this is the same as the wedge condition of the profunctor 
\begin_inset Formula $Q$
\end_inset

 for the values 
\begin_inset Formula $z\triangleright x$
\end_inset

 and 
\begin_inset Formula $z\triangleright y$
\end_inset

.
 By assumption, 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 has the weak pullback property; so, we may apply that property to 
\begin_inset Formula $z\triangleright x$
\end_inset

 and 
\begin_inset Formula $z\triangleright y$
\end_inset

 and obtain a value 
\begin_inset Formula $q^{:Q^{B,A}}$
\end_inset

 for which we have the equations
\begin_inset Formula 
\begin{equation}
q\triangleright f^{\uparrow Q^{B,\bullet}}=z\triangleright y\quad,\quad\quad q\triangleright f^{\downarrow Q^{\bullet,A}}=z\triangleright x\quad.\label{eq:weak-pullback-c-derivation1}
\end{equation}

\end_inset

We need to find 
\begin_inset Formula $p^{:Z\rightarrow Q^{B,A}}$
\end_inset

 such that 
\begin_inset Formula $x=p\bef f^{\downarrow Q^{\bullet,A}}$
\end_inset

 and 
\begin_inset Formula $y=p\bef f^{\uparrow Q^{B,\bullet}}$
\end_inset

.
 But these equations are the same as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:weak-pullback-c-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) if we define 
\begin_inset Formula $p(z)\triangleq q$
\end_inset

.
 So, we have found the value 
\begin_inset Formula $p$
\end_inset

 that completes the square diagram.
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 If 
\begin_inset Formula $P^{X,Y}=Q^{X,Y}\times R^{X,Y}$
\end_inset

 with profunctors 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 that both have the weak pullback property, we write the wedge condition
 for 
\begin_inset Formula $x^{:Q^{A,A}\times R^{A,A}}=x_{1}^{:Q^{A,A}}\times x_{2}^{:R^{A,A}}$
\end_inset

 and 
\begin_inset Formula $y^{:Q^{B,B}\times R^{B,B}}=y_{1}^{:Q^{B,B}}\times y_{2}^{:R^{B,B}}$
\end_inset

 as:
\begin_inset Formula 
\[
(x_{1}\times x_{2})\triangleright f^{\uparrow(Q\times R)}=(x_{1}\triangleright f^{\uparrow Q})\times(x_{2}\triangleright f^{\uparrow R})\overset{!}{=}(y_{1}\times y_{2})\triangleright f^{\downarrow(Q\times R)}=(y_{1}\triangleright f^{\downarrow Q})\times(y_{2}\triangleright f^{\downarrow R})\quad.
\]

\end_inset

This equation is equivalent to two equations,
\begin_inset Formula 
\[
x_{1}\triangleright f^{\uparrow Q}\overset{!}{=}y_{1}\triangleright f^{\downarrow Q}\quad\text{ and }\quad x_{2}\triangleright f^{\uparrow R}\overset{!}{=}y_{2}\triangleright f^{\downarrow R}\quad,
\]

\end_inset

which are the wedge conditions of the profunctors 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 By assumption, 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 have the weak pullback property.
 So, we may compute values 
\begin_inset Formula $p_{1}^{:Q^{B,A}}$
\end_inset

 and 
\begin_inset Formula $p_{2}^{:R^{B,A}}$
\end_inset

 such that
\begin_inset Formula 
\[
p_{1}\triangleright f^{\downarrow Q}=x_{1}\quad,\quad\quad p_{1}\triangleright f^{\uparrow Q}=y_{1}\quad,\quad\quad p_{2}\triangleright f^{\downarrow R}=x_{2}\quad,\quad\quad p_{2}\triangleright f^{\uparrow R}=y_{2}\quad.
\]

\end_inset

If we define 
\begin_inset Formula $p\triangleq p_{1}\times p_{2}$
\end_inset

, we complete the square diagram because
\begin_inset Formula 
\[
p\triangleright f^{\downarrow(Q\times R)}=(p_{1}\triangleright f^{\downarrow Q})\times(p_{2}\triangleright f^{\downarrow R})=x_{1}\times x_{2}\quad,\quad\quad p\triangleright f^{\uparrow(Q\times R)}=(p_{1}\triangleright f^{\uparrow Q})\times(p_{2}\triangleright f^{\uparrow R})=y_{1}\times y_{2}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 If 
\begin_inset Formula $P^{X,Y}=Q^{X,Y}+R^{X,Y}$
\end_inset

 with profunctors 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 that both have the weak pullback property, we write the wedge condition
 for 
\begin_inset Formula $x^{:Q^{A,A}+R^{A,A}}$
\end_inset

 and 
\begin_inset Formula $y^{:Q^{B,B}+R^{B,B}}$
\end_inset

 as:
\begin_inset Formula 
\[
x\triangleright\,\begin{array}{|c||cc|}
 & Q^{A,B} & R^{A,B}\\
\hline Q^{A,A} & f^{\uparrow Q^{A,\bullet}} & \bbnum 0\\
R^{A,A} & \bbnum 0 & f^{\uparrow R^{A,\bullet}}
\end{array}\,=y\triangleright\,\begin{array}{|c||cc|}
 & Q^{A,B} & R^{A,B}\\
\hline Q^{B,B} & f^{\downarrow Q^{\bullet,B}} & \bbnum 0\\
R^{B,B} & \bbnum 0 & f^{\downarrow R^{\bullet,B}}
\end{array}\quad.
\]

\end_inset

This equation can be satisfied only if both sides are either of type 
\begin_inset Formula $Q^{A,B}+\bbnum 0$
\end_inset

 or of type 
\begin_inset Formula $\bbnum 0+R^{A,B}$
\end_inset

.
 Since the lifting matrices are diagonal, this can happen only if 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $Q^{A,A}+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 has type 
\begin_inset Formula $Q^{B,B}+\bbnum 0$
\end_inset

, of if 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $\bbnum 0+R^{A,A}$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 has type 
\begin_inset Formula $\bbnum 0+R^{B,B}$
\end_inset

.
 In the first case, the property becomes equivalent to that of the profunctor
 
\begin_inset Formula $Q$
\end_inset

; in the second case, to that of the profunctor 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Standard
To see this more explicitly, consider two cases: 
\begin_inset Formula $x\triangleq x_{1}^{:Q^{A,A}}+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $x\triangleq\bbnum 0+x_{2}^{:R^{A,A}}$
\end_inset

.
 In the first case, 
\begin_inset Formula $x\triangleright f^{\uparrow P}=(x_{1}\triangleright f^{\uparrow Q})+\bbnum 0$
\end_inset

.
 This can be equal to 
\begin_inset Formula $y\triangleright f^{\downarrow P}$
\end_inset

 only if 
\begin_inset Formula $y\triangleright f^{\downarrow P}$
\end_inset

 is in the first part of the disjunction type 
\begin_inset Formula $Q^{A,B}+R^{A,B}$
\end_inset

.
 This happens only when 
\begin_inset Formula $y=y_{1}^{:Q^{B,B}}+\bbnum 0$
\end_inset

 with some 
\begin_inset Formula $y_{1}$
\end_inset

.
 So, the wedge condition of 
\begin_inset Formula $P$
\end_inset

 implies 
\begin_inset Formula $x_{1}\triangleright f^{\uparrow Q}=y_{1}\triangleright f^{\downarrow Q}$
\end_inset

.
 This is the same as the wedge condition of the profunctor 
\begin_inset Formula $Q$
\end_inset

.
 By assumption, 
\begin_inset Formula $Q$
\end_inset

 has the weak pullback property; so, we can compute some 
\begin_inset Formula $p_{1}^{:Q^{B,A}}$
\end_inset

 such that 
\begin_inset Formula $x_{1}=p_{1}\triangleright f^{\downarrow Q}$
\end_inset

 and 
\begin_inset Formula $y_{1}=p_{1}\triangleright f^{\uparrow Q}$
\end_inset

.
 If we now define 
\begin_inset Formula $p\triangleq p_{1}+\bbnum 0$
\end_inset

, we will have 
\begin_inset Formula $p\triangleright f^{\downarrow P}=x$
\end_inset

 and 
\begin_inset Formula $p\triangleright f^{\uparrow P}=y$
\end_inset

, and the square diagram is completed.
\end_layout

\begin_layout Standard
The case 
\begin_inset Formula $x\triangleq\bbnum 0+x_{2}^{:R^{A,A}}$
\end_inset

 is proved similarly, by referring to the weak pullback property of 
\begin_inset Formula $R$
\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsection
Strong dinaturality derived from parametricity
\begin_inset CommandInset label
LatexCommand label
name "subsec:Strong-dinaturality-derived-from-parametricity"

\end_inset


\end_layout

\begin_layout Standard
To find out which fully parametric functions are strongly dinatural, we
 will perform structural analysis on the functions' type signatures.
 The plan
\begin_inset Foot
status open

\begin_layout Plain Layout
The derivations in this section are based on talk slides 
\begin_inset CommandInset href
LatexCommand href
target "https://www.ioc.ee/~tarmo/tday-voore/vene-slides.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 is to show that a fully parametric function 
\begin_inset Formula $g:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 will satisfy the strong dinaturality law,
\begin_inset Formula 
\[
p_{1}^{:P^{A,A}}\triangleright f^{\uparrow P}=p_{2}^{:P^{B,B}}\triangleright f^{\downarrow P}\quad\Rightarrow\quad g(p_{1})\triangleright f^{\uparrow Q}=g(p_{2})\triangleright f^{\downarrow Q}\quad,
\]

\end_inset

for profunctors 
\begin_inset Formula $P^{A,A}$
\end_inset

 and 
\begin_inset Formula $Q^{A,A}$
\end_inset

 that are built up via a certain subset of type constructions.
 
\end_layout

\begin_layout Standard
The starting point is to note that 
\begin_inset Formula $g$
\end_inset

 satisfies the relational law for 
\begin_inset Formula $g$
\end_inset

 with the chosen relation 
\begin_inset Formula $\left<f\right>$
\end_inset

:
\begin_inset Formula 
\[
(p_{1}^{:P^{A,A}},p_{2}^{:P^{B,B}})\in\left<f\right>^{\updownarrow P}\quad\Rightarrow\quad(g(p_{1}),g(p_{2}))\in\left<f\right>^{\updownarrow Q}\quad.
\]

\end_inset

We will prove the strong dinaturality law of 
\begin_inset Formula $g$
\end_inset

 if we show that the relation 
\begin_inset Formula $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$
\end_inset

 follows from the wedge condition for 
\begin_inset Formula $(p_{1},p_{2})$
\end_inset

, and that the wedge condition for 
\begin_inset Formula $(g(p_{1}),g(p_{2}))$
\end_inset

 follows from the relation 
\begin_inset Formula $(g(p_{1}),g(p_{2}))\in\left<f\right>^{\updownarrow Q}$
\end_inset

.
 We will then have proved the following chain of implications:
\begin_inset Formula 
\[
\big(p_{1}\triangleright f^{\uparrow P}=p_{2}\triangleright f^{\downarrow P}\big)\Rightarrow\big((p_{1},p_{2})\in\left<f\right>^{\updownarrow P}\big)\Rightarrow\big((g(p_{1}),g(p_{2}))\in\left<f\right>^{\updownarrow Q}\big)\Rightarrow\big(g(p_{1})\triangleright f^{\uparrow Q}=g(p_{2})\triangleright f^{\downarrow Q}\big)\quad.
\]

\end_inset

Let us call the first of these implications the 
\begin_inset Quotes eld
\end_inset

post-wedge property
\begin_inset Quotes erd
\end_inset

 of the profunctor 
\begin_inset Formula $P$
\end_inset

 and the last the 
\begin_inset Quotes eld
\end_inset

pre-wedge
\begin_inset Quotes erd
\end_inset

 property of the profunctor 
\begin_inset Formula $Q$
\end_inset

:
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-pre-post-wedge-property"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-pre-post-wedge-property"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a profunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
profunctor!wedge relation
\end_layout

\end_inset

 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, two values 
\begin_inset Formula $p_{1}^{:P^{A,A}}$
\end_inset

 and 
\begin_inset Formula $p_{2}^{:P^{B,B}}$
\end_inset

 are in a 
\begin_inset Formula $\left(P,f\right)$
\end_inset

-
\series bold
wedge relation
\series default
 if 
\begin_inset Formula $p_{1}\triangleright f^{\uparrow P^{A,\bullet}}=p_{2}\triangleright f^{\downarrow P^{\bullet,B}}$
\end_inset

.
\end_layout

\begin_layout Standard
A profunctor 
\begin_inset Formula $P$
\end_inset

 has the 
\series bold
pre-wedge property
\series default
 if, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $p_{1}^{:P^{A,A}}$
\end_inset

, and 
\begin_inset Formula $p_{2}^{:P^{B,B}}$
\end_inset

:
\begin_inset Formula 
\[
\text{if }(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}\text{ then }p_{1}\triangleright f^{\uparrow P}=p_{2}\triangleright f^{\downarrow P}\quad.
\]

\end_inset

A profunctor 
\begin_inset Formula $P$
\end_inset

 has the 
\series bold
post-wedge property
\series default
 if, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $p_{1}^{:P^{A,A}}$
\end_inset

, and 
\begin_inset Formula $p_{2}^{:P^{B,B}}$
\end_inset

:
\begin_inset Formula 
\[
\text{if }p_{1}\triangleright f^{\uparrow P}=p_{2}\triangleright f^{\downarrow P}\text{ then }(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
In other words, the pre-wedge property means that the 
\begin_inset Formula $\left(P,f\right)$
\end_inset

-wedge relation follows from the lifted relation 
\begin_inset Formula $\left<f\right>^{\updownarrow P}$
\end_inset

, and the post-wedge property means that the lifted relation 
\begin_inset Formula $\left<f\right>^{\updownarrow P}$
\end_inset

 follows from the 
\begin_inset Formula $\left(P,f\right)$
\end_inset

-wedge relation.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-post-wedge"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A profunctor 
\begin_inset Formula $P$
\end_inset

 will have the post-wedge property if:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

 does not depend on 
\begin_inset Formula $X$
\end_inset

 or on 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We have 
\begin_inset Formula $P^{X,Y}=K^{X,Y}\times L^{X,Y}$
\end_inset

, where the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 have the post-wedge property.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 We have 
\begin_inset Formula $P^{X,Y}=K^{X,Y}+L^{X,Y}$
\end_inset

, where the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 have the post-wedge property.
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 We have 
\begin_inset Formula $P^{X,Y}=K^{Y,X}\rightarrow L^{X,Y}$
\end_inset

, where the profunctor 
\begin_inset Formula $K$
\end_inset

 has the weak pullback property and the profunctor 
\begin_inset Formula $L$
\end_inset

 has the post-wedge property.
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 We have a recursive type 
\begin_inset Formula $P^{X,Y}=S^{X,Y,P^{X,Y}}$
\end_inset

, where 
\begin_inset Formula $S^{X,Y,R}$
\end_inset

 is contravariant in 
\begin_inset Formula $X$
\end_inset

 and covariant in 
\begin_inset Formula $Y$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

, and has the post-wedge property when viewed as a profunctor with respect
 to 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Suppose 
\begin_inset Formula $P^{X,Y}=Q^{Y}$
\end_inset

 where 
\begin_inset Formula $Q$
\end_inset

 is a functor.
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a), we then have:
\begin_inset Formula 
\[
(x^{:Q^{A}},y^{:Q^{B}})\in\left<f\right>^{\updownarrow P}\text{ when }x\triangleright f^{\uparrow Q}=y\quad.
\]

\end_inset

This is equivalent to the 
\begin_inset Formula $\left(P,f\right)$
\end_inset

-wedge relation for 
\begin_inset Formula $(x,y)$
\end_inset

 because 
\begin_inset Formula $f^{\uparrow P}=f^{\uparrow Q}$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow P}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
Similarly, if 
\begin_inset Formula $P^{X,Y}=R^{X}$
\end_inset

 where 
\begin_inset Formula $R$
\end_inset

 is a contrafunctor, we have by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-lifting-relation-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b):
\begin_inset Formula 
\[
(x^{:R^{A}},y^{:R^{B}})\in\left<f\right>^{\updownarrow P}\text{ when }x=y\triangleright f^{\downarrow R}\quad.
\]

\end_inset

This is equivalent to the 
\begin_inset Formula $\left(P,f\right)$
\end_inset

-wedge relation for 
\begin_inset Formula $(x,y)$
\end_inset

 because 
\begin_inset Formula $f^{\uparrow P}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow P}=f^{\downarrow R}$
\end_inset

.
\end_layout

\begin_layout Standard
So, we have shown that the 
\begin_inset Formula $\left(P,f\right)$
\end_inset

-wedge relation for 
\begin_inset Formula $(x,y)$
\end_inset

 is 
\emph on
equivalent
\emph default
 to the relation 
\begin_inset Formula $(x,y)\in\left<f\right>^{\updownarrow P}$
\end_inset

.
 This equivalence means that 
\begin_inset Formula $P$
\end_inset

 has both the pre-wedge and the post-wedge properties.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The 
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The 
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 The 
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 The 
\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-pre-wedge"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A profunctor 
\begin_inset Formula $P$
\end_inset

 will have the pre-wedge property if:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

 does not depend on 
\begin_inset Formula $X$
\end_inset

 or on 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We have 
\begin_inset Formula $P^{X,Y}=K^{X,Y}\times L^{X,Y}$
\end_inset

, where the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 have the pre-wedge property.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 We have 
\begin_inset Formula $P^{X,Y}=K^{X,Y}+L^{X,Y}$
\end_inset

, where the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 have the pre-wedge property.
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 We have 
\begin_inset Formula $P^{X,Y}=K^{Y,X}\rightarrow L^{X,Y}$
\end_inset

, where the profunctor 
\begin_inset Formula $K$
\end_inset

 has the 
\emph on
post
\emph default
-wedge property and the profunctor 
\begin_inset Formula $L$
\end_inset

 has the pre-wedge property.
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 We have a recursive type 
\begin_inset Formula $P^{X,Y}=S^{X,Y,P^{X,Y}}$
\end_inset

, where 
\begin_inset Formula $S^{X,Y,R}$
\end_inset

 is contravariant in 
\begin_inset Formula $X$
\end_inset

 and covariant in 
\begin_inset Formula $Y$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

, and has the pre-wedge property when viewed as a profunctor with respect
 to 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a) derived also the pre-wedge property.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The 
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The 
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 The 
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 The 
\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-post-pre-wedge"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $P^{X,Y}\triangleq K^{Y,X}\rightarrow L^{X,Y}$
\end_inset

, where the profunctor 
\begin_inset Formula $K$
\end_inset

 has the post-wedge property and the profunctor 
\begin_inset Formula $L$
\end_inset

 has the pre-wedge property, then any fully parametric function 
\begin_inset Formula $g:\forall A.\,P^{A,A}$
\end_inset

 is strongly dinatural.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The strong dinaturality law of 
\begin_inset Formula $g$
\end_inset

 is written as:
\begin_inset Formula 
\[
\text{when }k_{1}^{:K^{A,A}}\triangleright f^{\uparrow K}=k_{2}^{:K^{B,B}}\triangleright f^{\downarrow K}\text{ then }g(k_{1})\triangleright f^{\uparrow L}=g(k_{2})\triangleright f^{\downarrow L}\quad.
\]

\end_inset

Since 
\begin_inset Formula $K$
\end_inset

 has the post-wedge property, we have:
\begin_inset Formula 
\[
\big(k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}\big)\quad\Rightarrow\quad(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\quad.
\]

\end_inset

The full parametricity of 
\begin_inset Formula $g$
\end_inset

 means that the relational naturality law holds:
\begin_inset Formula 
\[
(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\quad\Rightarrow\quad(g(k_{1}),g(k_{2}))\in\left<f\right>^{\updownarrow L}\quad.
\]

\end_inset

The profunctor 
\begin_inset Formula $L$
\end_inset

 has the pre-wedge property, so
\begin_inset Formula 
\[
(g(k_{1}),g(k_{2}))\in\left<f\right>^{\updownarrow L}\quad\Rightarrow\quad\big(g(k_{1})\triangleright f^{\uparrow L}=g(k_{2})\triangleright f^{\downarrow L}\big)\quad.
\]

\end_inset

This gives us the chain of implications that proves the strong dinaturality
 law of 
\begin_inset Formula $g$
\end_inset

:
\begin_inset Formula 
\[
\big(k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}\big)\Rightarrow\big((k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\big)\Rightarrow\big((g(k_{1}),g(k_{2}))\in\left<f\right>^{\updownarrow L}\big)\Rightarrow\big(g(k_{1})\triangleright f^{\uparrow L}=g(k_{2})\triangleright f^{\downarrow L}\big)\quad.
\]

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

 limits its results to type signatures 
\begin_inset Formula $\forall A.\,K^{A,A}\rightarrow L^{A,A}$
\end_inset

 with profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 having certain specific properties.
 Nevertheless, a broad range of practically encountered functions have type
 signatures of this form.
 Here are some examples.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-strong-dinaturality-for-some-type-signatures"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-strong-dinaturality-for-some-type-signatures"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with an appropriately chosen profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

 to show that strong dinaturality holds for all fully parametric functions
 with the following type signatures:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\forall A.\,G^{A}\rightarrow H^{A}$
\end_inset

 where 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are functors or contrafunctors.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow G^{A}\rightarrow H^{A}$
\end_inset

 where 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $H$
\end_inset

 are functors or contrafunctors.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\forall A.\,(F^{A}\rightarrow G^{A})\rightarrow H^{A}$
\end_inset

 where 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $H$
\end_inset

 are functors or contrafunctors.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 To represent the type 
\begin_inset Formula $\forall A.\,G^{A}\rightarrow H^{A}$
\end_inset

 as 
\begin_inset Formula $\forall A.\,P^{A,A}$
\end_inset

 with a profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

, we need to consider the four cases where 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are either covariant or contravariant.
 If 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are both covariant, we define 
\begin_inset Formula $P^{X,Y}\triangleq G^{X}\rightarrow H^{Y}$
\end_inset

.
 If 
\begin_inset Formula $G$
\end_inset

 is covariant but 
\begin_inset Formula $H$
\end_inset

 is contravariant, 
\begin_inset Formula $P^{X,Y}\triangleq G^{X}\rightarrow H^{X}$
\end_inset

.
 If 
\begin_inset Formula $G$
\end_inset

 is contravariant but 
\begin_inset Formula $H$
\end_inset

 is covariant, 
\begin_inset Formula $P^{X,Y}\triangleq G^{Y}\rightarrow H^{Y}$
\end_inset

.
 If 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are both contravariant, 
\begin_inset Formula $P^{X,Y}\triangleq G^{Y}\rightarrow H^{X}$
\end_inset

.
 In each case, 
\begin_inset Formula $P^{X,Y}=K^{Y,X}\rightarrow L^{X,Y}$
\end_inset

 where 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 depend on only one of their type parameters.
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a) and Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a), both 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 with have the pre-wedge and the post-wedge properties in all cases.
 So, the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 fulfill the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Since the function arrows group to the right, the type 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow G^{A}\rightarrow H^{A}$
\end_inset

 is of the form 
\begin_inset Formula $\forall A.\,K^{A,A}\rightarrow L^{A,A}$
\end_inset

 where 
\begin_inset Formula $K^{A,A}\cong F^{A}$
\end_inset

 and 
\begin_inset Formula $L^{A,A}\cong G^{A}\rightarrow H^{A}$
\end_inset

.
 Depending on whether 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $H$
\end_inset

 are covariant or contravariant, we need to define the profunctors 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, and 
\begin_inset Formula $P$
\end_inset

 differently.
 The profunctor 
\begin_inset Formula $L$
\end_inset

 will be of the form 
\begin_inset Formula $L^{X,Y}\triangleq M^{Y,X}\rightarrow N^{X,Y}$
\end_inset

 with some profunctors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 For instance, if 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $H$
\end_inset

 are all covariant, we need to define 
\begin_inset Formula $P^{X,Y}\triangleq F^{X}\rightarrow G^{X}\rightarrow H^{Y}$
\end_inset

, 
\begin_inset Formula $M^{X,Y}\triangleq G^{Y}$
\end_inset

, 
\begin_inset Formula $N^{X,Y}\triangleq H^{Y}$
\end_inset

.
 Reasoning as in the proof of part 
\series bold
(a)
\series default
, we conclude that in all cases the profunctors 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, and 
\begin_inset Formula $N$
\end_inset

 will depend only on one of their type parameters.
 So, the profunctors 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, and 
\begin_inset Formula $N$
\end_inset

 will have both the pre-wedge and the post-wedge properties.
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

(d), the profunctor 
\begin_inset Formula $L$
\end_inset

 will have the pre-wedge property.
 So, the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 fulfill the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The type 
\begin_inset Formula $\forall A.\,(F^{A}\rightarrow G^{A})\rightarrow H^{A}$
\end_inset

 is of the form 
\begin_inset Formula $\forall A.\,K^{A,A}\rightarrow L^{A,A}$
\end_inset

 with the profunctors 
\begin_inset Formula $K^{A,A}\cong F^{A}\rightarrow G^{A}$
\end_inset

 and 
\begin_inset Formula $L^{A,A}\cong H^{A}$
\end_inset

.
 We need to define 
\begin_inset Formula $K^{X,Y}\triangleq M^{Y,X}\rightarrow N^{X,Y}$
\end_inset

 with some profunctors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, depending on the covariance of 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

, and 
\begin_inset Formula $H$
\end_inset

.
 Reasoning as before, we find that the profunctors 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 must have both the pre-wedge and the post-wedge properties.
 In addition, Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-weak-pullback-property-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a) shows that 
\begin_inset Formula $M$
\end_inset

 has the weak pullback property.
 The post-wedge property of 
\begin_inset Formula $K$
\end_inset

 is then established via Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

(d).
 So, the profunctors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 fulfill the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We conclude this Appendix by showing that the strong dinaturality holds
 for type signatures of the form 
\begin_inset Formula $\forall A.\ (G^{A}\rightarrow A)\rightarrow A$
\end_inset

 used for the Church encoding of recursive types (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-Church-encoding-recursive-type-covariant"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-strong-dinaturality-for-Church-encoding"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-strong-dinaturality-for-Church-encoding"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that any fully parametric function 
\begin_inset Formula $g:\forall A.\ (F^{A}\rightarrow A)\rightarrow A$
\end_inset

 is strongly dinatural if 
\begin_inset Formula $F$
\end_inset

 is a covariant functor.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The type signature of 
\begin_inset Formula $g$
\end_inset

 has the form of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-strong-dinaturality-for-some-type-signatures"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c) with 
\begin_inset Formula $G^{A}\triangleq A$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq A$
\end_inset

.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
We have proved several results that apply to all fully parametric code:
\end_layout

\begin_layout Itemize
The lifting methods of any fully parametric bifunctor, profunctor, or bi-contraf
unctor obey the commutativity law such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Because of this, any fully parametric type constructor 
\begin_inset Formula $F^{A,B}$
\end_inset

 which is a functor separately with respect to 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 is always a bifunctor whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 method satisfies the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-bimap-composition-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Similar properties hold for profunctors and for bi-contrafunctors.
 The proof goes by induction on the exponential-polynomial type expression
 of 
\begin_inset Formula $F^{A,B}$
\end_inset

, which must be built up via the six type constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:six-pure-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Itemize
Any function of type 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 (where 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 are profunctors) obeys the dinaturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-dinatural-transformations-of-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which allows us to derive a specific naturality law for any fully parametric
 function.
 The form of the law depends only on the function's type signature and applies
 to all fully parametric implementations of that type signature.
 The proof goes by induction on the structure of the expression, which must
 be built up via the nine code constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:nine-pure-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Itemize
The lifting methods of functors and contrafunctors can be implemented in
 only one way once the identity and composition laws are imposed.
 The unique correct implementations are defined by the standard procedures
 shown in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and there are no other inequivalent implementations.
 Here, we do not distinguish 
\emph on
equivalent
\emph default
 implementations such as 
\begin_inset Formula $f(x)$
\end_inset

 and 
\begin_inset Formula $(y\rightarrow y)(f)(x)$
\end_inset

, which are syntactically different programs but will always give the same
 results.
 So, there is only one lawful implementation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contrafunctor
\end_layout

\end_inset

 typeclass instances for a given type constructor.
 (For many other typeclasses, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, many type constructors have several inequivalent and lawful typeclass
 instances.)
\end_layout

\begin_layout Itemize
Any fully parametric expression 
\begin_inset Formula $t:\forall A.\,Q^{A}$
\end_inset

 satisfies the relational naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Itemize
In general, the relational naturality law expresses a property of 
\emph on
relations
\emph default
 rather than functions.
 So, the relational naturality law of 
\begin_inset Formula $t$
\end_inset

 may not be equivalent to any equation satisfied by the function 
\begin_inset Formula $t$
\end_inset

.
 However, there are two cases where the relational naturality law is reduced
 to an equation for 
\begin_inset Formula $t$
\end_inset

: First, 
\begin_inset Formula $t$
\end_inset

 satisfies the dinaturality law.
 Second, if the type signature of 
\begin_inset Formula $t$
\end_inset

 satisfies the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the function 
\begin_inset Formula $t$
\end_inset

 satisfies the strong dinaturality law.
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-parametricity-theorem-via-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 derives the dinaturality law of 
\begin_inset Formula $t$
\end_inset

 by structural analysis of the code of 
\begin_inset Formula $t$
\end_inset

, but the proof depends on Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-dinatural-transformation-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, whose proof is incomplete as shown.
 We also did not derive the dinaturality law of 
\begin_inset Formula $t$
\end_inset

 directly from the relational parametricity law.
 It appears that the dinaturality law cannot be derived purely by structural
 analysis of code but requires more complicated methods that are beyond
 the scope of this book.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Janis Voigtl
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\begin_inset Quotes erd
\end_inset

a
\end_layout

\end_inset

nder
\begin_inset Index idx
status open

\begin_layout Plain Layout
Janis@Janis Voigtl
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\begin_inset Quotes erd
\end_inset

a
\end_layout

\end_inset

nder
\end_layout

\end_inset

 gave a general derivation of the dinaturality law from the relational parametri
city theorem in the paper 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/pdf/1908.07776.pdf"
literal "false"

\end_inset


\family default
.
 Another derivation of the dinaturality law, based on obtaining the syntactic
 normal form of dinatural transformations, was given by Joachim de Lataillade
\begin_inset Index idx
status open

\begin_layout Plain Layout
Joachim de Lataillade
\end_layout

\end_inset

 in the paper 
\begin_inset Quotes eld
\end_inset

Dinatural terms in System 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

: see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.irif.fr/~delatail/dinat.pdf"

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Chapter
Solutions of some exercises
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def at(n: Double, maxN: Int) = (0 to maxN)
\end_layout

\begin_layout Plain Layout

  .map { k => 1.0*(1 - k % 2 * 2) / (2 * k + 1) / math.pow(n, 2 * k + 1) }
\end_layout

\begin_layout Plain Layout

  .sum
\end_layout

\begin_layout Plain Layout

def p(n: Int) = 16 * at(5, n) - 4 * at(239, n)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> p(12)
\end_layout

\begin_layout Plain Layout

res0: Double = 3.141592653589794
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isPrime(n: Int) = (2 to n - 1).takeWhile(k => k * k <= n).forall(k =>
 n % k != 0)
\end_layout

\begin_layout Plain Layout

def ep(n: Int): Double = (2 to n)
\end_layout

\begin_layout Plain Layout

  .filter(isPrime)
\end_layout

\begin_layout Plain Layout

  .map  { k => 1.0 / (1.0 - 1.0 / k / k / k /k) }
\end_layout

\begin_layout Plain Layout

  .product
\end_layout

\begin_layout Plain Layout

val pi = 3.1415926535897932
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ep(100); pi*pi*pi*pi/90
\end_layout

\begin_layout Plain Layout

res0_0: Double = 1.0823231553280295
\end_layout

\begin_layout Plain Layout

res0_1: Double = 1.082323233711138 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

numsLists.map(_.sortBy(- _).take(3))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a.flatMap(x => b.map(y => (x, y)))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-12"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def payments[Person, Amount](data: Seq[Map[Person, Amount]]): Map[Person,
 Seq[Amount]] =
\end_layout

\begin_layout Plain Layout

  data.flatMap(_.toSeq).groupBy(_._1).mapValues(_.map(_._2))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def batching[A](xs: Seq[A], size: Int): Seq[Seq[A]] = {  
\end_layout

\begin_layout Plain Layout

  type Acc = (Seq[Seq[A]], Seq[A], Int)
\end_layout

\begin_layout Plain Layout

  val init: Acc = ((Seq(), Seq(), 0))
\end_layout

\begin_layout Plain Layout

  val (result, rem, _) = xs.foldLeft(init){ case ((seq, rem, len), x) =>
\end_layout

\begin_layout Plain Layout

    val newLen = len + 1
\end_layout

\begin_layout Plain Layout

    if (newLen > size) (seq ++ Seq(rem), Seq(x), 1)
\end_layout

\begin_layout Plain Layout

    else (seq, rem ++ Seq(x), newLen)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  result ++ Seq(rem)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def weightBatching[A](xs: Seq[A], maxW: Double)(w: A => Double): Seq[Seq[A]]
 = {  
\end_layout

\begin_layout Plain Layout

  type Acc = (Seq[Seq[A]], Seq[A], Double)
\end_layout

\begin_layout Plain Layout

  val init: Acc = ((Seq(), Seq(), 0.0))
\end_layout

\begin_layout Plain Layout

  val (result, rem, _) = xs.foldLeft(init) { case ((seq, rem, weight), x)
 =>
\end_layout

\begin_layout Plain Layout

    val wx = w(x)
\end_layout

\begin_layout Plain Layout

    if (wx > maxW) (seq ++ Seq(rem, Seq(x)), Seq(), 0.0)
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      val newWeight = weight + wx
\end_layout

\begin_layout Plain Layout

      if (newWeight > maxW) (seq ++ Seq(rem), Seq(x), wx)
\end_layout

\begin_layout Plain Layout

      else (seq, rem ++ Seq(x), newWeight)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  result ++ Seq(rem)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def groupBy[A, K](xs: Seq[A])(by: A => K): Map[K, Seq[A]] = {  
\end_layout

\begin_layout Plain Layout

  val init: Map[K, Seq[A]] = Map()
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(init) { (res, x) =>
\end_layout

\begin_layout Plain Layout

    val key = by(x)
\end_layout

\begin_layout Plain Layout

    val seq = res.getOrElse(key, Seq()) ++ Seq(x)
\end_layout

\begin_layout Plain Layout

    res.updated(key, seq)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ !=
 0).map(_ % 10).toList
\end_layout

\begin_layout Plain Layout

def cubeDigits(n: Int): Int = digitsOf(n).map(x => x*x*x).sum
\end_layout

\begin_layout Plain Layout

def cubes(n: Int): Stream[Int] = Stream.iterate(n)(cubeDigits)
\end_layout

\begin_layout Plain Layout

def stopRepeats[T](str: Stream[T]): Stream[T] = {
\end_layout

\begin_layout Plain Layout

  val halfSpeed = str.flatMap(x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

  val result = halfSpeed.zip(str).drop(1).takeWhile{ case (h, s) => h != s
 }.map(_._2)
\end_layout

\begin_layout Plain Layout

  if (result.isEmpty) str.take(1) else str
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def cubesReach1(n: Int): Boolean = stopRepeats(cubes(n)).contains(1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prod3(a: Set[Int], b: Set[Int], c: Set[Int]): Set[Set[Int]] =
\end_layout

\begin_layout Plain Layout

  a.flatMap(x => b.flatMap(y => c.map(z => Set(x, y, z))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prodSet(sets: Set[Set[Int]]): Set[Set[Int]] =
\end_layout

\begin_layout Plain Layout

    sets.foldLeft(Set[Set[Int]](Set())) {
\end_layout

\begin_layout Plain Layout

      // Combine each of results so far with each element in current set
\end_layout

\begin_layout Plain Layout

      case (accumSet: Set[Set[Int]], currSet: Set[Int]) =>
\end_layout

\begin_layout Plain Layout

        for {
\end_layout

\begin_layout Plain Layout

          s <- accumSet
\end_layout

\begin_layout Plain Layout

          i <- currSet
\end_layout

\begin_layout Plain Layout

        } yield s + i
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def pairs(goal: Int, xs: Array[Int])(
\end_layout

\begin_layout Plain Layout

  res: Set[(Int, Int)] = Set(), left: Int = 0, right: Int = xs.length): Set[(Int,
 Int)] =
\end_layout

\begin_layout Plain Layout

    if (left == right) res else {
\end_layout

\begin_layout Plain Layout

      val sum = xs(left) + xs(right - 1)
\end_layout

\begin_layout Plain Layout

      val (newLeft, newRight, newRes) = if (sum == goal) 
\end_layout

\begin_layout Plain Layout

                  (left + 1, right, res + ((xs(left), xs(right - 1)))) 
\end_layout

\begin_layout Plain Layout

                else if (sum < goal)
\end_layout

\begin_layout Plain Layout

                  (left + 1, right, res)
\end_layout

\begin_layout Plain Layout

                else (left, right - 1, res)
\end_layout

\begin_layout Plain Layout

      pairs(goal, xs)(newRes, newLeft, newRight)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2revdigits-Exercise-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ !=
 0).map(_ % 10).toList
\end_layout

\begin_layout Plain Layout

def revDigits(n: Int): Int = digitsOf(n).foldLeft(0){case (acc, d) => acc
 * 10 + d }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def isPalindrome(n: Int): Boolean = revDigits(n) == n
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findPalindrome(n: Int): Int = 
\end_layout

\begin_layout Plain Layout

  Stream.iterate(n) { x => x + revDigits(x) }
\end_layout

\begin_layout Plain Layout

        .filter(isPalindrome).take(1).toList.head
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-9-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def unfold2[A,B](init: A)(next: A => Option[(A,B)]): Stream[B] = next(init)
 match {
\end_layout

\begin_layout Plain Layout

   case None => Stream()
\end_layout

\begin_layout Plain Layout

   case Some((a, b)) => Stream.cons(b, unfold2(a)(next))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-non-empty-list-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList[A](nel: NEL[A]): List[A] = nel match {
\end_layout

\begin_layout Plain Layout

  case Last(x)         => List(x)
\end_layout

\begin_layout Plain Layout

  case More(x, tail)   => x :: toList(tail)
\end_layout

\begin_layout Plain Layout

} // Not tail-recursive.
\end_layout

\begin_layout Plain Layout

def toList[A](nel: NEL[A]): List[A] = foldLeft(nel)(Nil:List[A]) {
\end_layout

\begin_layout Plain Layout

  (prev, x) =>  x :: prev
\end_layout

\begin_layout Plain Layout

}.reverse // Tail-recursive, but performs two traversals.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-EvenList"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait EvenList[A]
\end_layout

\begin_layout Plain Layout

final case class Lempty[A]() extends EvenList[A]
\end_layout

\begin_layout Plain Layout

final case class Lpair[A](x: A, y: A, tail: EvenList[A]) extends EvenList
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def fmap[A, B](f: A => B): EvenList[A] => EvenList[B] = {
\end_layout

\begin_layout Plain Layout

case Lempty() => Lempty[B]()
\end_layout

\begin_layout Plain Layout

case Lpair(x, y, tail) => Lpair[B](f(x), f(y), fmap(f)(tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def convergeN[X](p: X => Boolean)(x:X)(m:Int)(f: X => X): Option[X]
 =  {
\end_layout

\begin_layout Plain Layout

              if (m <= 0) None
\end_layout

\begin_layout Plain Layout

              else if (p(x)) Some(x) else converge(p)(f(x))(m-1)(f)    
         }
\end_layout

\begin_layout Plain Layout

// Defining it as def convergeN[X]: (X => Boolean) => X => Int => (X =>
 X) => Option[X] = ???
\end_layout

\begin_layout Plain Layout

// will break tail recursion!
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-7-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def recover[E, A]: Option[Either[E, A]] => (E => A) => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case None => _ => None
\end_layout

\begin_layout Plain Layout

  case Some(Right(a)) => _ => Some(a)
\end_layout

\begin_layout Plain Layout

  case Some(Left(e)) => f => Some(f(e))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-composition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Choose 
\begin_inset Formula $f^{:A\rightarrow A}\triangleq\_\rightarrow z$
\end_inset

 and compute 
\begin_inset Formula $(f\bef h)(x)=h(z)\overset{!}{=}h(x)$
\end_inset

, for any 
\begin_inset Formula $x$
\end_inset

.
 So, 
\begin_inset Formula $h(x)$
\end_inset

 equals a fixed value 
\begin_inset Formula $h(z)$
\end_inset

.
 It follows that the value 
\begin_inset Formula $h(x)$
\end_inset

 does not depend on 
\begin_inset Formula $x$
\end_inset

, i.e., 
\begin_inset Formula $h$
\end_inset

 is a constant function.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Choose 
\begin_inset Formula $f^{:A\rightarrow B}\triangleq\_\rightarrow b$
\end_inset

 and compute 
\begin_inset Formula $(f\bef h)(x)=h(b)\overset{!}{=}(g\bef f)(x)=f(g(x))=b$
\end_inset

.
 It follows that 
\begin_inset Formula $h(b)=b$
\end_inset

 for any 
\begin_inset Formula $b^{:B}$
\end_inset

, so 
\begin_inset Formula $h$
\end_inset

 is an identity function.
 Substitute that into the law and get 
\begin_inset Formula $f=g\bef f$
\end_inset

 for any function 
\begin_inset Formula $f$
\end_inset

.
 Substitute 
\begin_inset Formula $f\triangleq\text{id}$
\end_inset

 into that and derive 
\begin_inset Formula $\text{id}=g\bef\text{id}=g$
\end_inset

.
 So, 
\begin_inset Formula $g$
\end_inset

 is the identity function.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $A\times\text{Int}+A\times\text{Char}+A\times\text{Float}$
\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
It is assumed that 
\begin_inset Formula $\phi:\forall A.\,F^{A}\rightarrow G^{A}$
\end_inset

 satisfies its naturality law: for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow F}\bef\phi=\phi\bef f^{\uparrow G}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 To verify the naturality law of 
\begin_inset Formula $\phi^{\uparrow K}$
\end_inset

: for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow F\uparrow K}\bef\phi^{\uparrow K}\overset{?}{=}\phi^{\uparrow K}\bef f^{\uparrow G\uparrow K}\quad,\\
\text{composition under }^{\uparrow K}:\quad & (f^{\uparrow F}\bef\phi)^{\uparrow K}\overset{?}{=}(\phi\bef f^{\uparrow G})^{\uparrow K}\quad.
\end{align*}

\end_inset

The last equation holds due to the naturality law of 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The naturality law of the pair product (
\begin_inset Formula $\phi\boxtimes\psi$
\end_inset

) says that for any 
\begin_inset Formula $p^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
p^{\uparrow(F\times K)}\bef(\phi\boxtimes\psi)\overset{?}{=}(\phi\boxtimes\psi)\bef p^{\uparrow(G\times L)}\quad.
\]

\end_inset

Begin with the left-hand side of this equation:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p^{\uparrow(F\times K)}\bef(\phi\boxtimes\psi)\\
\text{definition of }^{\uparrow(F\times K)}:\quad & =\big(f^{:F^{A}}\times k^{:K^{A}}\rightarrow(f\triangleright p^{\uparrow F})\times(k\triangleright p^{\uparrow K})\big)\bef(\phi\boxtimes\psi)\\
\text{definition of }\phi\boxtimes\psi:\quad & =f\times k\rightarrow\phi(f\triangleright p^{\uparrow F})\times\psi(k\triangleright p^{\uparrow K})=f\times k\rightarrow(f\triangleright p^{\uparrow F}\bef\phi)\times(k\triangleright p^{\uparrow K}\bef\psi)\quad.
\end{align*}

\end_inset

To rewrite the right-hand side, introduce the function argument into 
\begin_inset Formula $\phi\boxtimes\psi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & (\phi\boxtimes\psi)\bef p^{\uparrow(G\times L)}=\big(f^{:F^{A}}\times k^{:K^{A}}\rightarrow(f\triangleright\phi)\times(k\triangleright\psi)\big)\bef p^{\uparrow(G\times L)}\\
\text{definition of }^{\uparrow(G\times L)}:\quad & =f\times k\rightarrow(f\triangleright\gunderline{\phi\triangleright p^{\uparrow G}})\times(k\triangleright\gunderline{\psi\triangleright p^{\uparrow L}})=f\times k\rightarrow(f\triangleright\phi\bef p^{\uparrow G})\times(k\triangleright\psi\bef p^{\uparrow L})\quad.
\end{align*}

\end_inset

The remaining differences between the two sides disappear due to the naturality
 laws of 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

:
\begin_inset Formula 
\[
p^{\uparrow F}\bef\phi=\phi\bef p^{\uparrow G}\quad,\quad\quad p^{\uparrow K}\bef\psi=\psi\bef p^{\uparrow L}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The naturality law of the pair co-product (
\begin_inset Formula $\phi\boxplus\psi$
\end_inset

) says that for any 
\begin_inset Formula $p^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
p^{\uparrow(F+K)}\bef(\phi\boxplus\psi)\overset{?}{=}(\phi\boxplus\psi)\bef p^{\uparrow(G+L)}\quad.
\]

\end_inset

Begin with the left-hand side of this equation:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p^{\uparrow(F+K)}\bef(\phi\boxplus\psi)\\
\text{definitions of }^{\uparrow(F+K)}\text{ and of }\phi\boxplus\psi:\quad & =\,\begin{array}{|c||cc|}
 & F^{B} & K^{B}\\
\hline F^{A} & p^{\uparrow F} & \bbnum 0\\
K^{A} & \bbnum 0 & p^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{B} & \phi & \bbnum 0\\
K^{B} & \bbnum 0 & \psi
\end{array}\\
\text{matrix composition}:\quad & =\,\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{A} & p^{\uparrow F}\bef\phi & \bbnum 0\\
K^{A} & \bbnum 0 & p^{\uparrow K}\bef\psi
\end{array}\quad.
\end{align*}

\end_inset

The right-hand side is rewritten in a similar way:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & (\phi\boxplus\psi)\bef p^{\uparrow(G+L)}\\
 & =\,\begin{array}{|c||cc|}
 & G^{A} & L^{A}\\
\hline F^{A} & \phi & \bbnum 0\\
K^{A} & \bbnum 0 & \psi
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline G^{A} & p^{\uparrow G} & \bbnum 0\\
L^{A} & \bbnum 0 & p^{\uparrow L}
\end{array}\,=\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{A} & \phi\bef p^{\uparrow G} & \bbnum 0\\
K^{A} & \bbnum 0 & \psi\bef p^{\uparrow L}
\end{array}\quad.
\end{align*}

\end_inset

The remaining differences between the two sides disappear due to the naturality
 laws of 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidFunc[A: Monoid, R] = Monoid[R => A](
\end_layout

\begin_layout Plain Layout

  { (x, y) => r => x(r) |+| y(r) }, _ => implicitly[Monoid[A]].empty
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the code notation:
\begin_inset Formula 
\[
f^{:R\rightarrow A}\oplus g^{:R\rightarrow A}\triangleq a\rightarrow f(a)\oplus_{A}g(a)\quad,\quad\quad e\triangleq(\_\rightarrow e_{A})\quad.
\]

\end_inset

Proof of monoid laws:
\begin_inset Formula 
\begin{align*}
 & a\triangleright\left(\left(f\oplus g\right)\oplus h\right)=\left(a\triangleright(f\oplus g)\right)\oplus_{A}h(a)=f(a)\oplus_{A}g(a)\oplus_{A}h(a)\quad.\\
 & a\triangleright\left(f\oplus\left(g\oplus h\right)\right)=f(a)\oplus_{A}\left(a\triangleright(g\oplus h)\right)=f(a)\oplus_{A}g(a)\oplus_{A}h(a)\quad.\\
 & a\triangleright\left(e\oplus f\right)=e(a)\oplus_{A}f(a)=e_{A}\oplus_{A}f(a)=f(a)=a\triangleright f\quad.\\
 & a\triangleright(f\oplus e)=f(a)\oplus_{A}e(a)=f(a)\oplus_{A}e_{A}=f(a)=a\triangleright f\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-9-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 A counterexample is the functor 
\begin_inset Formula $F^{A}\triangleq R\rightarrow A$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

 is a fixed type.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The function 
\begin_inset Formula $C^{A}\times C^{B}\rightarrow C^{A+B}$
\end_inset

 cannot be implemented for 
\begin_inset Formula $C^{A}\triangleq\left(A\rightarrow P\right)+\left(A\rightarrow Q\right)$
\end_inset

.
 This more complicated contrafunctor 
\begin_inset Formula $C$
\end_inset

 is necessary because the simpler contrafunctor 
\begin_inset Formula $C^{A}\triangleq A\rightarrow P$
\end_inset

 does not provide a counterexample.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-9-1-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define the method 
\begin_inset Formula $\text{ex}_{F}$
\end_inset

 as 
\begin_inset Formula 
\[
\text{ex}_{F}\triangleq x^{:F^{A}}\rightarrow x\triangleright(a^{:A}\rightarrow a\times1)^{\uparrow F}\triangleright q^{A,\bbnum 1}\triangleright\pi_{1}\quad\text{ or equivalently: }\quad\text{ex}_{F}\triangleq(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\pi_{1}\quad.
\]

\end_inset

To show that the naturality law (
\begin_inset Formula $f^{\uparrow F}\bef\text{ex}_{F}=\text{ex}_{F}\bef f$
\end_inset

) holds, use the identity 
\begin_inset Formula $(f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow F}\bef\text{ex}_{F}=\gunderline{f^{\uparrow F}\bef(a^{:A}\rightarrow a\times1)^{\uparrow F}}\bef q^{A,\bbnum 1}\bef\pi_{1}=(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef\gunderline{(f\boxtimes\text{id})^{\uparrow F}\bef q^{A,\bbnum 1}}\bef\pi_{1}\\
 & =(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\gunderline{(f\boxtimes\text{id}^{\uparrow F})\bef\pi_{1}}=\gunderline{(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\pi_{1}}\bef f=\text{ex}_{F}\bef f\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Given a method 
\begin_inset Formula $\text{ex}_{F}$
\end_inset

, define 
\begin_inset Formula $q$
\end_inset

 as 
\begin_inset Formula 
\[
q^{A,B}\triangleq f^{:F^{A\times B}}\rightarrow(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright\pi_{2}^{\uparrow F})\quad\text{ or equivalently: }\quad q^{A,B}\triangleq\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id})\quad.
\]

\end_inset

Show that the required laws hold for 
\begin_inset Formula $q$
\end_inset

.
 Identity law: 
\begin_inset Formula 
\[
f\triangleright q^{\bbnum 1,B}=(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{\bbnum 1})\times(f\triangleright\pi_{2}^{\uparrow F})=1\times(f\triangleright\pi_{2}^{\uparrow F})
\]

\end_inset

because 
\begin_inset Formula $\text{ex}_{F}^{\bbnum 1}$
\end_inset

 produces a value of type 
\begin_inset Formula $\bbnum 1$
\end_inset

, which can only be 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Standard
Naturality law:
\begin_inset Formula 
\begin{align*}
(f^{:A\rightarrow C}\boxtimes g^{:B\rightarrow D})^{\uparrow F}\bef\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id}) & =\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id})\bef f\boxtimes(g^{\uparrow F})\\
\Delta\bef((f\boxtimes g)^{\uparrow F}\boxtimes(f\boxtimes g)^{\uparrow F})\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id}) & =\Delta\bef(\pi_{1}^{\uparrow F}\bef\text{ex}_{F}\bef f)\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F})\\
\Delta\bef(\pi_{1}^{\uparrow F}\bef\,\gunderline{f^{\uparrow F}\bef\text{ex}_{F}})\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F}) & =\Delta\bef(\pi_{1}^{\uparrow F}\bef\,\gunderline{\text{ex}_{F}\bef f})\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F})
\end{align*}

\end_inset

Associativity law: the left-hand side is
\begin_inset Formula 
\begin{align*}
 & f^{:F^{A\times B\times C}}\triangleright q^{A,B\times C}\bef(\text{id}^{A}\boxtimes q^{B,C})=(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright q^{B,C})\\
 & =(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{B})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright\pi_{2}^{\uparrow F})\\
 & =\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a)\right)\times\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow b)\right)\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\quad.
\end{align*}

\end_inset

The right-hand side is
\begin_inset Formula 
\begin{align*}
 & f^{:F^{A\times B\times C}}\triangleright q^{A\times B,C}=(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a\times b))\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\\
 & =\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a)\right)\times\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow b)\right)\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:filt-exercise-derive-liftOpt-equivalence-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Starting from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

's law, derive the naturality law:
\begin_inset Formula 
\[
\text{liftOpt}\left(g\right)\bef\text{liftOpt}\,(f\bef\text{pu}_{\text{Opt}})=\text{liftOpt}(f\bef\text{pu}_{\text{Opt}}\diamond_{_{\text{Opt}}}g)=\text{liftOpt}(f\bef g)\quad.
\]

\end_inset

Now use the naturality-identity law and get 
\begin_inset Formula $\text{liftOpt}\,(f\bef\text{pu}_{\text{Opt}})=f^{\downarrow C}$
\end_inset

.
 The result is the naturality law 
\begin_inset Formula $\text{liftOpt}\left(f\bef g\right)=\text{liftOpt}\left(g\right)\bef f^{\downarrow C}$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-filterable-laws-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A counterexample is the functor 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times\left(Z\rightarrow A\right)$
\end_inset

.
 For this functor, one can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

's type signature, but the code cannot obey the identity law because it
 must always return 
\begin_inset Formula $1+\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-flatten-concat-distributive-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The values 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 must have type 
\begin_inset Formula $\text{List}^{\text{List}^{A}}$
\end_inset

.
 There are two possibilities: 
\begin_inset Formula $p$
\end_inset

 is an empty list (
\begin_inset Formula $p=1+\bbnum 0$
\end_inset

), and 
\begin_inset Formula $p=\bbnum 0+h\times t$
\end_inset

.
 If 
\begin_inset Formula $p$
\end_inset

 is empty, so is 
\begin_inset Formula $p\triangleright\text{ftn}$
\end_inset

 and the law holds.
 In the other case, we have (due to the code of 
\begin_inset Formula $\pplus$
\end_inset

) that
\begin_inset Formula 
\[
\left(\bbnum 0+h\times t\right)\pplus q=\bbnum 0+h\times\left(t\pplus q\right)\quad,
\]

\end_inset

and so
\begin_inset Formula 
\begin{align*}
 & \left(p\pplus q\right)\triangleright\text{ftn}=\left(\bbnum 0+h\times\left(t\pplus q\right)\right)\triangleright\text{ftn}=h\pplus\gunderline{\left(t\pplus q\right)\triangleright\overline{\text{ftn}}}\\
\text{inductive assumption}:\quad & =\gunderline{h\pplus(t\triangleright\overline{\text{ftn}})}\pplus(q\triangleright\overline{\text{ftn}})\\
\text{code of }\text{ftn}:\quad & =\left(\bbnum 0+h\times t\right)\triangleright\overline{\text{ftn}}\pplus(q\triangleright\overline{\text{ftn}})=\left(p\triangleright\text{ftn}\right)\pplus\left(q\triangleright\text{ftn}\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define the empty element (
\begin_inset Formula $e_{M}$
\end_inset

) of the monoid 
\begin_inset Formula $M^{W}$
\end_inset

 as 
\begin_inset Formula 
\[
e_{M}\triangleq\text{pu}_{M}(e_{W})\quad.
\]

\end_inset

The binary operation 
\begin_inset Formula $\oplus_{M}$
\end_inset

 of the monoid 
\begin_inset Formula $M^{W}$
\end_inset

 may be implemented through 
\begin_inset Formula $\oplus_{W}$
\end_inset

 as
\begin_inset Formula 
\[
p\oplus_{M}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow q\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\quad.
\]

\end_inset

To check the left identity law of 
\begin_inset Formula $M^{W}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p:\quad & e_{M}\oplus_{M}p=e_{W}\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}\big(u^{:W}\rightarrow p\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\\
 & =e_{W}\triangleright\big(u^{:W}\rightarrow p\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)=p\triangleright(v\rightarrow\gunderline{e_{W}\oplus_{W}v})^{\uparrow M}\\
\text{left identity law of }W:\quad & =p\triangleright(v\rightarrow v)^{\uparrow M}=p\triangleright\text{id}^{\uparrow M}=p\quad.
\end{align*}

\end_inset

To check the right identity law of 
\begin_inset Formula $M^{W}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p:\quad & p\oplus_{M}e_{M}=p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow e_{W}\triangleright\gunderline{\text{pu}_{M}\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}}\big)\\
\text{naturality of }\text{pu}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow\gunderline{e_{W}\triangleright(v^{:W}}\rightarrow u\oplus_{W}v)\triangleright\text{pu}_{M}\big)\\
\text{apply function}:\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow(\gunderline{u\oplus_{W}e_{W}})\triangleright\text{pu}_{M}\big)\\
\text{right identity law of }W:\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow u\triangleright\text{pu}_{M}\big)=p\triangleright\text{id}=p\quad.
\end{align*}

\end_inset

To check the associativity law of 
\begin_inset Formula $M^{W}$
\end_inset

, we use the associativity law of 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (p\oplus_{M}q)\oplus_{M}r\\
 & =p\triangleright\gunderline{\text{flm}_{M}}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\,\gunderline{\triangleright\text{flm}_{M}}\big(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M}\big)\\
\text{associativity of }\text{flm}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(\gunderline (u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v)^{\uparrow M}\gunderline{)\bef}\,\text{flm}_{M}(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M})\big)\\
\text{compute composition}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v\gunderline{)^{\uparrow M}\triangleright\text{flm}_{M}}(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M})\big)\\
\text{naturality of }\text{flm}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow\gunderline{u\oplus_{W}v})\,\gunderline{\bef(t}\rightarrow r\triangleright(w\rightarrow\gunderline t\oplus_{W}w)^{\uparrow M}))\big)\\
\text{compute composition}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow(u\oplus_{W}v)\oplus_{W}w)^{\uparrow M})\big)\quad.
\end{align*}

\end_inset

Now write the right-hand side of the law:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & p\oplus_{M}(q\oplus_{M}r)=p\triangleright\text{flm}_{M}\big(u\rightarrow(q\oplus r)\triangleright(t\rightarrow u\oplus_{W}t)^{\uparrow M}\big)\\
\text{substitute }q\oplus r:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow v\oplus_{W}w)^{\uparrow M})\,\gunderline{\triangleright\,(}t\rightarrow u\oplus_{W}t\gunderline{)^{\uparrow M}}\big)\\
\text{naturality of }\text{flm}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow u\oplus_{W}w\gunderline{)^{\uparrow M}\bef}\,(t\rightarrow u\oplus_{W}t\gunderline{)^{\uparrow M}})\big)\\
\text{composition under }^{\uparrow M}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow u\oplus_{W}(v\oplus_{W}w))^{\uparrow M})\big)\quad.
\end{align*}

\end_inset

 The difference between the two sides is now exactly the associativity law
 of 
\begin_inset Formula $W$
\end_inset

, which we assume:
\begin_inset Formula 
\[
(u\oplus_{W}v)\oplus_{W}w\overset{!}{=}u\oplus_{W}(v\oplus_{W}w)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-9-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b)
\end_layout

\begin_layout Standard
The code is converted into monad methods like this,
\begin_inset Formula 
\begin{align*}
 & r_{1}=p\triangleright\text{flm}_{M}(x\rightarrow q\triangleright(y\rightarrow f(x,y))^{\uparrow M})\quad,\\
 & r_{2}=q\triangleright\text{flm}_{M}(y\rightarrow p\triangleright(x\rightarrow f(x,y))^{\uparrow M})\quad.
\end{align*}

\end_inset

The monoid operation 
\begin_inset Formula $\oplus_{M}$
\end_inset

 is defined by
\begin_inset Formula 
\[
p^{:M^{\bbnum 1}}\oplus_{M}q^{:M^{\bbnum 1}}\triangleq p\triangleright\text{flm}_{M}(1\rightarrow q)=p\triangleright(1\rightarrow q)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

Commutativity of 
\begin_inset Formula $\oplus_{M}$
\end_inset

 means that
\begin_inset Formula 
\[
p\oplus_{M}q=q\oplus_{M}p=q\triangleright\text{flm}_{M}(1\rightarrow p)=q\triangleright(1\rightarrow p)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

Use 
\begin_inset Formula $f(x,y)\triangleq1$
\end_inset

 in the above conditions for 
\begin_inset Formula $r_{1}$
\end_inset

, 
\begin_inset Formula $r_{2}$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-12"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The second possible definition, 
\begin_inset Formula $\text{pu}_{L}\triangleq a\rightarrow\bbnum 0+\text{pu}_{F}(a)$
\end_inset

, fails the right identity law:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\,\begin{array}{|c||ccc|}
 & A & F^{A} & F^{L^{A}}\\
\hline A & \bbnum 0 & \text{pu}_{F} & \bbnum 0\\
F^{A} & \bbnum 0 & \bbnum 0 & \text{pu}_{L}^{\uparrow F}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & F^{A}\\
\hline A & \text{id} & \bbnum 0\\
F^{A} & \bbnum 0 & \text{id}\\
F^{L^{A}} & \bbnum 0 & \gamma^{\uparrow F}\bef\text{ftn}_{F}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & F^{A}\\
\hline A & \bbnum 0 & \text{pu}_{F}\\
F^{A} & \bbnum 0 & ...
\end{array}\,\neq\text{id}\quad.
\end{align*}

\end_inset

This matrix cannot be equal to the identity function because it has a missing
 diagonal element.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-composition-mm"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is a semimonad, we have the Kleisli composition 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

 that already satisfies the associativity law.
 Define 
\begin_inset Formula $\diamond_{_{L}}$
\end_inset

 by
\begin_inset Formula 
\[
f^{:A\rightarrow M^{M^{B}}}\diamond_{_{L}}g^{:B\rightarrow M^{M^{C}}}\triangleq f\bef\text{ftn}_{M}\diamond_{_{M}}g\quad.
\]

\end_inset

Here, parentheses are unnecessary as shown in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-equivalence-kleisli-composition-and-flatMap"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
It is inconvenient to mix the Kleisli composition and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method, so we express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 as
\begin_inset Formula 
\[
\text{ftn}_{M}^{:M^{M^{A}}\rightarrow M^{A}}=\text{flm}_{M}(\text{id}^{:M^{A}\rightarrow M^{A}})=\text{id}^{:M^{M^{A}}\rightarrow M^{M^{A}}}\diamond_{_{M}}\text{id}^{:M^{A}\rightarrow M^{A}}\quad.
\]

\end_inset

For brevity, we will omit type annotations from now on.
 So, we can expression the Kleisli composition 
\begin_inset Formula $\diamond_{_{L}}$
\end_inset

 through 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

 by
\begin_inset Formula 
\[
f\diamond_{_{L}}g\triangleq f\bef\gunderline{\left(\text{id}\diamond_{_{M}}\text{id}\right)\diamond_{_{M}}g}=f\bef\left(\text{id}\diamond_{_{M}}\left(\text{id}\diamond_{_{M}}g\right)\right)=\left(f\bef\text{id}\right)\diamond_{_{M}}\left(\text{id}\diamond_{_{M}}g\right)=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Associativity of 
\begin_inset Formula $\diamond_{_{L}}$
\end_inset

 then follows from associativity of 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

 as:
\begin_inset Formula 
\begin{align*}
\left(f\diamond_{_{L}}g\right)\diamond_{_{L}}h & =\left(f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\right)\diamond_{_{M}}\text{id}\diamond_{_{M}}h=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\quad,\\
f\diamond_{_{L}}\left(g\diamond_{_{L}}h\right) & =f\diamond_{_{M}}\text{id}\diamond_{_{M}}\left(g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\right)=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This definition of 
\begin_inset Formula $\diamond_{_{L}}$
\end_inset

 corresponds to a definition of 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 that flattens the first three layers of 
\begin_inset Formula $M$
\end_inset

 in 
\begin_inset Formula $M\circ M\circ M\circ M$
\end_inset

.
\begin_inset Formula 
\[
\text{ftn}_{L}\triangleq\text{ftn}_{M}\bef\text{ftn}_{M}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
An alternative definition will flatten the last three layers:
\begin_inset Formula 
\[
\text{ftn}_{L}\triangleq(\text{ftn}_{M}\bef\text{ftn}_{M})^{\uparrow M}\quad.
\]

\end_inset

Both definitions satisfy the associativity law and so define a semimonad
 
\begin_inset Formula $L$
\end_inset

,
\begin_inset Formula 
\[
\text{ftn}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\text{ftn}_{L}\bef\text{ftn}_{L}\quad.
\]

\end_inset

Let us verify that directly.
 For the first definition:
\begin_inset Formula 
\begin{align*}
 & \gunderline{(\text{ftn}_{M}\bef\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\big(\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
\text{associativity of }M:\quad & =\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}^{\uparrow M\uparrow M}}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}=\gunderline{\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\bef\gunderline{\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\\
\text{associativity of }M:\quad & =\text{ftn}_{M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

For the second definition, we just apply 
\begin_inset Formula $^{\uparrow M}$
\end_inset

 for the preceding derivation.
\end_layout

\begin_layout Standard
A definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 that flattens separately the first two and the last two layers of 
\begin_inset Formula $M$
\end_inset

 (
\begin_inset Formula $\text{ftn}_{L}\triangleq\text{ftn}_{M}\bef\text{ftn}_{M}^{\uparrow M}$
\end_inset

) will fail the associativity law when 
\begin_inset Formula $M$
\end_inset

 is chosen in a suitable way.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is a full monad, we have 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 that satisfies the identity laws.
 Define 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

 by
\begin_inset Formula 
\[
\text{pu}_{L}\triangleq\text{pu}_{M}\bef\text{pu}_{M}\quad.
\]

\end_inset

There is no other way of defining 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

 since we cannot obtain an arbitrary value of type 
\begin_inset Formula $M^{A}$
\end_inset

 other than via 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

.
\end_layout

\begin_layout Standard
With any of the two possible definitions of 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

, at least one of the identity laws for 
\begin_inset Formula $\diamond_{_{L}}$
\end_inset

 fails.
\end_layout

\begin_layout Standard
For the definition of 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 that flattens the first three layers, the right identity law will fail:
\begin_inset Formula 
\[
\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\gunderline{(\text{pu}_{M}\bef\text{pu}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\text{pu}_{M}^{\uparrow M}\bef\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}=\text{ftn}_{M}\bef\text{pu}_{M}^{\uparrow M}\quad.
\]

\end_inset

In general, this function is not equal to an identity function, because
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 merges the two monadic layers of 
\begin_inset Formula $M$
\end_inset

 and in that way loses information about a value of type 
\begin_inset Formula $M^{M^{A}}$
\end_inset

.
\end_layout

\begin_layout Standard
For the definition of 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 that flattens the last three layers, the left identity law will fail:
\begin_inset Formula 
\[
\text{pu}_{L}\bef\text{ftn}_{L}=\text{pu}_{M}\bef\gunderline{\text{pu}_{M}\bef(\text{ftn}_{M}}\bef\text{ftn}_{M})^{\uparrow M}=\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\bef\text{pu}_{M}\bef\text{ftn}_{M}^{\uparrow M}=\text{pu}_{M}\bef\text{ftn}_{M}^{\uparrow M}=\text{ftn}_{M}\bef\text{pu}_{M}\quad.
\]

\end_inset

In general, this function is not equal to an identity function.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The identity law of monad morphisms says that 
\begin_inset Formula $\text{pu}_{\bbnum 1}\bef\phi=\text{pu}_{M}$
\end_inset

.
 However, 
\begin_inset Formula $\text{pu}_{\bbnum 1}=\_^{:A}\rightarrow1$
\end_inset

 and ignores its argument.
 So, 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 is also a function that ignores its argument.
 By the monad 
\begin_inset Formula $M$
\end_inset

's left identity law, 
\begin_inset Formula $\text{pu}_{M}\bef\text{ftn}_{M}=\text{id}^{:M^{A}\rightarrow M^{A}}$
\end_inset

.
 So, the identity function 
\begin_inset Formula $\text{id}:M^{A}\rightarrow M^{A}$
\end_inset

 ignores its argument.
 It always returns the same value of type 
\begin_inset Formula $M^{A}$
\end_inset

, say 
\begin_inset Formula $m_{0}$
\end_inset

.
 It follows that the type 
\begin_inset Formula $M^{A}$
\end_inset

 has only one distinct value, namely 
\begin_inset Formula $m_{0}$
\end_inset

.
 So 
\begin_inset Formula $M^{A}\cong\bbnum 1$
\end_inset

.
 This argument holds for each type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For any monad morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

, the monadic naturality law must hold:
\begin_inset Formula 
\[
\text{dbl}\bef\phi\overset{?}{=}\phi\bef\text{dbl}\quad.
\]

\end_inset

The left-hand side applied to an arbitrary value 
\begin_inset Formula $m^{:M^{A}}$
\end_inset

 is:
\begin_inset Formula 
\begin{align*}
 & m\triangleright\text{dbl}\bef\phi=m\triangleright(\_\rightarrow m)^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\phi}\\
\text{monad morphism law of }\phi:\quad & =m\triangleright\gunderline{(\_\rightarrow m)^{\uparrow M}\bef\phi^{\uparrow M}}\bef\phi\bef\text{ftn}_{M}\\
\text{compute composition}:\quad & =m\triangleright\gunderline{(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\phi}\bef\text{ftn}_{M}\\
\text{naturality of }\phi:\quad & =m\triangleright\phi\bef(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

The right-hand side applied to 
\begin_inset Formula $m$
\end_inset

 is:
\begin_inset Formula 
\begin{align*}
 & m\triangleright\phi\bef\text{dbl}=m\triangleright\phi\triangleright\text{dbl}=m\triangleright\phi\triangleright(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =m\triangleright\phi\bef(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The identity law holds:
\begin_inset Formula 
\[
a\triangleright\text{pu}_{M}\bef\text{dbl}=a\triangleright\text{pu}_{M}\triangleright\text{flm}_{M}(\_\rightarrow a\triangleright\text{pu}_{M})=a\triangleright(\_\rightarrow a\triangleright\text{pu}_{M})=a\triangleright\text{pu}_{M}\quad.
\]

\end_inset

The composition law:
\begin_inset Formula 
\[
\text{dbl}^{\uparrow M}\bef\text{dbl}\bef\text{ftn}_{M}\overset{?}{=}\text{ftn}_{M}\bef\text{dbl}\quad.
\]

\end_inset

Simplify the left-hand side, applying to an arbitrary value 
\begin_inset Formula $p:M^{M^{A}}$
\end_inset

.
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p\triangleright\text{dbl}^{\uparrow M}\bef\text{dbl}\bef\text{ftn}_{M}=p\triangleright\text{dbl}^{\uparrow M}\triangleright(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\\
\text{associativity law of }M:\quad & =p\triangleright\text{dbl}^{\uparrow M}\bef(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})^{\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\big(\text{dbl}\bef(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})\bef\text{ftn})\big)^{\uparrow M}\bef\text{ftn}_{M}=p\triangleright\big(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M}\bef\text{ftn}_{M})\big)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\text{flm}_{M}\big(\_\rightarrow p\triangleright\text{flm}_{M}(\text{dbl})\big)\quad.
\end{align*}

\end_inset

The right-hand side:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & p\triangleright\text{ftn}_{M}\bef\text{dbl}=p\triangleright\gunderline{\text{ftn}_{M}\bef(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M}}\bef\text{ftn}_{M}\\
\text{naturality of }\text{ftn}_{M}:\quad & =p\triangleright(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\\
\text{associativity law of }M:\quad & =p\triangleright(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\big((\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\text{flm}_{M}\big(\text{flm}_{M}(\_\rightarrow p\triangleright\text{ftn}_{M})\big)\quad.
\end{align*}

\end_inset

The simplification is stuck — we cannot make the two sides coincide; no
 law can be applied to simplify further.
\end_layout

\begin_layout Standard
Choosing specific values 
\begin_inset Formula $p=\text{pu}_{M}(m)$
\end_inset

 or 
\begin_inset Formula $p=\text{pu}_{M}^{\uparrow M}(m)$
\end_inset

 does not help to obtain a counter-example: the laws hold for those specific
 choices.
\end_layout

\begin_layout Standard
To obtain a counter-example, consider a specific non-commutative monad,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 For the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

double
\end_layout

\end_inset

 function repeats the entire list as many times as elements in the list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> double(List(1, 2))
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 1, 2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val ll = List(List(1, 2), List(3))
\end_layout

\begin_layout Plain Layout

ll: List[List[Int]] = List(List(1, 2), List(3))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> double(ll.flatten)
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 1, 2, 3, 1, 2, 3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> double(ll.map(double))
\end_layout

\begin_layout Plain Layout

res2: List[List[Int]] = List(List(1, 2, 1, 2), List(3), List(1, 2, 1, 2),
 List(3)) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> double(ll.map(double)).flatten
\end_layout

\begin_layout Plain Layout

res3: List[Int] = List(1, 2, 1, 2, 3, 1, 2, 1, 2, 3)
\end_layout

\end_inset

The composition law does not hold.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-search-and-selector-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The identity law does not hold:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }a\triangleright\text{pu}_{\text{Search}}:\quad & a\triangleright\text{pu}_{\text{Sel}}\bef\text{finder}=(\_^{:A\rightarrow\bbnum 1+P}\rightarrow a)\triangleright\text{finder}\\
 & =p\rightarrow p(a)\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
P & \bbnum 0 & a
\end{array}\,=p\rightarrow a\triangleright p\bef(\_\rightarrow a)^{\uparrow\text{Opt}}\neq p\rightarrow\bbnum 0+a\quad.
\end{align*}

\end_inset

The result should have been 
\begin_inset Formula $\text{pu}_{\text{Search}}(a)=\_\rightarrow\text{pu}_{\text{Opt}}(a)=\_\rightarrow\bbnum 0+a$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-selector-and-continuation-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }a\triangleright\text{pu}_{\text{Cont}}:\quad & a\triangleright\text{pu}_{\text{Sel}}\bef\text{scc}=f\rightarrow f(f\triangleright(\gunderline{a\triangleright\text{pu}_{\text{Sel}}}))\\
\text{use definition of }\text{pu}_{\text{Sel}}:\quad & =f\rightarrow f(f\triangleright(\_\rightarrow a))=f\rightarrow f(a)=a\triangleright\text{pu}_{\text{Cont}}\quad.
\end{align*}

\end_inset

To verify the composition law, we begin with the flipped Kleisli formulation
 of the two monads.
 The flipped Kleisli functions have types 
\begin_inset Formula $\left(B\rightarrow P\right)\rightarrow A\rightarrow P$
\end_inset

 (for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

) and 
\begin_inset Formula $\left(B\rightarrow P\right)\rightarrow A\rightarrow B$
\end_inset

 (for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset

).
\begin_inset Formula 
\begin{align*}
 & f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow P}\tilde{\diamond}_{_{\text{Cont}}}g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow P}\triangleq h^{:C\rightarrow P}\rightarrow h\triangleright g\triangleright f=g\bef f\quad,\\
 & f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow B}\tilde{\diamond}_{_{\text{Sel}}}g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow C}\triangleq h^{:C\rightarrow P}\rightarrow f(g(h)\bef h)\bef g(h)\quad.
\end{align*}

\end_inset

We need to check that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset

's Kleisli composition (
\begin_inset Formula $\tilde{\diamond}_{_{\text{Sel}}}$
\end_inset

) is mapped to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

's Kleisli composition (
\begin_inset Formula $\tilde{\diamond}_{_{\text{Cont}}}$
\end_inset

).
 First, we need to modify 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

 so that it works on the flipped Kleisli functions:
\begin_inset Formula 
\[
\tilde{\text{scc}}^{A,B}:\left(\left(B\rightarrow P\right)\rightarrow A\rightarrow B\right)\rightarrow\left(B\rightarrow P\right)\rightarrow A\rightarrow P\quad,\quad\tilde{\text{scc}}=c^{:\left(\left(B\rightarrow P\right)\rightarrow A\rightarrow B\right)}\rightarrow k^{:B\rightarrow P}\rightarrow c(k)\bef k\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Note that the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

 is uniquely determined by its type signature, and so is the implementation
 of 
\begin_inset Formula $\tilde{\text{scc}}$
\end_inset

.
 So, we can spare ourselves the effort of translating 
\begin_inset Formula $\text{scc}$
\end_inset

 into 
\begin_inset Formula $\tilde{\text{scc}}$
\end_inset

.
\end_layout

\begin_layout Standard
Now it remains to show that for any 
\begin_inset Formula $f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow C}$
\end_inset

 the law holds:
\begin_inset Formula 
\[
(f\triangleright\tilde{\text{scc}}^{A,B})\tilde{\diamond}_{_{\text{Cont}}}(g\triangleright\tilde{\text{scc}}^{B,C})=(f\tilde{\diamond}_{_{\text{Sel}}}g)\triangleright\tilde{\text{scc}}^{A,C}\quad.
\]

\end_inset

Rewrite the two sides of the law separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (f\triangleright\tilde{\text{scc}})\tilde{\diamond}_{_{\text{Cont}}}(g\triangleright\tilde{\text{scc}})=(g\triangleright\tilde{\text{scc}})\bef(f\triangleright\tilde{\text{scc}})=(k\rightarrow g(k)\bef k)\bef(h\rightarrow f(h)\bef h)\\
 & \quad=k\rightarrow f(g(k)\bef k)\bef g(k)\bef k\quad,\\
\text{right-hand side}:\quad & (f\tilde{\diamond}_{_{\text{Sel}}}g)\triangleright\tilde{\text{scc}}=\big(h\rightarrow f(g(h)\bef h)\bef g(h)\big)\triangleright\tilde{\text{scc}}=k\rightarrow\big(h\rightarrow f(g(h)\bef h)\bef g(h)\big)(k)\bef k\\
 & \quad=k\rightarrow f(g(k)\bef k)\bef g(k)\bef k\quad.
\end{align*}

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The operations 
\begin_inset Formula $\text{pu}_{N}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{N}$
\end_inset

 are defined by
\begin_inset Formula 
\[
\text{pu}_{N}\triangleq\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\quad,\quad\quad\text{ftn}_{N}\triangleq\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}:\quad & \text{pu}_{N}\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\text{pu}_{M}\quad.
\end{align*}

\end_inset

To verify the composition law, transform separately the two sides of the
 law:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \gamma_{M}\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{N^{A}}\\
\hline N^{A} & \text{pu}_{M}\\
M^{N^{A}} & \text{id}
\end{array}\,\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline N^{A} & \gunderline{\text{pu}_{M}\bef\gamma_{M}^{\uparrow M}}\bef\text{ftn}_{M}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\\
 & \quad=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline N^{A} & \gamma_{M}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad,\\
\text{right-hand side}:\quad & \text{ftn}_{N}\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\end{align*}

\end_inset

The two sides are now equal.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The operations 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{N}$
\end_inset

 are defined as usual for a free pointed monad:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{L}\triangleq\,\begin{array}{|c||c|}
 & L^{A}\\
\hline L^{A} & \text{id}\\
K^{L^{A}} & k\rightarrow\bbnum 0+k\triangleright\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\quad,\\
 & \text{ftn}_{N}\triangleq\,\begin{array}{|c||c|}
 & N^{A}\\
\hline N^{A} & \text{id}\\
M^{N^{A}} & m\rightarrow\bbnum 0+m\triangleright\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We define 
\begin_inset Formula $\psi$
\end_inset

 by
\begin_inset Formula 
\[
\psi=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law for 
\begin_inset Formula $\psi$
\end_inset

:
\begin_inset Formula 
\[
\text{pu}_{L}\bef\psi=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,=\text{pu}_{N}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law for 
\begin_inset Formula $\psi$
\end_inset

, write both sides of the law separately:
\begin_inset Formula 
\begin{align*}
\psi^{\uparrow L}\bef\psi\bef\text{ftn}_{N} & =\,\begin{array}{|c||ccc|}
 & A & M^{A} & K^{N^{A}}\\
\hline A & \text{id} & \bbnum 0 & \bbnum 0\\
K^{A} & \bbnum 0 & \phi & \bbnum 0\\
K^{L^{A}} & \bbnum 0 & \bbnum 0 & \psi^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||ccc|}
 & A & M^{A} & M^{N^{A}}\\
\hline A & \text{id} & \bbnum 0 & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id} & \bbnum 0\\
K^{N^{A}} & \bbnum 0 & \bbnum 0 & \phi
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\\
 & =\,\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi\\
K^{L^{A}} & \bbnum 0 & \psi^{\uparrow K}\bef\phi\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad,\\
\text{ftn}_{L}\bef\psi & =\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi
\end{array}\quad.
\end{align*}

\end_inset

It remains to show that
\begin_inset Formula 
\[
\psi^{\uparrow K}\bef\phi\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi\quad.
\]

\end_inset

The monad morphism law for 
\begin_inset Formula $\phi$
\end_inset

 gives
\begin_inset Formula 
\[
\phi\bef\phi^{\uparrow M}\bef\text{ftn}_{M}=\text{ftn}_{K}\bef\phi\quad.
\]

\end_inset

It remains to show that
\begin_inset Formula 
\begin{align*}
 & \gunderline{\psi^{\uparrow K}\bef\phi}\bef\gamma_{M}^{\uparrow M}\overset{?}{=}\gunderline{\gamma_{K}^{\uparrow K}\bef\phi}\bef\phi^{\uparrow M}\quad.\\
 & \phi\bef\psi^{\uparrow M}\bef\gamma_{M}^{\uparrow M}=\phi\bef(\psi\bef\gamma_{M})^{\uparrow M}\overset{?}{=}\phi\bef\gamma_{K}^{\uparrow M}\bef\phi^{\uparrow M}=\phi\bef(\gamma_{K}\bef\phi)^{\uparrow M}\quad.
\end{align*}

\end_inset

It remains to show that 
\begin_inset Formula $\psi\bef\gamma_{M}=\gamma_{K}\bef\phi$
\end_inset

.
 For that, we use the identity law of 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \psi\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \phi
\end{array}\quad,\\
 & \gamma_{K}\bef\phi=\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\,\bef\phi=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \gunderline{\text{pu}_{K}\bef\phi}\\
K^{A} & \phi
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \phi
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Verify the naturality law of 
\begin_inset Formula $\psi$
\end_inset

, assuming the naturality laws of 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\chi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (f^{:A\rightarrow B})^{\uparrow(K+L)}\bef\psi=\,\begin{array}{|c||cc|}
 & K^{B} & L^{B}\\
\hline K^{A} & f^{\uparrow K} & \bbnum 0\\
L^{A} & \bbnum 0 & f^{\uparrow L}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{B} & \phi\\
L^{B} & \chi
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \gunderline{f^{\uparrow K}\bef\phi}\\
L^{A} & \gunderline{f^{\uparrow L}\bef\chi}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \phi\bef f^{\uparrow M}\\
L^{A} & \chi\bef f^{\uparrow M}
\end{array}\quad,\\
 & \psi\bef f^{\uparrow M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline K^{A} & \phi\\
L^{A} & \chi
\end{array}\,\bef f^{\uparrow M}=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \phi\bef f^{\uparrow M}\\
L^{A} & \chi\bef f^{\uparrow M}
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Given the definitions of 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\chi$
\end_inset

, we can write 
\begin_inset Formula $\psi$
\end_inset

 as
\begin_inset Formula 
\[
\psi=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline K^{A} & \phi\\
L^{A} & \chi
\end{array}\quad.
\]

\end_inset

Assuming the naturality law of 
\begin_inset Formula $\psi$
\end_inset

, verify the naturality law of 
\begin_inset Formula $\phi$
\end_inset

 by applying to an arbitrary value 
\begin_inset Formula $k^{:K^{A}}$
\end_inset

 and expressing 
\begin_inset Formula $f^{\uparrow K}$
\end_inset

 through 
\begin_inset Formula $f^{\uparrow(K+L)}$
\end_inset

: 
\begin_inset Formula 
\begin{align*}
\text{expect to equal }k\triangleright\phi\bef f^{\uparrow M}:\quad & k\triangleright f^{\uparrow K}\bef\phi=k\triangleright f^{\uparrow K}\triangleright(k\rightarrow k+\bbnum 0)\triangleright\psi=\big((k\triangleright f^{\uparrow K})+\bbnum 0\big)\triangleright\psi\\
 & =(k+\bbnum 0)\triangleright\,\begin{array}{|c||cc|}
 & K^{B} & L^{B}\\
\hline K^{A} & f^{\uparrow K} & \bbnum 0\\
L^{A} & \bbnum 0 & f^{\uparrow L}
\end{array}\,\bef\psi=(k+\bbnum 0)\triangleright\gunderline{f^{\uparrow(K+L)}\bef\psi}\\
\text{naturality law of }\psi:\quad & =(\gunderline{k+\bbnum 0})\triangleright\psi\bef f^{\uparrow M}=k\triangleright\gunderline{(x\rightarrow x+\bbnum 0)\bef\psi}\bef f^{\uparrow M}=k\triangleright\phi\bef f^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The proof of the naturality law of 
\begin_inset Formula $\chi$
\end_inset

 is analogous.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Choose the monads 
\begin_inset Formula $K^{A}\triangleq R\rightarrow A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq S\rightarrow A$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 are fixed (but arbitrary) types.
 Define 
\begin_inset Formula $P^{A}\triangleq A+T_{K}^{M,A}$
\end_inset

 and show that there exist no monad morphisms 
\begin_inset Formula $\phi:M^{A}\rightarrow P^{A}$
\end_inset

.
 If such 
\begin_inset Formula $\phi$
\end_inset

 exists, it must satisfy the identity law, 
\begin_inset Formula $\text{pu}_{M}\bef\phi=\text{pu}_{P}$
\end_inset

.
 The type signature of 
\begin_inset Formula $\phi$
\end_inset

 is
\begin_inset Formula 
\[
\phi:(R\rightarrow A)\rightarrow A+(S\rightarrow R\rightarrow A)\quad.
\]

\end_inset

The only fully parametric implementation is
\begin_inset Formula 
\[
\phi:f^{:R\rightarrow A}\rightarrow\bbnum 0+(\_^{:S}\rightarrow f)\quad,
\]

\end_inset

because we cannot produce values of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 since we cannot create values of the unknown type 
\begin_inset Formula $R$
\end_inset

.
 However, this implementation of 
\begin_inset Formula $\phi$
\end_inset

 does not satisfy the identity law since 
\begin_inset Formula $\text{pu}_{P}$
\end_inset

 must return values of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Given 
\begin_inset Formula $\theta_{K}:K^{A}\rightarrow M^{A}$
\end_inset

, we define 
\begin_inset Formula 
\[
\theta_{L}:L^{A}\rightarrow M^{A}\quad,\quad\quad\theta_{L}\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \theta_{K}
\end{array}\quad.
\]

\end_inset

The proof becomes shorter if we express 
\begin_inset Formula 
\[
\theta_{L}=\gamma_{K}\bef\theta_{K}\quad,\quad\quad\gamma_{K}\triangleq\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\quad.
\]

\end_inset

We already know that 
\begin_inset Formula $\gamma_{K}:L\leadsto K$
\end_inset

 is a monad morphism (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, 
\begin_inset Formula $\theta_{L}$
\end_inset

 is a composition of monad morphisms.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Choose 
\begin_inset Formula $K^{A}\triangleq\bbnum 1$
\end_inset

 (the unit monad) and note that 
\begin_inset Formula $L^{A}=A+\bbnum 1$
\end_inset

 is the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 monad (there are no other lawful monad implementations for the type constructor
 
\begin_inset Formula $L^{A}\triangleq A+\bbnum 1$
\end_inset

).
 Choose 
\begin_inset Formula $M\triangleq L$
\end_inset

, so that a monad morphism 
\begin_inset Formula $\theta_{L}\triangleq\text{id}^{:L\leadsto M}$
\end_inset

 exists.
 If it were possible to define a monad morphism 
\begin_inset Formula $K\leadsto M$
\end_inset

, we would have a monad morphism 
\begin_inset Formula $\bbnum 1\rightarrow\bbnum 1+A$
\end_inset

, but this is impossible: the only natural transformation of type 
\begin_inset Formula $\bbnum 1\rightarrow\bbnum 1+A$
\end_inset

 is 
\begin_inset Formula $1\rightarrow1+\bbnum 0$
\end_inset

, which does not satisfy the identity law of monad morphisms, 
\begin_inset Formula $\text{pu}_{K}\bef\theta_{K}=\text{pu}_{M}$
\end_inset

, since it never returns any values of type 
\begin_inset Formula $\bbnum 0+A$
\end_inset

.
 (Generally, the existence of a monad morphism 
\begin_inset Formula $\bbnum 1\leadsto M$
\end_inset

 means that 
\begin_inset Formula $M=\bbnum 1$
\end_inset

.)
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 By Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we have a natural transformation 
\begin_inset Formula $\theta_{K}:K^{A}\rightarrow A$
\end_inset

 defined by 
\begin_inset Formula 
\[
\theta_{K}\triangleq(k\rightarrow\bbnum 0+k)\bef\theta_{L}\quad.
\]

\end_inset

The given runner 
\begin_inset Formula $\theta_{L}$
\end_inset

 is then expressed through 
\begin_inset Formula $\theta_{K}$
\end_inset

 as
\begin_inset Formula 
\[
\theta_{L}=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\quad,
\]

\end_inset

because the natural transformation in the upper row of the matrix has the
 type signature 
\begin_inset Formula $A\rightarrow A$
\end_inset

 and so must be an identity function.
\end_layout

\begin_layout Standard
It remains to verify the monad morphism laws of 
\begin_inset Formula $\theta_{K}:K\leadsto\text{Id}$
\end_inset

.
 The identity law is
\begin_inset Formula 
\[
\text{pu}_{K}\bef\theta_{K}\overset{?}{=}\text{pu}_{\text{Id}}=\text{id}\quad.
\]

\end_inset

 Since the function 
\begin_inset Formula $p\triangleq\text{pu}_{K}\bef\theta_{K}$
\end_inset

 has type signature 
\begin_inset Formula $A\rightarrow A$
\end_inset

 and is a natural transformation (as a composition of two natural transformation
s), that function must satisfy 
\begin_inset Formula $p\bef f=f\bef p$
\end_inset

 for any function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and so 
\begin_inset Formula $p$
\end_inset

 must be equal to the identity function.
\end_layout

\begin_layout Standard
The composition law of 
\begin_inset Formula $\theta_{K}$
\end_inset

 is an equation for functions of type 
\begin_inset Formula $K^{K^{A}}\rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{K}\bef\theta_{K}\overset{?}{=}\theta_{K}^{\uparrow K}\bef\theta_{K}\bef\text{ftn}_{\text{Id}}=\theta_{K}\bef\theta_{K}\quad.
\]

\end_inset

Applied to an arbitrary value 
\begin_inset Formula $k:K^{K^{A}}$
\end_inset

, this law becomes
\begin_inset Formula 
\[
k\triangleright\text{ftn}_{K}\bef\theta_{K}\overset{?}{=}k\triangleright\theta_{K}^{\uparrow K}\bef\theta_{K}\quad.
\]

\end_inset

Since 
\begin_inset Formula $\theta_{K}$
\end_inset

 is defined via 
\begin_inset Formula $\theta_{L}$
\end_inset

, we need to use the composition law of 
\begin_inset Formula $\theta_{L}$
\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{L}\bef\theta_{L}\overset{!}{=}\theta_{L}^{\uparrow L}\bef\theta_{L}\bef\text{ftn}_{\text{Id}}=\theta_{L}^{\uparrow K}\bef\theta_{L}\quad.
\]

\end_inset

Rewrite this law as
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{L}\bef\theta_{L}=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}\\
K^{L^{A}} & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}
\end{array}\quad,\\
 & \theta_{L}^{\uparrow L}\bef\theta_{L}=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \theta_{L}^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}\\
K^{L^{A}} & \theta_{L}^{\uparrow K}\bef\theta_{K}
\end{array}\quad.
\end{align*}

\end_inset

The third rows of the matrices give the equation for functions of type 
\begin_inset Formula $K^{L^{A}}\rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}\theta_{L}^{\uparrow K}\bef\theta_{K}\quad.
\]

\end_inset

Apply both sides of this equation to an arbitrary value 
\begin_inset Formula $p$
\end_inset

 of type 
\begin_inset Formula $K^{\bbnum 0+K^{A}}$
\end_inset

, defined via an arbitrary value 
\begin_inset Formula $k^{:K^{K^{A}}}$
\end_inset

 as 
\begin_inset Formula $p\triangleq k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & p\triangleright\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}p\triangleright\theta_{L}^{\uparrow K}\bef\theta_{K}\quad,\\
\text{or equivalently}:\quad & k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}\bef\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}\bef\theta_{L}^{\uparrow K}\bef\theta_{K}\quad.
\end{align*}

\end_inset

We compute some sub-expressions separately:
\begin_inset Formula 
\begin{align*}
 & (x\rightarrow\bbnum 0+x)\bef\gamma_{K}=(x\rightarrow\bbnum 0+x)\bef\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\,=x\rightarrow x=\text{id}\quad,\\
 & (x\rightarrow\bbnum 0+x)\bef\theta_{L}=\theta_{K}\quad.
\end{align*}

\end_inset

After these simplifications, the composition law of 
\begin_inset Formula $\theta_{L}$
\end_inset

 gives
\begin_inset Formula 
\[
k\triangleright\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}k\triangleright\theta_{K}^{\uparrow K}\bef\theta_{K}\quad.
\]

\end_inset

This is the composition law of 
\begin_inset Formula $\theta_{K}$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the monad morphism 
\begin_inset Formula $\varepsilon:K\leadsto\bbnum 1$
\end_inset

 defined by 
\begin_inset Formula $\varepsilon\triangleq\_\rightarrow1$
\end_inset

.
 (This is a monad morphism because all its laws reduce to the equation 
\begin_inset Formula $1=1$
\end_inset

.) By Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can implement a corresponding monad morphism between free pointed monads
 
\begin_inset Formula $\text{Id}+K\leadsto\text{Id}+\bbnum 1$
\end_inset

.
 Define 
\begin_inset Formula $\delta$
\end_inset

 as that monad morphism.
 The monad 
\begin_inset Formula $\text{Id}+\bbnum 1$
\end_inset

 (the free pointed monad on 
\begin_inset Formula $\bbnum 1$
\end_inset

) is the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 monad.
 So, we have implemented a monad morphism 
\begin_inset Formula $\delta:A+K^{A}\rightarrow\text{Opt}^{A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-effectful-list-not-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Consider the requirement of mapping 
\begin_inset Formula $L^{L^{A}}\rightarrow L^{A}$
\end_inset

 via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 function:
\begin_inset Formula 
\[
\text{ftn}_{L}:\bbnum 1+L^{A}\times M^{L^{L^{A}}}\rightarrow\bbnum 1+A\times M^{L^{A}}\quad,\quad\quad\text{ftn}_{L}=\text{???}
\]

\end_inset

The result value of this function cannot always be 
\begin_inset Formula $1$
\end_inset

, or else it will fail the monad laws.
 This function must sometimes return a pair of type 
\begin_inset Formula $A\times M^{L^{A}}$
\end_inset

.
 Let us rewrite the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 as
\begin_inset Formula 
\[
\text{ftn}_{L}:\bbnum 1+(\bbnum 1+A\times M^{L^{A}})\times M^{L^{L^{A}}}\rightarrow\bbnum 1+A\times M^{L^{A}}\quad.
\]

\end_inset

Consider input values of the form 
\begin_inset Formula 
\[
x\triangleq\bbnum 0^{:\bbnum 1}+(1+\bbnum 0^{:A\times M^{L^{A}}})\times m^{:M^{L^{L^{A}}}}\quad.
\]

\end_inset

the result of evaluating 
\begin_inset Formula $\text{ftn}_{L}(x)$
\end_inset

 must be 
\begin_inset Formula $1+\bbnum 0$
\end_inset

: a fully parametric function cannot extract values of type 
\begin_inset Formula $A$
\end_inset

 from a value of type 
\begin_inset Formula $M^{A}$
\end_inset

 with an unknown monad 
\begin_inset Formula $M$
\end_inset

.
 Note that the value 
\begin_inset Formula $(1+\bbnum 0^{:A\times M^{L^{A}}})$
\end_inset

 represents an empty list; let us denote that value by 
\begin_inset Formula $\text{Nil}^{:L^{A}}$
\end_inset

.
 So, we must have
\begin_inset Formula 
\[
\text{ftn}_{L}(\bbnum 0+\text{Nil}\times(...))=\text{Nil}\quad.
\]

\end_inset

Since the only way to extract list values is to run the 
\begin_inset Formula $M$
\end_inset

-effects, the implementation of 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 must proceed recursively, extracting list elements left to right.
 Now consider 
\begin_inset Formula $M=\text{Id}$
\end_inset

 (so we can simply omit the functor layers of 
\begin_inset Formula $M$
\end_inset

) and the nested list value
\begin_inset Formula 
\[
z\triangleq\left[p,q,\text{Nil},r,s,...\right]\quad,
\]

\end_inset

 where 
\begin_inset Formula $p$
\end_inset

, 
\begin_inset Formula $q$
\end_inset

, 
\begin_inset Formula $r$
\end_inset

, 
\begin_inset Formula $s$
\end_inset

 are some sub-lists of type 
\begin_inset Formula $L^{A}$
\end_inset

 with some type 
\begin_inset Formula $A$
\end_inset

.
 Then the value 
\begin_inset Formula $z$
\end_inset

 has the form
\begin_inset Formula 
\[
z=\bbnum 0+p\times(\bbnum 0+q\times(\bbnum 0+\text{Nil}\times(\bbnum 0+r\times(\bbnum 0+s\times(1+\bbnum 0)))))\quad.
\]

\end_inset

As we must have 
\begin_inset Formula $\text{ftn}_{L}(\bbnum 0+\text{Nil}\times t)=\text{Nil}$
\end_inset

 for any 
\begin_inset Formula $t^{:M^{L^{L^{A}}}}$
\end_inset

, the recursive evaluation of 
\begin_inset Formula $\text{ftn}_{L}(z)$
\end_inset

 will give
\begin_inset Formula 
\[
\text{ftn}_{L}(z)=...\text{ftn}_{L}(\bbnum 0+\text{Nil}\times(\bbnum 0+r\times(\bbnum 0+s\times(1+\bbnum 0))))=...\text{Nil}\quad.
\]

\end_inset

So, the result may be some function of 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 (which could be 
\begin_inset Formula $p\pplus q$
\end_inset

) but cannot depend on 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

.
 We have shown that 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 must ignore all sub-lists that follow an empty sub-list.
 Regardless of how we implement 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 (and whether it satisfies the monad laws), the result of evaluating 
\begin_inset Formula $\text{ftn}_{L}(z)$
\end_inset

 cannot be the full concatenation 
\begin_inset Formula $p\pplus q\pplus r\pplus s$
\end_inset

 because the computation must ignore the sub-lists 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We will now implement the non-standard monad instance for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 constructor
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def pure[A](x: A): List[A] = List(x) // $
\backslash
color{dkgreen}
\backslash
textrm{pu}_L$
\end_layout

\begin_layout Plain Layout

def flatten[A](p: List[List[A]]): List[A] = if (p.exists(_.isEmpty)) Nil else
 p.flatten  // $
\backslash
color{dkgreen}
\backslash
textrm{ftn}_L$
\end_layout

\end_inset

The new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 function gives exactly the same results as the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type constructor, except if one of the nested sub-lists is empty.
 In that case, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 function returns an empty list (unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method).
\end_layout

\begin_layout Standard
To verify the monad laws, we use the known fact that the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad obeys the laws.
 So, we only need to check the laws in the cases when the new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 function is applied to a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[A]]
\end_layout

\end_inset

 having an empty nested sub-list.
 That case cannot arise in the identity laws since neither 
\begin_inset Formula $\text{pu}_{L}(x^{:A})$
\end_inset

 nor 
\begin_inset Formula $\text{pu}_{L}^{\uparrow L}(x^{:\text{List}^{A}})$
\end_inset

 ever returns a value with a nested empty sub-list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pure(List(a, b, c)) == List(List(a, b, c))
\end_layout

\begin_layout Plain Layout

List(a, b, c).map(pure) == List(List(a), List(b), List(c))
\end_layout

\end_inset

Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 to these values will always give back the initial list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(a, b, c)
\end_layout

\end_inset

.
 So, both identity laws hold.
\end_layout

\begin_layout Standard
It remains to check the associativity law, which is an equality between
 functions 
\begin_inset Formula $\text{ftn}_{L}\bef\text{ftn}_{L}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{L}^{\uparrow L}\bef\text{ftn}_{L}$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[List[A]]] => List[A]
\end_layout

\end_inset

.
 A value 
\begin_inset Formula $p$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[List[A]]]
\end_layout

\end_inset

 could contain a nested empty list at the first and/or the second nesting
 depth, for instance:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val p1: List[List[List[Int]]] = List(List[List[Int]](), List(List(123),
 List(456)))
\end_layout

\begin_layout Plain Layout

val p2: List[List[List[Int]]] = List(List(List[Int](), List(123)), List(List(456
)))
\end_layout

\end_inset

Whenever 
\begin_inset Formula $p$
\end_inset

 contains an empty sub-list at the first nesting depth, we will have 
\begin_inset Formula $p\triangleright\text{ftn}_{L}=\text{Nil}$
\end_inset

 because 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 explicitly checks for the existence of an empty sub-list.
 So, 
\begin_inset Formula $p\triangleright\text{ftn}_{L}\bef\text{ftn}_{L}=\text{Nil}$
\end_inset

.
 On the other hand, 
\begin_inset Formula $p\triangleright\text{ftn}_{L}^{\uparrow L}$
\end_inset

 will be again a list containing an empty sub-list, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> p1.map(flatten)
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(), List(123, 456))
\end_layout

\end_inset

We will then have 
\begin_inset Formula $p\triangleright\text{ftn}_{L}^{\uparrow L}\triangleright\text{ftn}_{L}=\text{Nil}$
\end_inset

, and the law holds.
 If 
\begin_inset Formula $p$
\end_inset

 contains an empty sub-list at the 
\emph on
second
\emph default
 nesting depth, 
\begin_inset Formula $p\triangleright\text{ftn}_{L}$
\end_inset

 will contain an empty sub-list at the first nesting depth, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> flatten(p2)
\end_layout

\begin_layout Plain Layout

res1: List[List[Int]] = List(List(), List(123), List(456)) 
\end_layout

\end_inset

So 
\begin_inset Formula $p\triangleright\text{ftn}_{L}\bef\text{ftn}_{L}=\text{Nil}$
\end_inset

.
 On the other hand, 
\begin_inset Formula $p\triangleright\text{ftn}_{L}^{\uparrow L}$
\end_inset

 will also be a list with an empty sub-list at the first nesting depth,
 for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> p2.map(flatten)
\end_layout

\begin_layout Plain Layout

res2: List[List[Int]] = List(List(), List(456))
\end_layout

\end_inset

Applying 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 to the last result, we will get an empty list.
 Thus, 
\begin_inset Formula $p\triangleright\text{ftn}_{L}\triangleright\text{ftn}_{L}=\text{Nil}$
\end_inset

, and the law again holds.
 So, we have shown that the associativity law holds for the non-standard
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Try implementing the method 
\begin_inset Formula $\text{flift}:M^{A}\rightarrow L^{A}$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 must produce a value of type 
\begin_inset Formula $L^{A}\cong\bbnum 1+A\times M^{L^{A}}$
\end_inset

.
 Since 
\begin_inset Formula $M$
\end_inset

 is an arbitrary monad, we cannot extract a value of type 
\begin_inset Formula $A$
\end_inset

 out of 
\begin_inset Formula $M^{A}$
\end_inset

 while keeping the code fully parametric.
 So, we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 only by defining 
\begin_inset Formula $\text{flift}\triangleq\_^{:M^{A}}\rightarrow\text{Nil}^{:L^{A}}$
\end_inset

.
 However, that definition will not satisfy the identity law:
\begin_inset Formula 
\[
\text{pu}_{M}\bef\text{flift}=(\_\rightarrow\text{Nil})\neq\text{pu}_{L}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-combined-codensity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Denote for brevity 
\begin_inset Formula $\text{Cod}_{F}^{M,A}\triangleq C^{A}$
\end_inset

.
 The naturality law for functions 
\begin_inset Formula $c^{:C^{A}}$
\end_inset

 says that for any 
\begin_inset Formula $k^{:A\rightarrow F^{X}}$
\end_inset

 and 
\begin_inset Formula $q^{:X\rightarrow Y}$
\end_inset

, we have:
\begin_inset Formula 
\[
(k^{:A\rightarrow F^{X}}\bef q^{\uparrow F})\triangleright c^{Y}=k\triangleright c^{X}\bef q^{\uparrow M\uparrow F}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The flipped Kleisli method 
\begin_inset Formula $\tilde{\text{pu}}_{C}$
\end_inset

 is defined by
\begin_inset Formula 
\[
\tilde{\text{pu}}_{C}:\forall X.\,(A\rightarrow F^{X})\rightarrow A\rightarrow F^{M^{X}}\quad,\quad\quad\tilde{\text{pu}}_{C}\triangleq\forall X.\,k^{:A\rightarrow F^{X}}\rightarrow k\bef\text{pu}_{M}^{\uparrow F}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the left identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }g:\quad & \tilde{\text{pu}}_{C}\tilde{\diamond}g^{:\forall Y.\,(B\rightarrow F^{Y})\rightarrow A\rightarrow F^{M^{Y}}}=\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{k\triangleright g^{Z}\triangleright\tilde{\text{pu}}_{C}^{M^{Z}}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & =\forall Z.\,k^{:C\rightarrow F^{Z}}\rightarrow\big(g^{Z}(k)\bef\gunderline{\text{pu}_{M}^{\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}}\\
\text{left identity law of }M:\quad & =\forall Z.\,k^{:C\rightarrow F^{Z}}\rightarrow g^{Z}(k)=g\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the right identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f:\quad & f^{:\forall X.\,(B\rightarrow F^{X})\rightarrow A\rightarrow F^{M^{X}}}\tilde{\diamond}\tilde{\text{pu}}_{C}=\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{k\triangleright\tilde{\text{pu}}_{C}^{Z}}\triangleright f^{M^{Z}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{(k\bef\text{pu}_{M}^{\uparrow F})\triangleright f^{M^{Z}}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
\text{naturality law of }f:\quad & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(k\triangleright f^{Z}\bef\gunderline{\text{pu}_{M}^{\uparrow M\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}}\\
\text{right identity law of }M:\quad & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow k\triangleright f^{Z}=f\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the associativity law, write its two sides separately; omit all
 types for brevity:
\begin_inset Formula 
\begin{align*}
 & (f\tilde{\diamond}g)\tilde{\diamond}h=l\rightarrow\big(l\triangleright h\triangleright(\gunderline{f\tilde{\diamond}g})\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow\big(\gunderline{l\triangleright h\triangleright(k}\rightarrow(k\triangleright g\triangleright f)\bef\text{ftn}_{M}^{\uparrow F})\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & \quad=l\rightarrow\big((l\triangleright h\triangleright g\triangleright f)\bef\text{ftn}_{M}^{\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow l\triangleright h\bef g\bef f\bef\text{ftn}_{M}^{\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad,\\
 & f\tilde{\diamond}(g\tilde{\diamond}h)=l\rightarrow\big(l\triangleright(g\tilde{\diamond}h)\triangleright f\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow\big(l\triangleright(k\rightarrow(k\triangleright h\triangleright g)\bef\text{ftn}_{M}^{\uparrow F})\triangleright f\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & \quad=l\rightarrow\big(\big((l\triangleright h\triangleright g)\bef\gunderline{\text{ftn}_{M}^{\uparrow F}\big)\triangleright f}\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow l\triangleright h\triangleright g\triangleright f\bef\text{ftn}_{M}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad.
\end{align*}

\end_inset

In the last line, we have used the naturality law of 
\begin_inset Formula $f$
\end_inset

.
 The remaining difference between the two sides is
\begin_inset Formula 
\[
\text{ftn}_{M}^{\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\overset{?}{=}\text{ftn}_{M}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad,
\]

\end_inset

which follows from the associativity law of 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method must have the type signature
\begin_inset Formula 
\[
\text{flm}_{L}:\big((A\rightarrow X)\rightarrow M^{X}\big)\rightarrow(A\rightarrow(B\rightarrow X)\rightarrow M^{X})\rightarrow(B\rightarrow X)\rightarrow M^{X}\quad.
\]

\end_inset

Choose 
\begin_inset Formula $M^{A}\triangleq\bbnum 1+A$
\end_inset

; now we need to implement the type signature
\begin_inset Formula 
\begin{align*}
 & \text{flm}_{L}:\big((A\rightarrow X)\rightarrow\bbnum 1+X\big)\rightarrow\left(A\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\right)\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\quad,\\
 & \text{flm}_{L}\triangleq p^{:(A\rightarrow X)\rightarrow\bbnum 1+X}\rightarrow q^{:\left(A\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\right)}\rightarrow r^{:B\rightarrow X}\rightarrow\text{???}^{:\bbnum 1+X}\quad.
\end{align*}

\end_inset

Can this function ever return a value of type 
\begin_inset Formula $\bbnum 0+X$
\end_inset

? When we try filling out the typed hole 
\begin_inset Formula $\text{???}^{:\bbnum 1+X}$
\end_inset

, we cannot apply the function 
\begin_inset Formula $r$
\end_inset

 since we have no available values of type 
\begin_inset Formula $B$
\end_inset

.
 We could substitute 
\begin_inset Formula $r$
\end_inset

 into the second curried argument of 
\begin_inset Formula $q$
\end_inset

, obtaining a function of type 
\begin_inset Formula $A\rightarrow\bbnum 1+X$
\end_inset

.
 But we have no available values of type 
\begin_inset Formula $A$
\end_inset

.
 We also cannot apply the function 
\begin_inset Formula $p$
\end_inset

 since its argument is of type 
\begin_inset Formula $A\rightarrow X$
\end_inset

, but we only have 
\begin_inset Formula $A\rightarrow\bbnum 1+X$
\end_inset

, which is not guaranteed to return nonempty values.
 So, the only way of implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 via fully parametric code is to return the constant value 
\begin_inset Formula $1+\bbnum 0^{:X}$
\end_inset

.
 This would lose information and violate an identity law of monads.
\end_layout

\begin_layout Chapter
A humorous disclaimer
\end_layout

\begin_layout Standard

\emph on
The following text is quoted in part from an anonymous online source (
\begin_inset space ~
\end_inset


\begin_inset Quotes eld
\end_inset

Project Guten Tag
\begin_inset Quotes erd
\end_inset

) dating back at least to 1997.
 The original text is no longer available on the Internet.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\noun on
Warranto Limitensis; Disclamatantus Damagensis
\end_layout

\begin_layout Standard
Solus exceptus 
\begin_inset Quotes eld
\end_inset

Rectum Replacator Refundiens
\begin_inset Quotes erd
\end_inset

 describitus ecci,
\end_layout

\begin_layout Enumerate
Projectus (etque nunquam partum quis hic etext remitibus cum 
\noun on
Project Guten Tag
\noun default

\begin_inset Formula $^{\text{TM}}$
\end_inset

 identificator) disclamabat omni liabilitus tuus damagensis, pecuniensisque,
 includibantus pecunia legalitus, et 
\end_layout

\begin_layout Enumerate

\noun on
Remedia Negligentitia Non Habet Tuus, Warrantus Destructi
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

bus Contractus Nullibus Ni Liabilitus Sumus, Inclutatibus Non Limitatus
 Destructio Directibus, Consequentius, Punitio, O Incidentus, Non Sunt Si
 Nos Notificat Vobis
\noun default
.
 
\end_layout

\begin_layout Standard
Sit discubriatus defectus en etextum sic entram diariam noventam recibidio,
 pecuniam tuum refundatorium receptorus posset, sic scribatis vendor.
 Sit veniabat medium physicalis, vobis idem reternat et replacator possit
 copius.
 Sit venitabat electronicabilis, sic viri datus chansus segundibus.
 
\end_layout

\begin_layout Standard

\noun on
Hic Etext Venid 
\begin_inset Quotes eld
\end_inset

Como-asi
\begin_inset Quotes erd
\end_inset

.
 Nihil Warranti Nunquam Classum, Expressito Ni Implicato, Le Macchen Como
 Si Etexto Bene Sit O Il Medio Bene Sit, Inclutat Et Non Limitat Warranti
 Mercatensis, Appropriatensis Purposem.
 
\end_layout

\begin_layout Standard
Statuen varias non permitatent disclamabaris ni warranti implicatoren ni
 exclusioni limitatio damagaren consequentialis, ecco lo qua disclamatori
 exclusato
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
-
\end_layout

\end_inset

rique non vobis applicant, et potat optia alia legali.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
twocolumn
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
GNU Free Documentation License
\begin_inset CommandInset label
LatexCommand label
name "sec:GFDL"

\end_inset

 
\end_layout

\begin_layout Standard

\size footnotesize
Version 1.2, November 2002
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) 2000,2001,2002 Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
\end_layout

\begin_layout Standard

\size tiny
Everyone is permitted to copy and distribute verbatim copies of this license
 document, but changing it is not allowed.
\end_layout

\begin_layout Standard

\size tiny
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setcounter{subsection}{-1}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*

\size tiny
Preamble
\end_layout

\begin_layout Standard

\size tiny
The purpose of this License is to make a manual, textbook, or other functional
 and useful document free in the sense of freedom: to assure everyone the
 effective freedom to copy and redistribute it, with or without modifying
 it, either commercially or noncommercially.
 Secondarily, this License preserves for the author and publisher a way
 to get credit for their work, while not being considered responsible for
 modifications made by others.
\end_layout

\begin_layout Standard

\size tiny
This License is a kind of “copyleft
\begin_inset Quotes erd
\end_inset

, which means that derivative works of the document must themselves be free
 in the same sense.
 It complements the GNU General Public License, which is a copyleft license
 designed for free software.
\end_layout

\begin_layout Standard

\size tiny
We have designed this License in order to use it for manuals for free software,
 because free software needs free documentation: a free program should come
 with manuals providing the same freedoms that the software does.
 But this License is not limited to software manuals; it can be used for
 any textual work, regardless of subject matter or whether it is published
 as a printed book.
 We recommend this License principally for works whose purpose is instruction
 or reference.
\end_layout

\begin_layout Subsection
Applicability and definitions
\begin_inset CommandInset label
LatexCommand label
name "subsec:1Applicability-and-definitions"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
This License applies to any manual or other work, in any medium, that contains
 a notice placed by the copyright holder saying it can be distributed under
 the terms of this License.
 Such a notice grants a world-wide, royalty-free license, unlimited in duration,
 to use that work under the conditions stated herein.
 The “Document'', below, refers to any such manual or work.
 Any member of the public is a licensee, and is addressed as “you''.
 You accept the license if you copy, modify or distribute the work in a
 way requiring permission under copyright law.
\end_layout

\begin_layout Standard

\size tiny
A “Modified Version
\begin_inset Quotes erd
\end_inset

 of the Document means any work containing the Document or a portion of
 it, either copied verbatim, or with modifications and/or translated into
 another language.
\end_layout

\begin_layout Standard

\size tiny
A “Secondary Section
\begin_inset Quotes erd
\end_inset

 is a named appendix or a front-matter section of the Document that deals
 exclusively with the relationship of the publishers or authors of the Document
 to the Document's overall subject (or to related matters) and contains
 nothing that could fall directly within that overall subject.
 (Thus, if the Document is in part a textbook of mathematics, a Secondary
 Section may not explain any mathematics.) The relationship could be a matter
 of historical connection with the subject or with related matters, or of
 legal, commercial, philosophical, ethical or political position regarding
 them.
\end_layout

\begin_layout Standard

\size tiny
The “Invariant Sections'' are certain Secondary Sections whose titles are
 designated, as being those of Invariant Sections, in the notice that says
 that the Document is released under this License.
 If a section does not fit the above definition of Secondary then it is
 not allowed to be designated as Invariant.
 The Document may contain zero Invariant Sections.
 If the Document does not identify any Invariant Sections then there are
 none.
\end_layout

\begin_layout Standard

\size tiny
The “Cover Texts'' are certain short passages of text that are listed, as
 Front-Cover Texts or Back-Cover Texts, in the notice that says that the
 Document is released under this License.
 A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be
 at most 25 words.
\end_layout

\begin_layout Standard

\size tiny
A “Transparent'' copy of the Document means a machine-readable copy, represented
 in a format whose specification is available to the general public, that
 is suitable for revising the document straightforwardly with generic text
 editors or (for images composed of pixels) generic paint programs or (for
 drawings) some widely available drawing editor, and that is suitable for
 input to text formatters or for automatic translation to a variety of formats
 suitable for input to text formatters.
 A copy made in an otherwise Transparent file format whose markup, or absence
 of markup, has been arranged to thwart or discourage subsequent modification
 by readers is not Transparent.
 An image format is not Transparent if used for any substantial amount of
 text.
 A copy that is not “Transparent'' is called “Opaque
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
Examples of suitable formats for Transparent copies include plain ASCII
 without markup, Texinfo input format, \SpecialChar LaTeX
 input format, SGML or XML using
 a publicly available DTD, and standard-conforming simple HTML, PostScript
 or PDF designed for human modification.
 Examples of transparent image formats include PNG, XCF and JPG.
 Opaque formats include proprietary formats that can be read and edited
 only by proprietary word processors, SGML or XML for which the DTD and/or
 processing tools are not generally available, and the machine-generated
 HTML, PostScript or PDF produced by some word processors for output purposes
 only.
\end_layout

\begin_layout Standard

\size tiny
The 
\begin_inset Quotes eld
\end_inset

Title Page
\begin_inset Quotes erd
\end_inset

 means, for a printed book, the title page itself, plus such following pages
 as are needed to hold, legibly, the material this License requires to appear
 in the title page.
 For works in formats which do not have any title page as such, “Title Page”
 means the text near the most prominent appearance of the work's title,
 preceding the beginning of the body of the text.
\end_layout

\begin_layout Standard

\size tiny
A section 
\begin_inset Quotes eld
\end_inset

Entitled XYZ
\begin_inset Quotes erd
\end_inset

 means a named subunit of the Document whose title either is precisely XYZ
 or contains XYZ in parentheses following text that translates XYZ in another
 language.
 (Here XYZ stands for a specific section name mentioned below, such as “Acknowle
dgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the
 Title” of such a section when you modify the Document means that it remains
 a section “Entitled XYZ” according to this definition.
\end_layout

\begin_layout Standard

\size tiny
The Document may include Warranty Disclaimers next to the notice which states
 that this License applies to the Document.
 These Warranty Disclaimers are considered to be included by reference in
 this License, but only as regards disclaiming warranties: any other implication
 that these Warranty Disclaimers may have is void and has no effect on the
 meaning of this License.
\end_layout

\begin_layout Subsection
Verbatim copying
\begin_inset CommandInset label
LatexCommand label
name "subsec:2Verbatim-copying"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
You may copy and distribute the Document in any medium, either commercially
 or noncommercially, provided that this License, the copyright notices,
 and the license notice saying this License applies to the Document are
 reproduced in all copies, and that you add no other conditions whatsoever
 to those of this License.
 You may not use technical measures to obstruct or control the reading or
 further copying of the copies you make or distribute.
 However, you may accept compensation in exchange for copies.
 If you distribute a large enough number of copies you must also follow
 the conditions in section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
You may also lend copies, under the same conditions stated above, and you
 may publicly display copies.
\end_layout

\begin_layout Subsection
Copying in quantity
\begin_inset CommandInset label
LatexCommand label
name "subsec:3Copying-in-quantity"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
If you publish printed copies (or copies in media that commonly have printed
 covers) of the Document, numbering more than 100, and the Document's license
 notice requires Cover Texts, you must enclose the copies in covers that
 carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on
 the front cover, and Back-Cover Texts on the back cover.
 Both covers must also clearly and legibly identify you as the publisher
 of these copies.
 The front cover must present the full title with all words of the title
 equally prominent and visible.
 You may add other material on the covers in addition.
 Copying with changes limited to the covers, as long as they preserve the
 title of the Document and satisfy these conditions, can be treated as verbatim
 copying in other respects.
\end_layout

\begin_layout Standard

\size tiny
If the required texts for either cover are too voluminous to fit legibly,
 you should put the first ones listed (as many as fit reasonably) on the
 actual cover, and continue the rest onto adjacent pages.
\end_layout

\begin_layout Standard

\size tiny
If you publish or distribute Opaque copies of the Document numbering more
 than 100, you must either include a machine-readable Transparent copy along
 with each Opaque copy, or state in or with each Opaque copy a computer-network
 location from which the general network-using public has access to download
 using public-standard network protocols a complete Transparent copy of
 the Document, free of added material.
 If you use the latter option, you must take reasonably prudent steps, when
 you begin distribution of Opaque copies in quantity, to ensure that this
 Transparent copy will remain thus accessible at the stated location until
 at least one year after the last time you distribute an Opaque copy (directly
 or through your agents or retailers) of that edition to the public.
\end_layout

\begin_layout Standard

\size tiny
It is requested, but not required, that you contact the authors of the Document
 well before redistributing any large number of copies, to give them a chance
 to provide you with an updated version of the Document.
\end_layout

\begin_layout Subsection
Modifications
\begin_inset CommandInset label
LatexCommand label
name "subsec:4Modifications"

\end_inset


\end_layout

\begin_layout Standard

\size tiny
You may copy and distribute a Modified Version of the Document under the
 conditions of sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:2Verbatim-copying"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

 above, provided that you release the Modified Version under precisely this
 License, with the Modified Version filling the role of the Document, thus
 licensing distribution and modification of the Modified Version to whoever
 possesses a copy of it.
 In addition, you must do these things in the Modified Version:
\end_layout

\begin_layout Standard

\size tiny
A.
 Use in the Title Page (and on the covers, if any) a title distinct from
 that of the Document, and from those of previous versions (which should,
 if there were any, be listed in the History section of the Document).
 You may use the same title as a previous version if the original publisher
 of that version gives permission.
\end_layout

\begin_layout Standard

\size tiny
B.
 List on the Title Page, as authors, one or more persons or entities responsible
 for authorship of the modifications in the Modified Version, together with
 at least five of the principal authors of the Document (all of its principal
 authors, if it has fewer than five), unless they release you from this
 requirement.
\end_layout

\begin_layout Standard

\size tiny
C.
 State on the Title page the name of the publisher of the Modified Version,
 as the publisher.
\end_layout

\begin_layout Standard

\size tiny
D.
 Preserve all the copyright notices of the Document.
\end_layout

\begin_layout Standard

\size tiny
E.
 Add an appropriate copyright notice for your modifications adjacent to
 the other copyright notices.
\end_layout

\begin_layout Standard

\size tiny
F.
 Include, immediately after the copyright notices, a license notice giving
 the public permission to use the Modified Version under the terms of this
 License, in the form shown in the Addendum below.
\end_layout

\begin_layout Standard

\size tiny
G.
 Preserve in that license notice the full lists of Invariant Sections and
 required Cover Texts given in the Document's license notice.
\end_layout

\begin_layout Standard

\size tiny
H.
 Include an unaltered copy of this License.
\end_layout

\begin_layout Standard

\size tiny
I.
 Preserve the section Entitled 
\begin_inset Quotes eld
\end_inset

History
\begin_inset Quotes erd
\end_inset

, Preserve its Title, and add to it an item stating at least the title,
 year, new authors, and publisher of the Modified Version as given on the
 Title Page.
 If there is no section Entitled “History” in the Document, create one stating
 the title, year, authors, and publisher of the Document as given on its
 Title Page, then add an item describing the Modified Version as stated
 in the previous sentence.
\end_layout

\begin_layout Standard

\size tiny
J.
 Preserve the network location, if any, given in the Document for public
 access to a Transparent copy of the Document, and likewise the network
 locations given in the Document for previous versions it was based on.
 These may be placed in the 
\begin_inset Quotes eld
\end_inset

History
\begin_inset Quotes erd
\end_inset

 section.
 You may omit a network location for a work that was published at least
 four years before the Document itself, or if the original publisher of
 the version it refers to gives permission.
\end_layout

\begin_layout Standard

\size tiny
K.
 For any section Entitled 
\begin_inset Quotes eld
\end_inset

Acknowledgements
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Dedications
\begin_inset Quotes erd
\end_inset

, Preserve the Title of the section, and preserve in the section all the
 substance and tone of each of the contributor acknowledgements and/or dedicatio
ns given therein.
\end_layout

\begin_layout Standard

\size tiny
L.
 Preserve all the Invariant Sections of the Document, unaltered in their
 text and in their titles.
 Section numbers or the equivalent are not considered part of the section
 titles.
\end_layout

\begin_layout Standard

\size tiny
M.
 Delete any section Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

.
 Such a section may not be included in the Modified Version.
\end_layout

\begin_layout Standard

\size tiny
N.
 Do not retitle any existing section to be Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

 or to conflict in title with any Invariant Section.
\end_layout

\begin_layout Standard

\size tiny
O.
 Preserve any Warranty Disclaimers.
\end_layout

\begin_layout Standard

\size tiny
If the Modified Version includes new front-matter sections or appendices
 that qualify as Secondary Sections and contain no material copied from
 the Document, you may at your option designate some or all of these sections
 as invariant.
 To do this, add their titles to the list of Invariant Sections in the Modified
 Version's license notice.
 These titles must be distinct from any other section titles.
\end_layout

\begin_layout Standard

\size tiny
You may add a section Entitled 
\begin_inset Quotes eld
\end_inset

Endorsements
\begin_inset Quotes erd
\end_inset

, provided it contains nothing but endorsements of your Modified Version
 by various parties — for example, statements of peer review or that the
 text has been approved by an organization as the authoritative definition
 of a standard.
\end_layout

\begin_layout Standard

\size tiny
You may add a passage of up to five words as a Front-Cover Text, and a passage
 of up to 25 words as a Back-Cover Text, to the end of the list of Cover
 Texts in the Modified Version.
 Only one passage of Front-Cover Text and one of Back-Cover Text may be
 added by (or through arrangements made by) any one entity.
 If the Document already includes a cover text for the same cover, previously
 added by you or by arrangement made by the same entity you are acting on
 behalf of, you may not add another; but you may replace the old one, on
 explicit permission from the previous publisher that added the old one.
\end_layout

\begin_layout Standard

\size tiny
The author(s) and publisher(s) of the Document do not by this License give
 permission to use their names for publicity for or to assert or imply endorseme
nt of any Modified Version.
\end_layout

\begin_layout Subsection*

\size tiny
Combining documents
\end_layout

\begin_layout Standard

\size tiny
You may combine the Document with other documents released under this License,
 under the terms defined in section 4 above for modified versions, provided
 that you include in the combination all of the Invariant Sections of all
 of the original documents, unmodified, and list them all as Invariant Sections
 of your combined work in its license notice, and that you preserve all
 their Warranty Disclaimers.
\end_layout

\begin_layout Standard

\size tiny
The combined work need only contain one copy of this License, and multiple
 identical Invariant Sections may be replaced with a single copy.
 If there are multiple Invariant Sections with the same name but different
 contents, make the title of each such section unique by adding at the end
 of it, in parentheses, the name of the original author or publisher of
 that section if known, or else a unique number.
 Make the same adjustment to the section titles in the list of Invariant
 Sections in the license notice of the combined work.
\end_layout

\begin_layout Standard

\size tiny
In the combination, you must combine any sections Entitled “History” in
 the various original documents, forming one section Entitled “History”;
 likewise combine any sections Entitled “Acknowledgements”, and any sections
 Entitled “Dedications”.
 You must delete all sections Entitled “Endorsements.”
\end_layout

\begin_layout Subsection*

\size tiny
Collections of documents
\end_layout

\begin_layout Standard

\size tiny
You may make a collection consisting of the Document and other documents
 released under this License, and replace the individual copies of this
 License in the various documents with a single copy that is included in
 the collection, provided that you follow the rules of this License for
 verbatim copying of each of the documents in all other respects.
\end_layout

\begin_layout Standard

\size tiny
You may extract a single document from such a collection, and distribute
 it individually under this License, provided you insert a copy of this
 License into the extracted document, and follow this License in all other
 respects regarding verbatim copying of that document.
\end_layout

\begin_layout Subsection*

\size tiny
Aggregation with independent works
\end_layout

\begin_layout Standard

\size tiny
A compilation of the Document or its derivatives with other separate and
 independent documents or works, in or on a volume of a storage or distribution
 medium, is called an “aggregate” if the copyright resulting from the compilatio
n is not used to limit the legal rights of the compilation's users beyond
 what the individual works permit.
 When the Document is included an aggregate, this License does not apply
 to the other works in the aggregate which are not themselves derivative
 works of the Document.
\end_layout

\begin_layout Standard

\size tiny
If the Cover Text requirement of section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:3Copying-in-quantity"

\end_inset

 is applicable to these copies of the Document, then if the Document is
 less than one half of the entire aggregate, the Document's Cover Texts
 may be placed on covers that bracket the Document within the aggregate,
 or the electronic equivalent of covers if the Document is in electronic
 form.
 Otherwise they must appear on printed covers that bracket the whole aggregate.
\end_layout

\begin_layout Subsection*

\size tiny
Translation
\end_layout

\begin_layout Standard

\size tiny
Translation is considered a kind of modification, so you may distribute
 translations of the Document under the terms of section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:4Modifications"

\end_inset

.
 Replacing Invariant Sections with translations requires special permission
 from their copyright holders, but you may include translations of some
 or all Invariant Sections in addition to the original versions of these
 Invariant Sections.
 You may include a translation of this License, and all the license notices
 in the Document, and any Warranty Disclaimers, provided that you also include
 the original English version of this License and the original versions
 of those notices and disclaimers.
 In case of a disagreement between the translation and the original version
 of this License or a notice or disclaimer, the original version will prevail.
\end_layout

\begin_layout Standard

\size tiny
If a section in the Document is Entitled “Acknowledgements”, “Dedications”,
 or “History”, the requirement (section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:4Modifications"

\end_inset

) to Preserve its Title (section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:1Applicability-and-definitions"

\end_inset

) will typically require changing the actual title.
\end_layout

\begin_layout Subsection*

\size tiny
Termination
\end_layout

\begin_layout Standard

\size tiny
You may not copy, modify, sublicense, or distribute the Document except
 as expressly provided for under this License.
 Any other attempt to copy, modify, sublicense or distribute the Document
 is void, and will automatically terminate your rights under this License.
 However, parties who have received copies, or rights, from you under this
 License will not have their licenses terminated so long as such parties
 remain in full compliance.
\end_layout

\begin_layout Subsection*

\size tiny
Future revisions of this license
\end_layout

\begin_layout Standard

\size tiny
The Free Software Foundation may publish new, revised versions of the GNU
 Free Documentation License from time to time.
 Such new versions will be similar in spirit to the present version, but
 may differ in detail to address new problems or concerns.
 See 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
url{http://www.gnu.org/copyleft/}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

\size tiny
Each version of the License is given a distinguishing version number.
 If the Document specifies that a particular numbered version of this License
 “or any later version” applies to it, you have the option of following
 the terms and conditions either of that specified version or of any later
 version that has been published (not as a draft) by the Free Software Foundatio
n.
 If the Document does not specify a version number of this License, you
 may choose any version ever published (not as a draft) by the Free Software
 Foundation.
\end_layout

\begin_layout Subsection*

\size tiny
\noun on
Addendum
\noun default
: How to use this License for your documents
\end_layout

\begin_layout Standard

\size tiny
To use this License in a document you have written, include a copy of the
 License in the document and put the following copyright and license notices
 just after the title page:
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) <year> <your name>.
 Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.2 or any later
 version published by the Free Software Foundation; with no Invariant Sections,
 no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is included in the section entitled “GNU Free Documentati
on License”.
\end_layout

\begin_layout Standard

\size tiny
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
 replace the “with...Texts.” line with this:
\end_layout

\begin_layout Standard

\size tiny
with the Invariant Sections being <list their titles>, with the Front-Cover
 Texts being <list>, and with the Back-Cover Texts being <list>.
\end_layout

\begin_layout Standard

\size tiny
If you have Invariant Sections without Cover Texts, or some other combination
 of the three, merge those two alternatives to suit the situation.
\end_layout

\begin_layout Standard

\size tiny
If your document contains nontrivial examples of program code, we recommend
 releasing these examples in parallel under your choice of free software
 license, such as the GNU General Public License, to permit their use in
 free software.
\end_layout

\begin_layout Subsection*

\size tiny
Copyright 
\end_layout

\begin_layout Standard

\size tiny
Copyright (c) 2000, 2001, 2002 Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
\end_layout

\begin_layout Standard

\size tiny
Everyone is permitted to copy and distribute verbatim copies of this license
 document, but changing it is not allowed.
\end_layout

\end_body
\end_document
