#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Reasoning about types and code]{Reasoning about types and code}
\subtitle{What we functional programmers need to know}
\author{Sergei Winitzki}
\date{2019-08-17}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
A new draft book: 
\emph on
The Science of Functional Programming
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle

\emph on
With examples in Scala
\emph default
.
 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Practitioners of functional programming need to know how to...
\end_layout

\begin_layout Itemize
...reason about types:
\end_layout

\begin_deeper
\begin_layout Itemize
design the required custom data types for the given application
\end_layout

\begin_layout Itemize
derive an equivalent simpler type when possible
\end_layout

\begin_layout Itemize
use type constructions to create data types with required properties
\end_layout

\end_deeper
\begin_layout Itemize
...reason about code:
\end_layout

\begin_deeper
\begin_layout Itemize
verify that given implementations satisfy the required laws (e.g.
\begin_inset space ~
\end_inset

monad)
\end_layout

\begin_layout Itemize
derive lawful custom implementations of important typeclasses
\end_layout

\begin_layout Itemize
verify that certain functions are computationally equivalent
\end_layout

\begin_layout Itemize
derive an equivalent simpler code when possible
\end_layout

\end_deeper
\begin_layout Standard
This requires a 
\emph on
very limited
\emph default
 amount of mathematics (polynomials, monoids)
\end_layout

\begin_layout Standard
The book will explain (with examples and exercises):
\end_layout

\begin_layout Itemize
known techniques of reasoning about types and type constructors
\end_layout

\begin_layout Itemize
known techniques for symbolic calculations with code
\end_layout

\begin_layout Itemize
deriving and verifying laws symbolically (as equations for functions)
\end_layout

\begin_layout Itemize
real-life motivations for (and applications of) these techniques
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of reasoning tasks
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\size default
Can we compute a value of type 
\family typewriter
\size footnotesize
\color blue
Either[Z, R => A]
\family default
\size default
\color inherit
 given a value of type 
\family typewriter
\size footnotesize
\color blue
R => Either[Z, A]
\family default
\size default
\color inherit
? And conversely? (
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
R
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 are type parameters.)
\end_layout

\begin_layout Enumerate
How to use 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
 with 
\family typewriter
\size footnotesize
\color blue
Either[Z,A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Future[A]
\family default
\size default
\color inherit
 together?
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result = for {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  a <- Future(...) // A computation that takes time and may fail.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  b <- Either(...) // A computation whose result may be unavailable.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  c <- Future(...) // A computation that takes time and may fail.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield ??? // Continue computations when results are available.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space \hspace*{}
\length 1.8mm
\end_inset

Should 
\family typewriter
\size footnotesize
\color blue
result
\family default
\size default
\color inherit
 have type 
\family typewriter
\size footnotesize
\color blue
Either[Z,Future[A]]
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
Future[Either[Z,A]]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{2}
\end_layout

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Can we implement 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 for the type constructor 
\family typewriter
\size footnotesize
\color blue
Option[(A, A, A)]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Enumerate
What type describes a chain of 
\family typewriter
\size footnotesize
\color blue
Future[A]
\family default
\size default
\color inherit
 operations that, on any failure, will automatically execute specified cleanups
 in reverse order?
\end_layout

\begin_layout Enumerate
Different people define a 
\begin_inset Quotes eld
\end_inset

free monad
\begin_inset Quotes erd
\end_inset

 via different sets of case classes.
 Are these definitions equivalent? What is the difference?
\end_layout

\begin_layout Enumerate
How to define a free monad generated by a 
\family typewriter
\size footnotesize
\color blue
Pointed
\family default
\size default
\color inherit
 functor (i.e.
\begin_inset space ~
\end_inset

when the functor already has the 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 method)? Will that type have better performance than the standard free
 monad generated by a functor?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Short notation for types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset


\size default
A concise mathematical notation for types and type constructors:
\end_layout

\begin_layout Standard
\align center

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.00cm}
\end_layout

\end_inset


\size default

\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type parameter
\size default
 
\family typewriter
\size footnotesize
\color blue
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
tuple type
\size default
 
\family typewriter
\size footnotesize
\color blue
(A, B)
\family default
\color inherit
, or
\size default
 
\family typewriter
\size footnotesize
\color blue
case class C(a:
\begin_inset space ~
\end_inset

A, b:
\begin_inset space ~
\end_inset

B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
disjunctive type
\size default
 
\family typewriter
\size footnotesize
\color blue
Either[A,B]
\family default
\color inherit
 or 
\family typewriter
\color blue
trait/case class
\family default
\color inherit
es
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
function type
\size default
 
\family typewriter
\size footnotesize
\color blue
A => B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\family default
\size default
\color inherit
 
\size small
or a 
\begin_inset Quotes eld
\end_inset

named
\begin_inset Quotes erd
\end_inset

 unit type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
primitive type (
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size small
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size small
\color inherit
, etc.)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Int}$
\end_inset

, 
\begin_inset Formula $\text{String}$
\end_inset

, ...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Nothing
\family default
\size default
\color inherit
 
\size small
(the void type)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type constructor,
\size default
 
\family typewriter
\size footnotesize
\color blue
type P[A] = Option[(A,A,A)]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P^{A}\triangleq\bbnum 1+A\times A\times A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type constructor,
\size default
 
\family typewriter
\size footnotesize
\color blue
P[_]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P^{\bullet}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
parameterized function,
\size default
 
\family typewriter
\size footnotesize
\color blue
def f[A]:
\begin_inset space ~
\end_inset

A => (A, A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f^{A}:A\Rightarrow A\times A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset


\size default
This notation proved convenient for reasoning about equivalence of types:
\begin_inset Formula 
\begin{align*}
\left(A+B\right)\times C & \cong A\times C+B\times C\quad,\quad\quad A\Rightarrow B\Rightarrow C\cong A\times B\Rightarrow C\quad,\\
\bbnum 0+A & \cong A\quad,\quad\quad\quad A+B\Rightarrow C\cong\left(A\Rightarrow C\right)\times\left(B\Rightarrow C\right)
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Short notation for code
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
A concise mathematical notation for code:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
variable, or function argument
\size default
 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space ~
\end_inset

A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x^{:A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
tuple value
\size default
 
\family typewriter
\size footnotesize
\color blue
(a, b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a\times b$
\end_inset

 or 
\begin_inset Formula $a^{:A}\times b^{:B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
value of disjunctive type
\size default
 
\family typewriter
\size footnotesize
\color blue
Left[A, B](x)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
nameless function
\size default
 
\family typewriter
\size footnotesize
\color blue
{x: A => expr }
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x^{:A}\Rightarrow\text{expr}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\family default
\size default
\color inherit
 
\size small
value, 
\family typewriter
\size footnotesize
\color blue
()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def f[A, B]:
\begin_inset space ~
\end_inset

A => B => A = x => _ => x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f^{:A\Rightarrow B\Rightarrow A}\triangleq x^{:A}\Rightarrow\_^{:B}\Rightarrow x$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
identity[A]
\family default
\size default
\color inherit
 
\size small
(the identity function)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{id}^{A}$
\end_inset

 or 
\begin_inset Formula $\text{id}^{:A\Rightarrow A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
forward composition,
\size default
 
\family typewriter
\size footnotesize
\color blue
f andThen g
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f\bef g$
\end_inset

 or 
\begin_inset Formula $f^{:A\Rightarrow B}\bef g^{:B\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
argument piping,
\size default
 
\family typewriter
\size footnotesize
\color blue
x.pipe(f)
\family default
\size small
\color inherit
 (Scala 2.13)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x\triangleright f$
\end_inset

 where 
\begin_inset Formula $x^{:A}$
\end_inset

 and 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
lifted function,
\size default
 
\family typewriter
\size footnotesize
\color blue
p.map(f)
\family default
\size small
\color inherit
 where 
\family typewriter
\size footnotesize
\color blue
p:
\begin_inset space ~
\end_inset

P[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\triangleright f^{\uparrow P}$
\end_inset

 where 
\begin_inset Formula $p^{:P^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
This notation proved convenient for reasoning about equational laws:
\begin_inset Formula 
\[
f^{\uparrow P}\bef g^{\uparrow P}\bef h^{\uparrow P}=\left(f\bef g\bef h\right)^{\uparrow P}\quad,\quad\quad x\triangleright f\triangleright g=x\triangleright f\bef g
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example I.
 Free monad generated by a type constructor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

A free monad generated by a type constructor 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
 is...
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset

From a 
\begin_inset CommandInset href
LatexCommand href
name "blog post"
target "http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html"
literal "false"

\end_inset

 by Gabriel Gonzalez (2012), translated into Scala:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Free1[F[_], T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Pure[F[_], T](t: T)                 extends Free1[F, T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Flatten[F[_], T](f: F[Free1[F, T]]) extends Free1[F, T]
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{1}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.9cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
From a 
\begin_inset CommandInset href
LatexCommand href
name "talk"
target "http://functionaltalks.org/2014/11/23/runar-oli-bjarnason-free-monad/"
literal "false"

\end_inset

 given by Rúnar Bjarnason (2014):
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Free2[F[_], T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Pure[F[_], T](t: T) extends Free2[F, T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[F[_], T, A](f: F[A], g: A => Free2[F, T])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     extends Free2[F, T]
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{2}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.9cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
From a 
\begin_inset CommandInset href
LatexCommand href
name "talk"
target "https://www.slideshare.net/KelleyRobinson1/why-the-free-monad-isnt-free-61836547"
literal "false"

\end_inset

 given by Kelley Robinson (2016):
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Free3[F[_], T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Pure[F[_], T](t: T)         extends Free3[F, T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Suspend[F[_], T](f: F[T])   extends Free3[F, T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class FlatMap[F[_], T, A](f: Free3[F, A], g: A => Free3[F, T])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     extends Free3[F, T]
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

Are these definitions different? How to reason about them?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example I.
 Writing the definitions in the type notation
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

A free monad generated by a type constructor 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
 is...
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset

From G.
\begin_inset space ~
\end_inset

Gonzalez: 
\begin_inset Formula $\text{Free}_{1}^{F,T}\triangleq T+F^{\text{Free}_{1}^{F,T}}$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Free1[F[_], T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Pure[F[_], T](t: T)                 extends Free1[F, T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Flatten[F[_], T](f: F[Free1[F, T]]) extends Free1[F, T]
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{1}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.8cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
From R.
\begin_inset space ~
\end_inset

Bjarnason: 
\begin_inset Formula $\text{Free}_{2}^{F,T}\triangleq T+\exists A.\,F^{A}\times(A\Rightarrow\text{Free}_{2}^{F,T})$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Free2[F[_], T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Pure[F[_], T](t: T) extends Free2[F, T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[F[_], T, A](f: F[A], g: A => Free2[F, T])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     extends Free2[F, T]
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{2}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.8cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
From K.
\begin_inset space ~
\end_inset

Robinson: 
\begin_inset Formula $\text{Free}_{3}^{F,T}\triangleq T+F^{T}+\exists A.\,\text{Free}_{3}^{F,A}\times(A\Rightarrow\text{Free}_{3}^{F,T})$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Free3[F[_], T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Pure[F[_], T](t: T)         extends Free3[F, T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Suspend[F[_], T](f: F[T])   extends Free3[F, T]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class FlatMap[F[_], T, A](f: Free3[F, A], g: A => Free3[F, T])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     extends Free3[F, T]
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example I.
 Three definitions of the free monad
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset


\size default
What is the difference between definitions 1 and 2?
\end_layout

\begin_layout Itemize
Definition 
\begin_inset Formula $\text{Free}_{1}^{F,T}\triangleq T+F^{\text{Free}_{1}^{F,T}}$
\end_inset

 assumes that 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is a functor
\end_layout

\begin_layout Itemize
Definition 
\begin_inset Formula $\text{Free}_{2}^{F,T}\triangleq T+\exists A.\,F^{A}\times(A\Rightarrow\text{Free}_{2}^{F,T})$
\end_inset

 works for any 
\begin_inset Formula $F^{\bullet}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
if 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is a functor, the Yoneda identity gives 
\begin_inset Formula $F^{B}\cong\exists A.\,F^{A}\times\left(A\Rightarrow B\right)$
\end_inset

 
\end_layout

\begin_layout Itemize
then 
\begin_inset Formula $T+\exists A.\,F^{A}\times(A\Rightarrow\text{Free}_{2}^{F,T})\cong T+F^{\text{Free}_{2}^{F,T}}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
So, definitions 1 and 2 are equivalent when 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is a functor 
\end_layout

\begin_layout Standard
What is the difference between definitions 2 and 3?
\end_layout

\begin_layout Itemize
Can we replace 
\begin_inset Formula $\text{Free}_{3}^{F,A}$
\end_inset

 by 
\begin_inset Formula $F^{A}$
\end_inset

 in definition 3?
\size footnotesize
 Yes.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & T+F^{T}+\exists A.\,\gunderline{\text{Free}_{3}^{F,A}}\times(A\Rightarrow\text{Free}_{3}^{F,T})\\
 & =T+\gunderline{F^{T}}+\exists A.\,\left(A+F^{A}+\exists B.\,\text{Free}_{3}^{F,B}\times(B\Rightarrow\text{Free}_{3}^{F,A})\right)\times(A\Rightarrow\text{Free}_{3}^{F,T})\\
 & =T+\gunderline{\exists A.\,F^{A}\times(A\Rightarrow T)}+\gunderline{\exists A.\,A\times(A\Rightarrow\text{Free}_{3}^{F,T})}+\exists A.\,F^{A}\times(A\Rightarrow\text{Free}_{3}^{F,T})\\
 & \quad\quad\quad+\exists A.\,\exists B.\,\gunderline{\text{Free}_{3}^{F,B}\times(B\Rightarrow\text{Free}_{3}^{F,A})\times(A\Rightarrow\text{Free}_{3}^{F,T})}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset

By the monad's associativity law, we reduce 
\begin_inset Formula $\text{Free}_{3}^{F,B}\times(B\Rightarrow\text{Free}_{3}^{F,A})\times(A\Rightarrow\text{Free}_{3}^{F,T})$
\end_inset

 to 
\begin_inset Formula $\text{Free}_{3}^{F,B}\times(B\Rightarrow\text{Free}_{3}^{F,A}\times(A\Rightarrow\text{Free}_{3}^{F,T}))$
\end_inset

.
 By inductive assumption, this is 
\begin_inset Formula $\text{Free}_{3}^{F,B}\times(B\Rightarrow\text{Free}_{3}^{F,T})$
\end_inset

 and can be replaced by 
\begin_inset Formula $F^{B}\times(B\Rightarrow\text{Free}_{3}^{F,A})$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example II.
 The selection monad transformer
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The selection monad is defined as 
\family typewriter
\size footnotesize
\color blue
Sel[A] = (A => R) => A
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
This is related to the 
\begin_inset Quotes eld
\end_inset

search monad
\begin_inset Quotes erd
\end_inset

, 
\family typewriter
\size footnotesize
\color blue
(A => Boolean) => Option[A]
\end_layout

\begin_deeper
\begin_layout Itemize
but 
\emph on
not
\emph default
 related to the 
\begin_inset Quotes eld
\end_inset

search monad
\begin_inset Quotes erd
\end_inset

 in Haskell's 
\begin_inset CommandInset href
LatexCommand href
name "monad-dijkstra"
target "http://hackage.haskell.org/package/monad-dijkstra-0.1.1.2/docs/Control-Monad-Search.html"
literal "false"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
The paper 
\begin_inset Quotes eld
\end_inset

Monad Transformers for Backtracking Search
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/pdf/1406.2058.pdf"

\end_inset

 defines the selection monad transformer 
\family typewriter
\size footnotesize
\color blue
SelT[A] = (A => M[R]) => M[A]
\family default
\size default
\color inherit
.
 The author writes,
\end_layout

\begin_layout Quote

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size scriptsize
The proof that the selection monad satisfies the monad laws was found using
 an ad-hoc computer program written by Martin Escardó [...] The author has
 verified by hand that the selection monad transformer preserves the unit
 laws, however the proof for the associativity law appears to be unmanageable.
 The author is currently working on a formally verified proof that the selection
 monad transformer preserves the monad laws.
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The proof was too hard because (most likely) the author tried to write symbolic
 calculations in Haskell syntax, which is not well adapted to proofs.
 (This would have been worse if using Scala syntax.)
\end_layout

\begin_deeper
\begin_layout Itemize
The proof is 5 lines of calculations in the short code notation
\end_layout

\begin_layout Itemize
Doing a formally verified proof is 
\emph on
much harder
\emph default
 than proving by hand!
\end_layout

\begin_deeper
\begin_layout Itemize
(and you 
\emph on
already
\emph default
 need to know how to prove it by hand)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example II.
 Proof of the associativity law
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

The selection monad transformer's type is 
\begin_inset Formula $T^{M,A}\triangleq(A\Rightarrow M^{R})\Rightarrow M^{A}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
Define Kleisli functions 
\begin_inset Formula $f:A\Rightarrow T^{M,B}\triangleq A\Rightarrow(B\Rightarrow M^{R})\Rightarrow M^{B}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
Use a trick: flip arguments, 
\begin_inset Formula $f:(B\Rightarrow M^{R})\Rightarrow A\Rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $g:(C\Rightarrow M^{R})\Rightarrow B\Rightarrow M^{C}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
Define Kleisli composition, 
\begin_inset Formula $f\diamond_{T}g:(C\Rightarrow M^{R})\Rightarrow A\Rightarrow M^{C}$
\end_inset

 using the known 
\begin_inset Formula $\diamond_{M}$
\end_inset

 as
\begin_inset Formula 
\[
f\diamond_{T}g\triangleq k^{:C\Rightarrow M^{R}}\Rightarrow f(g(k)\diamond_{M}k)\diamond_{M}g(k)
\]

\end_inset

The operation 
\begin_inset Formula $\diamond_{M}$
\end_inset

 already satisfies the associativity law, 
\begin_inset Formula $\left(p\diamond_{M}q\right)\diamond_{M}r=p\diamond_{M}\left(q\diamond_{M}r\right)$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
Prepare the result of 
\begin_inset Formula $g\diamond_{T}h$
\end_inset

:
\begin_inset Formula 
\[
(g\diamond_{T}h)(k)=\gunderline{g(h(k)\diamond_{M}k)\diamond_{M}h(k)}
\]

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Now check associativity law for the flipped Kleisli composition 
\begin_inset Formula $\diamond_{T}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (f\diamond_{T}g)\diamond_{T}h=k\Rightarrow(\gunderline{f\diamond_{T}g})(h(k)\diamond_{M}k)\diamond_{M}h(k)\\
 & =k\Rightarrow f(g(\gunderline{h(k)\diamond_{M}k})\diamond_{M}\gunderline{h(k)\diamond_{M}k})\diamond_{M}g(\gunderline{h(k)\diamond_{M}k})\diamond_{M}h(k)\quad,\\
 & f\diamond_{T}(g\diamond_{T}h)=k\Rightarrow f((\gunderline{g\diamond_{T}h})(k)\diamond_{M}k)\diamond_{M}(\gunderline{g\diamond_{T}h})(k)\\
 & =k\Rightarrow f(\gunderline{g(h(k)\diamond_{M}k)\diamond_{M}h(k)}\diamond_{M}k)\diamond_{M}g\gunderline{(h(k)\diamond_{M}k)\diamond_{M}h(k)}\quad.
\end{align*}

\end_inset

So we have proved the associativity law, 
\begin_inset Formula $\left(f\diamond_{T}g\right)\diamond_{T}h=f\diamond_{T}\left(g\diamond_{T}h\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Mastering the type/code reasoning takes about 6 months of practice 
\end_layout

\begin_deeper
\begin_layout Itemize
and you will be able to use FP much more effectively in actual coding
\end_layout

\begin_layout Itemize
the special notation helped me a lot
\end_layout

\end_deeper
\begin_layout Itemize
Lots of explanations, examples, and exercises in the upcoming book
\end_layout

\begin_layout Itemize
Current progress: chapters 1–6 ready after a second proofreading
\end_layout

\begin_layout Itemize

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
