#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \bef inside a \text{} will cause a LaTeX error!
\newcommand{\bef}{\hspace{0.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY
\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,fontsize=10pt,utf8
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "Science of functional programming"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7in
\paperheight 9in
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 4
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip=2mm,showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\small\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.01mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin=4mm,framexrightmargin=4mm,xleftmargin=4mm,xrightmargin=4mm,framextopmargin={0.5mm},framexbottommargin={.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset Quotes eld
\end_inset

Free
\begin_inset Quotes erd
\end_inset

 type constructions
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
jatin or the functional programming tutorial the focus of this chapter is
 on three type constructions to begin let us consider the interpreter pattern
 this is a design pattern where you present your program as a data structure
 and you program an interpreter to run your data structure so as an example
 consider this domain specific language for complex numbers it's a very
 simple language it has three operations to create a complex number out
 of string to multiply complex numbers and to compute the complex conjugate
 number if I want to represent this computation as data in other words not
 to run it yet but to write down the operations as data then I could imagine
 implementing it like this I can implement some case classes in a disjunction
 like this so I have a program type it has three parts of the disjunction
 which is either a string which will represent this operation parsing a
 string into a complex number multiplication of two complex numbers and
 computing the complex conjugate number and then I can imagine that instead
 of this program I will have a data structure with nested case classes like
 this in order to be able to define such a data structure in my case classrooms
 should have these types so for instance multiplication case class will
 contain two parts and each can be itself another program so that's why
 the types of the parts of these schemes classes are again the type program
 itself so in this way having defined these type parts of the case class
 as programs I enable myself to write down arbitrary nested case classes
 so this has type program I can use this as part of another case class like
 MO or conjugate so in this way I have created a domain-specific language
 that expresses computations with complex numbers as data structures in
 order to actually compute anything with any complex numbers I would need
 to run this program this dsl program as I would say the interpreter will
 be a function of the type signature it may be like this it will take an
 argument of type program and it will return a pair of double numbers which
 would represent a complex number that is the result of computing this program
 so why would you use the interpreter pattern because it has certain benefits
 in certain cases one main main benefit is that you represent a certain
 domain specific language that is a number of operations that are specific
 to a certain task set or a domain such as complex number of computations
 you encapsulate all these operations in a data type that fully describes
 what needs to be done without actually doing it so you present as data
 what otherwise you would write as executable code data is much more easily
 composable it can be manipulated transformed before running it so before
 you run here DSO program you can store it in some data structure you can
 put it on disk in a file read it back send it over the internet and compose
 it with other DSL programs in the larger DSL program all that is data manipulat
ion that has nothing running yet nothing has computed yet when you're ready
 you call the run function and actually compute the results so this very
 simple DSL domain-specific language has shortcomings specifically it works
 only with simple expressions it represents expressions as unev a lated
 expression trees so every operation needs to be some vertex of the tree
 but that's that's okay but we don't have enough different operations defined
 so that for instance you cannot express variable binding and conditions
 here for instance we can imagine that this a could be used somehow in these
 operations but I cannot express it here all I can express is multiplying
 two complex numbers converting strings to complex numbers and computing
 a complex conjugate number there is no way to express that I have a variable
 in my language in the DSL not color variable Scala variables I can of of
 course have I can say Val x equals this but that is not at the level of
 the domain-specific language the language itself doesn't know as so far
 anything about defining variables and because of this I cannot use any
 code that is not expressed in this DSL so for example I could imagine calling
 a numerical algorithms library to compute some special function of the
 complex number and that could be a complicated algorithm but I cannot put
 it into a DSL I would have to express the entire algorithm using DSL operations
 if I wanted to do that so let's try to overcome these shortcomings these
 are certainly not due to interpreter pattern itself it's just that our
 DSL is too simple so let's see how we can do variable binding in a DSL
 like this now let's consider another example for this which is a DSL for
 reading and writing files but let's just look at reading files for now
 so the DSL will have two operations first so this on the left is a non
 DSL program is a program that we write in Scala we want to replace this
 with a DSL program within data structure so the functionality we want to
 implement is to create a path for a given file name so this could check
 that it exists or whatever translate this into some URL if necessary we
 don't know so right now we just say there is some operation that creates
 Bath's out of strings and there is another operation that reads a file
 at the given path and the result is a string so you read the contents of
 a file so then suppose we have this logic we read one file and if its contents
 is not empty and then we interpret its contents as another file name and
 we read that and then we want to return the string that is in the second
 file if it's an empty file then we return an error string like this so
 how can we implement this logic in the DSL well we need to bind a variable
 such as here STR to a value that is computed by the DSL at runtime and
 we need to evaluate some condition or generally we need to use the value
 of this variable while constructing further DSL expressions so to understand
 how we can implement this consider that in the DSL everything must be some
 kind of expression tree and this part of the program needs to be also represent
ed by an expression tree and this expression tree is actually a function
 of the variable STR so the variable STR will be assigned when we run this
 DSL program and actually read the files but before we do that the DSL already
 needs to specify that this entire rest of the program is a function of
 this variable so in order to represent that we need a special construction
 in the expression tree and I call this construction bind which is just
 the name of a case class and this case class will have an argument which
 is a function actually a scholar function from a Scala variable STR to
 another tree and so this is how I implement this domain-specific language
 again we I have a seal trade program or probe which now has four case classes
 and the three case classes here are the ones that I would need to implement
 functionality so for example I need literal strings so I'll represent that
 with this literal case class I need paths whose contents are maybe programs
 again because I don't know path can be computed and I need to read again
 I need to read something which could be another DSL program so that's what
 I do in these three case classes and I also had a case class bind which
 represents binding enum DSL variable to a value which is computed when
 you run the DSL and then so I have the first part of this case class is
 a DSL program which when run will give me a value of type string and the
 second part of the case class is a function from string to another DSL
 programmer so this function is a scalar function is not a DSL function
 is a scholar function which is now part of my data structure in this way
 I can inject arbitrary Scala code in principle in the code of this function
 including conditions or creating another dsl program by using the values
 of these variables in an arbitrary way so this variable will be the argument
 of F so here is an example I make a bind so this entire thing becomes a
 blind of this which is read path literal file and this which is a scholar
 function that executes my conditional computation and then returns a value
 of type program again so it returns a DSL program so this is a function
 that takes a string and returns a program so that is how I can easily implement
 the requirement that the DSL should express variable binding conditional
 computations arbitrary Scala code in those calculations and using the scala
 variables such as this one in creating expression trees so I still have
 an expression tree this entire thing is still expression tree and still
 undervalued but now I have a lot more flexibility in what sort of computations
 I can implement with the DSL the interpreter for the DSL will still have
 the same type signature it will be perhaps slightly more complicated so
 let's look at a code examples so first the DSL for complex numbers which
 is what we saw before so the only interesting code here is in running a
 DSL program and here's how we run we basically take the value of the program
 which is going to be one of these three case classes and we match it in
 each case we run what's inside so in this strain case the inside is a definitio
n of a complex number by string such as this one we need to parse it so
 I have some regular expression that I parse this with and the result is
 going to be one value than a sign and another value and then I create a
 complex number out of that a multiplication is a standard formula for complex
 multiplication but notice that both of these are programs so the mall case
 class contains two programs that first have to be run in order to get a
 complex numbers out of them and then I execute a complex multiplication
 similarly the conjugate operation first I have to run the program that
 is the argument here and then I execute the operation so here's a test
 conjugate of multiply of this which is equal to this complex number so
 in order to get it I do run of program so when I do this nothing is wrong
 yet it's a data structure and I could have code that for example simplifies
 this in some way maybe or prints it or whatever it's a data structure that
 is available for me to work with I could type set this in latex if I wanted
 to before running it so then I also can run it so this is the power of
 the interpreter pattern let's look at implementing the DSL for file operations
 that I described in order to run this I will have a mock file system which
 we just a map from string to string so that the filename is mapped to the
 text inside the farm so that this is just so that my tests are easy and
 I don't need to write a lot of code actually reading and writing files
 so I declare my probe type as a disjunction like this like shown in the
 slide and now I need to define the run now run is similar to what we had
 in the complex number case and that for example I need to always run the
 arguments first and then I do something with them so for simplicity path
 will just evaluate your string and read will look up the file contents
 in the dictionary so note we cannot guarantee that three is a path here
 he is just a program it could it is evaluated to a string but so maybe
 it surpassed maybe maybe not we have to be careful what right right writing
 this program the runner cannot check what the program makes sense and finally
 let's look at how we implement the bind so the bind is actually easy to
 implement so key as a type program we need to run it to get a string out
 of it F has a private string to program so we run the P then we apply F
 to that result which is a straining so then F of string is another program
 which we again run so that's how mind works and that's the entire implementatio
n of variable binding for our four in claim which for the DSL domain-specific
 language here is an example program this is what is shown in the slide
 and we can run it and see that it is equal to text this is equal to text
 because first we read the file 1 which gives us the string and we will
 read the file at this path which gives us the string so that's the text
 now notice that as DSL is not typesafe it allows us to read to write nonsensica
l programs like this when you read read read and that is nonsensical because
 you can only read the path and the result of a read is not a path as a
 string and the program doesn't know about it and just it gives us an exception
 key not found text which is a kind of a runtime exception since we don't
 have a file named text in our file system but this should not be the error
 the error should be you cannot read a literal string you must read a class
 on the file system which would have been a type error if this were a type
 safe language so that's the next concern our DSL so far has no type safety
 every value in it is a program and it's evaluated per string so what can
 we do if we wanted to avoid errors such that for example read of raid shouldn't
 even compile it should be impossible to write programs like this and compile
 them and run so the way to solve this problem is to change the type of
 the program data type to a type constructor so let us denote by this program
 of a a DSL program that when run will return a value of type a now in our
 case right now is going to be string but let's make sure it's string and
 not some other type such as a file fast so here's how we do it we define
 a disjunction type characterised by type a type parameter in and everything
 else remains the same except now we explicitly say that for example the
 argument of bind is a program that has a string result and a function will
 take that result and output another program with string result whereas
 previously bind had a program and this function returned the program now
 we explicitly demand the result must be of type string and then we can
 apply F to that result so literal will also give us a program returning
 a string and path will take a program that returns a string but it will
 heal the program that has the past in Iowa file path type in other words
 it's not a program returning string and the read will take that kind of
 program and return a program that evaluates the string so in this way we
 can achieve type safety so the program remains mostly the same except for
 the type the interpreter remains mostly the same except now it has type
 safety let's see how that works now so let's implement instead of ni√±o
 Java file types let's just have a mock type that represents a file path
 so now how do we implement run you know it's the same except now it's impossibl
e to have pass in a program of type string so the program of type strain
 can only be by and literal or read it cannot be a path because that's a
 program of type the are G of F path so we don't need this case here and
 instead we just implement directly this case where we have a read of the
 text because there is nothing else we can have so now the code is type
 safe it still works the same code works but a program like this doesn't
 compile this is a compile time error so we will not be able to even create
 data structures that represent incorrect expressions that's the advantage
 of making the DSL file save our types a so here is our DSL so far there
 is a problem with it which is it basically only binds variables of type
 string it cannot bind variables of other types or it cannot also return
 variables of other values of other types because our runner returns string
 and requires a program of strings so still the string type is very special
 and limiting us so for example we cannot do this we must have a program
 that returns at rest so we cannot directly read the past and if we wanted
 to compute this path using a scholar program then we cannot convert this
 into a program of path because there is no way to do that literal can only
 take a string and extends program of string so let's fix these problems
 now so first of all let's make literal a fully parameterize declaration
 so that it's literal of a and it returns program of a for any a and secondly
 let's replace this string by a parameter a as well so that would be a parameter
 even will be an aid to program of B so we want to now have arbitrary types
 instead of string here so we introduce two type parameters in Bound and
 we will have this generality everything else stays the same and except
 we get rid of this program of string and program of path because now we
 have a literal and the literal can always convert a string into a program
 of strain in the path into a program of path with no problem so we don't
 need to have programs as types here if we need this kind of thing we just
 bind a variable and we'll get get what we need so now this is an interesting
 type because the signatures of bind and literal are very similar to signatures
 of flat map and pure if you look at this carefully so literal is of type
 a to program of a bind is of this type program of a a to program of B and
 it returns program will be so if we imagine that this is a function from
 here to here then this is going to be just type signature flatmap and actually
 it is in some sense a function binding dot apply is a function that takes
 these as arguments and returns a value of this type except it's not just
 any function so type constructor so this function is defined in a special
 way so essentially this type has methods of type signature flat map and
 pure it looks like this type is a moment so let's actually define these
 methods flat map map and pure and it's very easy to do that flat map will
 just create a data structure with the case class bind map we defined automatica
lly by a flat map on theorem as we know that in a wallet you can define
 Maps through flat map and pure the pure is defined as just literal case
 closed so these methods don't actually compute anything they don't run
 the DSL they create further unevaluated data structures in other words
 these methods create DSL programs out of previously defined DSL programs
 these are combinators innocence but usually says then the combinators data
 are functions that take values of some type and circle those and create
 new values of the same type the advantage of Khalid affined in flat map
 map and pure is that we can write the assault programs as functor blocks
 and we can compose them very easily so for example if you look at the previous
 program we have a bit of a repetition to have this read past literal which
 we are using twice so how can we reuse that well they are easily make a
 function that returns a string value program like this so we take a path
 we read that files contents and this is a standard Scala syntax for the
 Thunderer block as I call it for yield block and we can use this syntax
 now because we have defined flat map and map in the program trade and now
 we can easily combine and reuse the mimetic values in another factor block
 so we can write this code as functor blocks as we would do with any other
 moaner let's see what the interpreter looks like for this one I think DSL
 now I have full dramatization of types defined viewer and map and flatmap
 and before as a shown in the slide now there is a bit of ugliness in the
 runner because of the problems with type pattern matching scholar has this
 problem where you want to have image at least closet has type parameters
 it's not easy to do that so I have to do a bit of dancing around first
 I match the bind and then I imagine a result I cannot put I parameters
 here that won't compile I think maybe it will but I wasn't able to do it
 right let me see if I can do it in one go Ashley you can see this was entirely
 wrong a great simplification maybe my idea is not the literal and other
 things are the same except now I have to do typecast so again Scala is
 not great when you have to do type parameters on a case class and the dual
 match expression so that's a bit of ugliness but that's not so bad perhaps
 so let's see that all of this actually works and so now we are pretty happy
 we can a monadic DSL now it's perhaps a little too cumbersome because you
 need to define all these things every time so if I wanted to define a DSL
 for complex numbers in the same way as this DSL then I would have to add
 the bind and the literal and these definitions every time so I would have
 to repeat this code every time note that there are no code changes between
 this DSL for the file operations and this DSL for complex numbers up to
 here so this is completely the same the custom code starts later when we
 define some more case classes so let's refactor the DSL so that the common
 code is separated and the custom code is just wrapped in some type constructor
 called F so here's how we do that we say there's a DSL type constructor
 that is paralyzed by the type a is minus 1 and it type constructor F that
 will encapsulate always custom code so the type constructor F will have
 the definition like this just like our first first try at DSL so this could
 be once we add the type parameter this could be the type constructor F
 and then we define just the typeclass the case classes that are necessary
 to implement the moon add functionality to bind and literal case classes
 and then we have this case class ops for operations which contain a value
 of type F of n and so this is a wrapper over whatever custom operations
 we have in our DSL and notice here DSL does not have programmers parameters
 here has the complex as parameters it's up to us we could have programmers
 parameters it's a matter of convenience what important in it but whatever
 that is it's going to be encapsulated now in the case class ops so this
 entire code is going to be generic in operations of your DSL so the type
 constructor F represents the operations of the DSL and power the our tech
 constructor DSL is a melodic DSL is permit rised by that tightness factor
 f so this car is now engineered in the operations of your Union now the
 cost of this is that the interpreter now needs to know how to interpret
 your operations so you have to write extra code as opposed to hard coding
 is you just write extra code that converts your operations to values so
 you evaluate your operation so for example this operation would be the
 domain specific part inside this F type constructor it needs to be evaluated
 to yield this path so let's see how that works so the DSL will be general
 so all this part of code is generic it does not depend on the domain all
 the domain-specific operations are encapsulated by the type constructor
 S which is defined later in a different place of your code so in this way
 we penalize by this type constructor in this code is fully generic in any
 domain so now we need to have the extractor the value extractor were evaluated
 for your domain so this needs to be a function as I showed of this type
 I would like to emphasize of this type is actually parameterize by a typewriter
 a inside the expression it is not business for all a I quantifier needs
 to be inside here it cannot be over there when the reason is that when
 we run the DSL it takes a program that evaluates a value of type a but
 intermediate steps could have different types it could be that in order
 to compute a value of type a you first need to compute some value of pi
 b r c and so on and when you run those programs you need to extract a value
 of type b from some domain-specific operation or a type c so you actually
 need to have a function in the extractor that is parametrized by an arbitrary
 other type it's not going to be of the same type a as the runner and that's
 why we cannot use in scala just a type parameter you need to have an extra
 trait that encapsulate inside but another type parameter so the extractor
 is not parameterize by eight here this parameter is just by F and it's
 function applied or extract or whatever you want to call it just has a
 single method and this method is paralyzed itself by the type aid so in
 this way if the runner has a parameter which is the extractor the runner
 is able to call the function extract on arbitrary types here not necessarily
 the same type as this one so this I could rename for clarity that's necessary
 for the correct operation so that's why this parameter of the runner is
 not characterized by a it's only parameterize by F and inside that drag
 that that value there is a function that works for every X for every type
 X so that is a little clunky in Scala Scala does not have right now a good
 syntax that expresses such a function but the cats library has a case class
 but essentially does this so you can use that it's called the natural transform
ation however so in the cats library this will be like that it's a natural
 transformation which has code something like that now in this case F does
 not have to be a factor you see if you look at our code for our domain-specific
 language this program is not a factor because we have specific types here
 now we do have a map function but only on the entire DSL the F will only
 encapsulate these two case classes because we are now separating the custom
 code from the generic monadic wrapper the binding literal and the F type
 constructor will only encapsulate the domain-specific code which has specific
 types here and does not have a map method so it cannot be a functor it's
 a partial type two type function that's only defined for specific type
 parameters and that cannot be a factor and so it's not really a natural
 transformation in the usual sense because natural transformations are defined
 between factors but it's very similar it's kind of a generic or maybe more
 general case of a natural transformation which you don't need a name for
 it's basically this generic mapping from f of X to G of X for any given
 X so that's the Scala code that expresses this and this now needs to be
 the argument of run so the first argument of run is this extractor and
 the second argument of run is this DSL program so how do we implement run
 very similarly to what we have before except now we have this extra argument
 extract if you compare this with the previous Runner code same code except
 we have run of extract here every time run extract run extract and the
 ops case is slightly different very similar to those other things but here
 we already take care of any custom operations because the extract function
 knows how to evaluate them so extract of F is the apply method which will
 give you an X out of f of X whatever X might might be and so this ops doesn't
 know what type it is doesn't it's parameterize by a type and that's fine
 so the result of this extract is is an f of a and so some kind of f of
 a for unknown type really not there's necessarily the same as this a so
 let's see now how we use this so we now define a type constructor just
 for the custom file operations so this is going to be the F here so we
 called File ops and now this is just the domain-specific operations there
 are no bind case constants were literally classes we don't need those those
 are going to be provided generically extractor needs to be defined only
 for these so this is the domain specific code how to read files how to
 create file paths or verify them or whatever this needs to be so this is
 going to be actual domain specific code and then how do we write programs
 the same way we just need to wrap our domain specific operations in ops
 case class that's all we could define helper functions to have less boilerplate
 in this code but that doesn't really matter right now what matters is that
 we are able to simply write monadic code with their little boilerplate
 so imagine that all this up here with a runner it's completely generic
 it's in the library our code is just this it's only the domain-specific
 operations and then we just use the DSL type constructor from the and we're
 done we use the oops from the library so cats library provides this it's
 called Freeman art and it works let's see how we can use now this is interestin
g yes L know we don't just want to rewrite code in a fancy way we want to
 have value out of this generality so one example of how we extract great
 value from this code is that now we can easily handle errors so previously
 we evaluated a DSL of FA to a now we can evaluate it to either of error
 and a all we need to do is to provide a different extractor an extractor
 would be of this type so instead of going FA to a and goes to fheo some
 error type was in it and the code of the interpreter is almost unchanged
 except so this is the same except the pure needs to put the or the literal
 case cause it's a pure function in the Monad it needs to put this into
 the right or the either and the bind needs to use the flat map on the either
 other than that it's exactly the same so how does this code work well it
 goes through the expression tree when it finds the bind expression it will
 now use the flat map of the either when Al it will first run the same it's
 the same around functions recursive will run on the P so we have a bind
 of P and F run the PETA gives you an either when you use the flat map on
 that either with a function that runs on the result and then applies the
 run to the result of the run ISM is a curried function so that I can write
 this more easily F and then run so the flat map here is from the ether
 moment and this is the pure function of the ether moment so it's very interesti
ng to see that the code of runner only uses flat map and pure from the ether
 moment it's not otherwise aware of the fact that we are running to evaluate
 things into the ether moment and that's very good because it means we can
 very easily generalize to any other model except instead of this one so
 let's look at the code for the either one and the way to do that so see
 the program remains the same we do not change the program at all we just
 evaluate it into a different unit into the ether moment instead of evaluating
 it to just the value a which is actually the identity moment so previously
 we evaluated the code into the identity monad now we are going to evaluate
 it into the either movement so all we need to do when define a new extractor
 which are called e^x just for brevity a new Runner which is aware of an
 arbitrary well it's aware of the either one I'm actually not arbitrable
 not yet and I just rewrite things a little bit so that I compile as : Scala
 and I find that these type parameters are required but that's all right
 so the code works in the same way as in the slides and it applies this
 functional F which is of type that it doesn't know it's not really of type
 in E it's of type type parameter that I have here but it doesn't know that
 so this function f computes a DSL program which I then run so I applied
 a runner to that program so that's exactly the same code as I had before
 except I'm extremely inserting a flight map from the either Monat and here
 is the implementation of the extractor so need a new extractor which will
 run domain-specific code and catch exceptions so I would very easily do
 it like this now I have an extractor that takes my file operations and
 from file operations of a gives me an either of throneworld name so that's
 all I need to run my program now you see I running exactly the same program
 as before I did not have to change that code but domain-specific language
 and I wrote here in order to add error extraction arrogantly that is a
 great power so I can just replace the extractor here and I run exactly
 the same program so this program could be computed by one part of the code
 and the extractor could be prepared by another part of the code completely
 independently and here I have shown how we can interpret the program with
 the result being an either so I call this to interpret the DSL into a monad
 and so here we interpreted this DSL into the ether moment we can just as
 easily interpret it into any other modern by adding the moolaade here is
 a type parameter and getting rid of either here and that's it the changes
 will be minimal because we're not actually using a specifics of either
 here we'll have to replace this by pure that's all so let us see what the
 resulting construction actually is we start with an Operations type constructor
 denoted by F such as this one v oops so this is a type constructor that
 needs to have a type parameter and it needs to encapsulate your domain
 specific operations in a very special way namely it takes the arguments
 of the operations as parts of the case class and the return type of the
 operation becomes the type parameter of this type constructor so that's
 the encoding this is because I remind you that this means a program that
 when run will compute a value of type a so this is a program that when
 run will compute a value of type path and that's how we encode domain-specific
 operations so this operation could be a function from string to file path
 and this is a function from file path to string so that's what we need
 to encompassed and often this type constructor will be not a factor maybe
 it will be a partial type to type function not a factor that needs to be
 a total type to type function always then we use this DSL which is a library
 construction that is written once for all F the interpreter again has written
 once for all F and then we run that program once we prepare a program value
 actually which we can do using a functor block or in any other way or we
 can do it directly using helper functions for instance we do ops of something
 and so on flat map we can just write by hand map flatmap and so on so in
 this way we can prepare a value of this type by combining value so this
 is very composable it's pure value it doesn't yet run anything can be stored
 in variables and arrays whatever you want then you prepare an extractor
 value that will run just your operations or your custom operations and
 represents their values in some monad so this mu naught can be identity
 mu naught if you already want just the final results it could be an error
 gathering monad it could be some other moment for instance could be a state
 monad if you want to represent your operations purely as a state updates
 or someone base it can be a combination of monads it can be anything that
 is a monad it could be another DSL with a different F it could be anything
 so once you have this extractor you run the program like this and this
 computes a value of that moment which could be just a or it could be error
 something or and so on so to summarize so far we begin with a number of
 operations and these operations could have these types we define a type
 constructor then like this typically well this could be more arguments
 and I'll have more parts in the case class if I have no arguments then
 I would have a case class with zero arguments but I need to have a type
 here so usually a domain-specific language would have functions like this
 with some return types so you just put them into your type constructor
 like this and then you do what I just described now there are some other
 things you can do which I will not discuss in a lot of detail in this chapter
 for instance you can choose a different monad and then you can interpret
 this value that you have into another moment so this transformation you
 can define separately and if this itself is a different DSL created in
 the same way then this will be the runner for that DSL that evaluated into
 yet another will not in so this could be very useful if you want to say
 test your your program so you have exactly the same program and you run
 a test interpreter into someone and that catches all the calls to something
 and prints Diagnostics or whatever or you could give design a different
 kinetic DSL that is more optimal let's say more low-level and then you
 can have a sophisticated optimizer that translates one DSL into another
 and the second DSL will be run later in a yet another runner you can use
 monad transformers since this is a monad API and you can combine these
 cells very easily using disjunction so you have several factors or type
 constructors not necessarily factors you can define a disjunction factor
 and the DSL of that contains all the operations from each of these factors
 in a single DSL so in this way you can define separately several dia cells
 using these different F's you could have F G H and so on and then you put
 all of them at once into a monadic wrapper so this is what I call DSL of
 something is really a monadic wrapper over type constructors so these are
 all the benefits that you get by modeling operations one article so let's
 see whether this dsl program respond which i and keep calling it an attic
 DSL is it really omona does it satisfy Monad laws it turns out that no
 it does not satisfy mana flows but it actually does satisfy them once you
 evaluate the program once you interpret it so after you run the program
 that's when the Monad laws are satisfied and that is a very interesting
 property let's see why that is so so consider one more nut law this this
 is one of the identity laws so flatmap applied to pure must be identity
 let's see if this is so now both sides of this law are functions on the
 moon'll so Munna is this so it's a function from this to this so we need
 to apply both sides to some arbitrary program of this type and we need
 to get the new value and see if that value is the same because that should
 be identity so let's see so what happens if we take a program and we execute
 dot flatmap of pure on it now flatmap according to our definition just
 makes bind data structure since nothing is really evaluated we'll just
 put more these classes on the data structure so that that is going to be
 the result now this value is a new data structure it's not equal to program
 PRG it cannot be equal because it contains that thing inside a case class
 it cannot be itself equal to a PRG so it means that this monitor law fails
 and we find that other laws also fail because those laws usually say that
 something is equal to something but all our operations if you look at the
 implementation of flatmap and mount all they do is put more case classes
 on top of things they don't actually simplify anything ever so for this
 reason it cannot simplify this to PRT it will create a new bind and all
 the other monad operations will create new case classes and never reduce
 anything so basically the laws fail if you demand that they hold literally
 like this so our data structure DSL is not a lawful munna it does not satisfy
 the laws but once you interpret this data structure into a target monad
 and assuming that this monad satisfies the Lord then the resulting values
 will satisfy the Lord and that's a very interesting property let's see
 how that works so let's run this value so how would you run this value
 if you apply a run to this and by definition of the code it needs to first
 run this and then apply flatmap with this function and then run the results
 of this function so that is the code and if we now symbolically evaluate
 this code will find that the runner of the literal it will just give you
 a write of a let's say in the ether moment it will be really pure of a
 in general but I'm just substituting the code from the previous line and
 because this is a pure for the either moment the either moment has the
 wall satisfied and so flat map of error is identity and so the result will
 be equal to running the program PRG so in this way assuming that the laws
 will hold for the monel m this both sides when we run them will won't be
 the same so all other laws also hold I will show that next but think about
 what it means it means that the violations of the Monad laws that this
 data structure has are not observable once you run the computation so the
 data structure and they have some extra information inside that gets computed
 away it gets reduced or simplified when you run or when you evaluate this
 into or interpret this into some target unit so in this sense I would say
 that the moral law violations are not observable when you actually observe
 or run or interpret this program there are no violations so these violations
 are hidden somewhere in this data structure and they don't change the results
 they don't make the results invalid and so it's okay to have those violations
 so let me show you now in the code why the moon at law was called after
 evaluating entire law faloona so we will reason by taking an arbitrary
 DSL program and just denote by M the result of running this program for
 brevity and let's see what happens when we run monadic operations on this
 program so for example let's say that program is a pure of something when
 we run that then we execute the code of the runner and that code is a pure
 in the case of the either mona this was the right of X but in the case
 of a general one other will be pure of X so therefore running the pure
 of the DSL gives you the pure of the target monad let's now run the map
 in the DSL and get some other ESL program with some arbitrary function
 f and by definition is going to be translated into this and we run this
 we have to translate that into flatmap because that's how buying is translated
 and then we get this combination now we know that when we do run dot flat
 map this is a flat map in them monad M now if we look at this this is a
 run of the pure so that is already as we know Emma dot pure so now we have
 a flat map in the moon at M of F followed by pure so that is the definition
 in the monad M of map so now this is equal to map in limited M in other
 words running the results of map in the DSL gives you the result of melt
 in the target monad and the same happens with flat map if you run the result
 of flat mapping in the DSL which is another DSL program and F is a function
 from some type a to a different ESL program now we still need to interpret
 the result of this F in the mana dem so this will give us a function G
 of this type instead of a going to DSL of B it's going to be a going to
 M of B this function is like this is f and then run so now if we interpret
 the bind it is going to be the flat map in the model M of F and then run
 and if you just look at what that is that's the function G that we defined
 which is the evaluating of the result of the function f so in this sense
 evaluating flatmap first in the DSL and then running the results is the
 same as evaluating in the Monad M with a function G which is obtained from
 F by running its results so in this sense all the Monad operations in the
 DSL are directly translated by the interpreter into the corresponding one
 at operations in the target one of them now if we consider the laws it's
 very easy to see that they hold after interpreting now we already saw that
 in the slides for this right identity long let's look at the left identity
 law this it needs to be verified we have apply run to both sides and we
 have to show that run of this is equal to run of that so let's evaluate
 the run if we do the pure flat map then this is translated into that we
 run that get run of literal which is just M of pure so you have a pure
 followed by flat map of this but pure followed by flat map is going to
 be in the Monon m and that is equivalent to just this function which is
 G so that's why the run of the two sides is the same because the run of
 this is G of X the natural T law for pure is like this so the DSL peer
 of X of f of X is the slf map of f of dsl P of X so now if we evaluate
 run on both sides then this becomes ampere this becomes MF map this becomes
 ampere so now obviously this hold because M has this law too and finally
 associative 84 flat map it is this one so that lets apply both sides to
 some program PRG and then apply run to both sides so we have the run of
 this should be equal to the run of that so if we now simplify this into
 the Monad m operations then we get this now this flat map G is still a
 bit complicated because G is not yet run in the moon and heaven into the
 moon and M so let's use the law and let's rewrite somehow this expression
 so that we get associative et law for the moon at M now the left hand side
 is this and it should be equal to run of this which is flat map of F and
 the run flat map of G and then run now notice these flat maps are in the
 m1 had this flat map is in the M walnut but the argument of that flat map
 is complicated so we do have the same law for the moon at em but we just
 need to rewrite this a little bit so because that this is going to be M
 flat map something flat map something needs to be simplified into M flat
 map this and then that so how do we figure that out we rewrite this complicated
 expression as an explicit function from a to - what well first we apply
 F to a size F of a then we apply map of G which is this and then we apply
 run so let's run over all this so let's simplify now so run of F of a now
 if we run a flat map that's the same as running this flat mapping of running
 that so what's this and equivalently we can say this is just F and then
 run applied to a and then this is flat map genome then run so if we get
 rid of this a now then we get just a function f and then run and then M's
 flat map of G and then run so that's exactly what we have in the associativity
 wall for EM it's M flat map of this is equal to that so now FM and GM are
 just these FM then run is FM G and the run is G M so we get the associativity
 law the naturality was for flat map could be verified as well we don't
 need to do that since our code is purely type parametric and naturality
 is automatic for that code so I mentioned that this construction is called
 a free Monat and in the cat's library is called free why this word free
 what does it mean free why do we call it a free construction well this
 terminology comes from mathematics in mathematics usually free construction
 is a group or mono end or vector space or some other kind of right construction
 that is generated by certain data with no constraints so free means no
 constraints so let me illustrate this is a bit vague so let me illustrate
 in two by two examples consider two things and I will choose things that
 mean very little by themselves the Russian lettered said and the Chinese
 word way the water say it doesn't really mean anything by itself it's just
 a letter of acrylic alphabet and the Chinese word sway it means water but
 it doesn't matter for now so now suppose what I wanted to multiply them
 I wanted to multiply say by Chui so what does it mean to multiply how would
 I multiply them so mathematicians first asked what kind of product do you
 want do you want associative commutative distributive product so let's
 say we want an associative product not necessarily commutative so mathematician
s would then say very very well what you want is to define some kind of
 semi group in other words a structure that has an associative but not necessari
ly too negative product and you want a semi group that contains say and
 Shui as elements that's what you want you don't and and you would say well
 but I have no idea what these are would say in Shui is I've no idea no
 no worries I'll get you a semi group that contains them and if you have
 a semi group that contains on a semi group is a set and these will be elements
 of that set and if you have a semi group that contains them then you can
 take a product of them so here's how the mathematicians would do it they
 would consider the set of all unevaluated expressions of this kind any
 onion valued expression with the multiplication sign or a product symbol
 dot which I have here and one of these symbols say say or Shui so this
 would be an unrelated expression this will be another undervalued expression
 but we will have the law that this product is associative so see this expressio
n isn't equal to another letter of the Russian alphabet or another Chinese
 word it's not equal to any of those things it's just an expression that's
 not evaluative it's a new thing so we have a set of a lot of new things
 and say and Troy is our one of those things but there are a lot more of
 those things in the set because we are considering the set of all unevaluated
 expressions of this kind so the set of all these expressions is called
 a free semi group generated by of the elements say and Shui and in some
 sense it's the most unrestricted semi group that contains these two things
 you could have a lot of semi groups that contain these two things as elements
 but this one is the least restrictive it's the most free of all arbitrary
 restrictions as long as of course you have associative 'ti of multiplication
 so you can calculate in this semi group for example this is a calculation
 that I can do I take these two expressions I take their product and then
 I multiplied by this expression and I get this expression as a result these
 are calculations that I would do in this free seminar and what would I
 do with that well I could interpret the semigroup value into another semi
 group for example integers imagine integers as a semi group with multiplication
 as a semi group operation I say that say is 17 and Troy is 3 so then these
 are just going to be 3 370 370 will take a product of all of those and
 I have a number so I have evaluated this so in other words this is going
 to be some kind of symbolic program that will later be evaluated in some
 way and that's very similar to what we have been doing with our DSL was
 a symbolic program that was interpreted at the end into a specific values
 but we can do calculations like this before evaluation and this is a similar
 to combining parts of a DSL into a larger DSL program and while we're doing
 this we still have the illusion we are performing these operations so how
 do we represent this as a data type now the easiest thing and what we have
 been doing so far is what I call the tree encoding in other words we represent
 the free semi group as a full expression tree so here's an example each
 operation of product is just a pair in the data structure so I have a tuple
 of this and this and I'm missing one parentheses on the left I will insert
 that in the slides and after the recording yeah so I have a tuple and this
 tuple represents the free product of the tube Shui then I have this tuple
 which is a free product then I have a free product of these two and finally
 a free product of the result and it's a and so that in this way I represent
 my expressions it's very easy and operations are very easy to implement
 because in order to do for example multiplication I just put the two parts
 into pop and I'm done so this is exactly equivalent to adding one more
 case class on top and having a nested structure and in this way I implement
 all my required operations but there is a another encoding which I call
 reduced encoding and this encoding is smarter it is less redundant and
 in this case it's going to be a list of all these things taken in this
 order this list is equivalent to what you would write on paper because
 the associativity law means that it doesn't matter where the parentheses
 are you can omit all parentheses and they will still get the correct result
 and so since we know about that we are clever and smart and we realize
 that the list of these things in this order is sufficient it is sufficient
 information to represent a value in the threesome Anoop now if we want
 to implement the multiplication operation you cannot just put the two lists
 in a tuple you need to actually concatenate the two lists and that could
 be more expensive depending on your implementation of Lists it could be
 a very quick Big O of one operation or it could be a more expensive operation
 but this structure has no redundancy whereas this structure has redundancy
 you could put parentheses in different order and it will be a different
 expression tree although the final value is supposedly the same let's consider
 another example which is a product of n dimensional vectors so what if
 I wanted to define a product of two n dimensional vectors or we have such
 a product for three dimensional vectors this is the well-known vector product
 in the usual euclidean three-dimensional space but let's ignore that and
 in any case I want product for n dimensional vectors with any n and that
 doesn't seem to be generalizable from three dimensional vectors so how
 do I do that all a mathematician again will ask me what kind of product
 do I want I say well it's a product of vectors so I expect it to be linear
 and distributive not necessarily commutative but I want a product that
 has these properties for example I want to be able to add so linear means
 I supposed to be able to add different products together and that should
 be associative and I'm supposed to do this so if I have a linear combination
 of vectors under a product I should be able to pull this thing out and
 expand the parentheses and that's a distributive law and the distributive
 law should hold for left and for right as well all right says the mathematician
 you need a free vector space generated by all kinds of pairs of vectors
 from your own dimensional space so let's do it in this way we consider
 all unevaluated expressions of this form where u and v are arbitrary vectors
 from your n-dimensional space so this is a the first step the second step
 is to impose the equivalence relationship so before this you gather just
 a free vector space you have all all possible linear combinations of all
 possible products that's the first step the second step is to impose equivalenc
e relations so you will consider certain pairs of expressions to be equivalent
 according to these laws the result is usually called the tensor product
 of vectors and again we can have two in codings for the tensor product
 the first encoding is the full onion valuated expression tree and that
 will be just a list of these vector pairs and that could be a very inefficient
 representation if you have a lot of those pairs but it could also be a
 very efficient representation if you have a very sparse tensor product
 the reduced encoding that is the encoding that has no redundancy is to
 represent tensor product as an N by n matrix of vector coordinates in some
 basis now reducing this expression to the matrix form requires computation
 and it could be well first we need to prove that you're encoding is adequate
 that for example this expression and this expression always corresponds
 to the same encoding and then your laws would be satisfied your preferences
 will be satisfied and any component operations so we'll translate this
 into matrix and add matrices and so on but do that so that's a choice so
 this is why we use the word free construction so basically we can use the
 mathematician the mathematics intuition to implement data structures with
 properties generated by things that don't have these properties you see
 the the common topic here is that I wanted to define an operation for things
 that don't have this operation like I wanted to multiply a Chinese and
 Russian together its word and the latter it's it's not defined but I wanted
 to define it in some way and I can in a free way so in the programming
 language we just saw an example where I was able to define a monad out
 of a type constructor that isn't even a function let's look at some other
 examples and here would be an example of a semigroup that's generated by
 two types so that's kind of similar to my chinese and russian example so
 how do we define that so let's see how that works so let's call it FS is
 which is free semigroup from integer and string so a value of FS is could
 be an integer or it could be a string also or if x and y are already of
 type of a silenced and so is this combination of ex-wife co-come the case
 class so i straightforwardly translate this specification into the datatype
 and this will be the three encoding it's a full expression tree unevaluated
 and but that's okay it's a good encoding for some usages the short type
 notation for this is going to be this is recursive type that is defined
 by this type equation so let's think about how we can use it now if we
 have an actual semigroup as a specific 7u and we know how to map integers
 and strings into that same group then we can map this FS is interested
 in you that's our interpretation so let's see how that works it's a little
 too specific with integers and strings let's just put all of these domain
 types into a type Z and make that type of parameter so then the three encoding
 would look like this it's a recursive type that's defined like this so
 I omit the Scour definition let me just write the definitions of the methods
 so the method of semigroup operation is very easy I just put the two arguments
 into a case class and the run method takes a semigroup and an extractor
 function which Maps my Z into a semigroup and that's equivalent to the
 two functions that I assumed here before just a single function from Z
 to s so then I get a function from my free semigroup generated by Z to
 us how would that work I match on the free Simon group it has two cases
 the case of F well I call it rap here let's call it f then I just oops
 I just extract I have a value of Z and I call this function extract and
 to extract the value of semigroup s from it and if I have a combination
 then I first run these two and then I get two values of type s and I just
 combined them in the seven group operation of s quite similarly the semigroup
 laws will hold after I try this run they did not hold before applying rather
 why is that it's well it's very easy to see that social Timothy does not
 hold because I would have a comp nested in different order and that's not
 equal so it's only after applying the interpreter that laws will start
 holding and the reduced encoding is a non-empty list of Z's so that's a
 reduced encoding actually I should have said here it's non empty list I
 didn't make that that remark MFG lists cannot be constructed because you
 have to start with either sell or Shui and apply the semigroup operation
 there is no empty value possible so that's why it's a non empty list and
 then the combination operation will require when you run this you'll have
 to concatenate the lists but maybe the run operation will become faster
 because then you have fewer structures to traverse as another example let's
 implement implement the feel annoyed the Fremen are generated by type Z
 it's very similar to a free summer the value of free monoid of Z can be
 empty because it's a monoid or it can be a Z and then you have a multiplication
 so I should have called it comm not law so therefore the female noid of
 Z in the tree encoding has these case classes the empty the wrap which
 has the inside and the chemical combination which has two values of F M
 of Z inside the short type notation for this is just like that so here's
 an implementation of there brother the plus operation simply puts to the
 occasion top and the runner just does the same thing as before and it puts
 the MS empty and Emma being Illinois it has an empty element instead of
 this so when we interpret this tree structure we just substitute specific
 operations of the monoi M except for the wrapped case when we use the extractor
 and Malloy Clause will hold after we apply this function so this was the
 tree encoding and the reduced encoding is just a simple list where this
 operation is concatenate in the lists the empty is the empty list and the
 wrap is a list over one element and so it's interesting actually to notice
 that after running the trillion coding and the reduced encoding would give
 you the same result there are just different in coulombs of the same value
 there are not equivalent in terms of their performance perhaps and memory
 requirements are different our equivalent in terms of the resulting value
 let's look at the code so here is an implementation of the free moderate
 generated by type Z so Z is some domain specific type and we have this
 combination and we just implement what I said in the slides and here's
 an example of using this definition so first I define an annoyed of integers
 in the standard way and then I want to do a free monoid over this this
 was my example in the slides so I define Z to be that then I if I an extractor
 extractor is a function from z to integer so how do I do that well if I
 have an integer I just leave it there if I have a string I have length
 of the string it's just for this illustration so now I construct a free
 monoid value so how do I do that well I use the wrap constructor to do
 specific values of Z so either left of interest right of strength so I
 wrap them and then I combine them with the plus operation so this is a
 free monoid value which I can then run with my extractor and the result
 is 16 because it's 12 and then 3 the length of this and then 0 because
 it's empty and then one so all this must be added so that's why it's 16
 so let me also verify that the monoid laws would hold after running so
 let's just maybe make extract into an implicit argument and not not right
 every time or something just I'll just run of excellent yes miss oh shit
 a beauty law so I run this and I should get the same result as when I'm
 running it with people other order of parentheses when I run this I run
 over this structure now you see this structure still has the information
 about the order of parenthesis but when they run it each comb is translated
 into the monoid operation plus in the target memory M and so when I run
 it the second time I get this result which is in the target monoid m and
 it has now no more information about the order of parentheses and so when
 I run the other order of parentheses I get the same result let's check
 the identity law this must be equal to the result of running X now this
 is not actually equal to X because it's this combination this class so
 as usual the laws do not hold before you run because you are piling up
 case classes but when you run that iran identity that becomes m empty then
 you're on of X and that's a monoid law in humanoid m that this should be
 equal to run of X and so running of empty + X gives you the same result
 as running X and the same will be for the other order now in the reduced
 encoding it's obvious that all of this works because it's just a list we
 know that list as I will know it so there's not much to implement and the
 runner however needs to go over the entire list so the runner I'm implementing
 it using a fold over list and I'm folding with the monoid operation in
 the target one with and I'm running exactly the same code as before with
 pretty much the same code except here I'm using a helper function to wrap
 my values I get again exactly the same result so what if we interpret this
 free semi group that we had before into another free semi group well that
 would be an interesting thing to do in general we can interpret if we have
 so for example free semi group generated by Y into a free semi group generated
 by Z we can interpret if we have an embedding from Y into the free seminar
 of Z that is certainly what we can do but we know it's a free semi group
 so what if we just haven't been emitting from Y to Z not from Y to the
 free Simon group of Z there's a free semi group is a big thing it's not
 maybe it's much easier to do this indeed that's very easy because we just
 need to map this into that and it's straightforward because this is a fun
 trip so this type constructor is a factor as you see it has the type parameter
 always in a covariant position for positive position so this is a standard
 code that you would write with your eyes closed to implement the map for
 this function so now we can use that and have a chain like this we first
 map map and then run let's think about how we can simplify this well first
 of all this is a functor so functor laws hold for its of' map is composable
 we can compose these two functions from X to Y and from Y to Z into a single
 function from X to Z and just F map once instead of F mapping twice what's
 interesting is that the interpreter also composes with F map in a way and
 this is done by this diagram so if you first so I'm killing the Z here
 so I have just FS x FS y and s if the first F map X to Y and then run through
 some function G that is the extractor from Y to s we should get the same
 result as when we are running with the composition of these two functions
 indeed that is a law that the interpreter satisfies and we can combine
 the semigroups in this way and we can also combine them in disjunctive
 way why is that well consider this semigroup we have obviously an injection
 from X to the disjunction X plus y so then we can F map it and we automatically
 get this injection which means that a free semigroup generated by a disjunction
 of some types contains a free seminar generated by one of these types so
 in this way we can combine semigroups in easily if we know the types of
 free semigroups to combine free semigroups if we know the types from which
 they were generated so next we will consider what we can do further to
 simplify mapping free semigroups to different targets 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
if we need to map a free semigroup into multiple targets in groups say s1
 s2 and so on then it would require many extractor functions with this type
 signature each extractor function will have to convert the generating element
 Z over the free semi group into a specific segment Rufus 1 as 2 and so
 on we can refactor these extractors it into evidence of a typeclass constraint
 so instead of saying we have a semi group s and we have this function for
 that semi group it would say we have a semi group s that additionally has
 a typeclass constraint and so we define a new typeclass let's call it X
 Z for extracting from Z and it has a single method of this type signature
 then we can refactor the run function into this form it will be now parameteriz
e by a semi group s that additionally to the semi group typeclass also has
 an extract Z typeclass instance and that would mean would have an evidence
 on value of this type which would contain this function so that's very
 similar to what we had before when we had the run method it had an argument
 containing the extract now we will have no such argument we'll just have
 an argument specifying the free semi group value and additionally we'll
 have a typeclass constraint which in Scala is translated into an implicit
 argument of the type exe of Seminole which will just contain this extract
 function so far this is a refactoring that doesn't seem to bring a lot
 of benefit except that now this code is going to be completely the same
 for all extractors and we just need to define different extractor typeclasses
 for different semi groups so another refactoring that will follow from
 this is found if we look at the structure of this run function so what
 does it do it translates the free semi group value into a value of the
 specific semi group s by pattern matching on the case classes from the
 free semi group and the free semi group has two case classes the rapp and
 the combined case class what the run does is that it replaces these case
 classes by some fixed functions and these fixed functions are permit rised
 by a semi group having this extractor constraint so all we have done is
 first we have created a value of free semigroup which will be some case
 classes and then we just translate these case classes mechanically into
 these fixed functions so the main idea of what is called the church encoding
 is to represent the free semi group directly by these functions just skip
 the case classes all these cases class case classes do is to denote what
 needs to be done what these functions will have to do when we run the free
 value so instead of representing a free semigroup through these case classes
 represented directly through these pieces of the run function in other
 words instead of saying that the free symmetric value is of type rap we
 say it is equal to this function which will be terrorized by this semi
 group s with two typeclass constraints so here's what will happen if we
 do that we will have two functions so one would be the combining function
 and one would be the wrapping function but the combining function actually
 is defined in the semi group s it is not something we define so really
 we just need to define the wrapping function so this wrapping function
 will be this part of the room and the combining function is already defined
 because the plus operation is part of the semi group typeclass so the definitio
n of the free semi group just becomes the definition of a wrap function
 which is parameter I'll begin by by this we don't need the semi group constrain
t right now for this function we could have written it but we wouldn't have
 used it and then suppose we want to define the value X of type free semigroup
 which would be say combination of wrapping one and wrap in two instead
 of doing that we just write down this so you know what these are values
 of the free semi group and these values are now deaf because they're they're
 not vowels their deaths because they're actually functions parametrized
 by a type parameter and having implicit arguments so they cannot really
 be valid anymore because they're parameterize by a type parameter that's
 another difference so now we have encoded this X so this X is basically
 a function that already runs it's waiting for you to give it a semigroup
 yes but once you give it then it will run and all the implicit arguments
 will be substituted and you will have a value in your signature but until
 then you have defined it and it's waiting for you to run it so this is
 then the encoding of the free semigroup using functions using directly
 pieces of the run function so we don't need a run function anymore we already
 encode values on the free semigroup through the pieces of the run function
 that would be run in the previous encoding so the previous including is
 a tree encoding or the expression tree encoding this encoding is called
 the Trojan Colin let's look at the type of X explicitly let's drop all
 this syntax what is the type of X well it's first of all is parameterize
 by a semi group type s and so this is a function that will work for any
 type s so let's write it down explicitly as a universal quantifier which
 will be read for all s so for all s we have a function that takes the extract
 Z typeclass evidence which is a function type z2 s it takes the semigroup
 class Evelyn's likewise evidence which is this method and it produces the
 value of s so in other words it is this function which is parameterized
 by type s so this should work for every s and we want to write those explicitly
 using the universal quantifier now we can simplify this type using an identity
 but the product of these two functions is equivalent to a single function
 from disjunction of Z and s times s to s so now this type which is equivalent
 to this type which is equivalent to this this is the church encoding of
 the free semi group over Z or free semi group generated by a type Z I call
 this charge encoding for reasons that I will explain but look at this type
 signature this type signature looks a little bit like a continuation monad
 continuation monad would have this type now we have this and then these
 two nested functions they are very similar to a continuation monad but
 it isn't really that it's it's not really a continuation monad because
 of this quantified type the continuation monad has a fixed result type
 R it is not quantified over that type does not permit rised by that type
 and does not have for all our in front of this but we do have for all s
 because this is our type parameter in the function so each value over the
 free Simon group is a function parameterize by an arbitrary s s being a
 concrete non free semi group or github perhaps another free semi group
 but eventually it must have must be a non free Simon group in order to
 get any values onto this non free actual useful values so that's the type
 now there is a theorem in type theory which is that this type expression
 is equivalent to just a type a I will present a derivation of this somewhat
 informally but this is the basic fact that is at the basis of the entire
 idea of the church encoding what I call the church encoding of a type a
 is this type expression so whatever type a is you can just say I have a
 type a or you can say I have this function parameterize by an arbitrary
 X with this type signature that's equivalent to having a type a so I call
 this the church encoding of other type a and so unlike the continuation
 monad the the presence of the universal quantifier makes this function
 fully generic in X and it becomes like a natural transformation between
 this factor and this identity factor so this is a reader factor with type
 a being read X is the parameter and this is the identity function with
 X as the parameter so this is resembling a natural transformation between
 these two functions and we know that if this is a a function with fully
 parametric code in other words code that does not use any type information
 about X then this will actually be a natural transformation so there is
 however a bit of difficulty in understanding how to work with Church encoded
 types there are complicated there is this function whose argument is again
 a function and it's parameterize over arbitrary X it's actually not easy
 to reason about such types so in order to develop intuition let us consider
 a simpler example where we take a disjunction type just an ordinary disjunction
 type not a functor nothing like that just an ordinary disjunction of types
 P and Q and let's work with its Church in Korea so by definition the church
 encoding of this type is this type expression now we can simplify this
 because it's a disjunction in a function argument and this is equivalent
 to a product of two functions from P to X and from Q to X and this is equivalen
t to a curried function with this type so so far I have done nothing but
 I have equivalently transformed this type into this for convenience now
 in Scala in order to implement such things I have to hide this type parameter
 somehow I cannot have a type so I need to have a type that has inside it
 inside of it a def with type parameter so in order to hide it I have this
 Scala code which is the usual pattern for putting a universally quantified
 value into star distance car does not have the universally quantified values
 it must be a def as I did before now this is not very convenient you want
 to have a Val with the universal quantification inside so in order to do
 that you define a trait let's call this trait disjunction it's going to
 be church and call it disjunction P and Q are going to be just parameters
 for it I didn't necessarily have to do it this way importantly the street
 has a method inside that is parameterize by X and this X is not one of
 these type parameters so this type parameter X is hidden inside the trait
 in this way as a method of the trait and when that happens when a type
 parameterize function is a method of the trait it means that you can call
 this method with any type parameter X so in this way it implements the
 universally quantified type X and it's very easy to just write down this
 function signature like this so how can we define values of this type so
 for example we define left given some ULP we want to define a left part
 of the disjunction we need to create a value of type disjunction so in
 Scala this would be creating a new anonymous class by extending this trait
 and implementing the method round so this is Scala's boilerplate for hiding
 the universal quantifier but then we just need to implement this function
 which is easy we need to return X we have the two functions P to X and
 Q to X and we have a P so how do we return X we'll just call this function
 on the P so in this way we implement the left we'll also implement the
 right in this way we can create values of this type now quite easily so
 suppose that this this this G is a value of this type how can we implement
 a case expression well we can just call the run method on two functions
 like this and that would be actually the case expression so the result
 would be of type X because that's the result of the run so in this way
 we program with disjunctions in the church including and note that this
 would work in any programming language that has nameless functions it does
 not the programming language does not need to have disjunction types built-in
 so all we need to do is we need to create this construction which does
 not have any disjunctions inside now this does so this I would not be able
 to implement in a programming language that doesn't have disjunctions but
 this I can implement in such a programming language and so actually I have
 heard that people have used this trick the church encoding for implementing
 disjunctions in JavaScript the GU language also comes to mind as a very
 primitive type system and I'm not sure how but with generics it would certainly
 be able to implement disjunction types Java could do this too so general
 recipe for church encoding is that you need to hide your universal quantifier
 so you create a trait with method which adi will always call run in this
 tutorial this method has an argument which is this continuation like function
 or this function maybe several of them may be a product of them if you
 have a disjunction and then you can also think about making it more convenient
 so if you have a lot of things here and not just one function but a lot
 of parts of the disjunction this could be cumbersome so you could split
 it into products product of functions and then you could say this is a
 value of some type so you could even do a trait or a case class and parameteriz
e by X containing just this argument of the Church encoding just for convenience
 and this is specifically very convenient with disjunctions because you
 could just define like this instead of defining a run method with this
 type signature define it as a function from exo X to X and so this is actually
 much easier to use with languages such as Java or JavaScript where you
 have objects with methods but you do not have disjunctions now notice that
 case expression which replaces pattern matching for these junctions is
 actually consisting of running this function so the church encoding of
 the type is a function and calling that function means running so just
 like in the free type constructions when you interpret the free value or
 DSL or your interpreter runs you get some final value that's in the Church
 in Korean means you call this function and get your final result the church
 encoding in some sense encodes your DSL or your operations or your program
 your declarative program encodes in terms of pieces of the interpreter
 that are necessary to run it and so pattern matching is impossible on functions
 you cannot determine whether this function uses its argument or not for
 example by any kind of pattern matching on this function value you cannot
 do that the only thing you can do is to run this function so one deficiency
 of church encoded types is that they have to be run in order to a pattern
 match they cannot pattern match say on disjunction without actually having
 some kind of result type some kind of target X and putting that X in there
 putting the extractors in there and running this function now certainly
 you could be clever and your ex could be another Church encoded something
 else so you or non Church encoded something else you could very easily
 convert this back into the ordinary disjunction type and then you could
 pattern match on that but in order to convert this to anything you have
 to run it so Church encoding has certain advantages it is easier to work
 with if you have many targets and we will see other advantages of the church
 and queen it does have also disadvantages and I will talk about them but
 one disadvantage we see right away is that pattern matching is impossible
 until you run or unless you actually run your church encoded value so let
 us see how the church encoding works so why is this type equivalent to
 the type a so let's just consider this very simple church encoding of a
 fixed type a which will be implemented like this so in order to show equivalenc
e between the church encoding and the type a we need to present isomorphism
 between the types which is a pair of functions from a to the church encoding
 and from the church encoding vector a and we need to show that these functions
 are inverses of each other so that a composition of these two functions
 in every order is identity so if we have a value of a how do we get the
 value of church encoded a well if we have a value of a then in order to
 produce this we take this argument which is a function of a and apply that
 function to the value of a that we have the result will be a value of x
 which we return so that is the code I just applied this given function
 or the continuation argument if you will to the given value of a so that
 is in one direction in the other direction in order to extract a out of
 this we can call well the only thing we can do obviously on this value
 which is a function is the call that function on which argument and with
 which type X that is our choice so we call this function by calling run
 with type X equal to a so like this and in an argument which is identity
 function from a to a the result would be some a so that's our second converter
 c28 Church included two direct type so it remains to show that these functions
 are inverses of each other so how do we do that let's think about how could
 it be that we have a value of this type for any X given this function we're
 able to produce a value of x now if I I'm able to produce a value of an
 arbitrary type X and I don't know anything about that type the only way
 I can do that is by using this function somehow and this function needs
 to be called to produce an X on some value of a so unless I have a value
 away I can't possibly have this so this is the intuition that explains
 why this type is equivalent to a the only way of having a value of this
 type is to have some value of a now this value what if I have two different
 values of a well the problem is I could only use one of these two values
 because I'm supposed to produce this which has a universally quantified
 X and I'm not supposed to look at X so this is supposed to be generic in
 X so I could not for example check whether X is integer then I use one
 value of a if X is not integer then I use another value of a that is not
 allowed by by this type this type is fully generic in X and so I am not
 allowed to use any specific information about what the type X might be
 I could not write code like that I mean I can write code like this and
 scholar of course but that is not what this type is this type says this
 is a fully generic function which is a natural transformation from this
 function to this functor I'm not allowed to look at the code of X at the
 type of X I'm not allowed to use reflection for instance or any other informati
on about the type of X or or the value of anything I'm supposed to be completely
 generic so if I had many values of a at my disposal I be forced to choose
 one of them for all X and use that one value of a in order to create this
 thing for all X in other words the only way to have a value of this type
 is to have a fixed value of a and then this is how I'm forced to implement
 a value of this type so that's intuition now I would like to be more formal
 and show that for any Church encoded value CH if I first convert it to
 a using this converter and then I converted back to CH then I have the
 same stage as I started with but what does it mean I have the same CHCH
 as a function so this function must be equal to that function now equality
 of functions means if I substitute some argument into that function I get
 the same value as a result by applying this side and this side so let's
 apply both sides to some function f of type a 2x and then we can simplify
 this so what does the CH run of f is on the left hand side and the right
 right hand side is this run of F now this run of F we can see what that
 is it is a continuation of a which means it is an F because the continuation
 is going to be F the argument of run is going to be f so f of this now
 substitute the definition of c2a it is this and F of that so see H dot
 run of a to a now we cannot really simplify this anymore because we don't
 know what CH that run does it is a arbitrary given value of this type so
 we don't really know what it does when we call it on a to it but if we
 look carefully at this equation so we are now required to prove that this
 is equal to that looking careful in this equation we find that this is
 the condition of naturality of the function G H run as a transformation
 between the reader factor and the identity function applied at type X this
 is a natural allottee condition here is how I can illustrate this using
 a type diagram naturality condition means that if we do an F map so we
 have one factor on the left another factor on the right we have a natural
 transformation between them if we now F map with some function on the left
 and we F map with the same function on the right diagram should commute
 and this is precisely the equation what we have written here run over F
 is precisely that F sorry I'm I'm confused it is this direction first the
 left hand side is this direction this is the run of F and the right hand
 side is this direction first Iran of identity and then you apply F to that
 so the left-hand side corresponds to this direction on the diagram and
 the right-hand side responds to that direction on the diagram commutativity
 of the diagram is therefore exactly the same as this equation so in other
 words we have shown that this function will be equal to that function as
 long as we demand that this is a natural transformation so this code must
 be fully generic should not use any type information about X and the counter
 example would be looking at the type of X and using different values of
 a to create a to see here so calling this on different values of a depending
 on what X is so that we could write this code in Scala but this would not
 be an actual transformation the other direction is easy very fun if we
 just substitute the code C to a of a to C of a C to a is this and then
 a to C away as a run function and then you have identity applied to a and
 that's 8 so in this way we can show more formally that this type the church
 encoded a is actually equivalent to the type a as long as we understand
 that this must be fully generic code and in other words a natural transformatio
n that means these two parameters and another property of the church encoding
 is that since it is built up from parts of the run method of some typeclass
 usually it will automatically satisfy the laws of that typeclass now this
 example as well as this example were not examples of typeclasses that are
 and what I was going to church in code this example was a typeclass the
 tie church encoded the free semi group and the property of the church encoding
 is that it will automatically satisfy the laws and the reason is we know
 that laws will be satisfied after you run the typeclass a free time class
 instance this we already saw and therefore since our church encoding is
 basically functions that run and the only way you can use them is to call
 these functions then Church including will satisfy laws automatically in
 the same ways this function is equal to that function which we verify by
 calling these functions applying them to specific arbitrary argument a
 war for a typeclass means that you need to run the church encoding and
 then compare the results so since we know that the run method for free
 typeclasses satisfies the laws it follows that the church enrolling over
 free typeclass will automatically satisfy the laws of the type course so
 this is a very nice property of the church encoding let us look at the
 code of church encoding a free similar here we define the extraction as
 a typeclass and then in order to define the free semi group we have very
 low to work left to do unlike previous implementations where we have to
 first define case classes and so on we don't define any case classes here
 the Reb constructor is like this and then we are ready after this we have
 defined the extraction typeclass we are ready to start working with seven
 group values don't need any anymore preparation so here is x and y these
 are already values of the three seven groups so here's a computation we
 wrap one wrap to wrap three add them that's it we have now defined x and
 y these are three similar values no more ceremony so this is another good
 thing about the church including perhaps in order to interpret we don't
 need to define interpreters these are already interpreters let's see how
 that works we will interpret this threesome in two string which would have
 a standard seven group instance so let's define are those standard semi
 group instance for string now in order to extract into string we need to
 have an extractor so let's make it available so now string has a typeclass
 instance of the extractor typeclass and we can run that's it that's how
 we run we do need to specify the type parameter but that's it so we don't
 say or run this with that extractor all of that is in place and so we have
 a lot of computations in our DSL those computations are going to be more
 concise here is the code for implementing disjunction with some testing
 here is for example how we have a case expression so X is a disjunction
 which is left of ABC and here we want to match on X and we have the two
 possible cases and that's how it works so now we have seen the encoding
 coatings of three typeclasses let's now look at examples and have a more
 have more intuition about how these including actually work and what are
 the trade-offs in each of these in committees the simplest typeclass that
 has type constructors is factor now until now we are looking at the semi
 group or Minh mono it now these are typeclasses for types functor is a
 typeclass for type constructors and for type constructors things are a
 little more difficult and there will be more syntax and more type notations
 however they are quite similar to non-constructive typeclasses in very
 important ways they are very similar so keep in mind that free semigroup
 Freeman or your free filter are basically applications of the same construction
 to different typeclasses in order to construct a free functor the first
 question we need to ask is what methods is typeclass requires so there
 is one method let's look at this method so the tree encoding of a free
 factor would have directly encoded this as a case class let's call it f
 map and it will also have a case class for wrapping a type constructor
 that we base that we generate from so to remind the free functor typeclass
 needs to be generated by a type constructor so we don't just have a free
 semi group we have a seat free semi group generated by type Z so we don't
 have a free functor we have a free functor generated by a type constructor
 if we need to start with some type constructor which doesn't have to be
 a functor it can be but it doesn't have to be so we I call this free funder
 over F now I introduce this notation this bullet in order to emphasize
 that F is a type constructor it has a type argument here which I'm not
 writing I could write F a but a is not known is an argument so it's a type
 function really so I'm trying to find notation for type function so in
 Scala it'll be like this and I don't like this notation so much but it's
 okay but in my short notation I right now found this to be a little better
 more visual so this is a type constructor F that waits to be given a type
 arguments so just like this in Scala and so this is the tree encoding of
 a free factor so I call this a tree encoding because this encodes an expression
 tree unevaluated expression tree for a functor valley now what did I do
 in order to write this code are basically the wrapping now a trait must
 be there this is a scala syntax for disjunction so I need a disjunction
 so one case class raps a value of F of N and the other case class raps
 this so it's it's going to denote the result of applying F map to a free
 constructor note that this F map has an extra type parameter because we
 extend the F of a so I have chosen the name Z here the result of F map
 is F of a so we extend f of a but the arguments of this case class or the
 parts of the case class have a parameter Z it's an arbitrary FZ which is
 going to be this free functor of Z which we map with a function of Z to
 it and the result is a free factor of a so this type parameter Z is hidden
 inside the type constructor we extend F of F F F F a naught of Z so the
 Z is not visible outside so we outside we will think this is a value of
 this type but actually inside it has a Z now this is a very interesting
 situation that we have a case class permit rise by an extra type parameter
 which is hidden from the outside type and let us look a little in more
 detail about what it means to have such a type parameter let's consider
 a simpler example simpler than all this and write this code so I declare
 a sealed trait with a type parameter a and inside it I have a case class
 that is permit rised by another type parameter Z and it has values but
 depend on Z but it extends key of it so it hides the Z from the outside
 type let's look at how this works what if I wanted to construct a value
 of type K of F how would I do that well here's here's how there's only
 this case class so I have to use this case class and I have to specify
 some other type for Z let's specify string and then I would have a value
 which has visible type Q int but actually inside it's hiding a string type
 and it knows that it's hiding experiment right so it could have been another
 type so when we have a value Q of this type we know that it is integer
 in this parameter but we don't know what is this other parameter Z we know
 that it exists inside Q hidden inside Q so it is called the existential
 quantified type so this is a tie Plantation that I would use to denote
 this this definition this definition is a type constructor with parameter
 a witch inside hides a type Z which must exists also to build a value this
 type we need to find some type or select some type Z put it in put a value
 of this type in there but we hide it so other outside we don't see that
 Z it's exists inside so this is a notation and this is called the existential
 quantifier so this existential quantifier basically says that this I constructo
r it has this type so the function qz construct s-- a value of key of a
 so it hides zi some very interesting thing so the syntax says that qz is
 parameterize by both NZ but rho is very different for a and precede the
 role for Z is existentially quantified because it's hidden from the outside
 role of a is a type parameter visible from outside and the functor ends
 in a so this is always a factor in a it is not universally quantified so
 even though it's a type parameter here it's not universally quantified
 with respect to Z and this is so because when you build up a value of this
 type you must use a specific Z it will not work for another see later it
 would have that specific Z baked in the value Q once you construct it so
 that's why it is an existential quantifier and not a universal quantifier
 but the code does not show this explicitly the code is a bit confusing
 we have just seen a universal quantifier in the code here and here and
 the way to implement this universal quantifier was to have a method insider
 threat a trait and the method was paralyzed by this X the way to have an
 existential quantifier is to have a case class inside the trait and the
 case class experiment rised by the Z the method inside the trade hides
 the X because the X is not a parameter here the case class inside the trade
 hides the Z because the Z is not a parameter here so until now it's very
 similar but case class is not method quite rate so this is the crucial
 difference so if it's a method of a trait then this would be a universal
 quantifier a method that has an extra parameter hidden from the outside
 a case class with an extra parameter hidden from the outside that represents
 the existence of quantifier so we have to keep track of this ourselves
 the syntax of Scala does not help so much to keep track of this but this
 is a very significant difference between the types 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
so we need to keep in mind that the encoding of the three-factor uses here
 Z as the existence of quantified title to get a little more intuition about
 how the existence of modified type works let us consider a simple example
 similar to this one where you have existential quantified type Z with a
 function mapping it to something and another piece of data containing that
 type so consider this type expression just temporarily I denoted this by
 P a and we will now show that P a is actually equivalent to the type a
 a scholar implementation of PA would look like this we would have a sealed
 trait and a single case class that hides the type Z now imagine we would
 like to construct a value of P a where a would be some fixed type say integer
 in order to construct it it would have to use the case class easy and we
 would have to give some value of the type Z and the function from Z to
 a so imagine that we have the type Z equal to a well it's our choice we
 can choose that we give a value of type a and here instead of this function
 will give identity we can always do that for any type a and so this means
 we can always build a value of this type if we have a value of type a so
 that gives us a function that converts from a value of type a to a value
 of this type just inserting identity function here and inserting the value
 a here and setting Z equal to a so we are free to choose what Z is when
 we construct the value of this type so this gives us the equivalence function
 in one direction from a to P now how about extracting a from P if we have
 a value of this type we actually cannot extract Z out of it so a value
 of this type contains Z as part of it but we don't know what the type of
 Z is and because the type Z is hidden we cannot extract it out of the function
 PA we cannot have a function whose type is unknown whose whose type signature
 contains an unknown type however what we can do is we can extract a out
 of PA in order to do that we need to apply this function to this value
 this is the code and we don't need to know what the type disease this would
 be some unknown type the function f has the right type signature so that
 we can apply it to that Valley so this is a well defined value and so in
 this way we can extract a value V out of PA no actually we cannot transform
 PA into anything else other than into a value of type a because this data
 only allows us to get a Z or to get this function or to apply this function
 to this now we cannot get a Z out because we don't know the type of Z we
 cannot get this out because we don't know the type of this function so
 we cannot write code that says take a pee and output some unknown type
 that doesn't work in Scala the result type of the function must be given
 must be fixed before you can write the code of the function so this means
 this value is observable only via this function so the only way of doing
 any computations with this PA is to apply is extracting function and to
 get an A out of it and so if you wanted for example to compare two different
 values of type PA then you cannot directly do that because you don't know
 what what Z is you cannot look into it it's hidden so the only thing you
 have to you are then forced to do is to extract an a out of this and compare
 the resulting values of type a and so for this reason the functions a to
 P and P to a are inverse to each other when we use P to a in order to come
 compare any values of type P a so this can be shown relatively easily thank
 you for example take a composition of a to P and P to a in one or another
 direction and you can substitute the code in one direction this will be
 identity of Z so that's clearly going to be identity in the other direction
 you have this and this should be equal to the results on so this a equal
 to a PTA of sum P and that should be equal to that P in order to show the
 isomorphism in the opposite direction so that requires us to compare two
 different values of type P of a and we have to do that by applying P to
 a to both sides and that's what will again give us identity so I skipped
 this calculation but this is very similar to what we did for proving the
 identity of types and a couple of slides before when we used the universally
 quantified type so this proves this equivalence and actually there is a
 stronger version of the equivalence which is this if you have a functor
 if so this is not a free construction this is just a given factor then
 this is equivalent to that factor and this is proved in a very similar
 way the only way to observe a value of QA in other words to compute anything
 out of it is to extract an FA out of it you can extract an FA by taking
 FZ and doing F map with this function and you can't extract anything else
 cannot extract an FZ out of it because you don't know Z you can't extract
 this function out of it you don't know what this function is what would
 the type of this function is so the only thing you can get out of this
 QA is some value of type of a so that's the transform transformed q2 f
 f2 q is similar to this one you take an affiliate take identity function
 and very similarly we can show that these two are observational inverse
 is now they are not directly inverses in a sense because you cannot directly
 compare values of this type because that contains some unknown type Z inside
 and what if this type is different however this type Z is not observable
 even if it's different so you have some value of Q with one Z and another
 value of Q with another Z you cannot see that this type z are different
 in these two values you have to first extract the observable value out
 of this which is a value of this type once you have extracted it you compare
 those so this is what I mean by a traditional equality and so you can show
 that these two functions are inverse of each other when the Equality is
 understood as observational equality so whenever you compare values of
 this type instead you extract FA by using this function and compare the
 resulting values so this is how the existing shop type works now in the
 free functor construction we use the extensional type and we can rewrite
 a construction using this type expression so I just taken this code I have
 rewritten it using the type notation that I'm using so that is the definition
 of the free function so this is a recursive definition because we're reusing
 the type FF itself as we are doing here so if F is reused as part of one
 of the case classes so this is the tree encoding in other words this encodes
 the young unevaluated expression tree of an expression obtained from with
 a free factor of values and operations so there are operations which are
 insert an FA into the free function and apply and a map to free frontier
 so using these operations in any order we gets arbitrary values of the
 free functor so let us derive reduced in cooking to derive the reduced
 important we start from the tree including we try to see how it could simplify
 values of the tree encoded type using the laws of the typeclass so the
 furniture typeclass has two laws there are the identity and the composition
 law and composition is also associative so that's another property so we
 need to see if we can simplify values of this type so let's consider values
 of this type any value of this type you must be by construction either
 wrapping of this or it will be a previously constructed value of this type
 multiplied by a function like this so essentially we have to start with
 some wrapping and then we multiply a few times every time we multiply so
 we use a map function every time we do that we add another existing type
 parameter so then we have all these existential type parameters then we
 have the first wrapped value of this type constructor F which is not necessaril
y itself a functor and we have a bunch of functions of different types now
 all these functions must be composed associatively in other words the law
 of composition is that the result of mapping with this function and then
 later mapping with another function and then later again mapping with another
 function must be the same as a result of a single mapping with the composition
 of all these functions and the composition is associative so in other words
 we should be able to simplify this value into a product of this and the
 single function here which is composed out of all of these and the result
 of the composition doesn't depend on on the order in which we evaluate
 the composition because of associativity so therefore by using these laws
 we can simplify this expression into this expression where there is only
 one quantified type all of these other types are not visible anymore because
 we're not using them and there's only one function here or also there is
 a possibility that we just have this no functions and this possibility
 should be equivalent to having this value mapped with an identity function
 because of the identity law for function so therefore we can say let's
 just always have this type and if necessary put identity function here
 and we always have some value of type constructive F and we always have
 a single function but we no longer have disjunction because we can represent
 this case by putting an identity function in here due to the identity law
 of the factor so this concludes the derivation of the reduced encoding
 so the result is this formula which means we have successfully simplified
 this expression we got rid of a disjunction and we got rid of the recursion
 this is non recursive we don't use the recursive instance anymore we just
 found that it's equivalent to have just type constructor F and that's the
 reduced encoding of the free factor so the only important remark here is
 that it requires a proof that actually this is a reduced in Korean so by
 definition a reduced encoding is such that it respects the laws so if you
 apply for example map to a value of this type with identity the result
 must be equal to this it must so it is not true for the tree encoding the
 result will have an extra function here an extra existential type and so
 on and that's kind of not good enough for reduced encoding it must not
 be there so the reduced income must satisfy the laws and that's what it
 does so it requires nevertheless some ingenuity we have to derive it doesn't
 follow automatically what it should be and the proof that it is equivalent
 to the tree in holding and satisfies a lot another good result from reduced
 encoding is that we can see what happens when the type constructor from
 which we generate the free function is already itself a functor so if we
 are taking a free factor of a tied over a type constructor that is already
 a factor then as I already already said this expression which is that is
 equivalent to the factor itself so so this type is going to be equivalent
 which means that while there's no harm done including this free function
 except maybe performance will suffer you have some extra stuff will have
 some identity function here's a mother function basically you are just
 postponing the map there might be some advantages in doing that which I
 will show because you can make this stack safe but this will certainly
 be a performance hit so don't do this if the type constructor is already
 a function if you can avoid it but there's no harm done it's the same equivalen
t type so you won't have more information so proud so this is an interesting
 property because usually what happens with free constructions is that they
 wrap you're generating type in some stuff and so they add information to
 it so the resulting type is usually not equivalent to the type constructor
 that your racket but in this case a physical one so for functors functors
 are special and free functor all over a functor is equivalent to that function
 so that's a special property finally let's look at the church and according
 now this is a more challenging task because we are dealing with the type
 constructor so we let's start with this and what's children coldness now
 church encoding means we need to add a universal quantifier but since our
 result is a type constructor the universal quantifier must be for a type
 constructor so the church encoding that I have shown before was for a ordinary
 type or a free semigroup or something like that for a free semi group the
 type is not a type constructor for a free factor it is a type constructor
 so therefore the church encoding must have a universally quantified type
 constructor in it and things are just going to be more complicated because
 here's the structure of the type expression in the church encoding of a
 type constructor we have a universally quantified different type constructor
 then you have a function from your type to that type constructor and again
 from that to your type constructor so that's the general structure of the
 church encoding but because the insides are type constructors then this
 must be natural transformation so this must have another Universal quantified
 type inside so I use this squiggly arrow to indicate universally quantified
 functions such as natural transformations just it's the same error it's
 just suggestive so that like keep track of where I have universally quantified
 where I don't so if you follow this structure then this is going to be
 the entire expression for the church encoded free function now this is
 starting from the tree encoding we have a choice what do we charge encode
 which version code this or do we charge encode this and they're going to
 be two different Church encoders so starting from the tree encoding that's
 what we need to do now there's one interesting side of the church including
 that I'm going to explore in more detail now which is that the recursive
 use of the type is not seen in the church including in instead he replaced
 that with this universally quantified type constructor that is present
 so to speak so instead of the recursive use of free factor here I have
 this universally quantified P that is a very important part how church
 including works with recursive types and just before we go through that
 I want to remark that in this expression the quantifiers cannot be moved
 and you cannot move this quantifier to the outside it is really inside
 these parentheses that the C is dis quantified so to all see this function
 is given so for all C this function is given and that function is the argument
 of the outside function so this is important for the church included so
 you have several layers where types are 25 this type quantifier is specific
 to the free functor this wouldn't appear if we had no type quantifier here
 so this is specific but this would be always true for any Church including
 of a type constructor have a type quantifier inside that cannot be moved
 to the outside and of course also you cannot move this existential quantifier
 to the outside so for this reason when we write code we have to take care
 to hide these quantified types at the right place inside the data structure
 so let's look at in more detail on at how church encoding deals with recursive
 types and with type constructors so let's consider an example here's a
 recursive type not a type constructor it's just a type with fixed type
 Z it's a tree with leaves carrying values of type C the church encoding
 of this type looks like this so I'm looking directly at our encoding of
 the fee-free mono which was very similar and this was the encoding the
 church including of the free memory so we know this is correct now let's
 look at how it works we take this expression which uses the type P recursively
 twice and we write it here but instead of the recursive type P we replace
 that with X where X is the universal quantified type given outside so in
 this way the church encoding replaces the inductive use or recursive use
 of P by using this parameter X so the result is a non recursive type expression
 or at least it doesn't look recursive it does not use itself somehow to
 define it it's type but it is equivalent to this recursive type so it's
 very interesting that just by using a type quantifier you can remove type
 recursion well at least on the surface you don't of course actually remove
 it because the type is equivalent it's still encodes a tree with devalued
 leaves so it's still a recursive type or your recursive data structure
 but it's encoding does not show recursion so that's that's interesting
 so how shall we understand the way it works this is a run method of a declarati
ve way encoded DSL and so this method tells us that in order to extract
 a value what you need is to be able to extract value from this and here
 you have again these values how would you ever get the value X in practice
 in practice it would have to call this function on a Z several times to
 get some X's and then you would put these X's in here call this function
 again to get some more X's and so on so in practice it is a recursive process
 it can encode recursion but all of this is already encoded in this function
 so the type does not show recursion so in other words how can we produce
 a value of type X and we don't know what that type is it's we're required
 to write code that produces an value of type X whatever the type might
 be well the only ways to use this function somehow and this function requires
 us to give this as an argument so how can we give this as an argument either
 we give a value of Z as an argument and then we have our X we can return
 it or we give two excess as arguments and then we have a new value of x
 and we can return it but how where do we get the two x's well we still
 have this function so again either we give some Z to this function or we
 give a two-axis to this function so this is where the recursion comes in
 in order to produce a value of this type we need to have a tree with Z
 valued leaves and once we have that tree we can write this function so
 these functions are equivalent to trees with Z value leaves in this way
 now we can generalize this construction to a recursive type defined arbitrarily
 like this now here s is an arbitrary function that is fixed and this functor
 determines the structure of the step of recursion so for example here this
 functor would be as P equals Z plus P times P so this factor I call this
 induction factor because it describes one step of the induction when we
 derived values of the type so what we have seen right now suggests that
 the church encoding of this recursive type looks like this so this is a
 general way of encoding recursive types by church encoding and it's not
 recursive at least on the surface and I will show an example of church
 encoding of lists of integers [Music] so here's an example of church encoding
 of list of integers first let's do the recursive encoding just for reference
 it would have a be a shield trait with two case classes one representing
 the end of the list or an empty list and another representing non empty
 link in other words a value of integer type and and next value now Scala
 does not allow us to do this this would be the short type notation but
 this cannot be done in Scala because Scala does not allow you to do universal
 quantifiers while is explicitly so instead we denote first this as some
 helper case class CP just to make it easier for us and well we could actually
 probably define this as a type rather than as a case class but let's keep
 it like this for clarity so the CP of a is just a helper case class that
 represents this type it represents a product because we can simplify this
 function as a product of two functions one to a and this to and then we
 can simplify further 1/2 is just a and this is like that just for convenience
 later now it's very easy to encode the church encoding of the rest of it
 just a function from C POA to it now if you look at what that type signature
 is it's very similar to the type signature we'll fold it's a function from
 a and this function which looks like an updated updated function for fall
 gives you an A and a is arbitrary so here a needs to be hidden inside the
 trade as a universal quantifier so as I said before that's how we need
 to keep in mind that this is universal quantifier and therefore we do a
 method in a trade so we don't do a case class parameterize by a hidden
 parameter that would be an existential qualifier we do a method in a trade
 because it means that this method can be called with any parameter unknown
 at the time of defining this method and that's what the universal quantifier
 does so ok we are done we define this type let's define values of this
 type so to create an empty list we need to write this boilerplate now how
 do we implement an empty list well we need to implement a function that
 takes this and returns that you know this has two functions inside we need
 to think about what these functions mean in order to be able to implement
 anything here so what do they mean all these functions mean what to do
 we'll look at this for example what to do when the list is empty how to
 run the list how to fold the list what is the result value when the list
 is empty and this function tells you what is the result value when the
 list is not empty it has a head value act some type integer and it has
 some additional arrest values which have been already evaluated or folded
 that your value a is given so what do you do then how do you update your
 fold down now an empty list would never get into this case it will always
 just give you the eighth so therefore this function for an empty list ignores
 the link function and just returns in whatever the end is the empty list
 when folded always gives you gives you that justice this value which is
 denoted by hint in the fold signature this is denoted by in it but we're
 trying to imagine the list being created so there's a empty list or end
 of the list that's just the name of the variable so for this reason that's
 the implementation of an empty list in the church encoding now let's do
 them list with one element how do we do that so we need to fold and in
 order to fold with a list with one element we need to use this updater
 function on this element and on the rest of the list which is empty which
 is going to always evaluate to the end value so that's there for the implementa
tion of a one element list so this is now more suggestive but we are having
 an and one element list linking X to end so this could be this class like
 this in your case class in coin but you know this word we don't have any
 case classes here representing lists all the lists are our functions the
 CP is just a convenience type where pattern matching here just for convenience
 we don't need to do that if we for example encoded this just as a tuple
 of two values then we would not need the case expression we would just
 take this under square one on your store two and so on but it will be less
 readable so that's why I I write it like this let's implement appending
 so we have an element X and a previous list we want to add this to the
 list what we need to implement is how to run the resulting list or running
 a list means folding it we are given the initial value of length function
 now we need to use the link function on the X and on the rest of the list
 but the rest of the list is this so we need to run this using the same
 fold information so the CP case class encapsulate all the fold information
 we need in order to run the list so when you run it with the same old informati
on we get a value and then we update with the X so this is how we append
 now folding is just the same as run so we can implement the fold function
 with this type signature and it's just calling run with these arguments
 notice that fold is non recursive the fold function is non recursive actually
 none of these functions are recursive we can implement convert into ordinary
 lists just as a fold with a list constructor we can implement math again
 this is going to be non recursive because we're just going to pass some
 modified food so the lists are how do we run how do we fold a list after
 mapping we just fold it with modified function so instead of X's we substitute
 f of X that's all this is not recursive so the map is non recursive on
 these lists the fold is non recursive in these lists all the recursion
 has hidden inside these functions that they run functions those run functions
 will call other run functions and critically what we don't see that our
 our code here is not you closer here's how do we--how implement has option
 we run it on an especially crafted folder folding information and [Music]
 that actually is an interesting observation that I would like to make is
 that pattern matching such as head and tail is not directly available on
 this data structure this is a function now it is not a bunch of case classes
 we cannot directly pattern mention it and determine if it's empty or not
 for example we have to run this function on some arguments and this run
 could take a while so for example tail cannot be implemented efficiently
 as a Big O of one operation it has to run lowest to the end and build the
 tails as a second list so that's a deficiency of the church encoding but
 if you need pattern matching operations you need to run the structure or
 the entire function which might take a while so let's run some tests here
 implement just some function so here's how we create it's just a folding
 with the Sun here's how we create some lists in the church encoding so
 it's a pure of ten which is one element list we append five to this we
 get a two element lists with five and ten in it so then we check the sum
 of these elements is correct and converting it to list gives you what you
 expect in the map gives you what you expect now the map operation here
 is perhaps stock safe we can check that some is stack safe so our fold
 implementation is stack safe creating a list of any elements is stack safe
 when implemented in this way so what we need to do is we need to compose
 many links together but this needs to be done in a stack safe way which
 is why we do it by hand here we don't just do link compose link composing
 writing this would actually not be stack safe you'll see that later in
 more detail also appending many elements is not stack safe we obtained
 a large number of elements then trying to run that list do anything with
 it would be a stack overflow so you see the sum the sum function itself
 is a stack safe as long as you can run the list inside it but it's the
 list itself that needs to be stack safe now the function that constructs
 the list is a function that builds other functions and that function needs
 to be stack safe I should for example avoid composing many functions but
 you can't avoid that if you do attending one by one so you need some more
 clever implementation which is possible but I will not discuss it right
 here let us see that the church encoding of a type constructor so I'm using
 this notation with a bullet to denote type functions so the scows index
 for that will be this so the church encoding let's begin with the church
 encoding of a type function P just the type constructor P so what is the
 church encoding of that this is the church encoding of the type constructor
 P you have to have two quantified types and one of them is a new type construct
ion which is quantified in other words this is a function others parameterize
 by an arbitrary type constructor F and it's argument is a function that's
 parameterize by an arbitrary X which has this type signature so this function
 world alternatively can denote it like that with the squiggly arrow that
 I'm using just it's the same I just want to have a different notation for
 this it resembles a natural transformation however these P and F are not
 necessarily filters so we don't necessarily have a naturality law it's
 just a generic function parameterize by a very mature X with fully generic
 code but if these are not factors then there are no materiality laws imposed
 on us so this is not a natural transformation but a type signature is exactly
 the same so this is somewhat complicated and for this reason I'm going
 to show you an example of how to encode the option type yeah the option
 type constructor in the church encoding so that you see how all this is
 translated into code so the direct encoding option would be a polynomial
 data type like this and with these classes that you could call like this
 so we're going to implement this type expression now where this is going
 to be the first type parameter and this is going to be a second type parameter
 which is inside this argument so let's first encode this argument has a
 separate type for convenience so this argument is a function that extracts
 a P from an option so it's again looks like a natural transformation from
 option to P except P is not necessarily a function so let's denote this
 X option which is this extractor from option now this X option just for
 convenience we define this type separately parameterize by P but it is
 not parameterize by X because X is the universal quantifier type which
 needs to be hidden inside this X option so therefore we have methods in
 the X option what are characterized by X now I could have just had one
 method here such as apply with parameter X and then I would have this function
 as the type of that method but it is actually more convenient especially
 in Scala to have separated methods so if this is a typical pattern of a
 function from a disjunction to something is equivalent to product of functions
 from each part of the disjunction to that something so then the equivalent
 type is less and we can just denote each of these as a separate method
 in the trait so that's just convenience we haven't done anything really
 we just equivalently transformed this type for convenience it's a little
 easier to read and we can give these trade methods suggestive names so
 having defined this type it's now easy to define the church encoding on
 the option which is parameterize by a notice listen thing has only one
 type parameter which is a that is visible outside the type parameters P
 and X should not be visible outside they're hidden inside his type expression
 so therefore we put the type parameter a outside and the run method I just
 call this run for convenience to suggest what the church encoding does
 is that if it runs a DSL program with an interpreter so this is an interpreter
 for the the operations of the DSL and this entire thing is the runner of
 the DSL program into an arbitrary target type so that's why I always call
 these methods run but this is just been named doesn't do anything by itself
 it is the type that do all the word no types so the run method needs to
 be permit rised by the parameter P which is itself a type constructor and
 this is the type of the run so that's it we have finished implementing
 the church encoding as a type now we need some helper functions so that
 we can easily create values of the Church encoded option so how do we implement
 for instance constructors the Sun and none now these are not these trade
 methods these are our so these are our methods mean we could you could
 make these methods private if we wanted to this entire type could be made
 private the users should not have access to it so to define some we need
 to put an X of type a into the auction so how do we do that we define this
 church and call it option with around method and we need to implement this
 so how do we run a non empty option well clearly we use the sum method
 on the x value that we have to get a P of X so that's what we do here how
 do we run an empty option we use the non method which has no arguments
 and gives us a P of X that's it a lot of boilerplate as you can notice
 all of this is boilerplate all this is boilerplate this is the actual code
 implementing the Constructors for direction there are some libraries that
 make it easier to use but it doesn't matter enough so we can also show
 that option the ordinary option is equivalent to the church encoded option
 to do that we do a wrap and unwrap methods let's say so first we take an
 ordinary option and we implement the church encoded option that's very
 easy we just do one of these two constructors unwrapping from a see option
 into an ordinary option requires running let's see option again we have
 the same [Music] same phenomenon but if you want to pattern match for instance
 you want to detect whether this option is empty or not you have to run
 it there is nothing we can pattern match directly on this value because
 this values a function you cannot pattern match on code of functions so
 how do we do that so we need to run it but to run it on what we need to
 provide an interpreter so the interpreter will take our church encoded
 option and produce an ordinary option so that's what we need to prove produce
 and these are just the standard methods of the standard Scala option and
 that's that's it so here's how we can use it so we can create some values
 of option type now pattern matching does not work cannot directly implement
 that imagine so which if we try it there's a type of problem so for example
 we wanted to pattern match directly like this by running the option on
 something but I can't really do that because we need to provide an interpreter
 that interprets arbitrary type X under the option but we only have a specific
 types here type a so if we write this code which will be kind of what we
 want we gathered a pair so the only way of doing a case expression would
 be first to run this like this to unwrap it convert it to an actual option
 with case buttons and then we can pattern match on those on the other hand
 natural transformations work fine they don't require running on some first
 on on a real option you can just run on a constructed interpreter and interpret
 this into another function so that's that works fine and here's the test
 code so now finally let's look at how the church encoding works for a recursive
ly defined type constructor so this is very similar to how it works for
 a recursive type in that all the recursive usages of the type constructor
 are replaced by this type that is universally quantified and since now
 we are dealing with a type constructor we need to adjust our notation so
 that we define first of all the reclusive type constructor like this where
 s is now a factor that describes at the induction principle but it's now
 paralyzed by this type constructor so this notation that I'm using for
 a higher-order type function in other words it's a it's a functional of
 types that are themselves function of types and Escalus index won't be
 like this so an example of that would be a list cursor we define like this
 and if we define s like this then you see the P parameter P denotes the
 recursive use of the type constructor in its recursive definition so this
 is how we could denote this construction and then the church encoding of
 this looks like that so there is similar to a church including for cursor
 types and it's non-recursive it's a type expression that does not require
 recursion so let's see how the list constructor is defined in the church
 encoding this is the type expression for the church encoding of the list
 because this is the structure or induction factor for a list we just saw
 and I'm just adding all the type quantifiers explicitly I have a B which
 works inside these parentheses only it's hidden I'm gonna have a tree which
 gives me this is this it's also hidden from the outside I can equivalently
 transform this type signature into this where I [Music] again replace a
 function from disjunction to B or B by a function from just part of the
 disjunction to P of B and then from this part of the disjunction to P of
 B which I simplify to just beyond P so that is how I would seem to fight
 now I will deliberately write code similarly to an on parameterize list
 that I did first so the end needs to be paralyzed by this B now I used
 X instead of B here and now finally I search encode the list of a just
 as a function from this to P of a very similar code that I had before in
 order to define empty list a list of one element and appending there was
 a difference that link and the run I'm getting them as methods of a trait
 whereas before I was getting them as parts of a case class I could have
 done a trait before as well because really it's just a convenience but
 here I could not do case class because I need this type parameter oh I
 didn't know that this be in English used for consistency this type parameter
 being what I have here needs to be hidden inside the type CL which is this
 type which is the argument of this function and case classes will not do
 this frame so I need a little trade with methods in Scala other than that
 the code is very similar fold is non recursive in order to implement fold
 I need to have a bit of typecasting because the only way to get anything
 out of the list is to run but I need to run on an interpreter if I'm folding
 are not interpreting into another type constructor I am interpreting into
 a single type so however need to pretend I'm interpreting into a type construct
or because that's the type signature of the church encoding it's run into
 an arbitrary type constructor so I can choose that type constructor to
 be the identity factor and in this way I can get ordinary types out so
 I define or constant factor be another possibility so I define a constant
 factor and then I run into that so I give that C is a type parameter and
 then I encode the running just like I did in the fold implementation above
 in this hold implementation here except that now I need to specify this
 as methods over trait rather than as parts of the case class other than
 that it's very similar and here I typecast X X has type X but I know this
 will only be called on values of type a so I know that even though I'm
 supposed to provide [Music] this CL of C with arbitrary X actually this
 will only be called on values of type a so I can cast this safe way to
 satisfy the type checker now this is a little ugly but that's what I found
 to be necessary with the constant factor being used so using this I define
 a sum I define two lists and I run exactly the same tests as I ran before
 network of the lists so now I would like to generalize the constructions
 we have seen two arbitrary typeclasses so this is something that the church
 encoding makes it particularly easy to understand but it does not have
 anything to do with the church encoding so let's look at first of the church
 encoding of a three-cylinder looked like this now here X is an arbitrary
 type but this is a signature of the semi group method which is combined
 so if X were constrained to the semi group typeclass and this would be
 given already as an implicit argument let's omit that argument and I would
 denote it like this so here the typeclass constraint is denoted here like
 this so now it is an arbitrary type X which must be of this typeclass and
 then I have this so it's a much simpler presentation and notice that the
 induction factor for semi group over Z is this so basically what happens
 is that a church encoding of a cylinder which is this one which we can
 generally write down as the semi group functor or induction functor as
 I call it before but actually this is always going to be of the form Z
 plus something when we do a free side quest inspection because we have
 to wrap the Z pipe and then we have these methods this tells us how to
 generalize the country construction to arbitrary typeclasses so first of
 all we define a functor that describes the operations of the typeclass
 so for example for the semi group we have a single operation and writing
 it in this form means that CX is just a pair of XX but in more general
 typeclasses ships would be more more general and so that would be what
 I call the method factor this type is in a category theory called an algebra
 or sea algebra so if C is a functor when this type is called a sea algebra
 which is a type parameterize by X but I just mentioned this because the
 fact that it is called sea algebra in category theory it doesn't really
 help us so much it is suggestive typeclass has some operations these operations
 maybe have some laws some algebraic laws and so for this reason it is suggestiv
e to call this an algebra but it's perhaps more confusing than suggested
 so let's just not use that terminology instead let's concentrate on what
 these things actually do so this I would call the method factor of the
 typeclass C I would call the typeclass C inductive if such a functor exists
 why because it appears that we are defining values of x by induction so
 if this factor is given so this is some kind of container of some shape
 containing X then we can derive new values of X using these operations
 so the operations the value of this type that tells us how we can derive
 new values of x given some previous values and how we're supposed to have
 the previous values is described by the shape of the method functor so
 for instance this method FUNKER could have a disjunction of several parts
 and each part would have zero one or more X's in it and so that would correspon
d to operations with zero one or more arguments in the operations of the
 typeclass so for the semigroup the C is just a pair for others it will
 be more complicated but given this C we can write down a general formula
 for the free typeclass C over a type Z so the three encoding would be like
 this so the free c generated by z or free c over z is a recursive type
 defined like this the church encoding would be like this because we replace
 the recursive use of the type through the type parameter X now quite equivalent
ly we could say the church encoding is like this it's for every X of the
 typeclass C in other words for which we have this value we have this it
 is then obvious that also the laws of the typeclass will be automatically
 satisfied by the church encoding after running and this value and the reason
 is X must be of typeclass C and so after you run this you would have a
 value of typeclass C so whatever operations you apply to this are actually
 implemented in the typeclass C and they therefore already satisfied law
 type constructors used in the same way here I have shown what to do with
 new type constructors with ordinary types it's just that there's more notation
 and more parameters so for example the freetypeclass C over a type constructor
 F in the church encoding looks like this where you have an arbitrary P
 from typeclass C and then you have this generic transformation or natural
 transformation which might be mapped into PA now it's very important to
 notice where the tag trailers are here so this a is the outside a this
 is the only outside type parameter that is visible and this type rather
 is hidden and also this is a hidden type parameter inside so we have generalize
d from our examples to an arbitrary typeclass let us remind ourselves what
 we have done first we start with some arbitrary type z and we enriched
 it to a monoid which was a free monoid we have started with an arbitrary
 that constructor and we enriched it to a unit which is DSL that was motivated
 by the interpreter pattern but this was actually a free monad so this enrichmen
t was done in the tree encoding by adding case classes that simply represented
 the operations but there are also other encoded in cuttings that are more
 sophisticated and so this works for any type Zi and any type constructor
 and the result is a free type construction and this type construction performs
 no computations it just accumulates all the data and it needs to be run
 in order to actually perform computations and so intuitively the free Mona
 and mono it over the type Zi adds some wrapping to Z just enough to make
 it look like a monoid to satisfy the type signatures of the moon your head
 doesn't actually perform computations inside it just adds some stuff so
 that the result looks like a mono it similarly the free functor it wraps
 a type constructor and just enough stuff to make it look like a functor
 and we can interpret these free values into non free values into specific
 concrete functors monomers and so on by running please notice so we have
 seen several coatings and running is done differently for these inquiries
 but all of these including do the same thing they provide you a free type
 construction which performs no computations it delays all the computations
 records all the data that you to perform these computations later and later
 happens when you run so you create a DSL program you can combine different
 programs very easily and you can then run so what are the questions that
 are but remain to us so what are the five classes we can construct in this
 way so can we construct for a given typeclass C can we construct a free
 instance on the typeclass over and given say FA the answer is in turns
 out to be yes with some typeclasses no with others so I will show examples
 I really started with functor I will show examples of these typeclasses
 and I will show why you cannot sometimes have a free typeclass which encoding
 is to use this is an important question for reference some recordings perform
 better than others these encoders are not the only ones available but I
 don't want to go too far into other possible encodings and if you're interested
 look up church encoding and you would immediately see other related components
 such as course encoding every go encoding and some other info base and
 another set of questions related to each other are about the laws so what
 are the properties of this free instance can we define the free instance
 by its properties formulated in some way in the turns out there are four
 main properties that are important first of all if we have a free instance
 of a typeclass over a type construct if it means that we need to be able
 to wrap a value of F into a value of this free type lasso this free C is
 this free instance of a typeclass so we should have a function with this
 type signature now for second property is that for all specific instances
 of this typeclass we should be able to run our type free instance into
 that specific instance given this function so this function the extractor
 as I was used calling it before this extractor only shows how to map the
 generating element or to generating type the F into m and once we know
 how to do that we should be able to wrap the entire tree instance into
 him so in other words is generating type the Z here and the F here has
 been wrapped into some stuff to make it look like typeclass C and we should
 be able to unwrap it into a specific M only knowing how to transform to
 generating type into him so this extra stuff should be transferable automatical
ly into the correct typeclass the laws of the typeclass must hold after
 running into that ami and the last property is interesting is that if we
 transform the generating type into another type then we should be able
 to automatically transform the free instance as well so in other words
 the free instance should be so to speak a factor in F except of course
 F is a type constructor so we need to generalize the notion of laughter
 it should be covariant in the type parameter F and so we should have some
 kind of map function that map's atlandis indeed if we look at this definition
 we had right here it satisfies all these properties so for example this
 is covariant in F because F is behind two arrows this is covariant in Z
 obviously so these are the properties that we will show that how we already
 know that some of these properties hold but we will show that more more
 formally so what is the recipe for encoding a freetypeclass the recipe
 is this first the typeclass needs to be understood as having methods that
 is functions with some type signatures like this and all these Q's must
 be covariant complete there are some functors or some type constructors
 that must be covariant in the parameter P and that is required that all
 these methods should have a type signature of this form in other words
 the final return type must be the type constructor not here that were given
 if that is so we can put all of these Q's together in a disjunction like
 this call it s and then this generic function will be a single value that
 represents all the methods of the typeclass at once and then we call s
 the methods factor so once we do that we define the tree encoding which
 would look like this it will be recursive because these queues will have
 FC inside them perhaps but that that's fine now the queues might contain
 existential type primer so if if these methods contain more type parameters
 on the left hand side it's fine they will become type parameters here and
 as we have seen type parameters in case class inside a trait that are hidden
 from the trait become exist tential type parameters and so those are fine
 those might be present and then finally we can implement the run method
 for this there are easier so if we are in the wrap case which is this part
 of the disjunction then we just map it to him and we're done and for all
 other parts these methods are run recursively so we run recursively all
 the keys that are inside the queues and then we just use the method of
 the typeclass M which will have the same signature except that instead
 of peas will have specific values already of type M and so we can just
 use those methods and that's how the run function works so this is very
 easy to encode the tree with coding it's very straightforward almost mechanical
 so you have a definition of a typeclass you can mechanically generate this
 and it's run method there's no problem at all to generate instance of the
 typeclass and the run method mechanical in order to get a reduced encoding
 however you need to perform reasoning about what are the possible values
 of this free typeclass instance and what are the laws of a typeclass and
 how you can simplify if possible values you would start with the tree encoding
 which is going to give you some nested case classes and then you try to
 simplify them and that is non trivial you don't have a generic procedure
 for doing that so that has to be done separately in each case or factor
 for contra contrary and so on so the factor we have done this but we will
 do that for all the other typeclasses finally the church encoding can be
 defined either using the tree encoding which again is completely mechanical
 so we just do this you do the S and then you have SP TP all in parentheses
 going to P put a type quantifier and P and you're done or you can do a
 church encoding of the reduced encoding so that's a choice and there might
 be different performance in all these occurrences so this in other words
 well we will show the more formally if this is all true but if you have
 an inductive typeclass which is characterized by a methods fantasy and
 so it's methods are this algebra the C algebra then you have a free instance
 always it has all the properties and we have further properties for instance
 if P and Q are instances of this class then the product of P and Q and
 the function from z2 p where Z is a fixed type are also instances of pi
 plus C not necessarily these sum or a disjunction and the product with
 a constant type are not necessary parts of it last class but those are
 and this is relatively easy to prove for instance if you have this and
 this means you have a P is an instance of C and you have a Q as an instance
 of C and you can derive this easily just project this to this project out
 the Q C is a factor so you can do that project out the P to get sick you
 get your P get your Q get their product so that's very easy and it's similar
 will you come to this but you cannot implement the disjunction for example
 because you would need to decide which part of the disjunction you have
 but you can decide that because we have a C of P plus Q and it's not necessaril
y that you can decide which part of the disjunction it must be so that function
 cannot be implemented without losing information so that won't satisfy
 lowest similarly you cannot get Z P because if we need to create values
 of type Z but you don't have them necessarily plus Z so it's also an instance
 of the same of course and indeed we have seen looking at all the previous
 typeclasses that we analyzed factored contra functor applicative Minard
 and so on they all have this property the product of two typeclass instances
 and this construction always again if you have a new type cross sixties
 so that is one because they are inducted all inductive typeclasses have
 this property and type constructor typeclasses have the same property just
 that the methods function needs to be in coded language what type lasses
 cannot be trained included and they're not inductive well one typeclass
 that's not inductive is reversible and indeed this is not true for traversable
 this construction does not work for traversable if P is favorable than
 a function from some types need P is not reversible in general any typeclass
 that has a method that's not returning a value of that type that's not
 inductive the reason is methods must be of this sort so if you have methods
 not of the sort that did not return values of this type then it's not an
 inductive typeclass so here's an example imagine a typeclass for a type
 constructor PA it has two methods point which inserts a value of a into
 P and extract which extracts a value of a out of P now this would be of
 this form because it returns the type construction but this is not it returns
 just bear type a and so this typeclass that has both of these methods is
 not inductive it does not have a representation of methods through a methods
 function like this or like this and therefore we cannot do a free construction
 of it using trees and we don't know how to encode free instances of this
 class traversable functor is another example of non-inductive now just
 to mention that if all methods of the typeclass have the opposite form
 that it consumes a value of this type constructor and then gives you something
 like this but if all methods are on this for not just some so this is still
 not non good enough there's some methods did not consume values over this
 high class of this type constructor but if all methods are of this form
 they consume PA and return something then there is another way of doing
 a free instance which is called Co free and these typeclasses are called
 Co inductive I'm not going to describe them in this tutorial but perhaps
 in another chapter so if we're going to free control function let me go
 to the code over free factor which I have not yet shown but actually here's
 the code what I was just talking about I can define free instance of any
 inductive typeclass I can write code for this generically so it's a free
 instance of an arbitrary inductive typeclass now this is not for type construct
ors for simplicity this is just for ordinary types this before semigroup
 monoid and such typeclasses and here goes the rap and the operation so
 the operations contains the sea of free so this is the definition but I
 just showed of the free instructor so that is the hopes and basically that's
 it we can show that it has methods of the typeclass and we can run we can
 write the run method so you see the run method is for a generic oh it means
 to assume is that C is a functor C not not everything I see is this methods
 function and and I'm done so the P method C is the evidence that the type
 P into which I am running is an instance of typeclass C so this is a value
 that encapsulates all the required methods so that's why I called P methods
 C so P has all the methods of C and this is a very easy code that just
 checks whether it's wrapping then it runs the extractor or if it's the
 operation then it runs the methods of T on the result of running under
 map so I'm required to run under map because I'm under the sea and coming
 here I need to run this first into a value of P under map of C so then
 I get C of P and then I can use methods to convert that to pee that's how
 it works and there's an example I use this for a generic construction to
 define some free semigroup so these are this is the methods functor for
 the semigroup I'll show it as a factor this is a free semi-group that's
 it generate it by screen now this is just to be clear this is my own definition
 here it's not the cats library definition or any other or scalzi definition
 I believe in those libraries what is called free is actually the free Mona
 it's a free Mona not just freaking structure any type cons so in my definition
 here it's of generic free instance of a given typeclass for inductive typeclass
es and here's code that creates some values and runs them so I create ABC
 XYZ wrap them then I use operations to add them and I run this into a string
 and I'm done and I can do the same with the church encoding it's slightly
 more type definitions but it's exactly similar the church encoding is this
 type equivalently it is this type and so I just define the trait for the
 argument and then I have this and then I can show that it's a five class
 now the showing that it is a typeclass is actually non-trivial this church
 encoding must have methods of the typeclass C in other words it must have
 a function of this type C of the charging : must be mapped into the church
 encoding itself and the types here are different with an X inside here
 and all Y inside here because are different so this actually is not very
 trivial to derive you just need to be very careful and following the types
 and here's how this works so how can we get this value now we would get
 this value we have Z or we don't have a Z obviously all we have is this
 we have C of something so it looks like our only hope is to get this C
 of Y and then we would have a function from C of Y to Y and we can call
 on that C of one and that give us the result now we are given this so we
 are required to be able to work with an arbitrary given Y so imagine we
 are given someone but then we have this function which has an arbitrary
 X inside that we can set so this function accepts arbitrary axis so let's
 set this X equal to Y in that function and then we would have a value of
 C with Y in here Z plus C of Y going to 1 but we have AZ plus C of Y going
 to 1 we are given that value so we can substitute that value in here mapping
 undersea so that we can get a sea of why as a result so then we get a sea
 of why we can put it in here and get the white house so this is a little
 convoluted but that's the code we map under sea given a type train with
 your Y in here to run the free instance and then we use the ops and the
 resulting sea wide so this is this gives us a CL what we run the ops on
 it we get away and that's what we returned so if you want to understand
 exactly how this code works you would have to write it yourself it's a
 lot of manipulation with types all these types are permit rised so this
 is kind of technical and not so easy to see looking at the code but this
 is the only way to implement the required type signature which is this
 and now we implement the rap which is straightforward and the Run which
 is straightforward by using these methods so this again we run the semigroup
 example is exactly the same code up to some syntax changes give us exactly
 the same results so let us now look at the functor so I already showed
 how the functor here the free functor is implemented and I derived the
 tree encoding and the reduced income and then I started to talk about the
 church encoding and that was so complicated that we have to go through
 much slower and through all the parts that are required so let's now look
 at the code for the free functor so the free functor actually starts from
 a given type constructor so it's always a free funder generated by a given
 type constructor or a free funder over a card constructor and that that
 constructor doesn't have to be a function and actually in many applications
 it is a node is not a factor and it cannot be possibly a functor because
 it has index types with specific type parameters and it tries types with
 non-free specific sign type parameters like this so I call these things
 unfocus it's a funny term that I think is appropriate here because this
 is it is like a factor because it's characterized by a type but it couldn't
 possibly be a furniture because of the way it's defined so this unfactored
 could be seen as describing two operations in some business logic where
 you add the name to some database say and you get an ID back don't you
 get named by ID and this name may may not exist in a database and so the
 result is an option of string now we would like to transform this unfilter
 into a factor run some program with it and then transform that into an
 ordinary option of some result so say sometimes you would have an option
 of strange sometimes not so let's be safe and run this into an option so
 in order to do this we need to define an extractor or interpreter for this
 and type constructor into options so this is this type which is natural
 transformation but actually doesn't have to be natural transformation it's
 just a generic transformation from one type constructor to another I'm
 using the cats library type it's defined there so how do I transform other
 two cases if it's alone then I just transform it into a one and if it's
 an option string then I transform it into none so doesn't matter it's just
 an interpreter of some kind it doesn't all it does is gives me an empty
 option or non empty option it doesn't really do a lot of good so that's
 what I'm going to be using so I'm going to right now a free factor based
 on this free function over this on Fronter I'm going to write some maps
 on it add some transformations and then run into an option that's going
 to be the example so here's where the code starts this is the three encoding
 of the three factor and have the wrap case class I have the map case class
 map case class has an existential type B I define the function instance
 for the typeclass functor and the map method does nothing just creates
 a new wrapping with map typeclass case classes then I have my function
 here which creates a free program 300 programs all it does it applies map
 to some given value many times so this number of iterations is given so
 that many times I apply map with the same function to that value so this
 is just a test I'm going to start with some value wrap it and then map
 many times the runner I'm trying to make it stack safe and that's a little
 bit of a problem actually and here is why I will have a lot of nested case
 classes I'll have to and go through all of them so the unfold function
 and I'm defining here is going to call itself and so one thing I could
 have done is just applied in the map we see that F of Z is a free functor
 value I could just have run it through the same function and then apply
 the map with F to it but that would have been not like safe so I did another
 thing so I didn't take a recursive unfold where I first accumulate so what
 I did here actually is I did and then George that was my first implementation
 every time I have a map I have a new function so the result is this accumulator
 that I have in the unfold and so I just accumulate all the functions inside
 the map and I run them only at the end so I I run this only at the end
 so that's the idea so that is tail recursive and then I hope to be stack
 safe but I'm not stuck safe this will actually give me a stack overflow
 and the reason is that and then is problematic in Scala and that was quite
 surprising to me because it's not so in Haskell and I didn't expect it
 but and then is actually not stack safe in this car here's why here's my
 sample test code that shows why this is so let's compose a large number
 of functions and call the resulting function so here's a code it does this
 let's just compose a lot of functions all these functions are just adding
 one to their argument and so that's very simple but if we do do this with
 a large number of functions we'll have a stack overflow so whatever we
 do we'll have a stack work for we we can compose these functions or we
 can directly compute still we have a stack overflow so the reason is that
 composition of functions introduces another stack frame and that's unfortunate
 and it cannot be removed apparently in job in JVM for technical reasons
 so you could not have a compiler that automatically removes this extra
 stack frame so what do we do well cats library includes this and then structure
 which you can use and if you use that so if you start with this and then
 you compose with more functions then this is stack safe how does it work
 it doesn't actually compose these functions until much later until you
 need to run this function and then it actually accumulates all the functions
 you give it in the list and then it runs that so I implemented the same
 kind of thing which I call safe compose using a data structure called chain
 which is from the cat's library which is a very high-performance list and
 so here's what I implemented based on some of these suggestions actually
 Michael Gilchrist suggested this so I just did good massaging so now the
 idea is that instead of composing you wrap the function into this chain
 F data structure and then composing this with others things doesn't actually
 compose functions it adds to the to the chain of functions of these functions
 are all stored in lists and only after you run them so the apply function
 is called then you fold over the chain and apply these functions so that's
 how it works and I made it so that you can compose on the left or on the
 right with the chain and you get a chain again so this what I did and the
 result is good so it's actually faster then using cats library and attend
 so that's what I had to do introduced here I have to use before before
 is my replacement of anything which is easier to use than cats library
 and it is faster so this is what I would do if I didn't have this I would
 accumulate results functions in the list one at the end I would fold over
 that list so this is kind of uglier and it's better to put this code into
 a library and here's a benchmark free functor in the reduced encoding it
 has fewer at least classes but it has a more complicated map because now
 it needs to do this in the map notice that in the tree encoding the map
 didn't do anything it just wrapped the data into a nucleus class but in
 the reduced encoding the map method of the factor actually performs a computati
on it already composes the functions although were revealing this smart
 composition but that's what we do before and after are the smart methods
 of I implemented here in place and then compose in the sky and then I do
 the same testing and it's slightly slower than three encoding 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
now let us consider the church including of the three functor the church
 including is our equivalent as types but they have different performance
 characteristics and they are more complicated to implement the three including
 of the three factor is like this and in order to implement it we would
 have to first implement the trait that hides this inside type parameter
 you will have to implement the trait that hides this type parameter and
 the outside parameter as well so that's why there is quite a lot of boilerplate
 involved so first I define this auxiliary type and then i encode the free
 factor using a trick that if if I look at the type expression here then
 this is the same as the magnitude of the function so I can transform this
 type expression into this which is an equivalent type and this is the same
 as the magnitude of the factor and so a shorter way of implementing a free
 typeclass in the church tree encoding is to impose a type constraint typeclass
 constraint on G and to declare this as an argument so that's why I'm saving
 a lot of typing if I do that but it's not necessary it's equivalent to
 doing it in a straightforward way now the result is that in life refactor
 looks like this it has a single method trade parameterize by an arbitrary
 type constructor which needs to have a functor constraint and the type
 of the method is this now we know that the three-factor has a punctured
 typeclass instance and in the tree encoding it was trivial to define it
 but in the church including it is much less trivial because of the complicated
 type signatures of these functions so these are functions whose arguments
 or functions and type parameters are hidden inside so here is the definition
 of the factor instance for this type I need to define a map function that
 takes a previous ffs away in function a to be and return the new F F of
 B where F is kept as a type parameter throughout now in order to return
 a new fffb the only thing i can do is to create a new anonymous instance
 of the trait and overwrite the run method so now I'm here in the run method
 I'm supposed to do this so let me write a function so now I have the following
 data I have this church encoded fffe I have a function A to B by heaven
 FF C which is simply a natural transformation F to G or if you wish generic
 transformation after Jesus if F is not necessarily a function so given
 this data I need to produce G of B how do I do that well the only way to
 produce any kind of G is to call this run method from the previous F of
 a which will give me a G of some X where X is up to this F of a so is going
 to give me G of a out of here there's no other way I can get any G here
 I need to run therefore this method but I'm free to specify a type parameter
 for this run method so I specify the G which is given to me here at that
 type parameter and then I apply that to an F FC which I have so that gives
 me a G of a now I need to write this syntax and not just run away for see
 because run has an implicit argument and it will be confused if I do that
 this will not work so having gotten G of a I just map it through the function
 f into a G of B since G has a functor instance so I do it like this just
 very explicitly so that's my implementation now in order to use this I
 need a helper function that lifts values of F of a into the free functor
 so that is like that we need to implement the run method so the only way
 to create a value of the free founder is to do this too to have a new FF
 with the run method so then I have an FF C I can apply this to FA and I
 get G of a out of it since F FC is directly a transformation from F to
 G so that's very easy and another helper function is to interpret free
 factor into a given specific function G so that is also very easy just
 to run the function the run function itself is already the interpreter
 that is a defining characteristic of the church encoding it is encoding
 which is assembled out of pieces of the run function so the value of a
 church included type itself is already its own interpreter now performing
 tests performance tests given some reasonable results however some paper
 claims that church and coatings are always slower it's not necessarily
 always the case you need to benchmark your code if you want to be sure
 now the problem with this code is that there there's a stack overflow because
 this run method is actually not stack safe again as before I already said
 stack safety in the Trojan Queen it is up to the implementation of the
 run method if the run method calls functions too many times then it's not
 going to I'm not going to be able to make it stack safe in the other parts
 of my implementation and can't really made stock safe the reason being
 that I have to do so the map function needs to do this I have to apply
 to this FFC and you have to run in the map function so since map function
 has to run there's no way to guarantee stack safety every time if you have
 a million maps when I would have a million nested calls here so that's
 a stack overflow now let's consider the church encoding of the reduced
 encoding of the free function [Music] reduced in Korean is slightly simpler
 for the free function and so let's search encode that we can search encode
 anything any any type can be Church encode the question it doesn't bring
 us any advantage it turns out it does because the church encoding of the
 reduced encoding of the free factor can be made stack safe and here is
 how so first of all we cannot do the same trick as before with the typeclasses
 we have to encode directly this type expression so that's encoded directly
 so first we called the exists tential type so we named a straight and it
 will have a single case class representing this value and here instead
 of B and is a Z so that's the implementation of an existential type expression
 then I implement this function for all a from that to G of a so that's
 the straight with apply method parameterize by a and finally I'll code
 the type by having another universal quantifier outside which is paralyzed
 here so in this way I have encoded this type expression so this is the
 boilerplate in Scala that is required in order to encode this type expression
 now to define the function instance I'm going to be more careful in order
 to make its taxi so I'm going to pull things out of the run method they
 have to be if they don't have to be reevaluated and so one thing I can
 pull outside is to reevaluate the run it can be done once so it can be
 done outside of this room if I do that and I actually can achieve stage
 stack safety another way but I use the before method which is my own implementa
tion my IntelliJ is a bit confused right now but before it's my own implementati
on of a function composition which is tag safe so how do i implement this
 well it's kind of cumbersome because of all these boilerplate and types
 I have a very complicated type expression it is still a factor the church
 encoding doesn't change the properties of the type that will church encoding
 it just adds a lot of functions and have a choice types and quantified
 types but it doesn't change the properties of the type it's just a different
 encoding of the same type so clearly we should be able to define a furniture
 instance if we are able to define a factor instance before church including
 but defining the file that would just be more work but this has work done
 only once so here's what we need to do we need to define a lab method and
 that method needs to return a new FF of FB so we return that and overwrite
 the run method in it run method takes an FF C and now we have the situation
 at work that we have this data and we need to produce G OD now the only
 way of getting G of B anywhere is to use this run to run this but running
 this will give us a value of death commit which will produce us G of B
 so where do we get that value we need to get that value out of our church
 included free function that we have we have before so now let's remember
 that the church encoding is equivalent to the type that is being encoded
 so you can extract that type outer that encoded value so since the church
 encoding of the reduced encoding of the free factor is basically encoding
 of this we can retrieve this back from a church encoded type no need to
 do this is where it is done so basically we get this free F of fa out of
 C F of a which is basically running it with identity so random with identity
 is the way to retrieve the underlying type out of a church and call it
 that so that's what we do in these two lines and we put these lines outside
 of the run because this needs to be done it doesn't depend on these arguments
 needs to be done outside a memory also achieve star safety when we economize
 on the stack doing this one side of the run function so haven't gotten
 this value we imagine it or we imagine it just because we need to extract
 the parts the F Z and Z to be parts of this 3 F 3 F is just the case one
 side you find right here with this map C so I'm going to extract those
 things in it to match and this is a key part of the implementation I'm
 composing the functions inside the map case class I'm not actually running
 the map anywhere yet I'm only going to be running it here so this together
 with putting this outside achieves tag safety if I remove this replace
 Ness with and then or if I put this inside into the run function I will
 have a stack waterfall everything else in this encoding is very similar
 to what we had before the wrapping the run is trivial the interpreter is
 stack safe it just runs them up and we guarantee that run is stuck safe
 so performance test shows us that this is actually significantly slower
 then especially creating this method and all these things that come with
 creating nested Maps method is significantly slower than other in puddings
 but as we will see later Church encoding has certain advantages so if performan
ce is not a great concern but flexibility of design is a great concern as
 well in charge encoding has significant advantages so this concludes our
 implementation of the free function let us look at other three type questions
 how they are implemented the next typeclass is the free culture hunter
 in order to implement it let us follow the general procedure first be right
 down the methods of the typeclass it has only one method which has this
 type signature we realize that it's inductive because this method returns
 again the value of the type we're constraining and also we realize that
 it has an existential type inside because it's parameterize with this be
 there for the three encoding looks like this it's again we are just following
 the general recipe what tree encoding is a recursive type what is made
 out of a disjunction the first is the wrapping of the generating type construct
or F and the second part of the disjunction is the method the method factor
 now in this case this is what we need to do this is the accuracy of instance
 of that type now reduced encoding quite similarly to deriving the reduced
 including for the free filter we derived for the free control enter a value
 of a free country func you type in the tree encoding will always be of
 the form that either we have a NFB or we apply several times map to FB
 which will add here I forgot the direct product sign we add a few terms
 of this kind with products of functions and existence or quantifiers the
 difference between this and a fee factor is the opposite directions of
 the function arrows so this starts with Z 1 and then we have a function
 Z - 2 Z 1 and so on the N to the N minus 1 B to Z and the result is a contra
 factor parameterize by B however the property of contra funky are still
 such that we need to compose these functions associatively and we can compose
 them before doing map or other contra motive or we can compose them after
 doing Countryman that's a composition law there for the reduced encoding
 can simply compose all these functions and put them inside a single function
 of this type and so the equivalent type is just this with all these other
 and residential types simply dropped since they are not used so that's
 how we derive the reduced encoding we need to figure out what are the possible
 expressions and how they can be simplified using the laws of the typeclass
 there's some simpler type expression notice that the reduced encoding is
 non recursive just as it is for the free functor and I'm going to show
 code now this free country function might be a little difficult to understand
 or to see where it is to be used but it is just a general scan you know
 I don't take any type constructor and wrap it into some stuff can make
 it into a pet typeclass instance of an arbitrary typeclass so for instance
 I can take a function such as this one you know identity factor and I can
 wrap it into a freaking tree function so then this will become a contractor
 after wrapping and I can create a control factor program by replying confirm
 I have a few times to this then I can interpret the results interspecific
 control function such as this one and the interpreter the only thing the
 interpreter needs is a function from here to here this function example
 the something like this where we take a value and return a contractor and
 contractors are usually consumers of values so imagine you're logging something
 that can see so the logger is a typical consumer of values I'm just going
 to simplify this very much and consider this function as a contractor and
 then this would be a transformation from identity factor to this control
 factor which is prepending prefix to the log message and that's I'm going
 to show the code in a few minutes that's how we would use a free contractor
 anything that another important property is that if the type constructor
 F is already a contractor then this wrapping does not produce a new in
 equivalent type it's the result is equivalent the free country function
 of over F is equivalent to F you just like it is the case for the pre factor
 or the look at example code so here's how I encode the free country function
 tree encoding I encode the wrapping case - and then code the culture map
 case using an existing show a quantified type when I create a helper function
 to wrap things it's just putting it into the wrap is constantly the country
 funky turquoise instance which does nothing but wrap into the typeclass
 sorry into the in our case cost so there is no complete computation done
 here other than memory allocations finally I write an interpreter which
 is trivial you just run you do a controller and I implement it producing
 coding reduced encoding is shorter he just has a single case class with
 existential 25 type a wrapper for than a reduced encoding now that wrapper
 is less trivial because we don't have the wrap case anymore so wrapping
 a value of F means we have this reduced case when we have we put this F
 here and we supply an identity function in this place the control factor
 instance is stuck safe because we reduce every function we don't apply
 map and you are we and I don't run anything we just collect all these functions
 and we collect them in a stack safely using this before method which is
 a stack safe alternative to and then and here is a rather so we just run
 by extracting a value of C out of the value of F and then running a contra
 map with the single function that is left so that's the example I just
 described we have a logger with the prefix now the writer factor is going
 to be wrapped in two star to make it into a country funky so we have a
 free country founder over the writer function so the fact that it is a
 factor is just I chosen us to show that I can take anything but including
 the furniture that certainly is not a country function and I can wrap it
 into this construction 3 CFR and the result is a contractor so that's an
 that's an interesting property so the result is is a contractor but if
 you look at the country factories type signature it is say this it's a
 contractor in being but it is no longer a functor so even if the constructor
 that we used was a functor it is no longer function and indeed so it's
 a contractor indeed so we have we if we do this we take a function like
 the right here function we wrap it into American structure and we lose
 the factor for it's a little bit you know it is a country function just
 to make it clear what's going on and here is some example code where and
 have some prefix logger and I wrap my writer function which could be computed
 after something sound function computation that I wrap it in their country
 factor then I do some contour map on it and the result can be used I interpret
 that I run this thing and the result is as expected the next example is
 a free pointed front kick a pointed funder is a flat class it has a symbol
 method other than function so if we say that this is an arbitrary type
 construction done that pointer factor pointed functor class has two methods
 to the point which is this or it is just the same type signature as the
 pure method and moanin an applicative but since this is not going to be
 a monitor a negative this method is called point it just takes a and inject
 stuff into p8 and map so this is familiar so what's the tree encoding of
 this well it's just a so we follow the recipe we have the wrapping yes
 we have the first method which takes a few turns PA I have a second method
 which takes this in turns so that's how we encode so we have a disjunction
 with three parts always going to be like this one part is going to be the
 wrapping and the other parts correspond each to a metal in inductive typeclasse
s are all going to be minus three encoded to derive the reduced encoding
 we're going to have a bit more work need to do a bit more work we see what
 kind of expressions can be found by using this definition so we took we
 take the tree encode it and reason about it so either we take an A and
 apply a bunch of maps to it so we first apply points to some value you
 get an a value type a and then we apply some map state so that would be
 one possibility another possibility that would take some F a wrap it and
 then apply some maps to it so therefore we only have two cases one is like
 this a general value of this type will be either like this or like this
 well it also could be a single affair or a single a but none of those so
 if we do have those things we can compose all of them and just as we did
 before so we just have one function one function is sufficient now consider
 the second case we have a value and then a function we can just apply this
 function to a value and we just have a single pure value so we can encode
 the single pure value therefore and we can encode a function x sorry a
 functor wrapped x a single function and if if we just have this we put
 identity function in there as we did before there for the reduced encoding
 has only two cases one is a pure value and the second is this wrapped construct
or times the function and it's not recursive so that's very nice note that
 this is exactly the same as a free function over F Z so basically this
 is what we have if the type constructor F is already a functor then this
 is equivalent to F itself therefore a three-pointed function over a functor
 is just this it is a very simple expression so just adding the type a to
 a factor makes it into a three-pointed so that becomes appointed and it's
 actually free pointed and of course if it is already pointed factor we
 should not use this construction because then this would be not the same
 as a factor itself so unlike other cases if we just saw I should not use
 a free construction if a factor already has the pointed method only it
 functor and contra fun to have the property that applying the free construction
 doesn't change them all other typeclasses will change usually when you
 do free type construction so for example free wound at over a moment is
 not the same moment free pointed over a point that is not the same function
 only factors and country functions pure factors pure country funky typeclasses
 do not change under applying the free construction let's look at the code
 it's very easy to implement this we need three case classes that encapsulate
 these three parts and to implement this we only need two his courses and
 in implementing the factor is very similar except now we have a point case
 so in a point case we need to implement the function by him so applying
 a map to the value of this type will just need to apply that function to
 that type so consider a pretty filterable now the filterable typeclass
 was explained in chapter 6 it is not a class that is widely known so look
 at chapter 6 for more details it has two methods map and map ok so these
 are the methods of of inductive kind or inductive type signature when they
 return the type of know actually it's sufficient to keep just map upped
 because we can restore map from it so let's not overdo things and let's
 just implement one method in the free construction since we can easily
 get this out of this in other words if we have this function and we can
 implement this function by substituting a going to zero plus B yeah so
 the tree encoding has two cases very similar to tree encoding on a three-factor
 you start here we have this type signature if the F type constructor is
 already a function we can simplify the tree encoding by using the identity
 the basic identity of existential types and then we just obtained this
 recursive definition so we'll get rid of the essential type and this recursive
 definition can be visualized as an infinite disjunction like this so it's
 F a F 1 plus a F 1 plus 1 plus a and so on so clearly applying filter function
 to this will give us this applying filter to this will give us this so
 on so it's this in this way it's implementing the free filterable in the
 green color now this is not the most economical encoding and it reduced
 including actually is like this it is non recursive and you can size in
 order to derive it we do the same procedure as we did before these are
 we stay this is this should be essential like 25 not universal level correctly
 since lights now an arbitrary value of this type in the tree encoding would
 be FA to which a bunch of map opt have been applied so that will give you
 a product like this now using the laws remember that these are composed
 using the class like composition because these are of type a to option
 B so these can be composed since option of the moment so that composition
 needs to be done and it gives us a single function so that can be done
 and if we just have a single affair with no function that will encoded
 like this so we can still encode it so that's going to be reduced encoding
 and the most interesting simplification is when F is already itself a factor
 then we'll use basic identity and we get F of 1 plus a so the free filterable
 over F factor is just this you can just implement a filter for any factor
 applied to an option so for any function f f co-option of a is filterable
 and that's a free filterable over a functor and this is a free filterable
 over an arbitrary type constructor so we see again that free filterable
 over f is not the same as f in a very similar way we can construct filterable
 contra factors free filter whole country hunters will not go into details
 about free filter will control factors because that is completely analogous
 here's the code for the free filter will factor I'm just sure this is nothing
 new in terms of how to implement existential types and recursive types
 in three encoding introduced encode consider now Freeman and the moolaade
 has two methods pure and flat map the map method can be recovered and in
 this way we formulate inductive teleclass now just a comment and we have
 seen in previous chapters that typeclasses can be formulated in different
 ways you can for example cumulative monad as having methods pure and flat
 map or you can do flatten instead of flat map but flatten does not have
 the same power as pure and flat map because you cannot restore a flat map
 from flatten so you would have to have map here as a third method if you
 wanted to if you wanted to do a free one over an arbitrary type constructor
 that is not itself already a factor for the filterable there could be different
 ways of doing the definition as well and for the implicit if there's the
 different ways but what we need is a set of methods that return the type
 that we are constraining type itself and not something else and we need
 a set of methods that are sufficient so without assuming that the function
 instance is already given for example so that's why would she was pure
 and flat map here and we can recover map from that so now the tree encoding
 is very similar so what we have before except now it has two places in
 which we use the same type recursively free m and freedom so the reduced
 encoding needs to be derived let's derive it so first of all let's see
 what happens come on we use the tree encoding and create some values of
 the free monotype first we can take this cut type constructor and apply
 a few flat maps to it second we can take this constructor which will appear
 when the playa few flatmap start but these are the two possibilities if
 we take a pure value and apply a flat map to it that can be simplified
 due to the laws of the minute so if you take something else and apply two
 flat maps they also can be simplified to a single flat map with a more
 complicated function here again this is what social tivity load of the
 Bonett so therefore it is not necessary to have many flat maps here they
 can all be collapsed to a single flat map maybe with a more complicated
 function inside so so so then clearly the first element in the product
 does not have to be a pure that can also always be replaced so the first
 element in the product is going to be F a or F C for some for some Z and
 then we have a single flat map so we don't need more than one flat map
 however this does not let us encode the pure value in without any flat
 maps applied to it so that means we cannot just have one part of a disjunction
 we need to we still need to keep this part of the disjunction that we have
 here but we can eliminate a fee and we can eliminate one of the recursive
 usages but not the second one so the reduced in chlorine is still recursive
 it is somewhat shorter but it's still recursive now one comment is that
 recently the so-called final tagless style of programming has become more
 known in a scale community has become also known and has gotten into a
 few years before in my terminology what is called final Tablas style is
 nothing more than the church encoding of a free moment so you can do Church
 encoding of any type and you can do free going out without a church encoding
 and if you want you can do Georgian going over three mooner and you have
 a choice you can charge encode this or you can Church encode this and that
 could have different performance implications however just keep in mind
 I'm not going to talk about final tagless because it's not really something
 specific or or special to jamuna's or put the portal DSL it's just the
 church encoding of a free movement and you can choose it for certain reasons
 or anything not choose it for other it is stack safety is important I have
 just found that the church encoding of a free factor is not stack safe
 and unless you use reduced encoding first so you first reduce the improvement
 using the frontier laws and the nutrition code the results and that can
 be made stack safe most likely it's similar with monads and because the
 three encoding is twice recursive use of the type so that was probably
 going to prevent you from being stuck safe this is difficult enough to
 make a stack safe but may be possible certainly I would if I were to make
 a library I would use reduced encoding and Church encode that as an option
 but also provide non-church encoded reduced encoding of the free moment
 as an option there's almost never advantages in using a non reduced encoding
 but there might be an advantage in a church encoding so again let us consider
 what happens if you do a free Mon and over a functor so you can actually
 save yourself a lot of trouble because if F is a factor then we can use
 the identity which says that this expression is equal to F of this which
 is this so now we get recursive definition which is much simple which is
 a free monad over a factor so I would also provide this as an option in
 the library because it's so much simpler and more efficient perhaps definition
 and also it shows you that a free monad is different from the mana of itself
 if you just substitute it into here warranty here so the free mode of Ramon
 odd is not equivalent to that normal so don't do it as an exercise we can
 ask what is a 3-1 out over a pointed functor so again all we need to do
 is we need to start with 3 encoding and try to reduce it so how do we reduce
 it well first we start with this clearly the pointed factor doesn't mean
 this part of the disjunction and clearly we can start with this encoding
 collapsing all those flat map functions into one and the result is going
 to be this and that's it we cannot really simplify this because we don't
 have a pure encoded so we cannot say oh let's only have this case because
 we cannot encode a fade so we don't have a permitted for free we have a
 pure method for F a itself but not for free we have eliminated that so
 we cannot encode a failure we cannot save us as part of the disjunction
 therefore this is the reduced encoding we use again the identity for the
 existential type to get F of this so therefore the reduced encoding is
 FA plus F of this still record so going to be recursive free if free M
 of F is FA plus this so that's reduced encoding here is a code for the
 free moment so you spend a lot of time on this let's consider the free
 plug ative which is an interesting tie class it has two methods we choose
 pure and app because the other choice would be for example wrapped unit
 and zip they do not return the type that we're constraining so wrapped
 unit returns F of one not F of a and zip returns F of pair a B but we cannot
 have that as a return targetnode type must be the simple F a with no changes
 if it is not that and our typeclass is not inductive so if the typeclass
 allows us to have a formulation equivalent to the previous formulation
 of the typeclass such that the new formulation contains only methods of
 inductive type signatures that is methods that return the typeclass the
 instructor constraint then it's an inductive type cons so as before we
 think about which methods to choose and which is pure and half because
 map can be recovered from these so the tree encoding is straightforward
 and in order you can have two usages of the recursive type let's derive
 the reduced encoding that's going to be this so how do we derive that so
 we reason about what structure of the values we will have either we take
 F a and we apply a bunch of apps to it or we take a and apply bunch of
 apps to it so we can encode if we have an a to which we apply we can encode
 that as something like like this so we can do an app with a pure here with
 a different type signature because that's basically it's going basically
 going to be a Mac due to the laws of the zip so it's going to be equivalent
 to if free app on the Left just the one that is on the right we'll put
 it on the left and on the right we put some other thing so that means if
 the first one does not have to be a pure well the first value in this product
 it does not have to be a pure value it can always be wrapped F so but then
 we cannot encode the pure value so we still need in that case so therefore
 we need only two cases the pure value and the wrapped constructor with
 a free app so that's there for the reduced encoding a free applicative
 over a factor is taken from here we use this representation and what we
 find is that we cannot really reduce this using the identity for the existentia
l type because this is not of the form exists Z and then F Z and Z goes
 to something it is not Z goes to something it is a type constructor so
 therefore free applicative over a factor it looks like this we can still
 reduce this but we do need to have a rap constructor but the a is outside
 of the recursion so the only game that we have is that if the type constructor
 F is already a functor then the pure value is outside the recursion and
 other than that it's a very similar construction so first we construct
 the recursive case which is which can be seen as a reduced encoding of
 freezy bubble that is a type coins were only the ab method is given the
 no pure so this is a freezie bubble and then we do any three pointed out
 of that it's a free pointed over a freezie bubble over a functor if and
 we see that again free applicative over applicative is not the same as
 that functor so here's the code of the free applicative in the trie encoding
 and introduced including so having gone through all these examples let
 us generalize what our laws of the freetypeclass constructions so we will
 consider a general inductive typeclass and for simplicity we will not consider
 type constructors here only ordinary types so the typeclass will have methods
 of this type signature but you see all the examples we have seen have been
 inductive so it's going to be equivalent for them except is going to be
 much more syntax for all these types of constructors and type parameters
 so I'm not going to go through laws for type construction typeclasses they're
 going to be my analogous up to a much more complicated syntax I'm going
 to consider in inductive typeclasses that have just ordinary types as elements
 of the or instances of that class so a typeclass with a method functor
 c has these methods and this is the definition of the three instance of
 c over c over a fixed type z so that's we have seen so there are several
 general properties that this construction has i'm not going to consider
 church encoding because the church encoding is equivalent to this it has
 exactly the same properties but it's much more complicated to reason about
 it's just a much more complicated type I'm going to use a recursive algebraic
 or polynomial definition of the three type instance the first property
 is that this type is actually an instance of typeclass C so in other words
 we can implement these methods all the methods are summarized in a single
 value of this type and so once we show that we can implement a value of
 this type we're done we have implemented methods another property is that
 it is a function in Z so it has an F map which works by changing the generating
 type another property is that if we have a specific type of that see we
 can implement these functions around and wrap so the wrap will lift a value
 of Z into the freetypeclass instance and the run will take a free typeclass
 instance it will also take this extractor function which translates Z into
 P and then it can translate the entire free instance entity these functions
 have certain laws the first law is that run of the rap is identity so what
 does it mean um if we wrap a value Z and then you run it then it's the
 same as if you did not wrap so he transforms e to the same P if you first
 just take Z to P or you first wrap it and then you run it you get the same
 P so that's this law the second law is the natural allottee of run so the
 run was this z type argument and in this type argument it is natural so
 the naturality law as usual it is a lot of how to put F map outside or
 inside of your function so this is typically an equation of this sort you
 left map either the right hand side has no F mat board has an F map on
 the other side so in this case it has no worth map here is a type diagram
 so you start with a crease free instance of C over Y you can transform
 it into a free C over Z using the F not function f map of F f is an arbitrary
 transformation Y to Z and then you can run this into P or you can run this
 into P and that shouldn't be different so you can first run directly with
 the combine function or you can run first by transforming into Z and then
 you can run from Z and it should be exactly the same so that's what this
 law specifies another important property is the so called Universal property
 and this property says that the Runner is universal you only have one runner
 so if you have for example to run into two different types and the same
 runner works for them in a way that is compatible so suppose you have two
 types a and Q and you want to run into P and run into Q and there is a
 function that transforms from P to Q well this function preserves the typeclass
 so it's not just an arbitrary transformation from P to Q it's a transformation
 that preserves the time class the property of preserving the typeclass
 is this diagram which is that here is the methods frontier of the typeclass
 and here's the method for P and here are the methods for Q and if you map
 P the Q and the methyls are also mapped to each other so in other words
 for instance if the class is a monoid then the function f must transform
 the unit element of the mono would P into the unit element of the monomyth
 Q and it must transform product in the P monoid into the product in the
 QM owner so that's automatically guaranteed by this diagram because the
 ops value is already all the methods but all the metals put together into
 a single so if the function f from P to Q satisfies this commutativity
 condition then what I say it preserves the typeclass and for these functions
 f you can see this diagram that you can run first into P and then you transform
 into Q or you directly transform into Q and that's the same function run
 does it so that is another kind of property that is it is quite important
 so let's see how these properties can be proved so first I will repeat
 the code for the universal construction of a tree encoded typeclass now
 you noticed I have been using a tree encoding here again this is the simplest
 encoding it is mechanically produced does not require any reasoning in
 order to be implemented whereas the reduced encoding requires some reasoning
 improves to show that it is actually reduced and adequate for encoding
 all possible values and so it's much more difficult to reason about although
 it can give you advantages in performance so that's why I'm reasoning about
 the tree in going here so I implemented the function ops that basically
 says that the free typeclass has the methods that are required for that
 typeclass C so the opposite of function from C all free to free so that's
 this function and that that's the first one that I need and put in this
 the second is that I can wrap that is trivial I just put the wrap constructor
 then of that I can interpret interpreter it's just the general interpreter
 which we have seen I sure that it is a functor well this is a simple exercise
 in making a functor instance for a recursive type where I use the recursively
 the map function in the hopes because obviously the recursive part of the
 type so the first law is that um if we run on wrap let's our identity on
 both sides from the first law are functions of this type so therefore we
 need to apply both functions on arbitrary value of this type so let's call
 this value free seasonally and also instead of this because we're working
 in this type the runner needs an even argument of this obstacle need to
 have the hopes for the free type constructor so that's our hopes you find
 above so if we do that and we substitute the code then this is what we
 get now if we look at this this function must be identity which means that
 it's a free CZ match something in this match should be just identity cases
 cases like this indeed they are identity the rap case is just rap which
 is defined like this that's the definition of herbs and wrap so oops requires
 us to execute a recursive call to the run and so we can use the induction
 assumption but run of ramp is identity and that assumption can be applied
 to recursive calls of the function that we are proving more for so therefore
 this is identity so that's a map on identity well that's just observe C
 F which is equal to that so that is again identity the second law is a
 little more involved it's a natural T now I could say well much reality
 is obvious because our code doesn't look at an edit type but we can prove
 this informally so again we look at two sides of this equation the functions
 of this type so we apply both sides to an arbitrary value of that type
 when we just substitute and compute the left-hand side which is going to
 be this and run of that is going to be that then we compute the right-hand
 side so we already see that the wrap case is the same and water is what
 remains is to demonstrate that the ops case is the same you know there
 is a slight difference between these two expressions and the difference
 can be resolved because we can use the induction assumption for this so
 we are proving the law of this kind and we can use this law for the recursive
 call here so if we do that we can assume this is true and then that's exactly
 what remains to be demonstrated that we can do the map so this is a functor
 whose map for United we're using so we can use a composition law for the
 function and that's exactly the expression that we have here what remains
 not equal that's the composition of two maps so we simplify that we get
 this so the universal property is slightly more involved yet but it is
 proved in a similar way so both sides are functions of this type so we
 apply both sides to an arbitrary value of type faces E or compute the left
 hand side will contain the right hand side and we use the typeclass preserving
 property which is this equation or it will only written in a scholar corner
 to space equation so when we have F of ops P we replace that with upscale
 of something so oops P and obscure are assumed to be available now these
 are typeclass evidence for P and Q and simplifying the code we put the
 code until identical shape so that leaves us home proof from the laws now
 what she would call that I have here that code is for the next slide so
 another general thing we can do the free typeclass is that we can combine
 different generating instructors so far we have been only looking at a
 free instance of a typeclass C generated by a single type Z but we can
 also consider several constructors at the same time several generating
 types of constructors and this would correspond in a monadic DSL that we
 have different sets of operations that are defined separately we would
 like to combine them and recall that monads did not compose in general
 so it is in general not easy to compose different sets of operations but
 it is actually easy in the free typeclass because all you need to do is
 to take a disjunction since the definition of the free typeclass is this
 if you have several generating types all you need to do is to have several
 parts of the disjunction here Z 1 plus Z 2 plus Z 3 and so on which means
 that the free instance of C over several constructor is the same as the
 free instance of C over the disjunction of these constructors so it is
 sufficient to take the disjunction and generate the free type cause using
 a disjunction now the only inconvenience is that you would need to inject
 parts into the disjunction that it can become cumbersome I will show called
 in a minute and the church encoding actually makes it easier to manage
 this situation so the reason is that the church encoding for an inductive
 typeclass it looks like yes if you have several constructors and it will
 be like this you can take the junction and transform it into this sort
 of expression now you can do the trick of type questions so you can encode
 each of these as extractor typeclass and then the church encoding would
 look like this and you can even simplify it further by saying that even
 this is a typeclass constraint on X which means that X must be of type
 C and so the church encoding would look like this so in this in this form
 it is an easier code to maintain at the same time we find that this definition
 actually works for any number of generators and for any typeclass C it's
 a general formula for Church encoded free instance of class typeclass C
 and generated by any number of given types so in this very concise form
 it's very easy to implement as well let's see how this works in order to
 test this I have three type constructors that are not functions in other
 words unfactored and they describe different kinds of operations in some
 kind of imaginary business project the first one factor adds a name care
 database and returns a database ID and it gets named by second and funky
 logs a message returns unit a third on factor creates a new ID so these
 are just for example and I defined generic transformations from each of
 these unfactored to the option factor these are just defined in arbitrary
 ways for testing purposes only this is not useful for any kind of application
 this kind of transformation which are none a lot nicer just testin I testing
 that all the types fit together so the first way of combining the three
 operation constructors I'm going to put them into a three factor and as
 we have seen all I need to do is I need to take a disjunction of all these
 constructors so let me define this unfold as a disjunction of the three
 type constructors now I also need to define a generic transformation from
 the new function to option let me put the syntax a little easier like this
 now notice that I need to write this column in this code this code is pure
 boilerplate but it depends on how I defined my unfunny here if I add another
 one then this entire core don't have to be reversed and this is kinda this
 is a bit of a burden now defining a free function in the reduced encoding
 is straightforward in order to use it I need to lift values from each of
 the unfactored into the free function so I define these lifting functions
 and again I have boilerplate that depends on how the order of disjunction
 is chosen now this is an example computation where I require this type
 annotation in order to lift I could have called these functions directly
 : over keys I could have called them directly where I can do this but I
 have to do it so let's see how the same works in the church encoding so
 first I define an extractor typeclasses and then I define the church encoding
 this is the entire church including it has a type parameter G and then
 there are three type constraints for each of the unfactored extractors
 and then a function type constraint and I've done this is the entire encoding
 the furniture instance is trivial but it is not stock safe unfortunately
 because we know that the church including of the three encoding over three
 frontier is not stack safe now the boilerplate for lifting does not depend
 on the order of the heart functions there's no notion of order anywhere
 if I need the first one I can just add it here here here and here there's
 no possibility of making a mistake there and finally I run the computation
 the extractors are need to declare and see there is the run is very simple
 I don't need an extra brother I have less code [Music] another important
 thing that we can do is combining different trade type process so suppose
 you have two different hypotheses C 1 and C 2 and you want to combine them
 several ways of doing that and one is to use factor composition so for
 example I can do 3 C 1 over a 3 C 2 over Z I can do that there are disadvantage
s in doing this one big disadvantage is that the order of composition actually
 matters in terms of what semantics I get if these type assets return effects
 and the effects are combined and nested in this order and not in the opposite
 order so I would not be able to encode this order of nesting I must encode
 always miss order of nesting and of course all the operations that I want
 to execute in situ need to be lifted through the factor C 1 I can do it
 because it's a factor as we have seen and this only works for inductive
 typeclasses of course well that is not a big limitation perhaps since most
 of our typeclasses are inductive not all for example traversable is not
 inductive so there is no free traversable that can be encoded in this way
 but these are significant disadvantages most importantly we are not free
 to encode arbitrary nesting of effects the second option is to use the
 disjunction of method factors and then you build the free typeclass instance
 using this C in other words you make a new typeclass that has all the methods
 of the previous hypothesis disjunction of method functors is equivalent
 to conjunction of the f-typeclass evidence families because type costs
 evidence values are of type function CX to X and so this disjunction is
 equivalent to taking a conjunction of those functions so that's the same
 as building one big type ones with all the methods put together now this
 is of course not ideal because you would have to change the code if you
 wanted to combine different typeclasses but church encoding can give you
 this combination for free because all you need to do is to write this kind
 of type and then obviously this was just a product of c1 c2 so you have
 this formula where you can put different typeclasses here and different
 in your use here and so the church encoding automatically gives you a way
 to have a way of having a free typeclass instance for any combination of
 typeclasses and any combination of generators it's a very powerful mechanism
 let's consider just two examples one is for curiosity what if we combine
 the filter in the control function we would have a typeclass that is at
 once a function and the control factor and that's possible we can do it
 the question is what do you do with this class because this class is going
 to be free encoding so you need to interpret it into some specific class
 typeclass so you could probably interpret it in a pro factor although I
 don't know what is the use case for this a better example is to combine
 munna and applicative this is actually useful in practice because ma not
 an applicative encode slightly different kind of effects monad encodes
 sequential effects look at them encodes effects that are partially parallel
 so not necessarily completely independent but the effect parts can be run
 in Kerala so computation with applicative factor can be paralyzed very
 easily but computations with monads cannot be paralyzed because they are
 sequentially the next step depends on the value of the previous step and
 the effect also depends on the value of the previous step so you cannot
 start running the effect before you know the value but with a quick edit
 of you can now ordinarily a monad also has an applicative instance however
 in Sun walnuts in other words you can implement zip if you have flat map
 but in some walnuts there is a non-standard implementation of zip that
 has specific advantages in other words an implementation of zip that is
 not equal to that which you get out of a flat map and you do that for specific
 reasons either for performance so it could it could give you the same results
 but it will run effects differently and will have different performance
 for example imagine that you have a future monad and the zip can be implemented
 as parallel execution of futures and flatmap is implemented as sequential
 execution of futures so if you combined monad and duplicative in the freetypecl
ass and interpreted that pi plus into a future such that the monadic methods
 the flat map are converted into flat map in the future but applicative
 methods are converted into parallel execution of futures using a special
 code then you get an advantage because each zip or create fellow branches
 in each flat mark sequential branches so let's see how that works in some
 example code so here's the encoding of the free monad and applicative at
 the same time so I put them into one typeclass for simplicity I could have
 done it differently you could have done it using the church including the
 real is right before but this is more interesting because you can see how
 you would run a combined frame on a duplicative over a type constructor
 G that has both applicative and one on instances the way you would do that
 is that all you would translate of course wrapping to wrap here into pure
 flatmap you would translate like this you would run and then you run this
 you so you run the flat map in the target unit but the applicative you
 know that you translate like this you run in parallel and then you combine
 them using an applicative method in the model so you see this run is not
 in peril because this is inside the function which is this function which
 will be called only inside the flat map after the first effect is finished
 but these two effects are going to be run in parallel so if I implement
 the interpreter like this and I will automatically translate all the applicativ
e operations into parallel executions potentially parallel executions let's
 see for example for future I just translate the same into futures and this
 is actually going to be pair execution of futures because we know what's
 calendars once you have a future it already is scheduled and run I give
 it an execution context and it's already run so in this way I can have
 so I don't have the typeclass instances for functor monad it's more or
 less boilerplate I just do a little bit of simplification it's not important
 most so let me just skip this and then here is my DSL I have some operations
 I make a free monad out of it which is at the same time a free applicative
 and then I run it through the future so I can run my code melodically so
 this is nomadic code the lift is a just method that I defined to make it
 quicker to lift things it's a wrapper so basically I generate an ID when
 I generate three new IDs and I validate them in parallel and I wait until
 all of this validation is done and I close the session so this is a combination
 of melodic and wicked methods at the same time the interpreter is just
 some translating these into specific business logic that I imagined and
 this is all for a less boilerplate so basically when I run this computations
 computations of course just a pure value doesn't do anything it's a pure
 data structure that describes what needs to be done but when I run this
 computation and automatically all these zipped parts become executed in
 parallel but all the mimetic parts are executed sequentially and I can
 I don't need to worry about the order of these things I can nest them in
 any way want for example I could define first validate using monadic the
 line I combine different validates using applicative and I again put the
 results into a monadic context it's fine it's all working it all works
 in arbitrary order this is what I was indicating here and this is an advantage
 over this method the frankly composition where I would have to choose whether
 I have moon add outside applicative inside or more not inside applicative
 outside and whatever I choose I can only then encode one of those combinations
 so this concludes this chapter and here are some exercises for making your
 dream code introduced in coding and working with inductive typeclasses
 implement an idea cells implementing the church encoding simplifying quantified
 types and deriving a reduced encoding color of a tree encoding for different
 cases this concludes chapter tune 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
