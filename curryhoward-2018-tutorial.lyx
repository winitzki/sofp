#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Introduction to Curry-Howard]{Introduction to the Curry-Howard
correspondence}
\subtitle{The logic of types in functional programming languages}
\author{Sergei Winitzki}
\date{February 17, 2018}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructions in functional programming
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
The common ground between OCaml, Haskell, Scala, Rust, and other languages
\end_layout

\begin_layout Standard
Five type constructions are common in FP languages:
\end_layout

\begin_layout Itemize
Tuple (
\begin_inset Quotes eld
\end_inset

product
\begin_inset Quotes erd
\end_inset

) type: 
\begin_inset Formula $\text{Int}\times\text{String}$
\end_inset


\end_layout

\begin_layout Itemize
Function type: 
\begin_inset Formula $\text{Int}\Rightarrow\text{String}$
\end_inset


\end_layout

\begin_layout Itemize
Disjunction (
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

) type: 
\begin_inset Formula $\text{Int}+\text{String}$
\end_inset


\end_layout

\begin_layout Itemize
Unit type (
\begin_inset Quotes eld
\end_inset

empty tuple
\begin_inset Quotes erd
\end_inset

): 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Itemize
Type parameters: 
\begin_inset Formula $\text{List}^{T}$
\end_inset


\end_layout

\begin_layout Standard
Up to differences in syntax, the FP languages share all these features
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructions: Scala syntax
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tuple type: 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
val pair:
\begin_inset space \space{}
\end_inset

(Int, String) = (123, "abc")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
val y:
\begin_inset space \space{}
\end_inset

String = pair._2
\end_layout

\end_deeper
\begin_layout Itemize
Function type: 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
val f:
\begin_inset space \space{}
\end_inset

(Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 "Value is " + x.toString
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
val y:
\begin_inset space \space{}
\end_inset

String = f(123)
\end_layout

\end_deeper
\begin_layout Itemize
Disjunction type: 
\family typewriter
\size footnotesize
\color blue
Either[Int, String]
\family default
\size default
\color inherit
 defined in standard library
\end_layout

\begin_deeper
\begin_layout Itemize
Create:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue

\begin_inset space \space{}
\end_inset

val x:
\begin_inset space \space{}
\end_inset

Either[Int, String] = Left(123)
\begin_inset Newline newline
\end_inset

 val y:
\begin_inset space \space{}
\end_inset

Either[Int, String] = Right("abc")
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
val z:
\begin_inset space \space{}
\end_inset

Boolean = x match {
\begin_inset Newline newline
\end_inset

 case Left(i) 
\begin_inset Formula $\Rightarrow$
\end_inset

 i > 0
\begin_inset Newline newline
\end_inset

 case Right(_) 
\begin_inset Formula $\Rightarrow$
\end_inset

 false
\begin_inset Newline newline
\end_inset

}
\end_layout

\end_deeper
\begin_layout Itemize
Unit type: 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
val x:
\begin_inset space \space{}
\end_inset

Unit = ()
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructions: OCaml syntax
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tuple type: 
\family typewriter
\size footnotesize
\color blue
int * string
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
let pair:
\begin_inset space \space{}
\end_inset

int * string = (123, "abc")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
let y:
\begin_inset space \space{}
\end_inset

string = snd pair
\end_layout

\end_deeper
\begin_layout Itemize
Function type: 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
let f:
\begin_inset space \space{}
\end_inset

int -> string =
\begin_inset Newline newline
\end_inset

 fun x -> Printf.sprintf "Value is %d" x
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
let y:
\begin_inset space \space{}
\end_inset

string = f 123
\end_layout

\end_deeper
\begin_layout Itemize
Disjunction type: 
\family typewriter
\size footnotesize
\color blue
type e = Left of int | Right of string
\end_layout

\begin_deeper
\begin_layout Itemize
Create:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue

\begin_inset space \space{}
\end_inset

let x:
\begin_inset space \space{}
\end_inset

e = Left 123
\begin_inset Newline newline
\end_inset

 let y:
\begin_inset space \space{}
\end_inset

e = Right "abc"
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
let z:
\begin_inset space \space{}
\end_inset

bool = match x with
\begin_inset Newline newline
\end_inset

 Left i -> i > 0
\begin_inset Newline newline
\end_inset

 Right _ -> false
\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Unit type: 
\family typewriter
\size footnotesize
\color blue
unit
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
let x:
\begin_inset space \space{}
\end_inset

unit = ()
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructions: Haskell syntax
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tuple type: 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
pair = (123, "abc")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
(_, y) = pair
\end_layout

\end_deeper
\begin_layout Itemize
Function type: 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
f = 
\backslash
x -> "Value is " ++ show x
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
y = f 123
\end_layout

\end_deeper
\begin_layout Itemize
Disjunction type: 
\family typewriter
\size footnotesize
\color blue
data E = Left Int | Right String
\end_layout

\begin_deeper
\begin_layout Itemize
Create:
\begin_inset Newline newline
\end_inset


\begin_inset space \space{}
\end_inset

 
\family typewriter
\size footnotesize
\color blue
x = Left 123
\begin_inset Newline newline
\end_inset

 y = Right "abc"
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
z = case x of
\begin_inset Newline newline
\end_inset

 Left i -> i > 0
\begin_inset Newline newline
\end_inset

 Right _ -> false
\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Unit type: 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
x = ()
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
From types to propositions
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The code 
\family typewriter
\size footnotesize
\color blue
val x:
\begin_inset space \space{}
\end_inset

T =
\family default
\size default
\color inherit
 ...
 shows that 
\emph on
we can compute a value
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 as part of our program expression
\end_layout

\begin_layout Itemize
Let's denote this 
\emph on
proposition
\emph default
 by 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 – 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathcal{C}$
\end_inset

ode 
\begin_inset Formula $\mathcal{H}$
\end_inset

as a value of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Correspondence between types and propositions, for a given program:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Short notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(T)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\wedge B$
\end_inset

; 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
or
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\vee B$
\end_inset

; 
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
implies
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Type parameter 
\family typewriter
\size footnotesize
\color blue
[T]
\family default
\size default
\color inherit
 in a function type means 
\begin_inset Formula $\forall T$
\end_inset


\end_layout

\begin_layout Itemize
Example: 
\family typewriter
\size footnotesize
\color blue
def dupl[A]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, A)
\family default
\size default
\color inherit
.
 The type of this function, 
\begin_inset Formula $A\Rightarrow A\times A$
\end_inset

, corresponds to the (valid) theorem 
\begin_inset Formula $\forall A:A\Rightarrow A\wedge A$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Translating language constructions into the logic I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
What are the derivation rules for the logic of types?
\end_layout

\begin_layout Standard
Code expressions create
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
,
\end_layout

\end_inset


\emph on
logical relationships
\emph default
 between propositions 
\begin_inset Formula ${\cal CH}(...)$
\end_inset


\end_layout

\begin_layout Itemize
Expressions (program code) are represented by 
\series bold
sequents
\end_layout

\begin_deeper
\begin_layout Itemize

\color blue
\begin_inset Formula $A,B\vdash C$
\end_inset


\color inherit
 represents an 
\emph on
expression
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
C
\family default
\size default
\color inherit
 that uses 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
y:
\begin_inset space \space{}
\end_inset

B
\end_layout

\begin_deeper
\begin_layout Itemize
Sequents only describe the 
\emph on
types
\emph default
 of expressions and their parts
\end_layout

\end_deeper
\begin_layout Itemize
In 
\begin_inset Formula $A,B,...\vdash C$
\end_inset

 the 
\series bold
premises
\series default
 are 
\begin_inset Formula $A,B,...$
\end_inset

 and the 
\series bold
goal
\series default
 is 
\begin_inset Formula $C$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Some sequents are immediate, others follow from previous ones
\end_layout

\begin_deeper
\begin_layout Itemize
Tuple type: 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\begin_inset Formula $A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
Use: 
\begin_inset Formula $A\times B\vdash A$
\end_inset

 and also 
\begin_inset Formula $A\times B\vdash B$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Function type: 
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create: if we have 
\begin_inset Formula $A\vdash B$
\end_inset

 then we will have 
\begin_inset Formula $\emptyset\vdash A\Rightarrow B$
\end_inset

 
\end_layout

\begin_layout Itemize
Use: 
\begin_inset Formula $A\Rightarrow B,A\vdash B$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Disjunction type: 
\begin_inset Formula $A+B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\begin_inset Formula $A\vdash A+B$
\end_inset

 and also 
\begin_inset Formula $B\vdash A+B$
\end_inset


\end_layout

\begin_layout Itemize
Use: 
\begin_inset Formula $A+B,A\Rightarrow C,B\Rightarrow C\vdash C$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Unit type: 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\begin_inset Formula $\emptyset\vdash1$
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Translating language constructions into the logic II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Additional rules for the logic of types
\end_layout

\begin_layout Standard
In addition to constructions that use types, we have 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 constructions:
\end_layout

\begin_layout Itemize
a single, unmodified value of type 
\begin_inset Formula $A$
\end_inset

 is a valid expression of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
For any 
\begin_inset Formula $A$
\end_inset

 we have the sequent 
\begin_inset Formula $A\vdash A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
if a value can be computed using some given data, it can also be computed
 if given
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
,
\end_layout

\end_inset


\emph on
additional
\emph default
 data
\end_layout

\begin_deeper
\begin_layout Itemize
If we have 
\begin_inset Formula $A,...,C\vdash G$
\end_inset

 then also 
\begin_inset Formula $A,...,C,D\vdash G$
\end_inset

 for any 
\begin_inset Formula $D$
\end_inset


\end_layout

\begin_layout Itemize
For brevity, we denote by 
\begin_inset Formula $\Gamma$
\end_inset

 a sequence of arbitrary premises
\end_layout

\end_deeper
\begin_layout Itemize
the order in which data is given does not matter, we can still compute all
 the same things given the same premises in different order
\end_layout

\begin_deeper
\begin_layout Itemize
If we have 
\begin_inset Formula $\Gamma,A,B\vdash G$
\end_inset

 then we also have 
\begin_inset Formula $\Gamma,B,A\vdash G$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Syntax conventions:
\end_layout

\begin_layout Itemize
the implication operation associates 
\emph on
to the right
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A\Rightarrow B\Rightarrow C$
\end_inset

 means 
\begin_inset Formula $A\Rightarrow\left(B\Rightarrow C\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
precedence order: implication, disjunction, conjunction
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A+B\times C\Rightarrow D$
\end_inset

 means 
\begin_inset Formula $\left(A+\left(B\times C\right)\right)\Rightarrow D$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Quantifiers: implicitly, all our type variables are universally quantified
\end_layout

\begin_layout Itemize
When we write 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset

, we mean 
\begin_inset Formula $\forall A:\forall B:A\Rightarrow B\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The logic of types I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Now we have all the axioms and the derivation rules of the logic of types.
\end_layout

\begin_layout Itemize
What theorems can we derive in this logic?
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Start with an axiom 
\begin_inset Formula $A\vdash A$
\end_inset

; add an unused extra premise 
\begin_inset Formula $B$
\end_inset

: 
\begin_inset Formula $A,B\vdash A$
\end_inset


\end_layout

\begin_layout Itemize
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

, get 
\begin_inset Formula $A\vdash B\Rightarrow A$
\end_inset


\end_layout

\begin_layout Itemize
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B\Rightarrow A$
\end_inset

, get the final sequent 
\begin_inset Formula $\emptyset\vdash A\Rightarrow\left(B\Rightarrow A\right)$
\end_inset

 showing that 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset

 is a 
\series bold
theorem
\series default
 since it is derived from no premises
\end_layout

\end_deeper
\begin_layout Itemize
What code does this describe?
\end_layout

\begin_deeper
\begin_layout Itemize
The axiom 
\begin_inset Formula $A\vdash A$
\end_inset

 represents the expression 
\begin_inset Formula $x$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 is of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Itemize
The unused premise 
\begin_inset Formula $B$
\end_inset

 corresponds to unused variable 
\begin_inset Formula $y$
\end_inset

 of type 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives the function 
\begin_inset Formula $y\Rightarrow x$
\end_inset


\end_layout

\begin_layout Itemize
The second 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow x\right)$
\end_inset


\end_layout

\begin_layout Itemize
Scala code: 
\family typewriter
\size footnotesize
\color blue
def f[A, B]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B 
\begin_inset Formula $\Rightarrow$
\end_inset

 A = (x:
\begin_inset space \space{}
\end_inset

A) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (y:
\begin_inset space \space{}
\end_inset

B) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x
\end_layout

\end_deeper
\begin_layout Itemize
Any code expression's type can be translated into a sequent
\end_layout

\begin_layout Itemize
A proof of a theorem directly guides us in writing code for that type
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Correspondence between programs and proofs
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
By construction, any theorem can be implemented in code
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def identity[A](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

A = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def toUnit[A](x:
\begin_inset space \space{}
\end_inset

A): Unit = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def inLeft[A,B](x:A):
\begin_inset space \space{}
\end_inset

Either[A,B] = Left(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\times B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def first[A,B](p:
\begin_inset space \space{}
\end_inset

(A,B)):
\begin_inset space \space{}
\end_inset

A = p._1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow(B\Rightarrow A)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def const[A,B](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

B
\begin_inset Formula $\Rightarrow$
\end_inset

A = (y:B)
\begin_inset Formula $\Rightarrow$
\end_inset

x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Also, non-theorems 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_deeper
\begin_layout Itemize
Examples of non-theorems:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\Rightarrow A$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:A+B\Rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\Rightarrow A\times B$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Given a type's formula, can we implement it in code? Not obvious.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\forall A\forall B:((((A\Rightarrow B)\Rightarrow A)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Can we write a function with this type?
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The logic of types II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
What kind of logic is this?
\end_layout

\begin_layout Standard
This is called 
\begin_inset Quotes eld
\end_inset

intuitionistic propositional logic
\begin_inset Quotes erd
\end_inset

, IPL (also 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
Disjunction works very differently from classical (Boolean) logic
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $A\Rightarrow B+C\vdash(A\Rightarrow B)+(A\Rightarrow C)$
\end_inset

 does not hold in IPL
\end_layout

\begin_layout Itemize
This is counter-intuitive!
\end_layout

\begin_layout Itemize
We cannot implement a function with this type:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def q[A,B,C](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[B, C]): Either[A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B, A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C]
\end_layout

\begin_layout Itemize
Disjunction is 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

: need to supply one of the parts
\end_layout

\begin_deeper
\begin_layout Itemize
But 
\family typewriter
\size footnotesize
\color blue
Either[A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B, A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C]
\family default
\size default
\color inherit
 is not a function of 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Implication works somewhat differently
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\left(\left(A\Rightarrow B\right)\Rightarrow A\right)\Rightarrow A$
\end_inset

 holds in Boolean logic but not in IPL
\end_layout

\begin_layout Itemize
Cannot compute an 
\family typewriter
\size footnotesize
\color blue
x:
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 because of insufficient data
\end_layout

\end_deeper
\begin_layout Itemize
Conjunction works the same as in Boolean logic
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula 
\[
A\Rightarrow B\times C\vdash\left(A\Rightarrow B\right)\times\left(A\Rightarrow C\right)
\]

\end_inset

 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The logic of types III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
How to determine whether a given IPL formula is a theorem?
\end_layout

\begin_layout Itemize
The IPL cannot have a truth table with a fixed number of truth values
\end_layout

\begin_deeper
\begin_layout Itemize
This was shown by G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
"
\end_layout

\end_inset

odel in 1932 (see 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia page"
target "https://en.wikipedia.org/wiki/Many-valued_logic"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
The IPL has a decision procedure (algorithm) that either finds a proof for
 a given IPL formula, or determines that there is no proof
\end_layout

\begin_layout Itemize
There may be several inequivalent proofs of an IPL theorem
\end_layout

\begin_layout Itemize
Each proof can be 
\emph on
automatically translated
\emph default
 into code
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"

\end_inset

 library implements an IPL prover as a Scala macro, and generates Scala
 code from types
\end_layout

\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "djinn-ghc"
target "https://hackage.haskell.org/package/djinn-ghc"

\end_inset

 compiler plugin and the 
\begin_inset CommandInset href
LatexCommand href
name "JustDoIt plugin"
target "https://github.com/nomeata/ghc-justdoit"

\end_inset

 implement an IPL prover in Haskell, and generate Haskell code from types
\end_layout

\end_deeper
\begin_layout Itemize
All these IPL provers use the same basic algorithm called LJT 
\end_layout

\begin_deeper
\begin_layout Itemize
and all cite the same paper 
\size footnotesize

\begin_inset CommandInset href
LatexCommand href
name "[Dyckhoff 1992]"
target "https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf"

\end_inset


\end_layout

\begin_layout Itemize
because most other papers on this subject are incomprehensible to engineers
 or describe algorithms that are too complicated
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search I: looking for an algorithm
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Why our initial presentation of IPL does not give a proof search algorithm
\end_layout

\begin_layout Standard
The FP type constructions give nine axioms and three derivation rules:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Itemize
\begin_inset Formula $\Gamma,A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash A$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\Rightarrow B,A\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A+B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,B\vdash A+B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A+B,A\Rightarrow C,B\Rightarrow C\vdash C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma\vdash1$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A$
\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma,A\vdash B}{\Gamma\vdash A\Rightarrow B}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma\vdash G}{\Gamma,D\vdash G}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma,A,B\vdash G}{\Gamma,B,A\vdash G}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Can we use these rules to obtain a finite and complete search tree? No.
\end_layout

\begin_layout Itemize
Try proving 
\begin_inset Formula $A,B+C\vdash A\times B+C$
\end_inset

: cannot find matching rules
\end_layout

\begin_layout Itemize
Need a better formulation of the logic
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search II: Gentzen's calculus LJ (1935)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

complete and sound calculus
\begin_inset Quotes erd
\end_inset

 is a set of axioms and derivation rules that will yield all (and only!)
 theorems of the logic
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{}{\Gamma,{\color{blue}X}\vdash X}\:Id & \qquad\frac{}{\Gamma\vdash{\color{blue}\top}}\,\top\\
\frac{\Gamma,A\Rightarrow B\vdash A\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A\Rightarrow B}\vdash C}\:L\Rightarrow & \qquad\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\Rightarrow B}}\,R\Rightarrow\\
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+ & \qquad\frac{\Gamma\vdash A_{i}}{\Gamma\vdash{\color{blue}A_{1}+A_{2}}}\,R+_{i}\\
\frac{\Gamma,A_{i}\vdash C}{\Gamma,{\color{blue}A_{1}\times A_{2}}\vdash C}\:L\times_{i} & \qquad\frac{\Gamma\vdash A\quad\;\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\times B}}\,R\times
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Two axioms and eight derivation rules
\end_layout

\begin_layout Itemize
Each rule says: The sequent at bottom will be proved if proofs are given
 for sequent(s) at top
\end_layout

\begin_layout Itemize
Use these rules 
\begin_inset Quotes eld
\end_inset

bottom-up
\begin_inset Quotes erd
\end_inset

 to perform a proof search
\end_layout

\begin_deeper
\begin_layout Itemize
Sequents are nodes and proofs are edges in the proof search tree
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search example I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Example: to prove 
\begin_inset Formula $\emptyset\vdash\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q$
\end_inset


\end_layout

\begin_layout Itemize
Root sequent 
\begin_inset Formula $S_{0}:\emptyset\vdash\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{0}$
\end_inset

 with rule 
\begin_inset Formula $R\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{1}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash Q$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{1}$
\end_inset

 with rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{2}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash R\Rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{3}:Q\vdash Q$
\end_inset


\end_layout

\begin_layout Itemize
Sequent 
\begin_inset Formula $S_{3}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom; it remains to prove 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{4}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash R\Rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{5}:Q\vdash R\Rightarrow R$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We are stuck here because 
\begin_inset Formula $S_{4}=S_{2}$
\end_inset

 (we are in a loop)
\end_layout

\begin_layout Itemize
We can prove 
\begin_inset Formula $S_{5}$
\end_inset

, but that will not help
\end_layout

\begin_layout Itemize
So we backtrack (erase 
\begin_inset Formula $S_{4}$
\end_inset

, 
\begin_inset Formula $S_{5}$
\end_inset

) and apply another rule to 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $R\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{6}:\left(R\Rightarrow R\right)\Rightarrow Q;R\vdash R$
\end_inset


\end_layout

\begin_layout Itemize
Sequent 
\begin_inset Formula $S_{6}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom
\end_layout

\begin_layout Standard
Therefore we have proved 
\begin_inset Formula $S_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $Q.E.D.$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search III: The calculus LJT
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Vorobieff-Hudelmaier-Dyckhoff, 1950-1990
\end_layout

\begin_layout Itemize
The Gentzen calculus LS will loop if rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 is applied 
\begin_inset Formula $\geq2$
\end_inset

 times
\end_layout

\begin_layout Itemize
The calculus LJT keeps all rules of LJ except rule 
\begin_inset Formula $L\Rightarrow$
\end_inset


\end_layout

\begin_layout Itemize
Replace rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 by pattern-matching on 
\begin_inset Formula $A$
\end_inset

 in the premise 
\begin_inset Formula $A\Rightarrow B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{\Gamma,X,B\vdash D}{\Gamma,X,{\color{blue}X\Rightarrow B}\vdash D}\:L\Rightarrow_{1}\\
\frac{\Gamma,A\Rightarrow(B\Rightarrow C)\vdash D}{\Gamma,{\color{blue}(A\times B)\Rightarrow C}\vdash D}\:L\Rightarrow_{2}\\
\frac{\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A+B)\Rightarrow C}\vdash D}\:L\Rightarrow_{3}\\
\frac{\Gamma,B\Rightarrow C\vdash A\Rightarrow B\quad\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\Rightarrow B)\Rightarrow C}\vdash D}\:L\Rightarrow_{4}
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
When using LJT rules, the proof tree has no loops and terminates
\end_layout

\begin_deeper
\begin_layout Itemize
See 
\begin_inset CommandInset href
LatexCommand href
name "this paper"
target "http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2618"

\end_inset

 for an explicit decreasing measure on the proof tree
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search IV: The calculus LJT
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
\begin_inset Quotes eld
\end_inset


\emph on
It is obvious that it is obvious
\emph default

\begin_inset Quotes erd
\end_inset

 – a mathematician after thinking for a half-hour
\end_layout

\begin_layout Itemize
Rule 
\begin_inset Formula $L\Rightarrow_{4}$
\end_inset

 is based on the key theorem: 
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\Rightarrow B\right)\Rightarrow C\right)\Rightarrow\left(A\Rightarrow B\right)\,\Longleftrightarrow\,\left(B\Rightarrow C\right)\Rightarrow\left(A\Rightarrow B\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
The key theorem for rule 
\begin_inset Formula $L\Rightarrow_{4}$
\end_inset

 is attributed to Vorobieff (1958):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Vorobieff-lemma.png
	display false
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\align center

\size footnotesize
[R.
 Dyckhoff, 
\emph on
Contraction-Free Sequent Calculi for Intuitionistic Logic
\emph default
, 1992]
\end_layout

\begin_layout Itemize
A stepping stone to this theorem:
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\Rightarrow B\right)\Rightarrow C\right)\Rightarrow B\Rightarrow C
\]

\end_inset


\size default
Proof (
\emph on
obviously
\emph default
 trivial): 
\begin_inset Formula $f^{\left(A\Rightarrow B\right)\Rightarrow C}\Rightarrow b^{B}\Rightarrow f\:(x^{A}\Rightarrow b)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Details are left as exercise for the reader
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search V: From deduction rules to code
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The new rules are equivalent to the old rules, therefore...
\end_layout

\begin_deeper
\begin_layout Itemize
Proof of a sequent 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 code/expression 
\begin_inset Formula $t(a,b,c):G$
\end_inset


\end_layout

\begin_layout Itemize
Also can be seen as a function 
\begin_inset Formula $t$
\end_inset

 from 
\begin_inset Formula $A,B,C$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sequent in a proof follow from an axiom or from a transforming rule
\end_layout

\begin_deeper
\begin_layout Itemize
The two axioms are fixed expressions, 
\begin_inset Formula $x^{A}\Rightarrow x$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Itemize
Each rule has a 
\emph on
proof transformer
\emph default
 function: 
\begin_inset Formula $\text{PT}_{R\Rightarrow}$
\end_inset

 , 
\begin_inset Formula $\text{PT}_{L+}$
\end_inset

 , etc.
\end_layout

\end_deeper
\begin_layout Itemize
Examples of proof transformer functions:
\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+\\
PT_{L+}(t_{1}^{A\Rightarrow C},t_{2}^{B\Rightarrow C})(x^{A+B})= & \ x\ \text{match}\begin{cases}
a\Rightarrow & t_{1}(a)\\
b\Rightarrow & t_{2}(b)
\end{cases}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\Rightarrow(B\Rightarrow C)\vdash D}{\Gamma,{\color{blue}(A\times B)\Rightarrow C}\vdash D}\:L\Rightarrow_{2}\\
PT_{L\Rightarrow_{2}}(f^{\left(A\Rightarrow B\Rightarrow C\right)\Rightarrow D})(g^{A\times B\Rightarrow C})= & f\,(x^{A}\Rightarrow y^{B}\Rightarrow g(x,y))
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Verify that we can indeed produce PTs for every rule of LJT
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search VI: Example deduction
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Once a proof tree is found, start from leaves and apply PTs
\end_layout

\begin_layout Itemize
Example: to prove 
\begin_inset Formula $S_{0}$
\end_inset

, start from 
\begin_inset Formula $S_{6}$
\end_inset

 backwards:
\size footnotesize

\begin_inset Formula 
\begin{align*}
S_{6}:\left(R\Rightarrow R\right)\Rightarrow Q;R\vdash R\quad(\text{axiom }Id)\quad & t_{6}(rrq,r):R=r\\
S_{2}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash\left(R\Rightarrow R\right)\quad\text{PT}_{R\Rightarrow}(t_{6})\quad & t_{2}(rrq):\left(R\Rightarrow R\right)=\left(r\Rightarrow t_{6}(rrq,r)\right)\\
S_{3}:Q\vdash Q\quad(\text{axiom }Id)\quad & t_{3}(q):Q=q\\
S_{1}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash Q\quad\text{PT}_{L\Rightarrow}(t_{2},t_{3})\quad & t_{1}(rrq):Q=t_{3}(rrq(t_{2}(rrq)))\\
S_{0}:\emptyset\vdash\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q\quad\text{PT}_{R\Rightarrow}(t_{1})\quad & t_{0}=\left(rrq\Rightarrow t_{1}(rrq)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
The expression for the proof of 
\begin_inset Formula $S_{0}$
\end_inset

 is
\begin_inset Formula 
\begin{align*}
t_{0} & =rrq\Rightarrow t_{3}\left(rrq\left(t_{2}\left(rrq\right)\right)\right)=rrq\Rightarrow rrq(r\Rightarrow t_{6}\left(rrq,r\right)\\
 & =rrq\Rightarrow rrq\left(r\Rightarrow r\right)
\end{align*}

\end_inset

Simplified final code (proof term) having the required type: 
\begin_inset Formula 
\[
t_{0}:\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q=\left(rrq\Rightarrow rrq\left(r\Rightarrow r\right)\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms I: identities
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Using known properties of propositional logic and arithmetic
\end_layout

\begin_layout Standard
Are 
\begin_inset Formula $A+B,\:A\times B$
\end_inset

 more like logic 
\begin_inset Formula $\left(A\vee B,\;A\wedge B\right)$
\end_inset

 or like arithmetic?
\end_layout

\begin_layout Itemize
Some standard identities in logic (
\begin_inset Formula $\forall A\forall B\forall C$
\end_inset

 is assumed):
\begin_inset Formula 
\begin{align*}
A\times1=A; & \quad A\times B=B\times A\\
A\vee1=1; & \quad A\vee B=B\vee A\\
(A\times B)\times C=A\times(B\times C); & \quad A\vee(B\times C)=(A\vee B)\times(A\vee C)\\
(A\vee B)\vee C=A\vee(B\vee C); & \quad A\times(B\vee C)=(A\times B)\vee(A\times C)\\
(A\times B)\Rightarrow C & =A\Rightarrow(B\Rightarrow C)\\
A\Rightarrow(B\times C) & =(A\Rightarrow B)\times(A\Rightarrow C)\\
(A\vee B)\Rightarrow C & =(A\Rightarrow C)\times(B\Rightarrow C)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Each identity means 2 function types: 
\begin_inset Formula $X=Y$
\end_inset

 is 
\begin_inset Formula $X\Rightarrow Y\text{ \emph{and} }Y\Rightarrow X$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
Do these functions convert values between the types 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are isomorphic, 
\begin_inset Formula $A\equiv B$
\end_inset

, if there is a 1-to-1 correspondence between the sets of values of these
 types
\end_layout

\begin_deeper
\begin_layout Itemize
Need to find two functions 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

 and 
\begin_inset Formula $g:B\Rightarrow A$
\end_inset

 such that 
\begin_inset Formula $f\circ g=id$
\end_inset

 and 
\begin_inset Formula $g\circ f=id$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Example 1: Is 
\begin_inset Formula $\forall A:A\times1\equiv A$
\end_inset

? Types in Scala: 
\family typewriter
\size footnotesize
\color blue
(A, Unit)
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
A
\end_layout

\begin_layout Itemize
Two functions with types 
\begin_inset Formula $\forall A:A\times1\Rightarrow A$
\end_inset

 and 
\begin_inset Formula $\forall A:A\Rightarrow A\times1$
\end_inset

:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A]: ((A, Unit)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 A = { case (a, ()) 
\begin_inset Formula $\Rightarrow$
\end_inset

 a }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A]: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, Unit) = a 
\begin_inset Formula $\Rightarrow$
\end_inset

 (a, ())
\end_layout

\begin_layout Itemize
Verify that their compositions equal 
\family typewriter
\size footnotesize
\color blue
identity
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Example 2: Is 
\begin_inset Formula $\forall A:1+A\equiv1$
\end_inset

? (The formula 
\begin_inset Formula $\forall A:A\vee1=1$
\end_inset

 is a theorem!)
\end_layout

\begin_layout Itemize
Types in Scala: 
\family typewriter
\size footnotesize
\color blue
Option[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Unit
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
These types are obviously 
\emph on
not
\emph default
 equivalent
\end_layout

\end_deeper
\begin_layout Standard

\emph on
Some
\emph default
 logic identities yield
\emph on
 
\emph default
isomorphisms of types
\end_layout

\begin_layout Itemize
Which ones 
\emph on
do
\emph default
 
\emph on
not
\emph default
 yield isomorphisms, and why?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Verifying type equivalence by implementing isomorphisms
\end_layout

\begin_layout Itemize
Need to verify that 
\begin_inset Formula $f_{1}\circ f_{2}=id$
\end_inset

 and 
\begin_inset Formula $f_{2}\circ f_{1}=id$
\end_inset


\end_layout

\begin_layout Standard
Example 3: 
\begin_inset Formula $\forall A\forall B\forall C:(A\times B)\times C\equiv A\times(B\times C)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: (((A, B), C)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, (B, C)) = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: ((A, (B, C))) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ((A, B), C) = ???
\end_layout

\begin_layout Standard
Example 4: 
\begin_inset Formula $\forall A\forall B\forall C:(A+B)\times C\equiv A\times C+B\times C$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: ((Either[A,B], C)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[(A,C), (B,C)] = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: Either[(A,C), (B,C)] 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Either[A, B], C) = ???
\end_layout

\begin_layout Standard
Example 5: 
\begin_inset Formula $\forall A\forall B\forall C:(A+B)\Rightarrow C\equiv(A\Rightarrow C)\times(B\Rightarrow C)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: (Either[A, B] 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C, B 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: ((A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C, B 
\begin_inset Formula $\Rightarrow$
\end_inset

 C)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[A, B] 
\begin_inset Formula $\Rightarrow$
\end_inset

 C = ???
\end_layout

\begin_layout Standard
Example 6: 
\begin_inset Formula $\forall A\forall B\forall C:A+B\times C\not\equiv(A+B)\times(A+C)$
\end_inset

 – 
\begin_inset Quotes eld
\end_inset

information loss
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: Either[A,(B,C)]
\begin_inset Formula $\Rightarrow$
\end_inset

(Either[A,B],Either[A,C]) = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: ((Either[A,B],Either[A,C])) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[A,(B,C)] = ???
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms IV
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Logical CH vs.
\begin_inset space \space{}
\end_inset

arithmetical CH
\end_layout

\begin_layout Itemize
WLOG consider types 
\begin_inset Formula $A,B,...$
\end_inset

 that have 
\emph on
finite
\emph default
 sets of possible values
\end_layout

\begin_deeper
\begin_layout Itemize
Sum type 
\begin_inset Formula $A+B$
\end_inset

 (size 
\begin_inset Formula $\left|A\right|+\left|B\right|$
\end_inset

) provides a disjoint union of sets
\end_layout

\begin_layout Itemize
Product type 
\begin_inset Formula $A\times B$
\end_inset

 (size 
\begin_inset Formula $\left|A\right|\cdot\left|B\right|$
\end_inset

) provides a Cartesian product of sets
\end_layout

\begin_deeper
\begin_layout Itemize
Have identities 
\begin_inset Formula $\left(a+b\right)+c=a+\left(b+c\right)$
\end_inset

, 
\begin_inset Formula $\left(a\times b\right)\times c=a\times(b\times c)$
\end_inset

, 
\begin_inset Formula $1\times a=a$
\end_inset

, 
\begin_inset Formula $\left(a+b\right)\times c=a\times c+b\times c$
\end_inset

, ...
 – as in 
\begin_inset Quotes eld
\end_inset

school-level
\begin_inset Quotes erd
\end_inset

 algebra
\end_layout

\end_deeper
\begin_layout Itemize
Function type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 provides the set of all maps between sets
\end_layout

\begin_deeper
\begin_layout Itemize
The size of 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 is 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset


\end_layout

\begin_layout Itemize
Have identities 
\begin_inset Formula $a^{c}\times b^{c}=\left(a\times b\right)^{c}$
\end_inset

, 
\begin_inset Formula $a^{b+c}=a^{b}\times a^{c}$
\end_inset

, 
\begin_inset Formula $a^{b\times c}=\left(a^{b}\right)^{c}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
If the set size (
\series bold
cardinality
\series default
) differs, 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 cannot be equivalent 
\end_layout

\begin_layout Standard
The meaning of the type/logic/arithmetic correspondence:
\end_layout

\begin_layout Itemize
Arithmetical identities signify type equivalence (isomorphism)
\end_layout

\begin_layout Itemize
Logic identities only signify 
\emph on
equal implementability
\emph default
 of types
\end_layout

\begin_layout Standard
Reasoning about types is 
\emph on
school-level algebra
\emph default
 with polynomials and powers
\end_layout

\begin_layout Itemize

\series bold
Exp-polynomial 
\series default
expressions: constants, sums, products, exponentials
\end_layout

\begin_deeper
\begin_layout Itemize
exp-poly types: primitive types, disjunctions, tuples, functions
\end_layout

\begin_layout Itemize
polynomial types are commonly called 
\begin_inset Quotes eld
\end_inset

algebraic types
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Making practical use of the CH correspondence I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for actually writing code
\end_layout

\begin_layout Standard
What can we do now?
\end_layout

\begin_layout Itemize
Given a fully parametric type, decide whether it can be implemented in code
 (
\begin_inset Quotes eld
\end_inset

type is inhabited
\begin_inset Quotes erd
\end_inset

); if so, 
\emph on
generate
\emph default
 the code
\end_layout

\begin_layout Itemize
Let the computer fill in the code when it is 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 to do so
\end_layout

\begin_deeper
\begin_layout Itemize
This is often (not always) the case for fully type-parametric functions
\end_layout

\end_deeper
\begin_layout Itemize
Decide type isomorphisms using the 
\begin_inset Quotes eld
\end_inset

arithmetical CH
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Isomorphically transform types using school-level algebra
\end_layout

\begin_layout Standard
What problems cannot be solved with these tools?
\end_layout

\begin_layout Itemize
Automatically generate code satisfying properties (e.g.
\begin_inset space \space{}
\end_inset

isomorphism) 
\end_layout

\begin_layout Itemize
Express complicated conditions via types (e.g.
\begin_inset space \space{}
\end_inset


\begin_inset Quotes eld
\end_inset

array is sorted
\begin_inset Quotes erd
\end_inset

) 
\end_layout

\begin_layout Itemize
Generate code using type constructors with properties (e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
)
\end_layout

\begin_deeper
\begin_layout Itemize
Scala type signature: 
\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

List[A]).map[B](f:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B):
\begin_inset space \space{}
\end_inset

List[B]
\end_layout

\begin_layout Itemize
This formula has a quantifier 
\emph on
inside
\emph default
: 
\begin_inset Formula $\text{List}^{A}\Rightarrow(\forall B:f^{A\Rightarrow B}\Rightarrow\text{List}^{B})$
\end_inset


\end_layout

\begin_layout Itemize
This requires 
\series bold
first-order logic
\series default
, which is generally 
\emph on
undecidable
\emph default
 (no algorithm can guarantee finding a proof or showing its absence)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Some caveats
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The CH correspondence becomes informative only with parameterized types.
 For concrete types, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
, we can always produce 
\emph on
some
\emph default
 value even with no previous data, so 
\begin_inset Formula $\mathcal{CH}(\text{Int})$
\end_inset

 is always true.
\end_layout

\begin_layout Itemize
Functions such as 
\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

Int) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x + 1
\family default
\size default
\color inherit
 have type 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 
\begin_inset Formula $\Rightarrow$
\end_inset


\family typewriter
\size footnotesize
\color blue
 Int
\family default
\size default
\color inherit
, and the type signature is insufficient to specify the code.
 Only for fully type-parametric functions the type signature can be, in
 some cases, informative enough for deriving the code automatically.
\end_layout

\begin_layout Itemize
Having an arithmetic identity does not 
\emph on
guarantee
\emph default
 that we have a type equivalence via CH (it is a necessary but not a sufficient
 condition); but it does yield a type equivalence in all cases I looked
 at so far.
\end_layout

\begin_layout Itemize
Scala's type 
\family typewriter
\size footnotesize
\color blue
Nothing
\family default
\size default
\color inherit
 and Haskell's type 
\family typewriter
\size footnotesize
\color blue
Void
\family default
\size default
\color inherit
 correspond to the logical constant 
\begin_inset Formula $False$
\end_inset

; but the practical uses of 
\begin_inset Formula $False$
\end_inset

 are extremely limited.
 
\end_layout

\begin_layout Itemize
We did not talk about the logical negation because it is defined as 
\begin_inset Formula $\neg A\equiv A\Rightarrow False$
\end_inset

 and its practical use is as limited as that of 
\begin_inset Formula $False$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Making practical use of the CH correspondence II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for designing new programming languages
\end_layout

\begin_layout Itemize
The CH correspondence maps the type system of each programming language
 into a certain system of logical propositions 
\end_layout

\begin_layout Itemize
Scala, Haskell, OCaml, F#, Swift, Rust, etc.
\begin_inset space ~
\end_inset

are mapped into the full constructive logic (all logical operations are
 available)
\end_layout

\begin_deeper
\begin_layout Itemize
C, C++, Java, C#, etc.
\begin_inset space ~
\end_inset

are mapped to 
\emph on
incomplete
\emph default
 
\emph on
logics
\emph default
 – without 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

 and without 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Python, JavaScript, Ruby, Clojure, etc.
\begin_inset space ~
\end_inset

have only one type (
\begin_inset Quotes eld
\end_inset

any value
\begin_inset Quotes erd
\end_inset

) and are mapped to logics with only one proposition
\end_layout

\end_deeper
\begin_layout Itemize
The CH correspondence is a principle for designing type systems:
\end_layout

\begin_deeper
\begin_layout Itemize
Choose a complete logic, free of inconsistency
\end_layout

\begin_deeper
\begin_layout Itemize
Mathematicians have studied all kinds of logics and determined which ones
 are interesting, and found the minimal sets of axioms for them
\end_layout

\begin_layout Itemize
Modal logic, temporal logic, linear logic, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Provide a type construction for each basic operation (e.g.
\begin_inset space ~
\end_inset


\begin_inset Quotes eld
\end_inset


\emph on
or
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
and
\emph default

\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
There should be a type for every logical operation and vice versa
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_body
\end_document
