#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 5: Type functions \& type classes]{Chapter 5: 
Type-level functions and type classes}
\author{Sergei Winitzki}
\date{January 14, 2018}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation for type classes I: Restricting type arguments
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
We would like a generic 
\family typewriter
\size footnotesize
\color blue
sum
\family default
\size default
\color inherit
 implementation for 
\family typewriter
\size footnotesize
\color blue
Seq[Int], Seq[Double]
\family default
\size default
\color inherit
, etc.
\end_layout

\begin_layout Itemize
but we cannot generalize 
\family typewriter
\size footnotesize
\color blue
sum
\family default
\size default
\color inherit
 to arbitrary types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 like this:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
\color blue
def sum[T](s: Seq[T]): T = ???
\end_layout

\end_deeper
\begin_layout Itemize
this can work only for 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 that are 
\begin_inset Quotes eld
\end_inset

summable
\begin_inset Quotes erd
\end_inset

 in some sense
\end_layout

\begin_layout Standard
We would like to define 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 for functors, using the available 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Itemize
but we cannot generalize 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 to arbitrary type constructors 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
\color blue
def fmap[F[_], A, B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): F[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[B] = ???
\end_layout

\end_deeper
\begin_layout Itemize
this can work only for type constructors 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
 that are functors
\end_layout

\begin_layout Standard
We would like to define functions whose type arguments, such as 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
, are required to belong to a 
\emph on
certain subset
\emph default
 of possible types
\end_layout

\begin_layout Itemize
We could then use the known properties of these type arguments
\end_layout

\begin_layout Itemize
We would also like to add new supported types as needed
\end_layout

\begin_deeper
\begin_layout Itemize
This is similar to the concept of 
\emph on
partial functions
\emph default
 – applied to types
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation for type classes II: Partial functions on types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Functions can be 
\series bold
total
\series default
 or 
\series bold
partial
\end_layout

\begin_deeper
\begin_layout Itemize
Total function: has a result for all argument values
\end_layout

\begin_layout Itemize
Partial function: has 
\emph on
no result
\emph default
 for 
\emph on
some
\emph default
 argument values
\end_layout

\end_deeper
\begin_layout Itemize
Also, functions can be, in principle, {from/to} {values/types}:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
to value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def f(x:
\begin_inset space \space{}
\end_inset

Int):
\begin_inset space \space{}
\end_inset

Int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def point[A]: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 List[A]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
to type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
dependent type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
type MyData[A] = Either[Int, A]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Evaluation: value-to-value – run time, type-to-value – compile time
\end_layout

\begin_deeper
\begin_layout Itemize
if we use type casts, type-to-value can become run-time (
\emph on
yuck!
\emph default
)
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
partial function:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 value-level (PVVF)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from type (PTVF)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
example:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
{ case Some(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x-1 }
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
implicitly[T]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when misapplied:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exception at run time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
error at compile time
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Type classes provide a systematic way of managing PTVFs
\end_layout

\begin_deeper
\begin_layout Itemize
we can apply a PTVF to type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 if 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset

belongs to a certain type class
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example of using value-level PFs: The caveats
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Filter a 
\family typewriter
\size footnotesize
\color blue
Seq[Either[Int, Boolean]]
\family default
\size default
\color inherit
, then apply 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 with a PF:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val s: Seq[Int] = Seq( Left(1), Right(true), Left(2) )
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .filter(_.isLeft) 
\family roman
\color gray
// result here is still of type 
\family default
\color blue
Seq[Either[...]]
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .map { case Left(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x } 
\family roman
\color gray
// result is of type 
\family default
\color blue
Seq[Int]
\family roman
\color gray
 but unsafe
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

We know
\begin_inset Quotes erd
\end_inset

 it is okay to apply this PF here...
\end_layout

\begin_deeper
\begin_layout Itemize
but the types do not show this, – compile-time checking doesn't help
\end_layout

\begin_layout Itemize
if refactored, the code may become wrong and break 
\emph on
at run time
\end_layout

\end_deeper
\begin_layout Itemize
The type-safe version uses 
\family typewriter
\size footnotesize
\color blue
.collect
\family default
\size default
\color inherit
 instead of 
\family typewriter
\size footnotesize
\color blue
.filter().map()
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val s: Seq[Int] = Seq( Left(1), Right(true), Left(2) )
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .collect { case Left(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x }
\family roman
\color gray
  // result is safe, of type 
\family default
\color blue
Seq[Int]
\end_layout

\begin_layout Itemize
PFs are only safe in certain places, such as within 
\family typewriter
\size footnotesize
\color blue
.collect()
\end_layout

\begin_deeper
\begin_layout Itemize
make functions total: either add code, or use 
\emph on
more restrictive types
\end_layout

\begin_layout Itemize
e.g.
\begin_inset space \space{}
\end_inset

types such as 
\begin_inset Quotes eld
\end_inset

non-empty list
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

positive number
\begin_inset Quotes erd
\end_inset

, 
\family typewriter
\size footnotesize
\color blue
Some[T]
\family default
\size default
\color inherit
, etc.
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def f(xs: NonEmptyList[Int]) = {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  val h = xs.head
\family roman
\color gray
  // safe and checked at compile time
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\end_deeper
\begin_layout Itemize
Can we restrict the 
\emph on
type
\emph default
 
\emph on
parameter(s)
\emph default
 of a PTVF to a subset of types?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand I: Using GADTs
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTTFs: Partial Type-to-Type Functions
\end_layout

\begin_layout Itemize
A type constructor that accepts only certain types as parameters:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
sealed trait 
\family typewriter
MyTC
\family default
[A] 
\family roman
\color gray
// 
\begin_inset Quotes eld
\end_inset

sealed
\begin_inset Quotes erd
\end_inset

 GADT – user code can't add cases
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
final case class Case1(d: Double) extends 
\family typewriter
MyTC
\family default
[Int]
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
final case class Case2() extends 
\family typewriter
MyTC
\family default
[String]
\family roman
\color gray
 // whatever
\end_layout

\begin_layout Itemize
It looks like we have defined 
\family typewriter
\size footnotesize
\color blue
MyTC[
\family default
A
\family typewriter
]
\family default
\size default
\color inherit
 for any type 
\size footnotesize
\color blue
A
\size default
\color inherit
 ...
\end_layout

\begin_deeper
\begin_layout Itemize
actually, we can only ever create values of 
\family typewriter
\size footnotesize
\color blue
MyTC[Int]
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
MyTC[String]
\end_layout

\begin_layout Itemize
see example code
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\text{MyTC}^{A}$
\end_inset

 is a PTTF because its values exist only for 
\begin_inset Formula $A\in\left\{ \text{Int};\,\text{String}\right\} $
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The 
\series bold
type domain
\series default
 
\begin_inset Formula $\left\{ \text{Int};\,\text{String}\right\} $
\end_inset

 is defined 
\emph on
at compile time
\end_layout

\begin_layout Itemize
Note: 
\begin_inset Formula $\text{MyTC}^{A}$
\end_inset

 cannot be a functor since it is not defined for all types 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
When to use GADTs:
\end_layout

\begin_deeper
\begin_layout Itemize
for domain modeling (e.g.
\begin_inset space \space{}
\end_inset

queries with a fixed set of result types)
\end_layout

\begin_layout Itemize
for DSLs that represent typed expressions
\end_layout

\end_deeper
\begin_layout Itemize
Alternatively, a PTTF can be a 
\family typewriter
\size footnotesize
\color blue
trait
\family default
\size default
\color inherit
 with some implementation code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand II: Using OO method overriding
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTVFs: Partial Type-to-Value Functions – the object-oriented way
\end_layout

\begin_layout Itemize
A trait with 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
 methods that are overridden:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
\color blue
sealed trait HasPlus[A] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  def plus(a1: A, a2: A): A
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
final case class CaseInt() extends HasPlus[Int] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  override def plus(a1: Int, a2: Int): Int = a1 + a2
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
final case class CaseString() extends HasPlus[String] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  override def plus(a1: String, a2: String): String = a1 + a2
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Similar
\emph default
 to having defined 
\family typewriter
\size footnotesize
\color blue
plus[A]
\family default
\size default
\color inherit
 for 
\begin_inset Formula $A\in\left\{ \text{Int};\,\text{String}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
Limitations:
\end_layout

\begin_deeper
\begin_layout Itemize
We can only call 
\family typewriter
\size footnotesize
\color blue
plus() 
\family default
\size default
\color inherit
via a value of type 
\family typewriter
\size footnotesize
\color blue
HasPlus[A]
\family default
\size default
\color inherit
 
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Itemize
All PTVFs must be declared up front in the trait
\end_layout

\begin_deeper
\begin_layout Itemize
Not extensible – cannot add new PTVFs later
\end_layout

\begin_layout Itemize
Not compositional – cannot use this in other PTVFs defined later
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand III: 
\begin_inset Quotes eld
\end_inset

Type Evidence
\begin_inset Quotes erd
\end_inset

 arguments
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTVFs: Partial Type-to-Value Functions – the general case
\end_layout

\begin_layout Standard
To define a function 
\family typewriter
\size footnotesize
\color blue
func[A](...)
\family default
\size default
\color inherit
 only for certain types 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Enumerate
create a PTTF defined only for the relevant types 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
IsGood[A]
\family default
\size default
\color inherit
 
\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Enumerate
create some values of types 
\family typewriter
\size footnotesize
\color blue
IsGood[A]
\family default
\size default
\color inherit
 for relevant types 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 as needed
\end_layout

\begin_layout Enumerate
add an 
\emph on
extra argument
\emph default
 
\family typewriter
\size footnotesize
\color blue
ev:
\begin_inset space \space{}
\end_inset

IsGood[A]
\family default
\size default
\color inherit
 (
\series bold
type evidence
\series default
) to 
\family typewriter
\size footnotesize
\color blue
func[A](...)
\family default
\size default
\color inherit

\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
What we gained:
\end_layout

\begin_layout Itemize
it is now impossible to call 
\family typewriter
\size footnotesize
\color blue
func[A]
\family default
\size default
\color inherit
 with an unsupported type 
\family typewriter
\size footnotesize
\color blue
A
\end_layout

\begin_deeper
\begin_layout Itemize
trying to do so will fail 
\emph on
at compile time
\emph default
 
\begin_inset space \space{}
\end_inset

– TE values won't type-check
\end_layout

\end_deeper
\begin_layout Itemize
new supported types can be added in user code if 
\family typewriter
\size footnotesize
\color blue
IsGood
\family default
\size default
\color inherit
 is not 
\family typewriter
\size footnotesize
\color blue
sealed
\end_layout

\begin_layout Standard
The cost:
\end_layout

\begin_layout Itemize
all calls to 
\family typewriter
\size footnotesize
\color blue
func[A](args)
\family default
\size default
\color inherit
 will now become 
\family typewriter
\size footnotesize
\color blue
func[A](args, ev)
\end_layout

\begin_layout Itemize
one TE value 
\family typewriter
\size footnotesize
\color blue
ev
\family default
\size default
\color inherit
 needs to be created for 
\emph on
each
\emph default
 supported type 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit

\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Itemize
we now need to keep passing all these TE values around the code
\end_layout

\begin_layout Standard
Mitigate these issues in Scala by using 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 values:
\end_layout

\begin_layout Itemize
TE arguments are explicit only at 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
 declaration site
\end_layout

\begin_layout Itemize
once defined as 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
, TE values are passed around invisibly
\end_layout

\begin_layout Itemize
new 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 values can be built up automatically from previous ones
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Scala's mechanism of 
\begin_inset Quotes eld
\end_inset


\family typewriter
implicit
\family default
 values
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Implicit values are:
\end_layout

\begin_layout Itemize
declared as 
\family typewriter
\size footnotesize
\color blue
implicit val x:
\begin_inset space \space{}
\end_inset

SomeType = ...
\end_layout

\begin_deeper
\begin_layout Itemize
also have 
\family typewriter
\size footnotesize
\color blue
implicit def f[T](...)
\begin_inset space \space{}
\end_inset

= ...

\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
implicit class(...)
\end_layout

\end_deeper
\begin_layout Itemize
automatically passed into functions that declare extra arguments as
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f(args...)(implicit x: SomeType) = ...
\end_layout

\end_deeper
\begin_layout Itemize
searched in local scope, imports, companion objects, parent classes
\end_layout

\begin_deeper
\begin_layout Itemize
having 
\begin_inset Formula $\geq2$
\end_inset

 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 values of the same type is a compile-time error!
\end_layout

\end_deeper
\begin_layout Standard
Special short syntax for declaring implicit TE arguments in a PTVF:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def func[A: TC1, B: TC2](args...) = ...
\end_layout

\begin_layout Itemize
This is entirely equivalent to this longer code:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def func[A, B](args...)(implicit evA: TC1[A], evB: TC2[B])= ...
\end_layout

\begin_layout Itemize
standard library has 
\family typewriter
\size footnotesize
\color blue
def implicitly[A](implicit x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

A = x
\end_layout

\begin_layout Standard
We still need to:
\end_layout

\begin_layout Itemize
declare 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[A]
\family default
\size default
\color inherit
 as a PTTF elsewhere
\end_layout

\begin_layout Itemize
create TE values of various types and declare them as 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 
\begin_inset space \space{}
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type classes I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
The general definition
\end_layout

\begin_layout Standard
A 
\series bold
type class
\series default
 is a set of PTVFs that all have the same type domain
\end_layout

\begin_layout Itemize
In terms of specific code to be written, a type class is:
\end_layout

\begin_deeper
\begin_layout Enumerate
a PTTF, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 with some code that creates TE values, 
\emph on
and
\end_layout

\begin_layout Enumerate
the desired PTVFs that use this PTTF to define their type domain
\end_layout

\begin_layout Itemize
for many important use cases, the PTVFs must also satisfy certain laws
\end_layout

\end_deeper
\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset


\series bold
belongs to
\series default
 the type class 
\family typewriter
\size footnotesize
\color blue
MyTypeClass
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 if a TE value exists
\end_layout

\begin_deeper
\begin_layout Itemize
i.e.
\begin_inset space \space{}
\end_inset

if 
\emph on
some
\emph default
 value of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 can be found
\end_layout

\end_deeper
\begin_layout Itemize
A function 
\family typewriter
\size footnotesize
\color blue
func[T]
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset


\series bold
requires
\series default
 the type class 
\family typewriter
\size footnotesize
\color blue
MyTypeClass
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 if one of 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
's arguments is a value of PTTF-constructed type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 
\begin_inset space \space{}
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
that argument is the 
\series bold
type class instance
\series default
 for the type parameter 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_layout Itemize
this 
\series bold
constrains
\series default
 the type parameter 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 to 
\series bold
belong to
\series default
 the type class
\end_layout

\begin_layout Itemize
this is how we know that 
\family typewriter
\size footnotesize
\color blue
func[T]
\family default
\size default
\color inherit
 is a PTVF
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type classes II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implementation in Scala
\end_layout

\begin_layout Standard
A type class is typically implemented as:
\end_layout

\begin_layout Enumerate
a trait with a type parameter, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
trait MyTC[T]
\end_layout

\begin_layout Enumerate
code that creates values of type 
\family typewriter
\size footnotesize
\color blue
MyTC[T]
\family default
\size default
\color inherit
 for various 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_deeper
\begin_layout Itemize
these values are declared as 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 and made available via imports or in the companion objects for the specific
 types 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_deeper
\begin_layout Enumerate
some functions with implicit argument(s) of type 
\family typewriter
\size footnotesize
\color blue
MyTC[T]
\end_layout

\begin_deeper
\begin_layout Itemize
these functions are usually 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
 methods in a trait, but don't have to be
\end_layout

\begin_layout Itemize
laws for these functions may need to be enforced by property tests
\end_layout

\end_deeper
\begin_layout Standard
A TE value should carry all information the PTVFs need about the type 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_layout Itemize
usually, the trait 
\family typewriter
\size footnotesize
\color blue
MyTC[T]
\family default
\size default
\color inherit
 contains all the PTVFs as 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
 methods
\end_layout

\begin_layout Itemize
in simpler cases, TE can be a data type (not a trait with 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
 methods)
\end_layout

\begin_deeper
\begin_layout Itemize
a trait with 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
 methods is necessary for 
\emph on
higher-order
\emph default
 type functions
\end_layout

\end_deeper
\begin_layout Itemize
additional PTVFs (with unchanged PTTF) can be added later
\end_layout

\begin_deeper
\begin_layout Itemize
no need to modify the code of 
\family typewriter
\size footnotesize
\color blue
MyTC[T]
\family default
\size default
\color inherit
 if the type domain is unchanged
\end_layout

\end_deeper
\begin_layout Itemize
can combine with other PTTFs/PTVFs defined later
\end_layout

\begin_layout Standard
See example code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of type classes I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Some simple PTFs and their use cases
\end_layout

\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is a 
\series bold
semigroup
\series default
 if it has an 
\emph on
associative
\emph default
 binary operation
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def op[T](x: T, y: T): T
\end_layout

\begin_layout Itemize
a bare-bones operation, no inverse – just 
\begin_inset Quotes eld
\end_inset

can combine
\begin_inset Quotes erd
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is 
\series bold
pointed
\series default
 if there exists a function 
\family typewriter
\size footnotesize
\color blue
point[T]:
\begin_inset space \space{}
\end_inset

T
\end_layout

\begin_deeper
\begin_layout Itemize
This is a special, somehow 
\begin_inset Quotes eld
\end_inset

naturally
\begin_inset Quotes erd
\end_inset

 selected value of that type
\end_layout

\begin_deeper
\begin_layout Itemize
Examples: 
\family typewriter
\size footnotesize
\color blue
0:
\begin_inset space \space{}
\end_inset

Int
\family default
\size default
\color inherit
; 
\family typewriter
\size footnotesize
\color blue
"":
\begin_inset space \space{}
\end_inset

String
\family default
\size default
\color inherit
; 
\family typewriter
\size footnotesize
\color blue
identity[A]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 A
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is a 
\series bold
monoid
\series default
 if there exist functions
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def empty[T]: T
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def combine[T](x: T, y: T): T
\end_layout

\begin_layout Standard
such that the usual algebraic laws hold:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
combine
\family default
\size default
\color inherit
 is associative
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color black
\begin_inset Formula $\forall x:\text{combine}(\text{empty},x)=\text{combine}(x,\text{empty})=x$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
Monoids are an abstraction for any sort of data aggregation
\end_layout

\begin_layout Standard
See example code for implementing the 
\family typewriter
\size footnotesize
\color blue
Monoid
\family default
\size default
\color inherit
 type class:
\end_layout

\begin_layout Itemize
by using a case class as a PTTF (instance from scratch)
\end_layout

\begin_layout Itemize
by assuming 
\family typewriter
\size footnotesize
\color blue
Pointed
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Semigroup
\family default
\size default
\color inherit
 (
\begin_inset Quotes eld
\end_inset

derived
\begin_inset Quotes erd
\end_inset

 instance)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of type classes II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Higher-order PTFs
\end_layout

\begin_layout Itemize
A type constructor 
\begin_inset Formula $F^{A}$
\end_inset

 is a functor if it has a 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 operation
\end_layout

\begin_deeper
\begin_layout Itemize
or, equivalently, 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
that satisfies the functor laws (identity law, composition law)
\end_layout

\end_deeper
\begin_layout Itemize
We would like to write a generic function that tests the functor laws
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def checkFunctorLaws[F[_], A, B, C](): Assertion = ???
\end_layout

\end_deeper
\begin_layout Itemize
Need to get access to the function 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 defined for the given 
\family typewriter
\size footnotesize
\color blue
F
\end_layout

\begin_layout Itemize
We treat 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 as a PTVF whose type domain is all functors 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def map[F[_], A, B](fa: F[A], f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): F[B]
\end_layout

\end_deeper
\begin_layout Itemize
We constrain 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
 to belong to the 
\family typewriter
\size footnotesize
\color blue
Functor
\family default
\size default
\color inherit
 type class
\end_layout

\begin_deeper
\begin_layout Itemize
by adding 
\family typewriter
\size footnotesize
\color blue
implicit ev:
\begin_inset space \space{}
\end_inset

Functor[F]
\family default
\size default
\color inherit
 as extra argument to 
\family typewriter
\size footnotesize
\color blue
map
\end_layout

\begin_deeper
\begin_layout Itemize
note: 
\family typewriter
\size footnotesize
\color blue
Functor
\family default
\size default
\color inherit
 is a 
\emph on
higher-order
\emph default
 PTTF – its type argument is 
\family typewriter
\size footnotesize
\color blue
F[_]
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
See test code for implementation and functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Overview: Types and kinds
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Compare value-to-value functions (VVFs) vs.
\begin_inset space \space{}
\end_inset

type-to-value functions:
\end_layout

\begin_layout Itemize
the 
\series bold
domain
\series default
 of a VVF is the set of admissible argument 
\emph on
values
\end_layout

\begin_deeper
\begin_layout Itemize
a 
\begin_inset Quotes eld
\end_inset

value domain
\begin_inset Quotes erd
\end_inset

 (subset of values) is called a 
\series bold
type
\end_layout

\begin_layout Itemize
the VVF is applied safely only to argument values of the right 
\series bold
type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f(x: Option[Int]) = ...; f(y);
\end_layout

\end_deeper
\begin_layout Itemize
the 
\series bold
type domain
\series default
 of a PTVF is the set of admissible argument 
\emph on
types
\end_layout

\begin_deeper
\begin_layout Itemize
a 
\begin_inset Quotes eld
\end_inset

type domain
\begin_inset Quotes erd
\end_inset

 (subset of types) is called a 
\series bold
kind
\end_layout

\begin_layout Itemize
the PTVF is applied safely only to type arguments of the right 
\series bold
kind
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f[T: MyTypeClass](args...) = ...; f[A](args);
\end_layout

\end_deeper
\begin_layout Itemize
In both cases, the function call's safety is guaranteed 
\emph on
at compile time
\end_layout

\begin_layout Standard
Kinds are the 
\begin_inset Quotes eld
\end_inset

type system for types
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
a type class 
\family typewriter
\size footnotesize
\color blue
MyTypeClass
\family default
\size default
\color inherit
 defines a new kind (as a subset of types)
\end_layout

\begin_deeper
\begin_layout Itemize
suggested 
\series bold
kind
\series default
 notation:
\size footnotesize
 
\begin_inset Formula $(*:\text{MyTypeClass})$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
another existing kind is the 
\series bold
type function
\series default
 kind (notation: 
\begin_inset Formula $*\rightarrow*$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
in 
\family typewriter
\size footnotesize
\color blue
F[T]
\family default
\size default
\color inherit
, the 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
 and the 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 are types of different 
\series bold
kinds
\series default
 (
\begin_inset Formula $*\rightarrow*$
\end_inset

 and 
\begin_inset Formula $*$
\end_inset

 resp.)
\end_layout

\begin_layout Itemize
define 
\family typewriter
\size footnotesize
\color blue
type Ap[F[_], T] = F[T]
\family default
\size default
\color inherit
, then wrong kinds will fail in 
\family typewriter
\size footnotesize
\color blue
Ap[A, B]
\end_layout

\begin_deeper
\begin_layout Itemize
suggested 
\series bold
kind
\series default
 notation:
\size footnotesize
 
\begin_inset Formula $\text{Ap}:(*\rightarrow*,\,*)\rightarrow*$
\end_inset

 
\size default
(
\begin_inset Quotes eld
\end_inset

higher-kinded type
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
See test code
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Scala's 
\begin_inset Quotes eld
\end_inset

implicit method
\begin_inset Quotes erd
\end_inset

 syntax for PTVFs
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Two sorts of available syntax for Scala functions:
\end_layout

\begin_layout Enumerate
as in ordinary math: 
\family typewriter
\size footnotesize
\color blue
func(x, y)
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
func(x, y)(z)
\family default
\size default
\color inherit
 etc.
\end_layout

\begin_layout Enumerate
as 
\begin_inset Quotes eld
\end_inset

method
\begin_inset Quotes erd
\end_inset

: 
\family typewriter
\size footnotesize
\color blue
x.func(y)
\family default
\size default
\color inherit
 or equivalently 
\family typewriter
\size footnotesize
\color blue
x func y
\family default
\size default
\color inherit
 
\begin_inset space \space{}
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
this is similar to 
\family typewriter
\size footnotesize
\color blue
func(x)(y)
\family default
\size default
\color inherit
 but is implemented differently
\end_layout

\end_deeper
\begin_layout Standard
It is often convenient to use functions syntactically as methods:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def +++[T: HasPlusPlusPlus](t: T, arg: ...) = ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val t: T = ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
+++(t, arg) 
\family roman
\color gray
// that's how we have to call this function
\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color gray
// but instead we want to be able to write 
\family default
t +++ arg
\end_layout

\begin_layout Standard
Implementing the 
\begin_inset Quotes eld
\end_inset

implicit method syntax
\begin_inset Quotes erd
\end_inset

 for a PTVF 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
declare 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
 as a method on a new trait or class, say 
\family typewriter
\size footnotesize
\color blue
MyTCSyntax[T]
\end_layout

\begin_layout Itemize
declare an 
\emph on
implicit conversion 
\emph default
function from 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 to 
\family typewriter
\size footnotesize
\color blue
MyTCSyntax[T]
\end_layout

\begin_deeper
\begin_layout Itemize
to make the code shorter, use an 
\family typewriter
\size footnotesize
\color blue
implicit class
\end_layout

\begin_layout Itemize
see example code
\end_layout

\end_deeper
\begin_layout Standard
What we gained:
\end_layout

\begin_layout Itemize
the PTVF appears as a method 
\emph on
only
\emph default
 on values of the relevant types
\end_layout

\begin_layout Itemize
the new syntax is defined automatically on 
\emph on
all
\emph default
 the relevant types 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Define a PTVF 
\family typewriter
\size footnotesize
\color blue
def bitsize[T] = ...

\family default
\size default
\color inherit
 such that 
\family typewriter
\size footnotesize
\color blue
bitsize[Int]
\family default
\size default
\color inherit
 returns 
\begin_inset Formula $32$
\end_inset

 and 
\family typewriter
\size footnotesize
\color blue
bitsize[Long]
\family default
\size default
\color inherit
 returns 
\begin_inset Formula $64$
\end_inset

; otherwise 
\family typewriter
\size footnotesize
\color blue
bitsize[T]
\family default
\size default
\color inherit
 is undefined
\end_layout

\begin_layout Enumerate
Define a monoid instance for the type 
\begin_inset Formula $1+\left(\text{String}\Rightarrow\text{String}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Assuming that 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are monoids, define monoid instance for 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\begin_layout Enumerate
Show: If 
\begin_inset Formula $A$
\end_inset

 is a monoid and 
\begin_inset Formula $B$
\end_inset

 is a semigroup then 
\begin_inset Formula $A+B$
\end_inset

 is a monoid
\end_layout

\begin_layout Enumerate
Define a functor instance for 
\family typewriter
\size footnotesize
\color blue
type F[T] = Seq[Try[T]]
\end_layout

\begin_layout Enumerate
Define a Cats' 
\family typewriter
\size footnotesize
\color blue
Bifunctor
\family default
\size default
\color inherit
 instance for 
\begin_inset Formula $Q^{X,Y}\equiv X+X\times Y$
\end_inset


\end_layout

\begin_layout Enumerate
Define a 
\family typewriter
\size footnotesize
\color blue
ContraFunctor
\family default
\size default
\color inherit
 type class having 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def contrafmap[A, B](f: B 
\begin_inset Formula $\Rightarrow$
\end_inset

 A): C[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 C[B]
\end_layout

\begin_layout Standard
Define a 
\family typewriter
\size footnotesize
\color blue
ContraFunctor
\family default
\size default
\color inherit
 instance for type constructor 
\begin_inset Formula $C^{A}\equiv A\Rightarrow\text{Int}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Define functor instance for recursive type 
\begin_inset Formula $Q^{A}\equiv\left(\text{Int}\Rightarrow A\right)+\text{Int}+Q^{A}$
\end_inset


\end_layout

\begin_layout Enumerate
* If 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are functors, define functor instance for 
\begin_inset Formula $F^{A}+G^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Define a PTVF 
\family typewriter
\size footnotesize
\color blue
def isLong[T]:
\begin_inset space \space{}
\end_inset

Boolean
\family default
\size default
\color inherit
 that returns 
\family typewriter
\size footnotesize
\color blue
true
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
Long
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Double
\family default
\size default
\color inherit
; returns 
\family typewriter
\size footnotesize
\color blue
false
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Short
\family default
\size default
\color inherit
, and 
\family typewriter
\size footnotesize
\color blue
Float
\family default
\size default
\color inherit
; otherwise undefined
\end_layout

\begin_layout Enumerate
Define a monoid instance for the type 
\begin_inset Formula $\text{String}\times(1+\text{Int})$
\end_inset


\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $A$
\end_inset

 is a monoid and 
\begin_inset Formula $R$
\end_inset

 any type, define monoid instance for 
\begin_inset Formula $R\Rightarrow A$
\end_inset


\end_layout

\begin_layout Enumerate
Show: If 
\family typewriter
\size footnotesize
\color blue
S
\family default
\size default
\color inherit
 is a semigroup then 
\family typewriter
\size footnotesize
\color blue
Option[S]
\family default
\size default
\color inherit
 is a monoid
\end_layout

\begin_layout Enumerate
Define a functor instance for 
\family typewriter
\size footnotesize
\color blue
type F[T] = Future[Seq[T]]
\end_layout

\begin_layout Enumerate
Define a Cats' 
\family typewriter
\size footnotesize
\color blue
Bifunctor
\family default
\size default
\color inherit
 instance for 
\begin_inset Formula $B^{X,Y}\equiv\left(\text{Int}\Rightarrow X\right)+Y\times Y$
\end_inset


\end_layout

\begin_layout Enumerate
Define a 
\family typewriter
\size footnotesize
\color blue
ProFunctor
\family default
\size default
\color inherit
 type class having 
\family typewriter
\size footnotesize
\color blue
dimap
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def dimap[A, B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B, g: B 
\begin_inset Formula $\Rightarrow$
\end_inset

 A): F[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[B]
\end_layout

\begin_layout Standard
Define a 
\family typewriter
\size footnotesize
\color blue
ProFunctor
\family default
\size default
\color inherit
 instance for 
\begin_inset Formula $P^{A}\equiv A\Rightarrow\left(\text{Int}\times A\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Define a functor instance for recursive type 
\begin_inset Formula $Q^{A}\equiv\text{String}+A\times Q^{A}$
\end_inset


\end_layout

\begin_layout Enumerate
* If 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are functors, define functor instance for 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

 
\end_layout

\begin_layout Enumerate
* Define a functor instance for 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 where 
\begin_inset Formula $F^{A}$
\end_inset

 is a contrafunctor (use Cats' 
\family typewriter
\size footnotesize
\color blue
Contravariant
\family default
\size default
\color inherit
 type class for 
\begin_inset Formula $F^{A}$
\end_inset

) and 
\begin_inset Formula $G^{A}$
\end_inset

 is a functor
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Further directions
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
What problems can we solve now?
\end_layout

\begin_deeper
\begin_layout Itemize
Define arbitrary PTTFs and use them to define type classes (PTVFs) 
\end_layout

\begin_layout Itemize
Define them together or separately, combine them at will
\end_layout

\begin_layout Itemize
Use the Cats library to define instances for standard type classes
\end_layout

\begin_layout Itemize
Derive type class instances automatically from previous ones
\end_layout

\begin_layout Itemize
Reason about higher-order type functions, types, and kinds as necessary
\end_layout

\end_deeper
\begin_layout Itemize
What problems cannot be solved with these tools?
\end_layout

\begin_deeper
\begin_layout Itemize
Automatically derive type class instances for polynomial data types
\end_layout

\begin_deeper
\begin_layout Itemize
see 
\begin_inset CommandInset href
LatexCommand href
name "The guide to ``shapeless''"
target "https://github.com/underscoreio/shapeless-guide"

\end_inset

, chapter 3
\end_layout

\end_deeper
\begin_layout Itemize
Derive a recursive type generically from an arbitrary type function
\end_layout

\begin_deeper
\begin_layout Itemize
Given a type function 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
, define a recursive type 
\family typewriter
\size footnotesize
\color blue
R
\family default
\size default
\color inherit
 via 
\family typewriter
\size footnotesize
\color blue
R = F[R]
\end_layout

\begin_layout Itemize
This 
\family typewriter
\size footnotesize
\color blue
R
\family default
\size default
\color inherit
 will be a function of 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
; denote that type function by 
\family typewriter
\size footnotesize
\color blue
Y[F[_]]
\end_layout

\begin_layout Itemize
This 
\family typewriter
\size footnotesize
\color blue
Y
\family default
\size default
\color inherit
 must be defined by a type equation like this,
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type Y[F[_]] = F[Y[F]]
\family roman
\color gray
 // does not compile (
\begin_inset Quotes eld
\end_inset

cyclic type
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Automatically derive type class instances for such recursive types
\end_layout

\begin_deeper
\begin_layout Itemize
That requires type-level recursion (type-level fixpoints), see 
\begin_inset CommandInset href
LatexCommand href
name "matryoshka"
target "https://github.com/slamdata/matryoshka"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
This and other advanced topics are found in 
\begin_inset CommandInset href
LatexCommand href
name "this blog post from 2010"
target "https://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/"

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
