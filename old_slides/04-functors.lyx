#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 4: Functors]{Chapter 4: Functors}
\subtitle{Their laws and structure}
\author{Sergei Winitzki}
\date{December 28, 2017}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Container-like
\begin_inset Quotes erd
\end_inset

 type constructors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Visualize 
\family typewriter
\size footnotesize
\color blue
Seq[T]
\family default
\size default
\color inherit
 as a container with some items of type 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_deeper
\begin_layout Itemize
How to formalize this idea as a property of 
\family typewriter
\size footnotesize
\color blue
Seq
\family default
\size default
\color inherit
?
\end_layout

\end_deeper
\begin_layout Itemize
Another example of a container: 
\family typewriter
\size footnotesize
\color blue
Future[T]
\end_layout

\begin_deeper
\begin_layout Itemize
a value of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 will be available later, or may fail to arrive
\end_layout

\end_deeper
\begin_layout Standard
Let us separate the 
\begin_inset Quotes eld
\end_inset

bare container
\begin_inset Quotes erd
\end_inset

 functionality from other functionality
\end_layout

\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

bare container
\begin_inset Quotes erd
\end_inset

 will allow us to:
\end_layout

\begin_deeper
\begin_layout Itemize
manipulate items held within the container
\end_layout

\begin_deeper
\begin_layout Itemize
In FP, to 
\begin_inset Quotes eld
\end_inset

manipulate items
\begin_inset Quotes erd
\end_inset

 means to 
\emph on
apply functions to values
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Container holds items
\begin_inset Quotes erd
\end_inset

 = we can apply a function to the items
\end_layout

\begin_deeper
\begin_layout Itemize
but the new items 
\emph on
remain
\emph default
 within the same container!
\end_layout

\begin_layout Itemize
need 
\family typewriter
\size footnotesize
\color blue
map[A,B]:
\begin_inset space \space{}
\end_inset

Container[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Container[B]
\end_layout

\end_deeper
\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

bare container
\begin_inset Quotes erd
\end_inset

 will 
\emph on
not
\emph default
 allow us to:
\end_layout

\begin_deeper
\begin_layout Itemize
make a new container out of a given set of items
\end_layout

\begin_layout Itemize
read values out of the container
\end_layout

\begin_layout Itemize
add more items into container, or delete items from container
\end_layout

\begin_layout Itemize
wait and get notified when new items become available in container
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout

\family typewriter
Option[T]
\family default
 as a container I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In the short notation: 
\begin_inset Formula $\text{Option}^{A}=1+A$
\end_inset


\end_layout

\begin_layout Itemize
The 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 function is required to have the type
\begin_inset Formula 
\[
\text{map}^{A,B}:1+A\Rightarrow\left(A\Rightarrow B\right)\Rightarrow1+B
\]

\end_inset


\end_layout

\begin_layout Itemize
This function produces a new 
\begin_inset Formula $\text{Option}^{B}$
\end_inset

 value, possibly containing transformed data
\end_layout

\begin_layout Standard
Main questions:
\end_layout

\begin_layout Enumerate
How to avoid 
\begin_inset Quotes eld
\end_inset

information loss
\begin_inset Quotes erd
\end_inset

 in this function?
\end_layout

\begin_layout Enumerate
Does this 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 allow us to 
\begin_inset Quotes eld
\end_inset

manipulate values within the container
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout

\family typewriter
Option[T]
\family default
 as a container II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Avoiding 
\begin_inset Quotes eld
\end_inset

information loss
\begin_inset Quotes erd
\end_inset

 means:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
map[A,A](opt)(x
\begin_inset Formula $\Rightarrow$
\end_inset

x) == opt
\family default
\size default
\color inherit
 â€“ 
\begin_inset Quotes eld
\end_inset


\series bold
identity law
\series default

\begin_inset Quotes erd
\end_inset

 for 
\family typewriter
\size footnotesize
\color blue
map
\end_layout

\begin_layout Itemize
Actually, we have two implementations of the type: 
\begin_inset Formula 
\[
\text{map}^{[A,B]}=(1+a^{A})\Rightarrow(f^{A\Rightarrow B})\Rightarrow1+f(a)
\]

\end_inset

and
\begin_inset Formula 
\[
\text{map}^{[A,B]}=(1+a^{A})\Rightarrow(f^{A\Rightarrow B})\Rightarrow1+0^{B}
\]

\end_inset

The second implementation has 
\begin_inset Quotes eld
\end_inset

information loss
\begin_inset Quotes erd
\end_inset

!
\end_layout

\begin_layout Itemize
Short notation for code (type annotations are optional):
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Short notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Scala code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
val a: A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f^{[A]\,B\Rightarrow C}=...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def f[A]: B 
\begin_inset Formula $\Rightarrow$
\end_inset

 C = {...}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(a^{A}+b^{B})\Rightarrow...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
x: Either[A, B] match {...}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a^{A}+0^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Left(a):
\begin_inset space \space{}
\end_inset

Either[A, B]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
()
\family default
\size default
\color inherit
, also 
\family typewriter
\size footnotesize
\color blue
None
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout

\family typewriter
Option[T]
\family default
 as a container III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
What it means to 
\begin_inset Quotes eld
\end_inset

be able to manipulate values in a container
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Flip the two curried arguments in the type signature of 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}^{[A,B]}:\left(A\Rightarrow B\right)\Rightarrow\text{Option}^{A}\Rightarrow\text{Option}^{B}
\]

\end_inset


\end_layout

\begin_layout Itemize
A function 
\begin_inset Formula $f$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset


\series bold
lifted
\series default

\begin_inset Quotes erd
\end_inset

 from 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 to 
\begin_inset Formula $\text{Option}^{A}\Rightarrow\text{Option}^{B}$
\end_inset

 by 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}(f^{A\Rightarrow B}):\text{Option}^{A}\Rightarrow\text{Option}^{B}
\]

\end_inset


\end_layout

\begin_layout Itemize
Being able to manipulate values means that functions 
\emph on
behave normally when lifted
\emph default
, i.e.
\begin_inset space \space{}
\end_inset

when applied within the container
\end_layout

\begin_layout Itemize
The standard properties of function composition are
\size footnotesize

\begin_inset Formula 
\begin{align*}
f^{A\Rightarrow B}\circ id^{B\Rightarrow B} & =f^{A\Rightarrow B}\\
id^{A\Rightarrow A}\circ f^{A\Rightarrow B} & =f^{A\Rightarrow B}\\
f^{A\Rightarrow B}\circ(g^{B\Rightarrow C}\circ h^{C\Rightarrow D}) & =(f^{A\Rightarrow B}\circ g^{B\Rightarrow C})\circ h^{C\Rightarrow D}
\end{align*}

\end_inset


\size default
and should hold for the 
\begin_inset Quotes eld
\end_inset

lifted
\begin_inset Quotes erd
\end_inset

 functions as well!
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

identity law
\begin_inset Quotes erd
\end_inset

 already requires that 
\size footnotesize

\begin_inset Formula $\text{fmap}(\text{id}^{A\Rightarrow A})=\text{id}^{\text{Option}^{A}\Rightarrow\text{Option}^{A}}$
\end_inset


\end_layout

\begin_layout Itemize
It remains to require that 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 should preserve function composition:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}(f^{A\Rightarrow B}\circ g^{B\Rightarrow C})=\text{fmap}(f^{A\Rightarrow B})\circ\text{fmap}(g^{B\Rightarrow C})
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Functor: the definition
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
An abstraction for the functionality of a 
\begin_inset Quotes eld
\end_inset

bare container
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
A 
\series bold
functor
\series default
 is:
\end_layout

\begin_layout Itemize
a data type having a type parameter, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
MyData[T]
\end_layout

\begin_layout Itemize
such that a function 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 or, equivalently, 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 is available:
\size footnotesize

\begin_inset Formula 
\begin{align*}
\text{map}^{[A,B]}:\  & \text{MyData}^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{MyData}^{B}\\
\text{fmap}^{[A,B]}: & \left(A\Rightarrow B\right)\Rightarrow\text{MyData}^{A}\Rightarrow\text{MyData}^{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
such that the identity law and the composition law hold
\end_layout

\begin_deeper
\begin_layout Itemize
The laws are easier to formulate in terms of 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
:
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula 
\begin{align*}
\text{fmap}^{A,A}\,(\text{id}^{A\Rightarrow A}) & =\text{id}^{F^{A}\Rightarrow F^{A}}\\
\text{fmap}(f^{A\Rightarrow B}\circ g^{B\Rightarrow C}) & =\text{fmap}(f^{A\Rightarrow B})\circ\text{fmap}(g^{B\Rightarrow C})
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Verify the laws for 
\family typewriter
\size footnotesize
\color blue
Option[A]
\family default
\size default
\color inherit
: see test code
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def fmap[A,B](f: (A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B)): Option[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 Option[B] = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Some(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Some(f(x))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case None 
\begin_inset Formula $\Rightarrow$
\end_inset

 None
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of functors I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
(Almost) everything that has a 
\begin_inset Quotes eld
\end_inset


\family typewriter
map
\family default

\begin_inset Quotes erd
\end_inset

 is a functor
\end_layout

\begin_layout Itemize
Specific functors will have methods for creating them, reading values out
 of them, adding / removing items, waiting for items to arrive, etc.
\end_layout

\begin_deeper
\begin_layout Itemize
Common to all functors is the 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 function
\end_layout

\begin_layout Itemize
Right now we are only concerned about the properties of 
\family typewriter
\size footnotesize
\color blue
map
\end_layout

\end_deeper
\begin_layout Standard
Examples of functors in the Scala standard library:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Option[T]
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Either[L, R]
\family default
\size default
\color inherit
 with respect to 
\family typewriter
\size footnotesize
\color blue
R
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Seq[T]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Iterator[T] 
\end_layout

\begin_layout Itemize
various subtypes of 
\family typewriter
\size footnotesize
\color blue
Seq
\family default
\size default
\color inherit
 (
\family typewriter
\size footnotesize
\color blue
Range
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
List
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Vector
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
IndexedSeq
\family default
\size default
\color inherit
, etc.)
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Future[T]
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Try[T]
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Map[K, V]
\family default
\size default
\color inherit
 with respect to 
\family typewriter
\size footnotesize
\color blue
V
\family default
\size default
\color inherit
 (using 
\family typewriter
\size footnotesize
\color blue
mapValues
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Standard
Examples of 
\emph on
not-really-functors
\emph default
 that have a 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Set[T]
\family default
\size default
\color inherit
 â€“ it works only when 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 has a well-behaved 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
==
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 operation
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Map[K, V]
\family default
\size default
\color inherit
 with respect to both 
\family typewriter
\size footnotesize
\color blue
K
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
V
\family default
\size default
\color inherit
, because it is a 
\family typewriter
\size footnotesize
\color blue
Set
\family default
\size default
\color inherit
 w.r.t.
 
\family typewriter
\size footnotesize
\color blue
K
\end_layout

\begin_layout Itemize
See test code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of functors II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Polynomial type constructors as functors
\end_layout

\begin_layout Enumerate
Short notation: 
\begin_inset Formula $\text{QueryResult}^{A}=\text{String}\times\text{Int}\times A$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class QueryResult[A](name: String, time: Int, data: A)
\end_layout

\end_deeper
\begin_layout Enumerate
Short notation: 
\begin_inset Formula $\text{Vec3}^{A}=A\times A\times A$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Vec3[A](x: A, y: A, z: A)
\end_layout

\end_deeper
\begin_layout Enumerate
Short notation: 
\begin_inset Formula $\text{QueryResult}^{A}=\text{String}+\text{String}\times\text{Int}\times A$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait QueryResult[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Error[A](message: String) extends QueryResult[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Success[A](name: String, time: Int, data: A) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
                     extends QueryResult[A]
\end_layout

\end_deeper
\begin_layout Standard
See test code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of functors III: non-functors I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Data types that cannot have 
\begin_inset Quotes eld
\end_inset


\family typewriter
map
\family default

\begin_inset Quotes erd
\end_inset

 at all, due to type problems
\end_layout

\begin_layout Enumerate
Data types that 
\emph on
consume
\emph default
 a value of the parameter type
\begin_inset Formula 
\[
\text{NotContainer}^{A}=\left(A\Rightarrow\text{Int}\right)\times A
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class NotContainer[A](x: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int, y: A)
\end_layout

\end_deeper
\begin_layout Enumerate
Disjunction types with non-parametric type values
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait ServerAction[Res]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class GetResult[Res](r: Long 
\begin_inset Formula $\Rightarrow$
\end_inset

 Res) extends ServerAction[Res]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class StoreId(x: Long, y: String) extends ServerAction[Long]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class StoreName(name: String) extends ServerAction[String]
\end_layout

\begin_layout Itemize
The type 
\family typewriter
\size footnotesize
\color blue
ServerAction[Res]
\family default
\size default
\color inherit
 is called a GADT (
\begin_inset Quotes eld
\end_inset

generalized algebraic data type
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
Not sure what the short notation should be for GADTs!
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of functors III: non-functors II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
These 
\emph on
could
\emph default
 be functors, except for incorrect implementations of 
\begin_inset Quotes eld
\end_inset


\family typewriter
map
\family default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
We need a well-behaved 
\begin_inset Formula $\text{fmap}\,(f^{A\Rightarrow B}):\text{Container}^{A}\Rightarrow\text{Container}^{B}$
\end_inset


\end_layout

\begin_layout Standard
What could go wrong?
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
fmap(f)
\family default
\size default
\color inherit
 ignores 
\family typewriter
\size footnotesize
\color blue
f
\family default
\size default
\color inherit
 â€“ e.g.
\begin_inset space \space{}
\end_inset

always returns 
\family typewriter
\size footnotesize
\color blue
None
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
Option[B]
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
fmap(f)
\family default
\size default
\color inherit
 reorders data items in a container: 
\begin_inset Formula 
\[
\text{Container}^{A}\equiv A\times A;\qquad\text{fmap}^{A,B}\,(f^{A\Rightarrow B})({\color{blue}x}^{A},{\color{blue}y}^{A})=\left(f({\color{blue}y}),f({\color{blue}x})\right)
\]

\end_inset

e.g.
\begin_inset space \space{}
\end_inset

swaps some elements in 
\begin_inset Formula $A\times A\times A$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def fmap[A, B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): Vec3[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 Vec3[B] =
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  { case Vec3(x, y, z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Vec3(f(y), f(x), f(z)) }
\end_layout

\end_deeper
\begin_layout Itemize
Does a special computation if types are equal: if 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
B
\family default
\size default
\color inherit
 are the same type, do 
\family typewriter
\size footnotesize
\color blue
fmap[A, A](f) = identity
\family default
\size default
\color inherit
, otherwise 
\begin_inset Formula $f(x)$
\end_inset

 is applied
\end_layout

\begin_layout Itemize
Does a special computation if type is equal to a specific type, e.g.
\begin_inset space \space{}
\end_inset

if 
\family typewriter
\size footnotesize
\color blue
A = B = Int
\family default
\size default
\color inherit
 then do 
\begin_inset Formula $f(f(x))$
\end_inset

 else 
\begin_inset Formula $f(x)$
\end_inset


\end_layout

\begin_layout Itemize
Does a special computation if 
\begin_inset Formula $f$
\end_inset

 is equal to some 
\begin_inset Formula $f_{0}$
\end_inset

, otherwise use 
\begin_inset Formula $f(x)$
\end_inset


\end_layout

\begin_layout Standard
See test code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Recursive polynomial types as functors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Example: List of even length is a recursive type,
\begin_inset Formula 
\begin{align*}
LP^{A} & \equiv1+A\times A\times LP^{A}\\
 & =1+A\times A+A\times A\times A\times A+...
\end{align*}

\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait LP[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class LPempty[A]() extends LP[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class LPpair[A](x: A, y: A, tail: LP[A]) extends LP[A]
\end_layout

\begin_layout Itemize
We can implement 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 as a recursive function:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def fmap[A, B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): LP[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 LP[B] = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case LPempty() 
\begin_inset Formula $\Rightarrow$
\end_inset

 LPempty[B]()
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case LPpair(x, y, tail) 
\begin_inset Formula $\Rightarrow$
\end_inset

 LPpair[B](f(x), f(y), fmap(f)(tail))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
This is the only way to implement 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 that satisfies the functor laws!
\end_layout

\begin_layout Standard
See test code for checking the functor laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Contrafunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The type  
\begin_inset Formula $C^{A}\equiv A\Rightarrow\text{Int}$
\end_inset

 is not a functor (impossible to implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
), but we can implement 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
:
\begin_inset Formula 
\[
\text{contrafmap}^{A,B}:\left({\color{blue}B\Rightarrow A}\right)\Rightarrow C^{A}\Rightarrow C^{B}
\]

\end_inset


\end_layout

\begin_layout Itemize
The contrafunctor laws are analogous to functor laws:
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula 
\begin{align*}
\text{contrafmap}^{A,A}(\text{id}^{A\Rightarrow A}) & =\text{id}^{C^{A}\Rightarrow C^{A}}\\
\text{contrafmap}\left(g\circ f\right) & =\text{contrafmap}\left(f\right)\circ\text{contrafmap}\left(g\right)
\end{align*}

\end_inset


\family default
\size default
\color inherit
The 
\begin_inset Quotes eld
\end_inset

contra-
\begin_inset Quotes erd
\end_inset

 reverses the arrow between 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Itemize
The type parameter 
\begin_inset Formula $A$
\end_inset

 is to the left of the function arrow (
\begin_inset Quotes eld
\end_inset

consumed
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Functors contain data; contrafunctors consume data
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Example of non-contrafunctor:
\end_layout

\begin_layout Itemize
The type 
\begin_inset Formula $\text{NotContainer}^{A}=\left(A\Rightarrow\text{Int}\right)\times A$
\end_inset

 is neither a functor nor a contrafunctor
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Covariance, contravariance, and subtyping
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Example of subtyping:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait AtMostTwo
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Zero() extends AtMostTwo
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class One(x: Int) extends AtMostTwo
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Two(x: Int, y: Int) extends AtMostTwo
\end_layout

\begin_layout Itemize
Here 
\family typewriter
\size footnotesize
\color blue
Zero
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
One
\family default
\size default
\color inherit
, and 
\family typewriter
\size footnotesize
\color blue
Two
\family default
\size default
\color inherit
 are 
\series bold
subtypes
\series default
 of 
\family typewriter
\size footnotesize
\color blue
AtMostTwo
\end_layout

\end_deeper
\begin_layout Itemize
We can pass 
\family typewriter
\size footnotesize
\color blue
Two(10, 20)
\family default
\size default
\color inherit
 to a function that takes an 
\family typewriter
\size footnotesize
\color blue
AtMostTwo
\end_layout

\begin_layout Itemize
This is equivalent to an automatic type conversion 
\family typewriter
\size footnotesize
\color blue
Two 
\begin_inset Formula $\Rightarrow$
\end_inset

 AtMostTwo
\end_layout

\begin_layout Itemize
A container 
\family typewriter
\size footnotesize
\color blue
C[A]
\family default
\size default
\color inherit
 is 
\series bold
covariant
\series default
 if 
\family typewriter
\size footnotesize
\color blue
C[Two]
\family default
\size default
\color inherit
 is a subtype of 
\family typewriter
\size footnotesize
\color blue
C[AtMostTwo]
\end_layout

\begin_deeper
\begin_layout Itemize
And then a type conversion function
\family typewriter
\size footnotesize
\color blue
 C[Two] 
\begin_inset Formula $\Rightarrow$
\end_inset

 C[AtMostTwo]
\family default
\size default
\color inherit
 exists
\end_layout

\end_deeper
\begin_layout Itemize
More generally, when 
\family typewriter
\size footnotesize
\color blue
X
\family default
\size default
\color inherit
 is a subtype of 
\family typewriter
\size footnotesize
\color blue
Y
\family default
\size default
\color inherit
 then we have 
\family typewriter
\size footnotesize
\color blue
X 
\begin_inset Formula $\Rightarrow$
\end_inset

 Y
\family default
\size default
\color inherit
 and we need 
\family typewriter
\size footnotesize
\color blue
C[X] 
\begin_inset Formula $\Rightarrow$
\end_inset

 C[Y]
\family default
\size default
\color inherit
, which is guaranteed if we have a function of type
\begin_inset Formula 
\[
\left(X\Rightarrow Y\right)\Rightarrow(C^{X}\Rightarrow C^{Y})
\]

\end_inset


\end_layout

\begin_layout Itemize
Scala supports covariance annotations on types: 
\family typewriter
\size footnotesize
\color blue
sealed trait C[+T]
\end_layout

\begin_layout Standard
Functors are covariant, contrafunctors are contravariant
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Decide if a data type is a functor, a contrafunctor, or neither
\end_layout

\begin_layout Itemize
Implement a 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 or a 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
 function that satisfies the laws
\end_layout

\begin_layout Enumerate
Define case classes for these types, and implement 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A}\equiv\text{String}+A\times\text{Int}+A\times A\times A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A}\equiv1+A\times(\text{Int}\times\text{String}+A)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A}\equiv\left(\text{String}\Rightarrow\text{Int}\Rightarrow A\right)\times A+\left(\text{Boolean}\Rightarrow\text{Double}\Rightarrow A\right)\times A$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Decide which of these types are functors or contrafunctors, and implement
 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
 respectively:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A}\equiv\left(A\Rightarrow\text{Int}\right)+\left(A\Rightarrow A\Rightarrow\text{String}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A,B}\equiv\left(A+B\right)\times\left(\left(A\Rightarrow\text{Int}\right)\Rightarrow B\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Rewrite this code in the short notation; identify covariant and contravariant
 type usages; verify that with covariance annotations:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Coi[A, B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Pa[A, B](b: (A, B), c: B
\begin_inset Formula $\Rightarrow$
\end_inset

Int)  extends Coi[A, B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Re[A, B](d: A, e: B, c: Int)    extends Coi[A, B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Ci[A, B](f: String
\begin_inset Formula $\Rightarrow$
\end_inset

A, g: B
\begin_inset Formula $\Rightarrow$
\end_inset

A) extends Coi[A, B]
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Define case classes for these types, decide if they are covariant or contravaria
nt, and implement 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
 as needed:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A}\equiv\left(1+A\right)\times\left(1+A\right)\times\text{String}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A}\equiv\left(A\Rightarrow\text{String}\right)\Rightarrow\left(A\times\left(\text{Int}+A\right)\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A,B}\equiv\left(A\Rightarrow\text{String}\right)\times\left(\left(A+B\right)\Rightarrow\text{Int}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{A}\equiv\left(1+\left(A\Rightarrow\text{String}\right)\right)\Rightarrow\left(1+\left(A\Rightarrow\text{Int}\right)\right)\Rightarrow\text{Int}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{Data}^{B}\equiv\left(B+\left(\text{Int}\Rightarrow B\right)\right)\times\left(B+\left(\text{String}\Rightarrow B\right)\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Rewrite this code in the short notation; identify covariant and contravariant
 type usages; verify that with covariance annotations:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Result[A,B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class P[A,B](a: A, b: B, c: Int)   extends Result[A,B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Q[A,B](d: Int
\begin_inset Formula $\Rightarrow$
\end_inset

A, e: Int
\begin_inset Formula $\Rightarrow$
\end_inset

B) extends Result[A,B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class R[A,B](f: A
\begin_inset Formula $\Rightarrow$
\end_inset

A, g: A
\begin_inset Formula $\Rightarrow$
\end_inset

B)     extends Result[A,B]
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The structure of functor types I
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
How to build new functors out of old ones
\end_layout

\begin_layout Standard
Main question:
\end_layout

\begin_layout Itemize
Is any data type 
\begin_inset Formula $Z^{A}$
\end_inset

 with 
\begin_inset Formula $A$
\end_inset

 in covariant positions always a functor? 
\size footnotesize

\begin_inset Formula 
\[
Z^{A,R}\equiv\left(\left(A\Rightarrow R\right)\Rightarrow R\right)\times A+\left(R\Rightarrow A+\text{Int}\right)+A\times A\times\text{Int}\times\text{Int}
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Elementary
\begin_inset Quotes erd
\end_inset

 data types are built from parts:
\end_layout

\begin_deeper
\begin_layout Itemize
Constant types 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $\text{Int}$
\end_inset

, 
\begin_inset Formula $\text{String}$
\end_inset

, etc.
\end_layout

\begin_layout Itemize
Type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

, etc.
\end_layout

\begin_layout Itemize
Previously defined type constructors 
\begin_inset Formula $F^{A}$
\end_inset

, 
\begin_inset Formula $G^{A}$
\end_inset

, etc.
\end_layout

\begin_layout Itemize
Four operations: 
\begin_inset Formula $F^{A}+G^{A}$
\end_inset

,
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

,
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

,
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $F^{G^{A}}$
\end_inset

 (composition)
\end_layout

\begin_layout Itemize
Each time a type 
\begin_inset Formula $A$
\end_inset

 is moved to the left of 
\begin_inset Formula $\Rightarrow$
\end_inset

, its covariance is reversed
\end_layout

\begin_deeper
\begin_layout Itemize
So 
\begin_inset Formula $A\Rightarrow Z$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

, but 
\begin_inset Formula $\left(A\Rightarrow Z\right)\Rightarrow Z$
\end_inset

 is again covariant
\end_layout

\end_deeper
\begin_layout Itemize
If we exclude the operation 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

, the result is always covariant
\end_layout

\begin_deeper
\begin_layout Itemize
This yields polynomial type constructors = 
\series bold
polynomial functors
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
To answer the question:
\end_layout

\begin_layout Itemize
Build 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 incrementally as we build up the type expression
\end_layout

\begin_layout Itemize
Verify that the laws hold at every step
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The structure of functor types II
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
The building blocks
\end_layout

\begin_layout Itemize
Building blocks: creating functors from scratch
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Constant
\series default
 functors 
\begin_inset Formula $\text{Const}^{C,A}\equiv C$
\end_inset

 with 
\begin_inset Formula $\text{fmap}(f)=id$
\end_inset

, and are at the same time contrafunctors with 
\begin_inset Formula $\text{contrafmap}(f)=id$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Identity
\series default
 functor 
\begin_inset Formula $\text{Id}^{A}=A$
\end_inset

 with 
\begin_inset Formula $\text{fmap}(f)=f$
\end_inset

 (not a contrafunctor!)
\end_layout

\end_deeper
\begin_layout Itemize
Operations: creating new functors out of previous ones
\end_layout

\begin_deeper
\begin_layout Itemize
In each case, we already have the 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 implementations for 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

, and we assume that their functor laws were already checked 
\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}+G^{A}$
\end_inset

 â€“ 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 is built by pattern-matching and preserving the sides
\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

 â€“ 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 is built by tupling the two 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 results, in order
\end_layout

\begin_layout Itemize
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 â€“ 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 is built by substituting the function argument
\end_layout

\begin_deeper
\begin_layout Itemize
Here 
\begin_inset Formula $F^{A}$
\end_inset

 must be a contrafunctor and 
\begin_inset Formula $G^{A}$
\end_inset

 must be a functor
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $F^{G^{A}}$
\end_inset

 (
\family typewriter
\size footnotesize
\color blue
F[G[A]]
\family default
\size default
\color inherit
 in code) â€“ 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 is built by composing the two 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
s
\end_layout

\begin_layout Itemize
Type recursion: 
\begin_inset Formula $F^{A}=R^{A,F^{A}}$
\end_inset

, where 
\begin_inset Formula $R^{A,X}$
\end_inset

 is a functor in 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $X$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 for 
\begin_inset Formula $F^{A}$
\end_inset

 is recursive, uses the two 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
s of 
\begin_inset Formula $R^{A,X}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Similar constructions hold for contrafunctors, 
\emph on
mutatis mutandis
\end_layout

\begin_layout Standard
Will now check that the functor laws still hold after each operation
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples II: Checking the functor laws
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
To check that the 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}+G^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Itemize
From 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

, get 
\begin_inset Formula $\text{fmap}_{F}(f):F^{A}\Rightarrow F^{B}$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{G}(f):G^{A}\Rightarrow G^{B}$
\end_inset


\end_layout

\begin_layout Itemize
Define 
\begin_inset Formula $\text{fmap}_{F+G}(f)=(p^{F^{A}}+q^{G^{A}})\Rightarrow\text{fmap}_{F}(f)(p)+\text{fmap}_{G}(f)(q)$
\end_inset


\end_layout

\begin_layout Itemize
Identity law: 
\begin_inset Formula $f=id$
\end_inset

, so 
\begin_inset Formula $\text{fmap}_{F}(f)=id$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{G}(f)=id$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Hence we get 
\begin_inset Formula $\text{fmap}_{F+G}(id)(p+q)=id(p)+id(q)=p+q$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Composition law: 
\begin_inset Formula 
\begin{align*}
 & (\text{fmap}_{F+G}(f_{1})\circ\text{fmap}_{F+G}(f_{2}))(p+q)\\
=\  & \text{fmap}_{F+G}(f_{2})\left(\text{fmap}_{F}(f_{1})(p)+\text{fmap}_{G}(f_{1})(q)\right)\\
=\  & (\text{fmap}_{F}(f_{1})\circ\text{fmap}_{F}(f_{2}))(p)+\left(\text{fmap}_{G}(f_{1})\circ\text{fmap}_{G}(f_{2})\right)(q)\\
=\  & \text{fmap}_{F}(f_{1}\circ f_{2})(p)+\text{fmap}_{G}(f_{1}\circ f_{2})(q)\\
=\  & \text{fmap}_{F+G}(f_{1}\circ f_{2})(p+q)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Note how 
\begin_inset Formula $\text{fmap}_{F+G}(f)$
\end_inset

 works on each side of 
\begin_inset Formula $\left(p+q\right)$
\end_inset

 separately
\end_layout

\begin_layout Itemize
The laws would not hold if we mixed up some parts of 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples III: Checking the functor laws
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
To show that 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 is a functor, assuming that 
\begin_inset Formula $F^{A}$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $G^{A}$
\end_inset

 is a functor
\end_layout

\begin_layout Itemize
For a given 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

, denote for brevity 
\begin_inset Formula $\gamma_{f}=\text{fmap}_{G}(f):G^{A}\Rightarrow G^{B}$
\end_inset

 and 
\begin_inset Formula $\phi_{f}=\text{contrafmap}_{F}(f):F^{B}\Rightarrow F^{A}$
\end_inset

 , then define 
\begin_inset Formula $\text{fmap}_{F\Rightarrow G}(f)(p:F^{A}\Rightarrow G^{A}):\left(F^{B}\Rightarrow G^{B}\right)=q\Rightarrow\gamma_{f}(p(\phi_{f}(q)))$
\end_inset


\end_layout

\begin_layout Itemize
Identity law: 
\begin_inset Formula $f=id$
\end_inset

, so 
\begin_inset Formula $\gamma_{f}=id$
\end_inset

 and 
\begin_inset Formula $\phi_{f}=id$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Hence we get 
\begin_inset Formula $\text{fmap}_{F\Rightarrow G}(id)(p^{F^{A}\Rightarrow G^{A}})=\left(q^{F^{A}}\Rightarrow p(q)\right)=p$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Composition law, assuming 
\begin_inset Formula $\gamma_{f_{1}}\circ\gamma_{f_{2}}=\gamma_{f_{1}\circ f_{2}}$
\end_inset

 and 
\begin_inset Formula $\phi_{f_{2}}\circ\phi_{f_{1}}=\phi_{f_{1}\circ f_{2}}$
\end_inset

: 
\begin_inset Formula 
\begin{align*}
 & (\text{fmap}_{F\Rightarrow G}(f_{1})\circ\text{fmap}_{F\Rightarrow G}(f_{2}))(p^{F^{A}\Rightarrow G^{A}})\\
=\  & \text{fmap}_{F\Rightarrow G}(f_{2})\left(q\Rightarrow\gamma_{f_{1}}(p(\phi_{f_{1}}(q)))\right)\\
=\  & q\Rightarrow\gamma_{f_{2}}(\gamma_{f_{1}}(p(\phi_{f_{1}}(\phi_{f_{2}}(q)))))\\
=\  & q\Rightarrow\gamma_{f_{1}\circ f_{2}}(p(\phi_{f_{1}\circ f_{2}}(q)))\\
=\  & \text{fmap}_{F\Rightarrow G}(f_{1}\circ f_{2})(p)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
The order is reversed for 
\begin_inset Formula $\phi$
\end_inset

, so this wouldn't work if 
\begin_inset Formula $F$
\end_inset

 were a functor
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises II
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Check that the 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 laws hold for 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

 if they hold for 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset


\end_layout

\begin_layout Enumerate
Show that 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 is, in general, neither a functor nor a contrafunctor when both 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are functors or both are contrafunctors (an example of suitable 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 will be sufficient)
\end_layout

\begin_layout Enumerate
Show that 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 is a contrafunctor if 
\begin_inset Formula $F^{A}$
\end_inset

 is a functor and 
\begin_inset Formula $G^{A}$
\end_inset

 is a contrafunctor, by checking the 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
 laws for 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Other topics:
\end_layout

\begin_layout Itemize
Implementing Functor instance using Cats and Scalaz
\end_layout

\begin_layout Itemize
Implementing Functor instance for recursive types 
\end_layout

\begin_layout Itemize
Functor typeclass derivation using Shapeless
\end_layout

\begin_layout Itemize
Functions that are parameterized by a Functor type constructor
\end_layout

\begin_layout Itemize
Examples of APIs that consume a functor, with type class constraint
\end_layout

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
