#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Theorems for free]{Explaining ``Theorems for Free'' and parametricity}
\subtitle{A tutorial, with code examples in Scala}
\author{Sergei Winitzki}
\date{2020-10-17}
\institute[ABTB]{Academy By the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Parametricity: a theory about certain code refactorings
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To introduce the topic, I begin with practical use examples.
 It is useful for a programmer to know that purely functional code can be
 refactored in ways that are guaranteed to be correct.
 To formulate this fact rigorously, one writes an equation called a "naturality
 law".
 Programmers need to know that these laws exist and can be used for rigorous
 reasoning about code.
 I will show some examples of such reasoning.
\end_layout

\begin_layout Plain Layout
An inquisitive programmer would now ask how to write the naturality law
 for any given function, and also how to prove that the law always holds
 for purely functional code.
 The main part of the talk will answer these questions.
\end_layout

\begin_layout Plain Layout
[Difficulty level 1]
\end_layout

\begin_layout Plain Layout
The name "naturality" comes from "natural transformations" of category theory.
 However, a software engineer needs only a simplified definition of natural
 transformations in the context of functional programming.
 We just need to learn to recognize a natural transformation by its type
 signature: a function between two functors sharing a type parameter.
 After that, the corresponding naturality law is straightforward to write.
\end_layout

\begin_layout Plain Layout
The type signature of a natural transformation is of this form:
\end_layout

\begin_layout Plain Layout
def nt[A]: F[A] => G[A] = ??? // Both F and G must be covariant in A, or
 both contravariant in A.
\end_layout

\begin_layout Plain Layout
Examples of natural transformations in Scala:
\end_layout

\begin_layout Plain Layout
def headOption[A]: List[A] => Option[A] = ...
 def reverse[A]: List[A] => List[A] = ...
 def zipWithIndex[A]: List[A] => List[(A, Int)] = ...
\end_layout

\begin_layout Plain Layout
However, not all widely used functions have the type signature of a natural
 transformation; for example, `find`, `filter`, or `foldLeft` do not.
 A more general approach is necessary.
\end_layout

\begin_layout Plain Layout
[Difficulty level 2]
\end_layout

\begin_layout Plain Layout
One completely general approach is based on the Reynolds-Wadler parametricity
 theorem (known from Wadler's "theorems for free" paper).
 The Reynolds-Wadler theorem is usually formulated using specially defined
 type and value "relations", which are hard to use and to understand for
 programmers who always work with functions and never with arbitrary relations.
\end_layout

\begin_layout Plain Layout
I will explain a different approach that derives parametricity properties
 directly, without using relations.
 In that approach, Wadler's "free theorems" are just naturality laws satisfied
 by any purely functional code with a given type signature.
 For this to work with arbitrary type signatures, we need to extend naturality
 laws from natural transformations to more general "dinatural" transformations
 (functions between two "profunctors" sharing a type parameter).
 I will introduce the notions of profunctors and dinatural transformations.
 I will then show a recipe for writing naturality laws for all type signatures,
 and give some examples.
\end_layout

\begin_layout Plain Layout
The recipe depends on being able to derive the code of `map` or `contramap`
 for any given covariant or contravariant type constructor.
 I will explain an algorithm for deriving that code mechanically.
\end_layout

\begin_layout Plain Layout
In most cases, it is enough for a programmer to know how to write the naturality
 law.
 Proofs are more complicated.
 Without going through the full details, I will outline the proofs of three
 parametricity properties that apply to purely functional code:
\end_layout

\begin_layout Plain Layout
[Difficulty level 3]
\end_layout

\begin_layout Plain Layout
(1) The `fmap` methods defined with respect to any two different type parameters
 will always commute.
\end_layout

\begin_layout Plain Layout
Example in Scala:
\end_layout

\begin_layout Plain Layout
type T[A, B, C] = ...
 // Define some type constructor, covariant with respect to 3 type parameters.
 // Now define `fmap` methods with respect to each type parameter: def fmap_A[A,
 B, C, Z](f: A => Z): T[A, B, C] => T[Z, B, C] = ??? def fmap_B[A, B, C,
 Z](f: B => Z): T[A, B, C] => T[A, Z, C] = ??? def fmap_C[A, B, C, Z](f:
 C => Z): T[A, B, C] => T[A, B, Z] = ??? Then fmap_A, fmap_B, and fmap_C
 pairwise commute, for example:
\end_layout

\begin_layout Plain Layout
fmap_A(f) andThen fmap_B(g) == fmap_B(g) andThen fmap_A(f)
\end_layout

\begin_layout Plain Layout
Proof is by induction on the type structure of T.
\end_layout

\begin_layout Plain Layout
(2) Any purely functional expression with type parameters will satisfy one
 naturality law per type parameter.
\end_layout

\begin_layout Plain Layout
This applies not only to functions, but generally to expressions of any
 type.
 The naturality law is written via the "recipe" derived earlier in the talk.
\end_layout

\begin_layout Plain Layout
Proof is by induction on the code structure of the given expression.
\end_layout

\begin_layout Plain Layout
[Difficulty level 2]
\end_layout

\begin_layout Plain Layout
(3) Any type constructor covariant with respect to a type parameter `A`
 has a unique purely functional `fmap` method with respect to `A` satisfying
 the functor laws.
\end_layout

\begin_layout Plain Layout
Proof is a short symbolic calculation that uses statement (2) and the functor
 laws.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

Expected properties of code that manipulates collections: 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset

First extract user information, then convert stream to list; or first convert
 to list, then extract user information:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
db.getRows.toList.map(getUserInfo)
\family default
\size default
\color inherit
 gives the same result as
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
\color blue
db.getRows.map(getUserInfo).toList
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

First extract user information, then exclude invalid rows; or first exclude
 invalid rows, then extract user information:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
db.getRows.map(getUserInfo).filter(isValid)
\family default
\size default
\color inherit
 gives the same result as 
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
\color blue
db.getRows.filter(getUserInfo andThen isValid).map(getUserInfo)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
These refactorings are guaranteed to be correct
\end_layout

\begin_deeper
\begin_layout Itemize
because 
\family typewriter
\size footnotesize
\color blue
_.toList
\family default
\size default
\color inherit
 is a 
\series bold
natural transformation
\series default
 
\family typewriter
\size footnotesize
\color blue
Stream[A] => List[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
...
 and 
\family typewriter
\size footnotesize
\color blue
_.filter
\family default
\size default
\color inherit
 is also a natural transformation in disguise
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

Natural transformations 
\begin_inset Quotes eld
\end_inset

work the same way for all types
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
...
 and satisfy the 
\begin_inset Quotes eld
\end_inset

naturality laws
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Refactoring rules written as equations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

The refactoring involving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def toList[A]: Stream[A] => List[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For any function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.toList.map(f) == _.map(f).toList
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The refactoring involving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def filter[A]: Stream[A] => (A => Boolean) => Stream[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For any function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 and predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: B => Boolean
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.filter(f andThen p).map(f) == _.map(f).filter(p)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Generally: applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t[A]: F[A] => G[A]
\end_layout

\end_inset

 
\emph on
before
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.map(f)
\end_layout

\end_inset

 equals applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t[B]: F[B] => G[B]
\end_layout

\end_inset

 
\emph on
after
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.map(f)
\end_layout

\end_inset

, for any function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar[d]\sb(0.5){~\mathtt{\_.map(f)}\text{ for }\mathtt{F}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar[d]\sp(0.5){\mathtt{\_.map(f)}\text{ for }\mathtt{G}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is called a 
\series bold
naturality law
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws: further examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\series bold
Naturality law
\series default
 for a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t[A]: F[A] => G[A]
\end_layout

\end_inset

 is an equation that permutes the order of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 and of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.map(f)
\end_layout

\end_inset

, for an arbitrary function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
We expect it to hold if the code works the same way for all types
\end_layout

\begin_layout Itemize
Intuition: 
\family typewriter
t
\family default
 rearranges data in a collection, 
\begin_inset Quotes eld
\end_inset

not looking
\begin_inset Quotes erd
\end_inset

 at values
\end_layout

\begin_layout Standard
Further examples:
\end_layout

\begin_layout Itemize
The headOption method: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption: List[A] => Option[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

list.map(f).headOption == list.headOption.map(f)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Reverse a list: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse[A]: List[A] => List[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

list.map(f).reverse == list.reverse.map(f)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure[A]: A => L[A]
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Id[A] => L[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(x).map(f) == pure(f(x))
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Get length: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length[A]: List[A] => Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A] => Const[Int, A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length(list.map(f)) == length(list)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws in typeclasses
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Another use of naturality laws is in implementing typeclasses
\end_layout

\begin_layout Itemize
Typeclasses require type constructors with methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, and others
\end_layout

\begin_layout Standard
To be useful for programming, the methods must satisfy certain laws
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

: identity, composition
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

: identity, composition, partial function, naturality
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 (traverse): identity, composition, naturality
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

: identity, associativity, naturality
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

: naturality
\end_layout

\begin_layout Standard
We need to check the laws when implementing new typeclass instances
\end_layout

\begin_layout Standard
If naturality holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, then:
\end_layout

\begin_layout Itemize
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten: F[F[A]] => F[A]
\end_layout

\end_inset

 are equivalent 
\end_layout

\begin_layout Itemize
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate: F[Option[A]] => F[A]
\end_layout

\end_inset

 are equivalent 
\end_layout

\begin_layout Itemize
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure: A => F[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unit: F[Unit]
\end_layout

\end_inset

 are equivalent 
\end_layout

\begin_deeper
\begin_layout Itemize
Can simplify the definitions of some typeclasses 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws and 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The name 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset

 comes from a 
\begin_inset CommandInset href
LatexCommand href
name "1989 paper"
target "https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf"
literal "false"

\end_inset

 by P.
\begin_inset space ~
\end_inset

Wadler
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
From the type of a polymorphic function we can derive a theorem it satisfies.
 Every function of the same type satisfies the same theorem.
\end_layout

\end_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset

 are laws that come in two flavors:
\end_layout

\begin_deeper
\begin_layout Itemize
Naturality laws (most often seen in practice)
\end_layout

\begin_layout Itemize
Dinaturality laws (rarely seen) – a generalized form of naturality laws
\end_layout

\end_deeper
\begin_layout Itemize
The 
\series bold
parametricity theorem
\series default
 says:
\end_layout

\begin_deeper
\begin_layout Itemize
Any 
\series bold
fully parametric
\series default
 code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t: P[A] => Q[A]
\end_layout

\end_inset

 satisfies a dinaturality law
\end_layout

\begin_layout Itemize
There is a recipe for writing that law
\end_layout

\begin_layout Itemize
One independent law is obtained per type parameter
\end_layout

\begin_layout Itemize
In most cases, it is actually a naturality law
\end_layout

\end_deeper
\begin_layout Itemize
Usually, typeclass instances are written in fully parametric code
\end_layout

\begin_deeper
\begin_layout Itemize
Then it is not necessary to verify the naturality laws
\end_layout

\begin_layout Itemize
Can simplify some typeclass definitions
\end_layout

\begin_layout Itemize
Naturality laws save us time and simplify code
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What did 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset

 ever do for us programmers?
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Theorems for free
\begin_inset Quotes erd
\end_inset

 guarantee naturality laws for fully parametric code
\end_layout

\begin_layout Itemize
To use 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset

 in practice, programmers need to:
\end_layout

\begin_deeper
\begin_layout Itemize
Recognize and write fully parametric code
\end_layout

\begin_layout Itemize
Be able to write the refactoring that follows from naturality laws
\end_layout

\begin_layout Itemize
Be able to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.map
\end_layout

\end_inset

 for any covariant functor (as well as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.contramap
\end_layout

\end_inset

 for any contravariant functor)
\end_layout

\begin_layout Itemize
Recognize that the refactoring is guaranteed by parametricity
\end_layout

\begin_layout Itemize
Recognize simplifications in typeclasses
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Fully parametric code: example
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Fully parametric
\series default
 code: 
\begin_inset Quotes eld
\end_inset

works in the same way for all types
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Example of a fully parametric type:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Data[A, B](x: Either[A, B] => B, y: (A, B) => A)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Example of a fully parametric function:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def headOpt[A]: List[A] => Option[A] = 
\backslash
{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Nil => None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case head :: tail => Some(head)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The code does not use explicit types
\end_layout

\begin_layout Itemize
Naturality laws express the programmer's intuition about the properties
 of fully parametric code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Example of code that is 
\emph on
not
\emph default
 fully parametric:
\end_layout

\begin_layout Itemize
A bad implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOpt
\end_layout

\end_inset

 that has special code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 type
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def headOptBad[A]: List[A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case Nil                   => None
\end_layout

\begin_layout Plain Layout

  case (head: Int) :: tail   => Some((head + 100).asInstanceOf[A])
\end_layout

\begin_layout Plain Layout

  case head :: tail          => Some(head)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\begin_layout Itemize
The code uses explicit run-time type detection
\end_layout

\begin_deeper
\begin_layout Itemize
But the code is still purely functional and referentially transparent
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Full parametricity
\begin_inset Quotes erd
\end_inset

 is a stronger restriction on code
\end_layout

\end_deeper
\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOptBad
\end_layout

\end_inset

 fails the naturality law:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> headOptBad(  List(1, 2, 3).map(x => s"value = $x")  )
\end_layout

\begin_layout Plain Layout

res0: Option[String] = Some(value = 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> headOptBad(List(1, 2, 3))  .map(x => s"value = $x")
\end_layout

\begin_layout Plain Layout

res1: Option[String] = Some(value = 101)
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Full parametricity: The price of 
\begin_inset Quotes eld
\end_inset

free theorems
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Free theorems
\begin_inset Quotes erd
\end_inset

 only apply to 
\series bold
fully parametric
\series default
 code:
\end_layout

\begin_layout Itemize
All argument types are combinations of type parameters
\end_layout

\begin_layout Itemize
All type parameters are treated as unknown, arbitrary types
\end_layout

\begin_layout Itemize
No hard-coded values of specific types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123: Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

: String
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
No side effects (printing, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

var x
\end_layout

\end_inset

, mutating values, writing files, networking, starting or stopping new threads,
 GUI events, etc.)
\end_layout

\begin_layout Itemize
No 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

, no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

ing of exceptions, no run-time type comparison
\end_layout

\begin_layout Itemize
No run-time code loading, no external libraries with unknown code
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Fully parametric
\begin_inset Quotes erd
\end_inset

 is a stronger restriction than 
\begin_inset Quotes eld
\end_inset

purely functional
\begin_inset Quotes erd
\end_inset

 (referentially transparent)
\end_layout

\begin_layout Standard
Purely functional code is fully parametric if restricted to using only 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type or type parameters
\end_layout

\begin_layout Itemize
No hard-coded values of specific types, and no run-time type detection
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace 200baselineskip%
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Fully parametric programs are written using the 9 code constructions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = { // 3
\end_layout

\begin_layout Plain Layout

   case Nil            => Nil
\end_layout

\begin_layout Plain Layout

//   8   1                1,7 
\end_layout

\begin_layout Plain Layout

   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
\end_layout

\begin_layout Plain Layout

//   8       6             2 4     6  5 2 4     6    7   9
\end_layout

\begin_layout Plain Layout

}           // This code uses each of the nine allowed constructions.
\end_layout

\end_inset


\begin_inset VSpace -20baselineskip%
\end_inset


\end_layout

\begin_layout Enumerate
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value (or equivalent type), e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use bound variable (a given argument of the function)
\end_layout

\begin_layout Enumerate
Create a function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr(x) }
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Create a tuple: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a tuple: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Create a disjunctive value: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a disjunctive value: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...
 => ...
 }
\end_layout

\end_inset

 (pattern-matching)
\end_layout

\begin_layout Enumerate
Use a recursive call: e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(tail)
\end_layout

\end_inset

 within the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Approaches to using and proving the parametricity theorem
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Using the parametricity theorem à la Wadler is difficult
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "Reynolds"
target "https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "Wadler"
target "https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf"
literal "false"

\end_inset

) approach needs to replace functions (one-to-one or many-to-one) by 
\begin_inset Quotes eld
\end_inset

relations
\begin_inset Quotes erd
\end_inset

 (many-to-many)
\end_layout

\begin_deeper
\begin_layout Itemize
Derive a law with relation variables, then replace them by functions
\end_layout

\begin_layout Itemize
Need to learn how to work with relation values and relation types
\end_layout

\begin_layout Itemize
Need to guess how to replace relations by functions in the end
\end_layout

\end_deeper
\begin_layout Itemize
Alternative approach: analysis of dinatural transformations derives the
 naturality laws directly (
\begin_inset CommandInset href
LatexCommand href
name "Bainbridge et al."
target "https://www.sciencedirect.com/science/article/pii/0304397590901517"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "Backhouse"
target "https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "de Lataillade"
target "https://www.irif.fr/~delatail/dinat.pdf"
literal "false"

\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
See also a 
\begin_inset CommandInset href
LatexCommand href
name "2019 paper"
target "https://arxiv.org/pdf/1908.07776"
literal "false"

\end_inset

 by Voigtländer
\end_layout

\begin_layout Itemize
No need to use relations
\end_layout

\begin_layout Itemize
For any type signature, can quickly write the naturality law
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Dinatural transformations and profunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Some methods do 
\emph on
not
\emph default
 have the type signature of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] => G[A]
\end_layout

\end_inset

 where both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

 are functors (or both are contrafunctors)
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find[A]: (A => Boolean) => List[A] => Option[A]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold[A, B]: List[A] => B => (A => B => B) => B
\end_layout

\end_inset

 with respect to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The type parameter is in contravariant and covariant positions at once
\end_layout

\begin_layout Itemize
This gives us neither a functor nor a contrafunctor
\end_layout

\begin_deeper
\begin_layout Itemize
But we can identify the variance for each occurrence of type parameter
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Solution: use a 
\series bold
profunctor
\series default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[X, Y]
\end_layout

\end_inset

 (contravariant in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, covariant in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

) but set equal type parameters: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A, A]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Within any fully parametric type signature, each occurrence of a type parameter
 is either covariant or contravariant
\end_layout

\begin_layout Standard
A 
\series bold
dinatural transformation
\series default
 is a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t[A]: P[A, A] => Q[A, A]
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[X, Y]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q[X, Y]
\end_layout

\end_inset

 are some profunctors and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 satisfies the naturality law
\end_layout

\begin_layout Itemize

\emph on
All pure functions
\emph default
 have the type signature of a dinatural transformation
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The general naturality law for dinatural transformations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t[A]: P[A, A] => Q[A, A]
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[X, Y]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q[X, Y]
\end_layout

\end_inset

 are profunctors
\end_layout

\begin_layout Standard
The naturality law requires that for any function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

, 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.contramapPX(f).pipe(t).mapQY(f) == p.mapPY(f).pipe(t).contramapQX(f)
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset

Both sides must give the same result when applied to arbitrary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: P[B, A]
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize

\emph on
All 
\emph default
naturality laws (also for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

) are derived in this way 
\end_layout

\begin_layout Itemize
The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 must be lawful and fully parametric
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{5.5pc} & \mathtt{P[A,A]}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{Q[A,A]}\ar[rd]\sb(0.45){\mathtt{\_.mapQY(f)}~~~}\\
\mathtt{P[B,A]}\ar[rd]\sp(0.55){~~~\mathtt{\_.mapPY(f)}}\ar[ru]\sb(0.55){~~~\mathtt{\_.contramapPX(f)}} &  &  & \mathtt{Q[A,B]}\\
 & \mathtt{P[B,B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{Q[B,B]}\ar[ru]\sp(0.5){\mathtt{\_.contramapQX(f)}~~~~}
}
\]

\end_inset


\end_layout

\begin_layout Itemize
This law reduces to natural transformation laws when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

 are functors or contrafunctors
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: deriving the naturality law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Use a curried version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.filter
\end_layout

\end_inset

 for convenience:
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def filt[A]: (A => Boolean) => F[A] => F[A]
\end_layout

\end_inset

 for a filterable functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Rewrite as a dinatural transformation, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filt[A]: P[A, A] => Q[A, A]
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type P[X, Y] = X => Boolean
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type Q[X, Y] = F[X] => F[Y]
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Write the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 using the specific types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.contramapPX(f) == f andThen p
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.mapPY(f) == p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q.contramapQX(f) == _.map(f) andThen q
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q.mapQY(f) = q andThen _.map(f)
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Now write the dinaturality law and simplify: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f andThen p).pipe(filt) andThen _.map(f)) == _.map(f) andThen p.pipe(filt)
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Rewriting in terms of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.filter
\end_layout

\end_inset

, we obtain the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.filter(f andThen p).map(f) = _.map(f).filter(p)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Other parametricity properties
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Bifunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 calls commute if used with different type parameters:
\end_layout

\begin_deeper
\begin_layout Standard
For any value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B[X, Y]
\end_layout

\end_inset

, and any functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: X => P
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: Y => Q
\end_layout

\end_inset

, 
\end_layout

\begin_layout Standard
the commutativity law holds: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b.mapX(f).mapY(g) == b.mapY(g).mapX(f)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{B[X,Y]}\ar[d]\sb(0.5){~\mathtt{\_.mapY(g)}}\ar[r]\sp(0.5){\mathtt{\_.mapX(f)}} & \mathtt{B[P,Y]}\ar[d]\sp(0.5){\mathtt{\_.mapY(g)}}\\
\mathtt{B[X,Q]}\ar[r]\sp(0.5){\mathtt{\_.mapX(f)}} & \mathtt{B[P,Q]}
}
\]

\end_inset


\end_layout

\begin_layout Itemize
Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zio.IO[E, A]
\end_layout

\end_inset

 has 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.mapError
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.map
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
A given functor's lawful and fully parametric method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is unique 
\end_layout

\begin_deeper
\begin_layout Itemize
Note: many typeclasses may admit several lawful, fully parametric, but inequival
ent implementations of a typeclass instance for the same type constructor
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Applicative
\end_layout

\end_inset

 instances are not always unique.
 But instances are unique for the functor and contrafunctor type classes.
\end_layout

\end_deeper
\begin_layout Itemize
Analogous results for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

, contrafunctors, and profunctors
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Fully parametric code enables powerful mathematical reasoning:
\end_layout

\begin_deeper
\begin_layout Itemize
Naturality laws can be used for guaranteed correct refactoring
\end_layout

\begin_layout Itemize
Naturality laws allow us to reduce the number of type parameters
\end_layout

\begin_layout Itemize
In typeclass instances, all naturality laws hold, no need to check
\end_layout

\begin_layout Itemize
Functor, contrafunctor, and profunctor typeclass instances are unique
\end_layout

\begin_layout Itemize
Bifunctors and profunctors obey the commutativity law
\end_layout

\end_deeper
\begin_layout Itemize
Full details and proofs are in the Appendix D of the upcoming book
\end_layout

\begin_deeper
\begin_layout Itemize
Draft of the book: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
