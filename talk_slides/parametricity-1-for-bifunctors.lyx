#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Parametricity properties]{Parametricity properties of purely functional code}
%\subtitle{An extreme pragmatic un-academic approach}
\author{Sergei Winitzki}
\date{2020-02-01}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Parametricity properties and naturality laws
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset VSpace -30baselineskip%
\end_inset

Four main results about 
\emph on
purely functional
\emph default
 programs:
\end_layout

\begin_layout Enumerate
Parametricity theorem: programs automatically obey naturality laws
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption: List[A] => Option[A]
\end_layout

\end_inset

 satisfies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

list.map(f).headOption == list.headOption.map(f)
\end_layout

\end_inset


\begin_inset Formula 
\[
f^{\uparrow\text{List}}\bef\text{headOpt}=\text{headOpt}\bef f^{\uparrow\text{Opt}}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Recipe for writing the naturality law, given a function's type signature
\end_layout

\begin_deeper
\begin_layout Itemize
Dinatural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t: P[A, A] => Q[A, A]
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[X, Y]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q[X, Y]
\end_layout

\end_inset

 are profunctors (contravariant in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 and covariant in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

) has the naturality law 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t(pba.xmap(f, identity)).xmap(identity, g) == t(pba.xmap(identity, g)).xmap(f,
 identity)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Liftings with respect to different type parameters always commute
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IO[E, A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

io.map(f).mapError(g) == io.mapError(g).map(f)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Functors and contrafunctors are uniquely derived from types
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[A] = Either[(A, Int), String => A]
\end_layout

\end_inset

 has functor instance 
\begin_inset listings
lstparams "mathescape=false"
inline true
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Either[(A, Int), String => A] => Either[(B, Int),
 String => B] = 
\backslash
{ case Left(a, n) => Left(f(a), n); case Right(g) => Right(g andThen f)
 
\backslash
}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset VSpace 200baselineskip%
\end_inset


\end_layout

\begin_layout Standard

\series bold
Purely functional
\series default
 programs are written using the 9 code constructions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = { // 3
\end_layout

\begin_layout Plain Layout

   case Nil            => Nil
\end_layout

\begin_layout Plain Layout

//   8   1                1,7 
\end_layout

\begin_layout Plain Layout

   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
\end_layout

\begin_layout Plain Layout

//   8       6             2 4     6  5 2 4     6    7   9
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -70baselineskip%
\end_inset


\end_layout

\begin_layout Enumerate
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value (or a 
\begin_inset Quotes eld
\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

), e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Enumerate
Use bound variable (a given argument of the function).
 Notation: 
\begin_inset Formula $x$
\end_inset


\end_layout

\begin_layout Enumerate
Create function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr(x) }
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $f(x)$
\end_inset

 or 
\begin_inset Formula $x\triangleright f$
\end_inset


\end_layout

\begin_layout Enumerate
Create tuple: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $a\times b$
\end_inset


\end_layout

\begin_layout Enumerate
Use tuple: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $\nabla_{1}p$
\end_inset

 or 
\begin_inset Formula $p\triangleright\nabla_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
Create disjunctive value: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset


\end_layout

\begin_layout Enumerate
Use disjunctive value: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...
 }
\end_layout

\end_inset

 (pattern-matching).
 
\end_layout

\begin_layout Enumerate
Use recursive call: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(tail)
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $\overline{\text{fmap}_{\text{List}}}(f)(t)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws: motivation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

naturality law
\begin_inset Quotes erd
\end_inset

 expresses the programmer's intuitions about the properties of 
\series bold
fully parametric
\series default
 code:
\end_layout

\begin_layout Itemize
Code is written once and works in the same way for all types
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def headOpt[A]: List[A] => Option[A] = 
\backslash
{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Nil            => None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case head :: tail   => Some(head)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Fully parametric code:
\end_layout

\begin_layout Itemize
All argument types are combinations of type parameters
\end_layout

\begin_layout Itemize
All type parameters are treated as unknown, arbitrary types
\end_layout

\begin_layout Itemize
No hard-coded values of specific types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123: Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

: String
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
No side effects (printing, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

var x
\end_layout

\end_inset

 assignment, writing files, networking)
\end_layout

\begin_layout Itemize
No 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

, no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

ing of exceptions, no run-time type comparison
\end_layout

\begin_layout Itemize
No run-time code loading, no external libraries with unknown code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws: equations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\series bold
Naturality law
\series default
 for a transformation 
\begin_inset Formula $t$
\end_inset

 is an equation involving an arbitrary function 
\begin_inset Formula $f$
\end_inset

 that permutes the order of application of 
\begin_inset Formula $t$
\end_inset

 and of a lifted 
\begin_inset Formula $f$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "26col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{\text{List}^{A}\ar[r]\sp(0.55){\text{headOpt}^{A}}\ar[d]\sp(0.4){f^{\uparrow\text{List}}} & \text{Opt}^{A}\ar[d]\sb(0.4){f^{\uparrow\text{Opt}}}\\
\xyScaleY{1.6pc}\xyScaleX{3.0pc}\text{List}^{B}\ar[r]\sp(0.55){\text{headOpt}^{B}} & \text{Opt}^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "68col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

list.map(f).headOption == list.headOption.map(f)
\end_layout

\end_inset


\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow\text{List}}\bef\text{headOpt}=\text{headOpt}\bef(f^{:A\rightarrow B})^{\uparrow\text{Opt}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Lifting 
\begin_inset Formula $f$
\end_inset

 before transformation equals to lifting 
\begin_inset Formula $f$
\end_inset

 after transformation
\end_layout

\begin_deeper
\begin_layout Itemize
Intuition: 
\begin_inset Formula $t$
\end_inset

 rearranges data in a collection regardless of value types
\end_layout

\end_deeper
\begin_layout Standard
More examples: 
\end_layout

\begin_layout Itemize
Reversing a list; 
\begin_inset Formula $\text{reverse}^{A}:\text{List}^{A}\rightarrow\text{List}^{A}$
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

list.map(f).reverse == list.reverse.map(f)
\end_layout

\end_inset


\size footnotesize

\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow\text{List}}\bef\text{reverse}^{B}=\text{reverse}^{A}\bef(f^{:A\rightarrow B})^{\uparrow\text{List}}
\]

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure[A]: A => L[A]
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $\text{pu}_{L}:A\rightarrow L^{A}$
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(x).map(f) == pure(f(x))
\end_layout

\end_inset


\size footnotesize

\begin_inset Formula 
\[
\text{pu}_{L}\bef(f^{:A\rightarrow B})^{\uparrow L}=f\bef\text{pu}_{L}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why do we need to know about naturality laws
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Typeclasses: type constructors with methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To be useful for programming, the methods must satisfy certain laws
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

: identity, composition
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

: identity, composition, partial function, naturality
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 (traverse): identity, composition, naturality
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

: identity, composition, naturality
\end_layout

\begin_layout Standard
We need to check the laws when implementing a new typeclass instance
\end_layout

\begin_layout Itemize
The 
\series bold
parametricity theorem
\series default
 guarantees that all naturality laws hold as long as the method's code is
 purely functional
\end_layout

\begin_layout Itemize
This saves us time: 
\emph on
no need
\emph default
 to check the naturality laws
\end_layout

\begin_layout Standard
Proving the parametricity theorem is difficult
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "Reynolds"
target "https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "Wadler"
target "https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf"
literal "false"

\end_inset

) approach needs to replace functions (one-to-one or many-to-one) by 
\begin_inset Quotes eld
\end_inset

relations
\begin_inset Quotes erd
\end_inset

 (many-to-many)
\end_layout

\begin_deeper
\begin_layout Itemize
Derive a law with relation variables, then replace them by functions
\end_layout

\end_deeper
\begin_layout Itemize
Alternative approach: analysis of dinatural transformations derives the
 naturality laws directly (
\begin_inset CommandInset href
LatexCommand href
name "Bainbridge et al."
target "https://www.sciencedirect.com/science/article/pii/0304397590901517"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "Backhouse"
target "https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "de Lataillade"
target "https://www.irif.fr/~delatail/dinat.pdf"
literal "false"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructors with two type parameters
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
In particular: bifunctors and profunctors
\end_layout

\begin_layout Itemize
In Scala syntax: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A, B]
\end_layout

\end_inset

.
 Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type L[A, B] = Either[(A, B), B]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In the type notation: 
\begin_inset Formula $L^{A,B}$
\end_inset

.
 Example: 
\begin_inset Formula $L^{A,B}\triangleq A\times B+B$
\end_inset


\end_layout

\begin_layout Itemize
If a type constructor is 
\series bold
purely functional
\series default
, its type parameters will be either in covariant or in contravariant positions
\end_layout

\begin_layout Itemize

\series bold
Bifunctors
\series default
: both type parameters are always in covariant positions
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A, B]
\end_layout

\end_inset

 defined above is a bifunctor
\end_layout

\begin_layout Itemize
Method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap[A, B, C, D](f: A => C, g: B => D): L[A, B] => L[C, D]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Laws: identity and composition for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Profunctors
\series default
: one type parameter contravariant, the other covariant
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type P[X, Y] = Option[X] => (Y, Y)
\end_layout

\end_inset

 or 
\size footnotesize

\begin_inset Formula $P^{X,Y}\triangleq\bbnum 1+X\rightarrow Y\times Y$
\end_inset


\end_layout

\begin_layout Itemize
Method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap[A, B, C, D](f: C => A, g: B => D): P[A, B] => P[C, D]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Laws: identity and composition for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A, B]
\end_layout

\end_inset

 is a functor separately in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, is it a bifunctor?
\end_layout

\begin_layout Itemize
If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A, B]
\end_layout

\end_inset

 is contravariant in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and covariant in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, is it a profunctor?
\end_layout

\begin_layout Itemize
They are but only if all liftings in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 commute with liftings in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
These are the 
\begin_inset Quotes eld
\end_inset

commutativity laws
\begin_inset Quotes erd
\end_inset

 of bifunctors and profunctors
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 to bifunctors and profunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method can be applied with respect to one type parameter
\end_layout

\begin_layout Itemize
In a bifunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A,B]
\end_layout

\end_inset

, fix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Denote the resulting functor by 
\begin_inset Formula $L^{\bullet,B}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In the Scala syntax with 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[?, B]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Lifting a function 
\begin_inset Formula $f^{:U\rightarrow V}$
\end_inset

 is denoted by 
\begin_inset Formula $f^{\uparrow L^{\bullet,B}}:L^{U,B}\rightarrow L^{V,B}$
\end_inset


\end_layout

\begin_layout Itemize
If fixing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead, a lifting is denoted by 
\begin_inset Formula $f^{\uparrow L^{A,\bullet}}:L^{A,U}\rightarrow L^{A,V}$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Commutativity law
\series default
 for bifunctors: 
\size footnotesize

\begin_inset Formula $f^{\uparrow L^{\bullet,B}}\bef(g^{:B\rightarrow C})^{\uparrow L^{V,\bullet}}=g^{\uparrow L^{U,\bullet}}\bef f^{\uparrow L^{\bullet,C}}$
\end_inset


\size default
 
\end_layout

\end_deeper
\begin_layout Itemize
In a profunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A,B]
\end_layout

\end_inset

, fix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 The resulting 
\emph on
contrafunctor
\emph default
 is 
\begin_inset Formula $P^{\bullet,B}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Lifting a function 
\begin_inset Formula $f^{:U\rightarrow V}$
\end_inset

 is denoted by 
\begin_inset Formula $f^{\downarrow P^{\bullet,B}}:P^{V,B}\rightarrow P^{U,B}$
\end_inset


\end_layout

\begin_layout Itemize
If fixing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead, a lifting is denoted by 
\begin_inset Formula $f^{\uparrow P^{A,\bullet}}:P^{A,U}\rightarrow P^{A,V}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
For brevity, we may denote these liftings by 
\begin_inset Formula $f^{\downarrow P}$
\end_inset

 and 
\begin_inset Formula $f^{\uparrow P}$
\end_inset

 unambiguously
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Commutativity law
\series default
 for profunctors: 
\size footnotesize

\begin_inset Formula $f^{\downarrow P}\bef g^{\uparrow P}=g^{\uparrow P}\bef f^{\downarrow P}$
\end_inset


\size default
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{6.0pc}P^{A,B}\ar[r]\sb(0.55){\text{xmap}_{P}(f^{:C\rightarrow A},\text{id})~~~}\ar[d]\sb(0.45){\text{xmap}_{P}(\text{id},g^{:B\rightarrow D})} & P^{C,B}\ar[d]\sp(0.45){\text{xmap}_{P}(\text{id},g^{:B\rightarrow D})}\\
P^{A,D}\ar[r]\sp(0.45){~~~~\text{xmap}_{P}(f,\text{id})} & P^{C,D}
}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Commutativity laws hold for 
\emph on
all
\emph default
 purely functional type constructors
\end_layout

\begin_deeper
\begin_layout Itemize
It is not necessary to verify the bifunctor and profunctor laws!
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Natural transformations and their generalizations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A 
\series bold
natural transformation
\series default
 is a function 
\begin_inset Formula $t$
\end_inset

 with type signature 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

 that satisfies the naturality law 
\begin_inset Formula $f^{\uparrow F}\bef t=t\bef f^{\uparrow G}$
\end_inset


\end_layout

\begin_layout Itemize
Many standard methods have the form of a natural transformation
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lastOption
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If there are several type parameters, use one at a time:
\end_layout

\begin_deeper
\begin_layout Itemize
For 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, denote by 
\begin_inset Formula $\text{flm}_{M}:\left(A\rightarrow M^{B}\right)\rightarrow M^{A}\rightarrow M^{B}$
\end_inset

, fix 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Itemize
 
\begin_inset Formula $\text{flm}_{M}:F^{B}\rightarrow G^{B}$
\end_inset

 where 
\begin_inset Formula $F^{B}\triangleq A\rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $G^{B}\triangleq M^{A}\rightarrow M^{B}$
\end_inset


\end_layout

\begin_layout Itemize
The naturality law is then written as the equation
\begin_inset Formula 
\[
\text{flm}_{M}(p^{:A\rightarrow M^{B}}\bef f^{\uparrow M})=\text{flm}_{M}(p^{:A\rightarrow M^{B}})\bef f^{\uparrow M}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The naturality law for 
\begin_inset Formula $t^{A}:F^{A}\rightarrow G^{A}$
\end_inset

 when 
\begin_inset Formula $F^{A}$
\end_inset

, 
\begin_inset Formula $G^{A}$
\end_inset

 are contrafunctors:
\end_layout

\begin_layout Standard
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "26col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{F^{A}\ar[r]\sp(0.55){t^{A}}\ar[d]\sp(0.4){(f^{:B\rightarrow A})^{\downarrow F}} & G^{A}\ar[d]\sb(0.4){f^{\downarrow G}}\\
\xyScaleY{1.7pc}\xyScaleX{3.5pc}F^{B}\ar[r]\sp(0.55){t^{B}} & G^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "68col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
(f^{:B\rightarrow A})^{\downarrow F}\bef t^{B}=t^{A}\bef(f^{:B\rightarrow A})^{\downarrow G}
\]

\end_inset

then 
\begin_inset Formula $t$
\end_inset

 is a natural transformation 
\begin_inset Formula $F\leadsto G$
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Dinatural transformations and profunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Some methods do not have the type signature of the form 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find[A]: (A => Boolean) => List[A] => Option[A]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold[A, B]: List[A] => B => (A => B => B) => B
\end_layout

\end_inset

 with respect to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The type parameter is in contravariant and covariant positions at once
\end_layout

\begin_layout Itemize
This gives us neither a functor nor a contrafunctor
\end_layout

\end_deeper
\begin_layout Standard
A 
\series bold
dinatural transformation
\series default
 is a function 
\begin_inset Formula $t$
\end_inset

 with type signature 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 that satisfies the naturality law 
\begin_inset Formula $f^{\downarrow P}\bef t\bef f^{\uparrow Q}=f^{\uparrow P}\bef t\bef f^{\downarrow Q}$
\end_inset

 where 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 are suitable profunctors
\end_layout

\begin_layout Itemize

\emph on
All pure functions
\emph default
 have the type signature of a dinatural transformation
\end_layout

\begin_layout Itemize
The corresponding naturality law is guaranteed by parametricity
\end_layout

\begin_layout Itemize

\emph on
All 
\emph default
naturality laws (also for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

) are derived in this way
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The naturality law for dinatural transformations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Given two profunctors 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 and a function 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 
\end_layout

\begin_layout Standard
The naturality law is an equation for functions 
\begin_inset Formula $P^{B,A}\rightarrow Q^{A,B}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{!}{=}f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}
\]

\end_inset

Both sides must give the same result when applied to arbitrary 
\begin_inset Formula $p:P^{B,A}$
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{2.5pc} & P^{A,A}\ar[r]\sp(0.5){t^{A}} & Q^{A,A}\ar[rd]\sb(0.45){f^{\uparrow Q^{A,\bullet}}}\\
P^{B,A}\ar[rd]\sp(0.55){f^{\uparrow P^{B,\bullet}}}\ar[ru]\sb(0.55){f^{\downarrow P^{\bullet,A}}} &  &  & Q^{A,B}\\
 & P^{B,B}\ar[r]\sp(0.5){t^{B}} & Q^{B,B}\ar[ru]\sp(0.45){f^{\downarrow Q^{\bullet,B}}}
}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: writing the naturality law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def filter[A]: (A => Boolean) => F[A] => F[A]
\end_layout

\end_inset

 for a filterable functor 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Standard
Notation: 
\begin_inset Formula $\text{filt}^{A}:\left(A\rightarrow\bbnum 2\right)\rightarrow F^{A}\rightarrow F^{A}$
\end_inset


\end_layout

\begin_layout Standard
Rewrite in the form of a dinatural transformation: 
\begin_inset Formula 
\[
\text{filt}^{A}:P^{A,A}\rightarrow Q^{A,A}\quad,\quad P^{X,Y}\triangleq(X\rightarrow\bbnum 2)\quad,\quad Q^{X,Y}\triangleq F^{X}\rightarrow F^{Y}
\]

\end_inset

Write the code for the liftings using the specific types of 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\begin{align*}
(f^{:A\rightarrow B})^{\downarrow P^{\bullet,A}}=p^{:B\rightarrow\bbnum 2}\rightarrow f\bef p\quad, & \quad\quad f^{\uparrow P^{B,\bullet}}=\text{id}\quad,\\
(f^{:A\rightarrow B})^{\downarrow Q^{\bullet,B}}=q^{:F^{B}\rightarrow F^{B}}\rightarrow f^{\uparrow F}\bef q\quad, & \quad\quad f^{\uparrow Q^{A,\bullet}}=q^{:F^{A}\rightarrow F^{A}}\rightarrow q\bef f^{\uparrow F}\quad.
\end{align*}

\end_inset

Rewrite the naturality law 
\begin_inset Formula $f^{\downarrow P^{\bullet,A}}\bef\text{filt}^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{!}{=}f^{\uparrow P^{B,\bullet}}\bef\text{filt}^{B}\bef f^{\downarrow Q^{\bullet,B}}$
\end_inset

 as
\begin_inset Formula 
\[
(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\overset{!}{=}\text{id}\bef\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)\quad.
\]

\end_inset

To simplify the form of the naturality law, apply both sides to an arbitrary
 value 
\begin_inset Formula $p^{:P^{B,A}}=p^{:B\rightarrow\bbnum 2}$
\end_inset


\end_layout

\begin_layout Standard
Evaluate the results and obtain the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}\overset{!}{=}f^{\uparrow F}\bef\text{filt}_{F}(p)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Uniqueness of functor implementations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Statement 1
\series default
: For any purely functional type constructor 
\begin_inset Formula $F^{A}$
\end_inset

 covariant in 
\begin_inset Formula $A$
\end_inset

, there is a unique lawful and purely functional implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap[A, B]: (A => B) => F[A] => F[B]
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Statement 2
\series default
: For any purely functional type constructor 
\begin_inset Formula $F^{A}$
\end_inset

 contravariant in 
\begin_inset Formula $A$
\end_inset

, there is a unique lawful and purely functional implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap[A, B]: (B => A) => F[A] => F[B]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Note: many typeclasses may admit several lawful, purely functional, but
 non-equivalent implementations of a typeclass instance for the same type
 constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Applicative
\end_layout

\end_inset

 instances are not always unique.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of Statement 1 (uniqueness of functor instances)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For a given functor 
\begin_inset Formula $F$
\end_inset

, we can construct the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 that is involved in the naturality laws.
 Suppose that there exists 
\emph on
another
\emph default
 lawful and purely functional implementation 
\begin_inset Formula $\text{fmap}_{F}^{\prime}(f)$
\end_inset

.
 We need to show that 
\begin_inset Formula $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$
\end_inset

.
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}\quad,\quad\quad\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B})=\text{???}^{:F^{A}\rightarrow F^{B}}\quad.
\]

\end_inset


\size default
 Now, 
\begin_inset Formula $\text{fmap}_{F}^{\prime}$
\end_inset

 has a naturality law with respect to 
\begin_inset Formula $B$
\end_inset

:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]

\end_inset


\size default
 Use the composition law for 
\begin_inset Formula $\text{fmap}_{F}^{\prime}$
\end_inset

:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}_{F}^{\prime}(f\bef g)=\text{fmap}_{F}^{\prime}(f)\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]

\end_inset


\size default
Since 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is arbitrary, we can choose 
\begin_inset Formula $A=B$
\end_inset

 and 
\begin_inset Formula $f=\text{id}^{:B\rightarrow B}$
\end_inset

 to obtain
\size footnotesize

\begin_inset Formula 
\[
\gunderline{\text{fmap}_{F}^{\prime}(\text{id})}\bef\text{fmap}_{F}^{\prime}(g)=\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\gunderline{\text{fmap}_{F}^{\prime}(\text{id})}\bef g^{\uparrow F}=g^{\uparrow F}=\text{fmap}_{F}(g)\quad.
\]

\end_inset


\size default
This must hold for arbitrary 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, which proves that 
\begin_inset Formula $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Plan for a proof of commutativity law for profunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Main idea: induction on the type expression of a profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset


\end_layout

\begin_layout Itemize
A purely functional 
\begin_inset Formula $P^{X,Y}$
\end_inset

 must be a combination of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type (
\begin_inset Formula $\bbnum 1$
\end_inset

), parameters 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

, products 
\begin_inset Formula $A\times B$
\end_inset

, co-products 
\begin_inset Formula $A+B$
\end_inset

, exponentials 
\begin_inset Formula $A\rightarrow B$
\end_inset

, and type recursion (use of 
\begin_inset Formula $P$
\end_inset

 in its definition).
\end_layout

\begin_layout Itemize
For each of these cases, we need to show that the commutativity law holds
 given that it holds for all sub-expressions.
\end_layout

\begin_deeper
\begin_layout Itemize
Base case: show that the law holds for 
\begin_inset Formula $P^{X,Y}\triangleq\bbnum 1$
\end_inset

 and 
\begin_inset Formula $P^{X,Y}\triangleq Y$
\end_inset


\end_layout

\begin_layout Itemize
Induction steps: if the law holds for 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

, show that it also holds for 
\begin_inset Formula $P^{X,Y}+Q^{X,Y}$
\end_inset

 and 
\begin_inset Formula $P^{X,Y}\times Q^{X,Y}$
\end_inset

 and 
\begin_inset Formula $P^{Y,X}\rightarrow Q^{X,Y}$
\end_inset

; also show that the law holds for a recursively defined 
\begin_inset Formula $P^{X,Y}\triangleq S^{X,Y,P^{X,Y}}$
\end_inset

 for a type constructor 
\begin_inset Formula $S^{X,Y,R}$
\end_inset

 contravariant in 
\begin_inset Formula $X$
\end_inset

, covariant in 
\begin_inset Formula $Y$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
We need to use the code of functor and contrafunctor instances for products,
 co-products, exponentials, and recursive types.
\end_layout

\begin_layout Itemize
Example: Define 
\begin_inset Formula $R^{X,Y}\triangleq P^{X,Y}\times Q^{X,Y}$
\end_inset

, then the lifting to 
\begin_inset Formula $R$
\end_inset

 is given by 
\begin_inset Formula $f^{\uparrow R}\triangleq p\times q\rightarrow f^{\uparrow P}(p)\times f^{\uparrow Q}(q)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Plan for a proof of parametricity theorem
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Need to prove the naturality law for 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 written as
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}
\]

\end_inset


\end_layout

\begin_layout Itemize
The code of 
\begin_inset Formula $t$
\end_inset

 must be of the form 
\begin_inset Formula $p\rightarrow\text{expr}$
\end_inset

, where 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{expr}$
\end_inset


\begin_inset Quotes erd
\end_inset

 must be built up from the 9 purely functional code constructions
\end_layout

\begin_layout Itemize
Main idea: induction on the code of 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{expr}$
\end_inset


\begin_inset Quotes erd
\end_inset

, assuming that the naturality law holds for all sub-expressions
\end_layout

\begin_layout Itemize
Example: induction step for code construction 3 (
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
The code of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $p\rightarrow z\rightarrow r$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}\triangleq Z^{Y,X}\rightarrow R^{X,Y}$
\end_inset

 
\end_layout

\begin_layout Itemize
Inductive assumption is that any 
\begin_inset Formula $x\rightarrow r$
\end_inset

 satisfies the law; let 
\begin_inset Formula $x=p\times z$
\end_inset


\end_layout

\begin_layout Itemize
Assume that the law holds for 
\begin_inset Formula $u\triangleq p\times z\rightarrow r$
\end_inset

, 
\begin_inset Formula $u:P^{A,A}\times Z^{A,A}\rightarrow R^{A,A}$
\end_inset


\end_layout

\begin_layout Itemize
Derive the law for 
\begin_inset Formula $t=p\rightarrow z\rightarrow u(p\times z)$
\end_inset

 by a direct calculation
\end_layout

\end_deeper
\begin_layout Itemize
There are some technical difficulties (dinatural transformations do not
 generally compose) but these difficulties can be overcome with tricks
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Purely functional code enables powerful mathematical reasoning:
\end_layout

\begin_deeper
\begin_layout Itemize
Any type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 has the form of a diagonal profunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A, A]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Functor, contrafunctor, and profunctor instances are unique
\end_layout

\begin_layout Itemize
Any purely functional code obeys a naturality law
\end_layout

\begin_layout Itemize
Bifunctors and profunctors obey a commutativity law
\end_layout

\end_deeper
\begin_layout Itemize
Full details and proofs are in the upcoming book (Appendix D)
\end_layout

\begin_deeper
\begin_layout Itemize
Source (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

) for the book: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
