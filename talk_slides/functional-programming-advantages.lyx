#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Why functional programming]{What did functional programming ever do for us (software engineers)?}
\subtitle{An extreme pragmatic and un-academic approach}
\author{Sergei Winitzki}
\date{2020-08-22}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Overview: Advantages of functional programming
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Features of functional programming are being added to many languages
\end_layout

\begin_layout Itemize
What are these features?
\end_layout

\begin_layout Itemize
What advantages do they give programmers?
\end_layout

\begin_layout Standard
Programmer-facing features listed in the increasing order of complexity
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 (and decreasing order of advantage-to-cost ratio)
\end_layout

\begin_layout Enumerate
Write iterative code without loops
\end_layout

\begin_layout Enumerate
Use functions parameterized by types, checked by compiler
\end_layout

\begin_layout Enumerate
Use disjunctive types to model special cases, errors, etc.
\end_layout

\begin_layout Enumerate
Use special syntax for chaining effectful computations
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 1: Loop-free iterative programs.
 Transformation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
An easy interview question:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

Given an array of integers, find all pairs that sum to a given number
\end_layout

\begin_layout Itemize
Solutions using loops: 
\begin_inset CommandInset href
LatexCommand href
name "10-20 lines of code"
target "https://javarevisited.blogspot.com/2014/08/how-to-find-all-pairs-in-array-of-integers-whose-sum-equal-given-number-java.html"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
FP solution with 
\begin_inset Formula $O(n^{2})$
\end_inset

 complexity:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
# Python
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
[ (x, y) for x in array for y in array if x + y == n ]
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Scala
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
for { x <- array; y <- array; if x + y == n } yield (x, y)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
-- Haskell
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
do; x <- array; y <- array; guard (x + y == n); return (x, y)
\end_layout

\begin_layout Itemize
FP solution with 
\begin_inset Formula $O(n\log n)$
\end_inset

 complexity:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Scala
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val hash = array.toSet
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
for { x <- hash; if hash contains (n - x) } yield (x, n - x)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 1: Loop-free iterative programs.
 Aggregation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Given an array of integers, compute the sum of square roots of all elements
 except negative ones 
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
# Python
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sum( [ sqrt(x) for x in givenArray if x >= 0 ] )
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Scala
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
givenArray.filter(_ >= 0).map(math.sqrt).sum
\end_layout

\begin_layout Itemize
Given a set of integers, compute the sum of those integers which are non-negativ
e and whose square root is also present in the set 
\end_layout

\begin_deeper
\begin_layout Itemize
Solution using loops: 
\begin_inset CommandInset href
LatexCommand href
name "15-20 lines of code"
target "https://www.geeksforgeeks.org/sum-of-elements-whose-square-root-is-present-in-the-array/"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
FP solution:
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
givenSet
\family default
\color darkgray
 // Scala
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  .filter { x => x >= 0 && givenSet.contains(math.sqrt(x)) }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  .sum
\end_layout

\begin_layout Itemize
Compute a positive integer from a given array of its decimal digits
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
digits.reverse.zipWithIndex
\family default
\color darkgray
 // Scala
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  .map { case (d, i) => d * math.pow(10, i).toInt } .sum
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 1: Loop-free iterative programs.
 Induction
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Compute the mean value of a given sequence in single pass
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> Seq(4, 5, 6, 7).foldLeft((0.0, 0.0)) {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
       | case ((sum, count), x) => (sum + x, count + 1)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
       | }.pipe { case (sum, count) => sum / count } 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
res1: Double = 5.5
\end_layout

\begin_layout Itemize
Any inductive definition can be converted to a 
\begin_inset Quotes eld
\end_inset

fold
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Base case is the initial value
\end_layout

\begin_layout Itemize
Inductive step is the updater function
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 1: Loop-free iterative programs.
 Other applications
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The implementation of 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
groupBy
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
sum
\family default
\size default
\color inherit
, etc., may be asynchronous (Akka Streams), parallel, and/or distributed
 (Spark, Flink)
\end_layout

\begin_deeper
\begin_layout Itemize
The programmer writes loop-free code in the map/filter/reduce style
\end_layout

\begin_layout Itemize
The runtime engine implements parallelism, fault tolerance, etc.
\end_layout

\begin_layout Itemize
Many types of programmer errors are avoided automatically
\end_layout

\end_deeper
\begin_layout Itemize
What we need to support programming in the map/filter/reduce style:
\end_layout

\begin_deeper
\begin_layout Itemize
Collections with user-definable methods
\end_layout

\begin_layout Itemize
Functions (
\begin_inset Quotes eld
\end_inset

lambdas
\begin_inset Quotes erd
\end_inset

) passed as parameters to other functions
\end_layout

\begin_layout Itemize
Easy work with tuple types
\end_layout

\end_deeper
\begin_layout Itemize
Lambdas were added to most programming languages by 2015
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 2: Type parameters.
 Usage
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Collections can have types parameterized by element type
\end_layout

\begin_deeper
\begin_layout Itemize
Array of integers: 
\family typewriter
\size footnotesize
\color blue
Array[Int]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Array of strings: 
\family typewriter
\size footnotesize
\color blue
Array[String]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Array of arrays of pairs of integers and strings: 
\family typewriter
\size footnotesize
\color blue
Array[Array[(Int, String)]]
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Itemize
Methods such as 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
groupBy
\family default
\size default
\color inherit
 change the type parameters
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
Seq(4, 5, 6, 7)                     
\family default
\color darkgray
 // Seq[Int]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  .zip(Seq("a", "b", "c", "d"))
\family default
\color darkgray
      // Seq[(Int, String)]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  .map { case (i, s) => s"$s : $i" }
\family default
\color darkgray
 // Seq[String]
\end_layout

\begin_layout Itemize
The compiler prevents using incorrect type parameters anywhere
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 2: Type parameters.
 Language features
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Code can be written once, then used with different type parameters
\end_layout

\begin_layout Itemize
Example (Scala):
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def map[A, B](xs: Seq[A])(f: A => B): Seq[B] = ...
 
\end_layout

\begin_layout Itemize
Collections (
\family typewriter
\size footnotesize
\color blue
Array
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Set
\family default
\size default
\color inherit
, etc.) with type parameters support such methods
\end_layout

\begin_layout Itemize
Many programming languages have type parameters
\end_layout

\begin_deeper
\begin_layout Itemize
Functions with type parameters were added to Java in 2006
\end_layout

\begin_layout Itemize
C++ can imitate this functionality with templates
\end_layout

\begin_layout Itemize
Go-lang might get type parameters in the future
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 3: Disjunctive types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Enumeration type (
\family typewriter
\size footnotesize
\color blue
enum
\family default
\size default
\color inherit
) describes a set of disjoint possibilities:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
enum Color { RED, GREEN, BLUE; } 
\family default
\color darkgray
// Java
\end_layout

\begin_layout Itemize
A value of type 
\family typewriter
\size footnotesize
\color blue
Color
\family default
\size default
\color inherit
 can be only one of the three possibilities
\end_layout

\begin_layout Itemize
Disjunctive types are 
\begin_inset Quotes eld
\end_inset

enriched
\begin_inset Quotes erd
\end_inset

 
\family typewriter
\size footnotesize
\color blue
enum
\family default
\size default
\color inherit
 types, carrying extra values:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Scala 3
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
enum RootOfEq { case NoRoots(); case OneRoot(x: Float); }
\end_layout

\begin_layout Itemize
The 
\family typewriter
\size footnotesize
\color blue
switch
\family default
\size default
\color inherit
 is 
\begin_inset Quotes eld
\end_inset

enriched
\begin_inset Quotes erd
\end_inset

 to extract data from disjunctive values
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Scala
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
roots match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case OneRoot(x) => 
\family default
\color darkgray
// May use `x` in this expression.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case NoRoots() => 
\family default
\color darkgray
// May not use `x` here by mistake.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Disjunctive types describe values from 
\begin_inset Quotes eld
\end_inset

tagged union
\begin_inset Quotes erd
\end_inset

 sets
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
OneRoot(x)
\family default
\size default
\color inherit
 
\begin_inset Formula $\cong$
\end_inset

 the set of all 
\family typewriter
\size footnotesize
\color blue
Float
\family default
\size default
\color inherit
 values
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
NoRoots()
\family default
\size default
\color inherit
 
\begin_inset Formula $\cong$
\end_inset

 the set consisting of a single value
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
RootOfEq
\family default
\size default
\color inherit
 
\begin_inset Formula $\cong$
\end_inset

 either some 
\family typewriter
\size footnotesize
\color blue
Float
\family default
\size default
\color inherit
 value or the special value 
\family typewriter
\size footnotesize
\color blue
NoRoots()
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 3: Disjunctive types.
 Adoption in languages
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Disjunctive types and pattern matching are required for FP
\end_layout

\begin_layout Itemize
Introduced in Standard ML (1973)
\end_layout

\begin_layout Itemize
Supported in all FP languages (OCaml, Haskell, F#, Scala, Swift, ...)
\end_layout

\begin_layout Itemize
The support of disjunctive types only comes in FP-designed languages
\end_layout

\begin_deeper
\begin_layout Itemize
Not supported in C, C++, Java, JavaScript, Python, Go, ...
\end_layout

\begin_layout Itemize
Not supported in relational languages (Prolog, SQL, Datalog, ...)
\end_layout

\begin_layout Itemize
Not supported in configuration data formats (XML, JSON, YAML, ...)
\end_layout

\end_deeper
\begin_layout Itemize
Logical completeness of the type system:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logic operation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logic notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
conjunction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\wedge B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
disjunction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\vee B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
A => B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
implication
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\top$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Nothing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bot$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Programming is easier in languages having a 
\emph on
complete
\emph default
 logic of types
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Hindley-Milner type system
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 4: Chaining of effects.
 Motivation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
How to compose computations that may fail with an error?
\end_layout

\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

result or error
\begin_inset Quotes erd
\end_inset

 disjunctive type: 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 
\begin_inset Formula $\cong$
\end_inset

 
\family typewriter
\size footnotesize
\color blue
Either[Throwable, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
In Scala, 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 is a disjunction of 
\family typewriter
\size footnotesize
\color blue
Failure[Throwable]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Success[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Working with 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 requires two often-used code patterns:
\end_layout

\begin_layout Itemize
Use 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 in a computation that cannot fail, 
\family typewriter
\size footnotesize
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Success(a)
\family default
\size default
\color inherit
 goes to 
\family typewriter
\size footnotesize
\color blue
Success(f(a))
\family default
\size default
\color inherit
 but 
\family typewriter
\size footnotesize
\color blue
Failure(t)
\family default
\size default
\color inherit
 remains unchanged
\end_layout

\end_deeper
\begin_layout Itemize
Use 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 in a computation that can fail, 
\family typewriter
\size footnotesize
\color blue
g:
\begin_inset space ~
\end_inset

A => Try[B]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Success(a)
\family default
\size default
\color inherit
 goes to 
\family typewriter
\size footnotesize
\color blue
g(a)
\family default
\size default
\color inherit
 while 
\family typewriter
\size footnotesize
\color blue
Failure(t)
\family default
\size default
\color inherit
 remains unchanged
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 4: Chaining of effects.
 Implementation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Implementing the two code patterns using pattern matching:
\end_layout

\begin_layout Itemize
Pattern 1: use 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 in a computation that cannot fail
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
tryGetFileStats() match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Success(stats) => Success(stats.getTimestamp)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Failure(exception) => Failure(exception)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Pattern 2: use 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 in a computation that can fail
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
tryOpenFile() match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Success(file) => tryRead(file)
\family default
\color darkgray
 // Returns Try[Array[Byte]]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Failure(exception) => Failure(exception)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 4: Chaining of effects.
 Implementation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The two patterns may be combined at will
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Read a file, decode UTF-8, return the number of chars.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def utfChars(name: String): Try[Int] = tryOpenFile(name) match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Success(file) => tryRead(file) match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     case Success(bytes) => tryDecodeUTF8(bytes) match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
       case Success(decoded) => Success(decoded.length)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
       case Failure(exception) => Failure(exception)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     case Failure(exception) => Failure(exception)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Failure(exception) => Failure(exception)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
The code is awkwardly nested and repetitive 
\end_layout

\begin_deeper
\begin_layout Itemize
This sort of code is common in go-lang programs:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
err1, res1 := tryOpenFile();
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
if (res1 != nil) {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   err2, res2 := tryRead(res1);
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   if (res2 != nil) { ...
 } 
\family default
\color darkgray
 // Continue with no errors.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   else ...

\family default
\color darkgray
 // Handle second error.
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
else ...

\family default
\color darkgray
    // Handle first error.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 4: Chaining of effects.
 Using 
\family typewriter
map
\family default
 and 
\family typewriter
flatMap
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Implement the two code patterns using 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Try(a).map(f)
\family default
\size default
\color inherit
 – use with 
\family typewriter
\size footnotesize
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 that cannot fail
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Try(a).flatMap(g)
\family default
\size default
\color inherit
 – use with 
\family typewriter
\size footnotesize
\color blue
g:
\begin_inset space ~
\end_inset

A => Try[B]
\family default
\size default
\color inherit
 that can fail
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def fmap[A, B](f: A => B): Try[A] => Try[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def flm[A, B](g: A => Try[B]): Try[A] => Try[B]
\end_layout

\begin_layout Itemize
Pattern 1: use 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 in a computation that cannot fail
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
tryGetFileStats() match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Success(stats) => Success(stats.getTimestamp)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Failure(exception) => Failure(exception)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Pattern 2: use 
\family typewriter
\size footnotesize
\color blue
Try[A]
\family default
\size default
\color inherit
 in a computation that can fail
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
tryOpenFile() match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Success(file) => read(file)
\family default
\color darkgray
 // Returns Try[InputStream]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Failure(exception) => Failure(exception)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 4: Chaining of effects.
 Special syntax
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Using 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, the code from the previous slide simplifies:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
tryGetFileStats().map(stats => stats.getTimestamp)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
tryOpenFile().flatMap(file => read(file))
\end_layout

\begin_layout Itemize
We can now write code like this (avoiding nesting and repetition):
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
Try(one()).map { x => f(x) }.flatMap { y => Try(another(y)) }
\end_layout

\begin_layout Itemize
Instead of a chain of 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 methods, use a special syntax:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
for {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  x <- Try(one())
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  y = f(x)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  z <- Try(another(y))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield z
\end_layout

\begin_layout Itemize
Resembles the syntax for nested loops (
\begin_inset Quotes eld
\end_inset

for-comprehension
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
for { x <- list1; y <- list2 } yield p(x, y) 
\family default
\color darkgray
// Scala
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
[ p(x, y) for y in list2 for x in list1 ] 
\family default
\color darkgray
// Python
\end_layout

\begin_layout Itemize
In Haskell: 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
do
\family default
\size default
\color inherit
 notation
\begin_inset Quotes erd
\end_inset

, in F#: 
\begin_inset Quotes eld
\end_inset

computation expressions
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Feature 4: Chaining of effects.
 Special syntax
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Using the special syntax, a chain of computations looks like this:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Read a file, decode UTF-8, return the number of chars.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def utfChars(name: String): Try[Int] = for {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  file    <- tryOpenFile(name)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  bytes   <- tryRead(file)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  decoded <- tryDecodeUTF8(bytes)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  length  = decoded.length
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield length
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Features 1-4 may be combined at will
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The main advantages in practical coding come from combining features 1-4
 of functional programming
\end_layout

\begin_layout Itemize
Use functional methods on collections with type parameters
\end_layout

\begin_layout Itemize
Use disjunctive types to represent program requirements
\end_layout

\begin_layout Itemize
Avoid explicit loops and make sure all types match
\end_layout

\begin_layout Itemize
Compose programs at high level by chaining effects (
\family typewriter
\size footnotesize
\color blue
Try
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Future
\family default
\size default
\color inherit
, ...)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
FP proposes 4 essential features that make programming easier
\end_layout

\begin_deeper
\begin_layout Itemize
loop-free iteration, type parameters, disjunctive types, chaining syntax
\end_layout

\begin_layout Itemize
other, more advanced features have higher cost/advantage ratios
\end_layout

\end_deeper
\begin_layout Itemize
All 
\begin_inset Quotes eld
\end_inset

FP languages
\begin_inset Quotes erd
\end_inset

 have these features and give the same advantages
\end_layout

\begin_deeper
\begin_layout Itemize
OCaml, Haskell, Scala, F#, Swift, Rust, Elm, ...
\end_layout

\end_deeper
\begin_layout Itemize
Most 
\begin_inset Quotes eld
\end_inset

non-FP languages
\begin_inset Quotes erd
\end_inset

 lack at least 2 of these features
\end_layout

\begin_deeper
\begin_layout Itemize
Lack of features may be compensated but raises the cost of their use
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
