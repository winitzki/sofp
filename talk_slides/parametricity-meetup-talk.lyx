#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Parametricity properties]{Parametricity properties of purely functional code}
\subtitle{``Theorems for free'' demystified. A tutorial, with code examples in Scala}
\author{Sergei Winitzki}
\date{2020-03-24}
\institute[SFTTPL]{San Francisco Types, Theorems, and Programming Languages}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Refactoring code by permuting the order of operations
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To introduce the topic, I begin with practical use examples.
 It is useful for a programmer to know that purely functional code can be
 refactored in ways that are guaranteed to be correct.
 To formulate this fact rigorously, one writes an equation called a "naturality
 law".
 Programmers need to know that these laws exist and can be used for rigorous
 reasoning about code.
 I will show some examples of such reasoning.
\end_layout

\begin_layout Plain Layout
An inquisitive programmer would now ask how to write the naturality law
 for any given function, and also how to prove that the law always holds
 for purely functional code.
 The main part of the talk will answer these questions.
\end_layout

\begin_layout Plain Layout
[Difficulty level 1]
\end_layout

\begin_layout Plain Layout
The name "naturality" comes from "natural transformations" of category theory.
 However, a software engineer needs only a simplified definition of natural
 transformations in the context of functional programming.
 We just need to learn to recognize a natural transformation by its type
 signature: a function between two functors sharing a type parameter.
 After that, the corresponding naturality law is straightforward to write.
\end_layout

\begin_layout Plain Layout
The type signature of a natural transformation is of this form:
\end_layout

\begin_layout Plain Layout
def nt[A]: F[A] => G[A] = ??? // Both F and G must be covariant in A, or
 both contravariant in A.
\end_layout

\begin_layout Plain Layout
Examples of natural transformations in Scala:
\end_layout

\begin_layout Plain Layout
def headOption[A]: List[A] => Option[A] = ...
 def reverse[A]: List[A] => List[A] = ...
 def zipWithIndex[A]: List[A] => List[(A, Int)] = ...
\end_layout

\begin_layout Plain Layout
However, not all widely used functions have the type signature of a natural
 transformation; for example, `find`, `filter`, or `foldLeft` do not.
 A more general approach is necessary.
\end_layout

\begin_layout Plain Layout
[Difficulty level 2]
\end_layout

\begin_layout Plain Layout
One completely general approach is based on the Reynolds-Wadler parametricity
 theorem (known from Wadler's "theorems for free" paper).
 The Reynolds-Wadler theorem is usually formulated using specially defined
 type and value "relations", which are hard to use and to understand for
 programmers who always work with functions and never with arbitrary relations.
\end_layout

\begin_layout Plain Layout
I will explain a different approach that derives parametricity properties
 directly, without using relations.
 In that approach, Wadler's "free theorems" are just naturality laws satisfied
 by any purely functional code with a given type signature.
 For this to work with arbitrary type signatures, we need to extend naturality
 laws from natural transformations to more general "dinatural" transformations
 (functions between two "profunctors" sharing a type parameter).
 I will introduce the notions of profunctors and dinatural transformations.
 I will then show a recipe for writing naturality laws for all type signatures,
 and give some examples.
\end_layout

\begin_layout Plain Layout
The recipe depends on being able to derive the code of `map` or `contramap`
 for any given covariant or contravariant type constructor.
 I will explain an algorithm for deriving that code mechanically.
\end_layout

\begin_layout Plain Layout
In most cases, it is enough for a programmer to know how to write the naturality
 law.
 Proofs are more complicated.
 Without going through the full details, I will outline the proofs of three
 parametricity properties that apply to purely functional code:
\end_layout

\begin_layout Plain Layout
[Difficulty level 3]
\end_layout

\begin_layout Plain Layout
(1) The `fmap` methods defined with respect to any two different type parameters
 will always commute.
\end_layout

\begin_layout Plain Layout
Example in Scala:
\end_layout

\begin_layout Plain Layout
type T[A, B, C] = ...
 // Define some type constructor, covariant with respect to 3 type parameters.
 // Now define `fmap` methods with respect to each type parameter: def fmap_A[A,
 B, C, Z](f: A => Z): T[A, B, C] => T[Z, B, C] = ??? def fmap_B[A, B, C,
 Z](f: B => Z): T[A, B, C] => T[A, Z, C] = ??? def fmap_C[A, B, C, Z](f:
 C => Z): T[A, B, C] => T[A, B, Z] = ??? Then fmap_A, fmap_B, and fmap_C
 pairwise commute, for example:
\end_layout

\begin_layout Plain Layout
fmap_A(f) andThen fmap_B(g) == fmap_B(g) andThen fmap_A(f)
\end_layout

\begin_layout Plain Layout
Proof is by induction on the type structure of T.
\end_layout

\begin_layout Plain Layout
(2) Any purely functional expression with type parameters will satisfy one
 naturality law per type parameter.
\end_layout

\begin_layout Plain Layout
This applies not only to functions, but generally to expressions of any
 type.
 The naturality law is written via the "recipe" derived earlier in the talk.
\end_layout

\begin_layout Plain Layout
Proof is by induction on the code structure of the given expression.
\end_layout

\begin_layout Plain Layout
[Difficulty level 2]
\end_layout

\begin_layout Plain Layout
(3) Any type constructor covariant with respect to a type parameter `A`
 has a unique purely functional `fmap` method with respect to `A` satisfying
 the functor laws.
\end_layout

\begin_layout Plain Layout
Proof is a short symbolic calculation that uses statement (2) and the functor
 laws.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Expected properties of refactored code: 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
First extract user information, then convert stream to list; or first convert
 to list, then extract user information:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
db.getRows.toList.map(getUserInfo)
\family default
\size default
\color inherit
 gives the same result as
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
\color blue
db.getRows.map(getUserInfo).toList
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
First extract user information, then exclude invalid rows; or first exclude
 invalid rows, then extract user information:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
db.getRows.map(getUserInfo).filter(isValid)
\family default
\size default
\color inherit
 gives the same result as 
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
\color blue
db.getRows.filter(getUserInfo andThen isValid).map(getUserInfo)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
These refactorings are guaranteed to be correct
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary of the type notation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The short type notation helps in symbolic reasoning about types
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala examples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Typed value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: Int
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $x^{:\text{Int}}$
\end_inset

 or 
\begin_inset Formula $x:\text{Int}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Unit type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Type parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Product type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class P(x: A, y: B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Co-product type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Function type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Type constructor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{List}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Universal quantifier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait P 
\backslash
{ def f[A]: Q[A] 
\backslash
}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $P\triangleq\forall A.\,Q^{A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Existential quantifier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "43page%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Q[A, B]() extends P[A]
\end_layout

\end_inset


\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $P^{A}\triangleq\exists B.\,Q^{A,B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Example: Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def flm(f: A => Option[B]): Option[A] => Option[B]
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $\text{flm}:(A\rightarrow\bbnum 1+B)\rightarrow\bbnum 1+A\rightarrow\bbnum 1+B$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary of the code notation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The short code notation helps in symbolic reasoning about code
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala examples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $\text{true}$
\end_inset

, 
\begin_inset Formula $\text{"abc"}$
\end_inset

, 
\begin_inset Formula $123$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A](x: A) = ...
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f^{A}(x^{:A})\triangleq...$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
{ (x: A) => expr 
\backslash
}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}\rightarrow\text{expr}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 (Scala 2.13)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x)$
\end_inset

 or 
\begin_inset Formula $x\triangleright f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val p: (A, B) = (a, b)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $p^{:A\times B}\triangleq a\times b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
{case (a, b) => expr
\backslash
}
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a\times b\rightarrow\text{expr}$
\end_inset

 
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $p\triangleright\pi_{1}$
\end_inset


\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $p\triangleright\pi_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right[A, B](y)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset space \hspace*{}
\length -1.3line%
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset VSpace 14baselineskip%
\end_inset


\size footnotesize

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val q: C = (p: Either[A, B]) match 
\backslash
{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Left(x)   => f(x)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Right(y)  => g(y)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
}
\end_layout

\end_inset


\size small

\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\end_inset

 
\begin_inset space \hspace*{}
\length -0.9line%
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $q^{:C}\triangleq p^{:A+B}\triangleright\begin{array}{|c||c|}
 & C\\
\hline A & x^{:A}\rightarrow f(x)\\
B & y^{:B}\rightarrow g(y)
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f(x) = 
\backslash
{ ...
 f(y) ...
 
\backslash
}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "30col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset VSpace -64baselineskip%
\end_inset


\begin_inset Formula $f(x)\triangleq...~\overline{f}(y)~...$
\end_inset


\begin_inset VSpace 15baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f andThen g)(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f\bef g$
\end_inset

 and 
\begin_inset Formula $x\triangleright f\bef g$
\end_inset


\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.map(f).map(g)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $p\triangleright f^{\uparrow F}\triangleright g^{\uparrow F}$
\end_inset


\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

 
\begin_inset Formula $p\triangleright f^{\uparrow F}\bef g^{\uparrow F}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Refactored code: further examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Writing the previous examples as equations:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.3cm}
\end_layout

\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def toList[A]: Stream[A] => List[A]
\end_layout

\end_inset

 written as 
\size small

\begin_inset Formula $\text{toList}^{A}:\text{Str}^{A}\rightarrow\text{List}^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "26col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{\text{Str}^{A}\ar[r]\sp(0.55){\text{toList}^{A}}\ar[d]\sp(0.4){f^{\uparrow\text{Str}}} & \text{List}^{A}\ar[d]\sp(0.4){f^{\uparrow\text{List}}}\\
\xyScaleY{1.6pc}\xyScaleX{3.0pc}\text{Str}^{B}\ar[r]\sp(0.55){\text{toList}^{B}} & \text{List}^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "68col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.toList.map(f) == _.map(f).toList
\end_layout

\end_inset


\size small

\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow\text{Str}}\bef\text{toList}^{B}=\text{toList}^{A}\bef f^{\uparrow\text{List}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.3cm}
\end_layout

\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def filt[A]: (A => Boolean) => Stream[A] => Stream[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "26col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{\text{Str}^{A}\ar[r]\sp(0.55){\text{filt}^{A}(f\bef p)}\ar[d]\sp(0.4){f^{\uparrow\text{Str}}} & \text{Str}^{A}\ar[d]\sp(0.4){f^{\uparrow\text{Str}}}\\
\xyScaleY{1.6pc}\xyScaleX{3.0pc}\text{Str}^{B}\ar[r]\sp(0.55){\text{filt}^{B}(p)} & \text{Str}^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "68col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset Formula 
\begin{align*}
 & \text{filt}^{A}:(A\rightarrow\bbnum 2)\rightarrow\text{Str}^{A}\rightarrow\text{Str}^{A}\\
 & (f^{:A\rightarrow B})^{\uparrow\text{Str}}\bef\text{filt}^{B}(p^{:B\rightarrow\bbnum 2})=\text{filt}^{A}(f\bef p)\bef f^{\uparrow\text{Str}}
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.3cm}
\end_layout

\end_inset

A transformation before 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 equals a transformation after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This is called a 
\series bold
naturality law
\end_layout

\begin_layout Itemize
We expect it to hold if the code works the same way for all types
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws: equations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\series bold
Naturality law
\series default
 for a function 
\begin_inset Formula $t$
\end_inset

 is an equation involving an arbitrary function 
\begin_inset Formula $f$
\end_inset

 that permutes the order of application of 
\begin_inset Formula $t$
\end_inset

 and of a lifted 
\begin_inset Formula $f$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "26col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{\text{List}^{A}\ar[r]\sp(0.55){\text{headOpt}^{A}}\ar[d]\sp(0.4){f^{\uparrow\text{List}}} & \text{Opt}^{A}\ar[d]\sb(0.4){f^{\uparrow\text{Opt}}}\\
\xyScaleY{1.6pc}\xyScaleX{3.0pc}\text{List}^{B}\ar[r]\sp(0.55){\text{headOpt}^{B}} & \text{Opt}^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "68col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

list.map(f).headOption == list.headOption.map(f)
\end_layout

\end_inset


\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow\text{List}}\bef\text{headOpt}=\text{headOpt}\bef(f^{:A\rightarrow B})^{\uparrow\text{Opt}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Lifting 
\begin_inset Formula $f$
\end_inset

 before 
\begin_inset Formula $t$
\end_inset

 equals to lifting 
\begin_inset Formula $f$
\end_inset

 after 
\begin_inset Formula $t$
\end_inset


\end_layout

\begin_layout Itemize
Intuition: 
\begin_inset Formula $t$
\end_inset

 rearranges data in a collection, not looking at values
\end_layout

\begin_layout Standard
Further examples: 
\end_layout

\begin_layout Itemize
Reversing a list; 
\begin_inset Formula $\text{reverse}^{A}:\text{List}^{A}\rightarrow\text{List}^{A}$
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

list.map(f).reverse == list.reverse.map(f)
\end_layout

\end_inset


\size footnotesize

\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow\text{List}}\bef\text{reverse}^{B}=\text{reverse}^{A}\bef(f^{:A\rightarrow B})^{\uparrow\text{List}}
\]

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure[A]: A => L[A]
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $\text{pu}_{L}:A\rightarrow L^{A}$
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(x).map(f) == pure(f(x))
\end_layout

\end_inset


\size footnotesize

\begin_inset Formula 
\[
\text{pu}^{A}\bef(f^{:A\rightarrow B})^{\uparrow L}=f\bef\text{pu}^{B}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Reasoning with naturality: Simplifying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 for a functor 
\begin_inset Formula $L$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "26col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{A\ar[r]\sp(0.55){\text{pu}_{L}}\ar[d]\sp(0.4){f} & L^{A}\ar[d]\sp(0.4){f^{\uparrow L}}\\
\xyScaleY{1.6pc}\xyScaleX{3.0pc}B\ar[r]\sp(0.55){\text{pu}_{L}} & L^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "68col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(a).map(f) == pure(f(a))
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{pu}_{L}\bef f^{\uparrow L}=f\bef\text{pu}_{L}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.4cm}
\end_layout

\end_inset

Fix a value 
\begin_inset Formula $b^{:B}$
\end_inset

 and set 
\begin_inset Formula $A=\bbnum 1$
\end_inset

 and 
\begin_inset Formula $f\triangleq1\rightarrow b$
\end_inset

 in the naturality law:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "26col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{\bbnum 1\ar[r]\sp(0.55){\text{pu}_{L}}\ar[d]\sp(0.4){1\rightarrow b} & L^{\bbnum 1}\ar[d]\sp(0.4){(1\rightarrow b)^{\uparrow L}}\\
\xyScaleY{1.6pc}\xyScaleX{3.0pc}B\ar[r]\sp(0.55){\text{pu}_{L}} & L^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "68col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(()).map(_ => b) == pure(b)
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{pu}_{L}\bef(1\rightarrow b)^{\uparrow L}=(1\rightarrow b)\bef\text{pu}_{L}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.4cm}
\end_layout

\end_inset

We have expressed 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(b)
\end_layout

\end_inset

 via a constant value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(())
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[Unit]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 makes it equivalent to a 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value
\end_layout

\begin_layout Standard
This simplifies the definition of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 typeclass:
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

abstract class Pointed[L[_]: Functor] 
\backslash
{ def wu: L[Unit] 
\backslash
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Examples: for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wu = Some(())
\end_layout

\end_inset

.
 For 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wu = List(())
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws in typeclasses
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Another use of naturality laws is when implementing typeclasses
\end_layout

\begin_layout Itemize
Typeclasses require type constructors with methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, and others
\end_layout

\begin_layout Standard
To be useful for programming, the methods must satisfy certain laws
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

: identity, composition
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

: identity, composition, partial function, naturality
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 (traverse): identity, composition, naturality
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

: identity, associativity, naturality
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

: naturality
\end_layout

\begin_layout Standard
We need to check the laws when implementing new typeclass instances
\end_layout

\begin_layout Standard
Usually, typeclass instances are written in fully parametric code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Fully parametric code: example
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Fully parametric
\series default
 code: 
\begin_inset Quotes eld
\end_inset

works in the same way for all types
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Example of a fully parametric function:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def headOpt[A]: List[A] => Option[A] = 
\backslash
{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Nil => None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case head :: tail => Some(head)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The code does not use explicit types
\end_layout

\begin_layout Itemize
The same code in the matrix notation:
\begin_inset Formula 
\[
\text{headOpt}^{:\text{List}^{A}\rightarrow\bbnum 1+A}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times\text{List}^{A} & \bbnum 0 & h\times t\rightarrow h
\end{array}
\]

\end_inset

where 
\begin_inset Formula $\text{List}^{A}\triangleq\bbnum 1+A\times\text{List}^{A}$
\end_inset

 is a recursively defined type constructor: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

final case class List[A](x: Option[(A, List[A]])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Naturality laws express the programmer's intuition about the properties
 of fully parametric code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Example of code that is 
\emph on
not
\emph default
 fully parametric:
\end_layout

\begin_layout Itemize
An implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOpt
\end_layout

\end_inset

 that has special code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 type
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def headOptBad[A]: List[A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case Nil                   => None
\end_layout

\begin_layout Plain Layout

  case (head: Int) :: tail   => Some((head + 100).asInstanceOf[A])
\end_layout

\begin_layout Plain Layout

  case head :: tail          => Some(head)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\begin_layout Itemize
The code uses explicit run-time type detection
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOptBad
\end_layout

\end_inset

 fails the naturality law:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> headOptBad(List(1, 2, 3).map(x => s"value = $x"))
\end_layout

\begin_layout Plain Layout

res0: Option[String] = Some(value = 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> headOptBad(List(1, 2, 3)).map(x => s"value = $x")
\end_layout

\begin_layout Plain Layout

res1: Option[String] = Some(value = 101)
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Full parametricity: The price we pay for 
\begin_inset Quotes eld
\end_inset

free theorems
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Free theorems only apply to 
\series bold
fully parametric
\series default
 code:
\end_layout

\begin_layout Itemize
All argument types are combinations of type parameters
\end_layout

\begin_layout Itemize
All type parameters are treated as unknown, arbitrary types
\end_layout

\begin_layout Itemize
No hard-coded values of specific types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123: Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

: String
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
No side effects (printing, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

var x
\end_layout

\end_inset

, mutating values, writing files, networking, starting or stopping new threads,
 GUI events, etc.)
\end_layout

\begin_layout Itemize
No 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

, no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

ing of exceptions, no run-time type comparison
\end_layout

\begin_layout Itemize
No run-time code loading, no external libraries with unknown code
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Fully parametric
\begin_inset Quotes erd
\end_inset

 is a stronger restriction than 
\begin_inset Quotes eld
\end_inset

purely functional
\begin_inset Quotes erd
\end_inset

 (referentially transparent)
\end_layout

\begin_layout Standard
Purely functional code is fully parametric if restricted to using only 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type or type parameters
\end_layout

\begin_layout Itemize
No hard-coded values of specific types, and no run-time type detection
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace 200baselineskip%
\end_inset


\end_layout

\begin_layout Standard
Fully parametric programs are written using the 9 code constructions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = { // 3
\end_layout

\begin_layout Plain Layout

   case Nil            => Nil
\end_layout

\begin_layout Plain Layout

//   8   1                1,7 
\end_layout

\begin_layout Plain Layout

   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
\end_layout

\begin_layout Plain Layout

//   8       6             2 4     6  5 2 4     6    7   9
\end_layout

\begin_layout Plain Layout

}       // This code has used each of the nine allowed constructions.
\end_layout

\end_inset


\begin_inset VSpace -20baselineskip%
\end_inset


\end_layout

\begin_layout Enumerate
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value (or a 
\begin_inset Quotes eld
\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

), e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Enumerate
Use bound variable (a given argument of the function).
 Notation: 
\begin_inset Formula $x$
\end_inset


\end_layout

\begin_layout Enumerate
Create function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr(x) }
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $x\rightarrow\text{expr}\left(x\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Use function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $f(x)$
\end_inset

 or 
\begin_inset Formula $x\triangleright f$
\end_inset


\end_layout

\begin_layout Enumerate
Create tuple: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $a\times b$
\end_inset


\end_layout

\begin_layout Enumerate
Use tuple: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $\nabla_{1}p$
\end_inset

 or 
\begin_inset Formula $p\triangleright\nabla_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
Create disjunctive value: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset


\end_layout

\begin_layout Enumerate
Use disjunctive value: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...
 }
\end_layout

\end_inset

 (pattern-matching); matrix code
\end_layout

\begin_layout Enumerate
Use recursive call: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(tail)
\end_layout

\end_inset

.
 Notation: 
\begin_inset Formula $\overline{\text{fmap}_{\text{List}}}(f)(t)$
\end_inset


\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws and parametricity
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The 
\series bold
parametricity theorem
\series default
 guarantees that all naturality laws hold as long as the method's code is
 fully parametric
\end_layout

\begin_layout Itemize
This saves us time: 
\emph on
no need
\emph default
 to check the naturality laws
\end_layout

\begin_layout Standard
Using the parametricity theorem is difficult
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "Reynolds"
target "https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "Wadler"
target "https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf"
literal "false"

\end_inset

) approach needs to replace functions (one-to-one or many-to-one) by 
\begin_inset Quotes eld
\end_inset

relations
\begin_inset Quotes erd
\end_inset

 (many-to-many)
\end_layout

\begin_deeper
\begin_layout Itemize
Derive a law with relation variables, then replace them by functions
\end_layout

\end_deeper
\begin_layout Itemize
Alternative approach: analysis of dinatural transformations derives the
 naturality laws directly (
\begin_inset CommandInset href
LatexCommand href
name "Bainbridge et al."
target "https://www.sciencedirect.com/science/article/pii/0304397590901517"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "Backhouse"
target "https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions"
literal "false"

\end_inset

; 
\begin_inset CommandInset href
LatexCommand href
name "de Lataillade"
target "https://www.irif.fr/~delatail/dinat.pdf"
literal "false"

\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
See also a 
\begin_inset CommandInset href
LatexCommand href
name "2019 paper"
target "https://arxiv.org/pdf/1908.07776"
literal "false"

\end_inset

 by Voigtländer
\end_layout

\end_deeper
\begin_layout Itemize
Plan:
\end_layout

\begin_deeper
\begin_layout Itemize
Start with natural transformations
\end_layout

\begin_layout Itemize
Introduce profunctors and dinatural transformations
\end_layout

\begin_layout Itemize
Commutativity laws for bifunctors and profunctors
\end_layout

\begin_layout Itemize
Derive the naturality laws for dinatural transformations
\end_layout

\begin_layout Itemize
Uniqueness of functor typeclass instances
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Natural transformations and their laws
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A 
\series bold
natural transformation
\series default
 is a function 
\begin_inset Formula $t$
\end_inset

 with type signature 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

 that satisfies the naturality law 
\begin_inset Formula $f^{\uparrow F}\bef t=t\bef f^{\uparrow G}$
\end_inset

.
 Notation 
\begin_inset Formula $t:F\leadsto G$
\end_inset


\end_layout

\begin_layout Itemize
Many standard methods have the form of a natural transformation
\end_layout

\begin_deeper
\begin_layout Itemize
Examples: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lastOption
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If there are several type parameters, use one at a time:
\end_layout

\begin_deeper
\begin_layout Itemize
For 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, denote 
\begin_inset Formula $\text{flm}:\left(A\rightarrow M^{B}\right)\rightarrow M^{A}\rightarrow M^{B}$
\end_inset

, fix 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\text{flm}:F^{B}\rightarrow G^{B}$
\end_inset

 where 
\begin_inset Formula $F^{B}\triangleq A\rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $G^{B}\triangleq M^{A}\rightarrow M^{B}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The naturality law 
\begin_inset Formula $f^{\uparrow F}\bef\text{flm}=\text{flm}\bef f^{\uparrow G}$
\end_inset

 then gives the equation
\begin_inset Formula 
\[
\text{flm}\,(p^{:A\rightarrow M^{B}}\bef f^{\uparrow M})=\text{flm}\,(p^{:A\rightarrow M^{B}})\bef f^{\uparrow M}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The naturality law for 
\begin_inset Formula $t^{A}:F^{A}\rightarrow G^{A}$
\end_inset

 when 
\begin_inset Formula $F^{A}$
\end_inset

, 
\begin_inset Formula $G^{A}$
\end_inset

 are contrafunctors:
\end_layout

\begin_layout Standard
\begin_inset VSpace -20baselineskip%
\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{F^{A}\ar[r]\sp(0.55){t^{A}}\ar[d]\sp(0.4){(f^{:B\rightarrow A})^{\downarrow F}} & G^{A}\ar[d]\sp(0.4){f^{\downarrow G}}\\
\xyScaleY{1.7pc}\xyScaleX{3.5pc}F^{B}\ar[r]\sp(0.55){t^{B}} & G^{B}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
f^{\downarrow F}\bef t=t\bef f^{\downarrow G}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mnemonic rule: if 
\begin_inset Formula $t:F\leadsto G$
\end_inset

 then the lifting to 
\begin_inset Formula $F$
\end_inset

 is on the left, the lifting to 
\begin_inset Formula $G$
\end_inset

 is on the right
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Dinatural transformations and profunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Some methods do 
\emph on
not
\emph default
 have the type signature of the form 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find[A]: (A => Boolean) => List[A] => Option[A]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold[A, B]: List[A] => B => (A => B => B) => B
\end_layout

\end_inset

 with respect to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The type parameter is in contravariant and covariant positions at once
\end_layout

\begin_layout Itemize
This gives us neither a functor nor a contrafunctor
\end_layout

\end_deeper
\begin_layout Itemize
Solution: use a profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset

 (contravariant in 
\begin_inset Formula $X$
\end_inset

, covariant in 
\begin_inset Formula $Y$
\end_inset

) with equal type parameters: 
\begin_inset Formula $P^{A,A}$
\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
dinatural transformation
\series default
 is a function 
\begin_inset Formula $t$
\end_inset

 with type signature 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 that satisfies the naturality law 
\begin_inset Formula $f^{\downarrow P}\bef t\bef f^{\uparrow Q}=f^{\uparrow P}\bef t\bef f^{\downarrow Q}$
\end_inset

 where 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 are suitable profunctors
\end_layout

\begin_layout Itemize

\emph on
All pure functions
\emph default
 have the type signature of a dinatural transformation
\end_layout

\begin_layout Itemize

\emph on
All 
\emph default
naturality laws (also for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

) are derived in this way
\end_layout

\begin_layout Itemize
The corresponding naturality law is guaranteed by parametricity
\end_layout

\begin_layout Itemize
Proof of parametricity theorem is a direct proof that any pure function
 
\begin_inset Formula $t$
\end_inset

 satisfies its law, by induction on the code structure of 
\begin_inset Formula $t$
\end_inset


\end_layout

\begin_layout Itemize
The proof depends on the profunctor commutativity law and on the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 lifting codes for 
\begin_inset Formula $f^{\uparrow P}$
\end_inset

 and 
\begin_inset Formula $f^{\downarrow P}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructors with two type parameters
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
In particular: bifunctors and profunctors
\end_layout

\begin_layout Itemize
In Scala syntax: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A, B]
\end_layout

\end_inset

.
 Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type L[A, B] = Either[(A, B), B]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In the type notation: 
\begin_inset Formula $L^{A,B}$
\end_inset

.
 Example: 
\begin_inset Formula $L^{A,B}\triangleq A\times B+B$
\end_inset


\end_layout

\begin_layout Itemize
If a type constructor is fully parametric, its type parameters will be either
 in covariant or in contravariant positions
\end_layout

\begin_layout Itemize

\series bold
Bifunctors
\series default
: both type parameters are always in covariant positions
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type L[A, B] = Either[(A, B), B]
\end_layout

\end_inset

 is a bifunctor
\end_layout

\begin_layout Itemize
Method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap[A, B, C, D](f: A => C)(g: B => D): L[A, B] => L[C, D]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Laws: identity and composition for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Profunctors
\series default
: one type parameter contravariant, the other covariant
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type P[X, Y] = Option[X] => (Y, Y)
\end_layout

\end_inset

 or 
\size footnotesize

\begin_inset Formula $P^{X,Y}\triangleq\bbnum 1+X\rightarrow Y\times Y$
\end_inset


\end_layout

\begin_layout Itemize
Method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap[A, B, C, D](f: C => A)(g: B => D): P[A, B] => P[C, D]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Laws: identity and composition for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A, B]
\end_layout

\end_inset

 is a functor separately in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, is it a bifunctor?
\end_layout

\begin_layout Itemize
If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A, B]
\end_layout

\end_inset

 is contravariant in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and covariant in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, is it a profunctor?
\end_layout

\begin_layout Itemize
They are — as long as all liftings in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 commute with liftings in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
These are the 
\begin_inset Quotes eld
\end_inset

commutativity laws
\begin_inset Quotes erd
\end_inset

 of bifunctors and profunctors
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to bifunctors and profunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method can be applied with respect to only one type parameter
\end_layout

\begin_layout Itemize
In a bifunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A, B]
\end_layout

\end_inset

, fix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Denote the resulting functor by 
\begin_inset Formula $L^{\bullet,B}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In the Scala syntax with 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[?, B]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Lifting a function 
\begin_inset Formula $f^{:U\rightarrow V}$
\end_inset

 is denoted by 
\begin_inset Formula $f^{\uparrow L^{\bullet,B}}:L^{U,B}\rightarrow L^{V,B}$
\end_inset


\end_layout

\begin_layout Itemize
If fixing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead, a lifting is denoted by 
\begin_inset Formula $f^{\uparrow L^{A,\bullet}}:L^{A,U}\rightarrow L^{A,V}$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Commutativity law
\series default
 for bifunctors: 
\size footnotesize

\begin_inset Formula $f^{\uparrow L^{\bullet,B}}\bef(g^{:B\rightarrow C})^{\uparrow L^{V,\bullet}}=g^{\uparrow L^{U,\bullet}}\bef f^{\uparrow L^{\bullet,C}}$
\end_inset


\size default
 
\end_layout

\end_deeper
\begin_layout Itemize
In a profunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A, B]
\end_layout

\end_inset

, fix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 The resulting 
\emph on
contrafunctor
\emph default
 is 
\begin_inset Formula $P^{\bullet,B}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Lifting a function 
\begin_inset Formula $f^{:U\rightarrow V}$
\end_inset

 is denoted by 
\begin_inset Formula $f^{\downarrow P^{\bullet,B}}:P^{V,B}\rightarrow P^{U,B}$
\end_inset


\end_layout

\begin_layout Itemize
If fixing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead, a lifting is denoted by 
\begin_inset Formula $f^{\uparrow P^{A,\bullet}}:P^{A,U}\rightarrow P^{A,V}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
For brevity, we may denote these liftings by 
\begin_inset Formula $f^{\downarrow P}$
\end_inset

 and 
\begin_inset Formula $f^{\uparrow P}$
\end_inset

 unambiguously
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Commutativity law
\series default
 for profunctors: 
\size footnotesize

\begin_inset Formula $f^{\downarrow P}\bef g^{\uparrow P}=g^{\uparrow P}\bef f^{\downarrow P}$
\end_inset


\size default
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{6.0pc}P^{A,B}\ar[r]\sb(0.55){(f^{:C\rightarrow A})^{\downarrow P}~~~}\ar[d]\sb(0.45){(g^{:B\rightarrow D})^{\uparrow P}} & P^{C,B}\ar[d]\sp(0.45){(g^{:B\rightarrow D})^{\uparrow P}}\\
P^{A,D}\ar[r]\sp(0.45){~~~~(f^{:C\rightarrow A})^{\downarrow P}} & P^{C,D}
}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Commutativity laws hold for 
\emph on
all
\emph default
 fully parametric type constructors 
\end_layout

\begin_deeper
\begin_layout Itemize
It is not necessary to verify the bifunctor and profunctor laws!
\end_layout

\end_deeper
\begin_layout Itemize
Proof is by induction on the type structure of 
\begin_inset Formula $P^{X,Y}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of the composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
If 
\begin_inset Formula $P^{A,B}$
\end_inset

 is a functor in 
\begin_inset Formula $a$
\end_inset

 and a contrafunctor in 
\begin_inset Formula $B$
\end_inset

, define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset

 by:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{8.0pc}P^{A,B}\ar[rd]\sb(0.55){\text{xmap}\left(f\right)\left(g\right)\,\triangleq~~~}\ar[r]\sp(0.55){(f^{:C\rightarrow A})^{\downarrow P}~~~} & P^{C,B}\ar[d]\sb(0.4){g^{\uparrow P}}\\
 & P^{C,D}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Formula 
\[
\text{xmap}\,(f^{:C\rightarrow A})\,(g^{:B\rightarrow D})\triangleq f^{\downarrow P}\bef g^{\uparrow P}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset

 composition law: 
\begin_inset Formula 
\[
\text{xmap}\left(f_{1}\right)\left(g_{1}\right)\bef\text{xmap}\left(f_{2}\right)\left(g_{2}\right)=\text{xmap}\left(f_{2}\bef f_{1}\right)\left(g_{1}\bef g_{2}\right)
\]

\end_inset

Proof uses the commutativity law, 
\begin_inset Formula $f^{\downarrow P}\bef g^{\uparrow P}=g^{\uparrow P}\bef f^{\downarrow P}$
\end_inset

, for 
\begin_inset Formula $f_{2}$
\end_inset

 and 
\begin_inset Formula $g_{1}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{xmap}\left(f_{1}\right)\left(g_{1}\right)\bef\text{xmap}\left(f_{2}\right)\left(g_{2}\right)=f_{1}^{\downarrow P}\bef\gunderline{g_{1}^{\uparrow P}\bef f_{2}^{\downarrow P}}\bef g_{2}^{\uparrow P}\\
 & =\gunderline{f_{1}^{\downarrow P}\bef f_{2}^{\downarrow P}}\bef\gunderline{g_{1}^{\uparrow P}\bef g_{2}^{\uparrow P}}=\left(f_{2}\bef f_{1}\right)^{\downarrow P}\bef\left(g_{1}\bef g_{2}\right)^{\uparrow P}\\
 & =\text{xmap}\left(f_{2}\bef f_{1}\right)\left(g_{1}\bef g_{2}\right)
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The naturality law for dinatural transformations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Given two profunctors 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

 and a function 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 
\end_layout

\begin_layout Standard
The naturality law is an equation for functions 
\begin_inset Formula $P^{B,A}\rightarrow Q^{A,B}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{!}{=}f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}
\]

\end_inset

Both sides must give the same result when applied to arbitrary 
\begin_inset Formula $p:P^{B,A}$
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{2.5pc} & P^{A,A}\ar[r]\sp(0.5){t^{A}} & Q^{A,A}\ar[rd]\sb(0.4){f^{\uparrow Q^{A,\bullet}}\negthickspace\negthickspace}\\
P^{B,A}\ar[rd]\sp(0.55){~f^{\uparrow P^{B,\bullet}}}\ar[ru]\sb(0.65){\negthickspace\negthickspace\negthickspace f^{\downarrow P^{\bullet,A}}} &  &  & Q^{A,B}\\
 & P^{B,B}\ar[r]\sp(0.5){t^{B}} & Q^{B,B}\ar[ru]\sp(0.45){f^{\downarrow Q^{\bullet,B}}\negthickspace\negthickspace}
}
\]

\end_inset

This law reduces to natural transformation laws when 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are functors or contrafunctors
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: writing the naturality law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def filter[A]: (A => Boolean) => F[A] => F[A]
\end_layout

\end_inset

 for a filterable functor 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Standard
Notation: 
\begin_inset Formula $\text{filt}^{A}:\left(A\rightarrow\bbnum 2\right)\rightarrow F^{A}\rightarrow F^{A}$
\end_inset

 (the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 is 
\begin_inset Formula $\bbnum 2=\bbnum 1+\bbnum 1$
\end_inset

)
\end_layout

\begin_layout Standard
Rewrite in the form of a dinatural transformation: 
\begin_inset Formula 
\[
\text{filt}^{A}:P^{A,A}\rightarrow Q^{A,A}\quad,\quad P^{X,Y}\triangleq X\rightarrow\bbnum 2\quad,\quad Q^{X,Y}\triangleq F^{X}\rightarrow F^{Y}
\]

\end_inset

Write the code for the liftings using the specific types of 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\begin{align*}
(f^{:A\rightarrow B})^{\downarrow P^{\bullet,A}}=p^{:B\rightarrow\bbnum 2}\rightarrow f\bef p\quad, & \quad\quad f^{\uparrow P^{B,\bullet}}=\text{id}\quad,\\
(f^{:A\rightarrow B})^{\downarrow Q^{\bullet,B}}=q^{:F^{B}\rightarrow F^{B}}\rightarrow f^{\uparrow F}\bef q\quad, & \quad\quad f^{\uparrow Q^{A,\bullet}}=q^{:F^{A}\rightarrow F^{A}}\rightarrow q\bef f^{\uparrow F}\quad.
\end{align*}

\end_inset

Rewrite the naturality law 
\begin_inset Formula $f^{\downarrow P^{\bullet,A}}\bef\text{filt}^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{!}{=}f^{\uparrow P^{B,\bullet}}\bef\text{filt}^{B}\bef f^{\downarrow Q^{\bullet,B}}$
\end_inset

 as
\begin_inset Formula 
\[
(p\rightarrow f\bef p)\bef\text{filt}\bef(q\rightarrow q\bef f^{\uparrow F})\overset{!}{=}\text{id}\bef\text{filt}\bef(q\rightarrow f^{\uparrow F}\bef q)\quad.
\]

\end_inset

To simplify this equation, apply both sides to an arbitrary value 
\begin_inset Formula $p^{:P^{B,A}}$
\end_inset


\end_layout

\begin_layout Standard
Evaluate the results and obtain the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{filt}\,(f\bef p)\bef f^{\uparrow F}\overset{!}{=}f^{\uparrow F}\bef\text{filt}\,(p)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Uniqueness of functor implementations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Consequences of the parametricity theorem:
\end_layout

\begin_layout Standard

\series bold
Statement 1
\series default
: For any fully parametric type constructor 
\begin_inset Formula $F^{A}$
\end_inset

 covariant in 
\begin_inset Formula $A$
\end_inset

, there is a unique lawful and fully parametric implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap[A, B]: (A => B) => F[A] => F[B]
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Statement 2
\series default
: For any fully parametric type constructor 
\begin_inset Formula $F^{A}$
\end_inset

 contravariant in 
\begin_inset Formula $A$
\end_inset

, there is a unique lawful and fully parametric implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap[A, B]: (B => A) => F[A] => F[B]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Note: many typeclasses may admit several lawful, fully parametric, but non-equiv
alent implementations of a typeclass instance for the same type constructor
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Applicative
\end_layout

\end_inset

 instances are not always unique.
 But instances are unique for the functor and contrafunctor type classes.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of Statement 1 (uniqueness of functor instances)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For a given functor 
\begin_inset Formula $F$
\end_inset

, we can construct the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\text{fmap}$
\end_inset

 (denoted by 
\begin_inset Formula $...^{\uparrow F}$
\end_inset

) that is involved in the naturality laws
\end_layout

\begin_layout Standard
Suppose that there exists 
\emph on
another
\emph default
 lawful and fully parametric implementation 
\begin_inset Formula $\text{fmap}^{\prime}(f)$
\end_inset

:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}^{\prime}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}\quad,\quad\quad\text{fmap}^{\prime}(f^{:A\rightarrow B})=\text{???}^{:F^{A}\rightarrow F^{B}}
\]

\end_inset


\size default
We need to show that 
\begin_inset Formula $\text{fmap}^{\prime}=\text{fmap}$
\end_inset


\end_layout

\begin_layout Standard
By parametricity, 
\begin_inset Formula $\text{fmap}^{\prime}$
\end_inset

 has a naturality law with respect to 
\begin_inset Formula $B$
\end_inset

:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}\text{fmap}^{\prime}(f)\bef g^{\uparrow F}=\text{fmap}^{\prime}(f)\bef\text{fmap}\left(g\right)
\]

\end_inset


\size default
 This suggests using the composition law for 
\begin_inset Formula $\text{fmap}^{\prime}$
\end_inset

:
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}^{\prime}(f\bef g)=\text{fmap}^{\prime}(f)\bef\text{fmap}^{\prime}(g)\overset{!}{=}\text{fmap}^{\prime}(f)\bef\text{fmap}\left(g\right)
\]

\end_inset


\size default
Since 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is arbitrary, we may choose 
\begin_inset Formula $A=B$
\end_inset

 and 
\begin_inset Formula $f=\text{id}^{:B\rightarrow B}$
\end_inset

 to obtain
\size footnotesize

\begin_inset Formula 
\[
\gunderline{\text{fmap}^{\prime}(\text{id})}\bef\text{fmap}^{\prime}(g)=\text{fmap}^{\prime}(g)\overset{!}{=}\gunderline{\text{fmap}^{\prime}(\text{id})}\bef\text{fmap}\left(g\right)=\text{fmap}(g)
\]

\end_inset


\size default
This must hold for arbitrary 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, which proves that 
\begin_inset Formula $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Plan for a proof of commutativity law for profunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Main idea: induction on the type expression of a profunctor 
\begin_inset Formula $P^{X,Y}$
\end_inset


\end_layout

\begin_layout Itemize
A fully parametric 
\begin_inset Formula $P^{X,Y}$
\end_inset

 must be a combination of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type (
\begin_inset Formula $\bbnum 1$
\end_inset

), parameters 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

, products 
\begin_inset Formula $A\times B$
\end_inset

, co-products 
\begin_inset Formula $A+B$
\end_inset

, exponentials 
\begin_inset Formula $A\rightarrow B$
\end_inset

, and type recursion (use of 
\begin_inset Formula $P$
\end_inset

 in its definition)
\end_layout

\begin_layout Itemize
For each of these cases, we need to show that the commutativity law holds
 given that it holds for all sub-expressions
\end_layout

\begin_deeper
\begin_layout Itemize
Base case: show that the law holds for 
\begin_inset Formula $P^{X,Y}\triangleq\bbnum 1$
\end_inset

 and 
\begin_inset Formula $P^{X,Y}\triangleq Y$
\end_inset


\end_layout

\begin_layout Itemize
Induction steps: if the law holds for 
\begin_inset Formula $P^{X,Y}$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}$
\end_inset

, show that it also holds for 
\begin_inset Formula $P^{X,Y}+Q^{X,Y}$
\end_inset

 and 
\begin_inset Formula $P^{X,Y}\times Q^{X,Y}$
\end_inset

 and 
\begin_inset Formula $P^{Y,X}\rightarrow Q^{X,Y}$
\end_inset


\end_layout

\begin_layout Itemize
Show that the law holds for a recursively defined 
\begin_inset Formula $P^{X,Y}\triangleq S^{X,Y,P^{X,Y}}$
\end_inset

 for a type constructor 
\begin_inset Formula $S^{X,Y,R}$
\end_inset

 contravariant in 
\begin_inset Formula $X$
\end_inset

, covariant in 
\begin_inset Formula $Y$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Itemize
We need to use the code of functor and contrafunctor instances for products,
 co-products, function types, and recursive types
\end_layout

\end_deeper
\begin_layout Itemize
Example: For 
\begin_inset Formula $R^{X,Y}\triangleq P^{X,Y}\times Q^{X,Y}$
\end_inset

, the liftings to 
\begin_inset Formula $R$
\end_inset

 are given by 
\size footnotesize

\begin_inset Formula $f^{\uparrow R}\triangleq p\times q\rightarrow f^{\uparrow P}(p)\times f^{\uparrow Q}(q)$
\end_inset


\size default
 and 
\size footnotesize

\begin_inset Formula $f^{\downarrow R}\triangleq p\times q\rightarrow f^{\downarrow P}(p)\times f^{\downarrow Q}(q)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Write 
\begin_inset Formula $f^{\downarrow R}\bef g^{\uparrow R}$
\end_inset

 explicitly using 
\begin_inset Formula $f^{\downarrow P}$
\end_inset

, 
\begin_inset Formula $f^{\downarrow Q}$
\end_inset

, 
\begin_inset Formula $g^{\uparrow P}$
\end_inset

, and 
\begin_inset Formula $g^{\uparrow Q}$
\end_inset

, and show that 
\begin_inset Formula $f^{\downarrow R}\bef g^{\uparrow R}=g^{\uparrow R}\bef f^{\downarrow R}$
\end_inset

 by assuming that the same law already holds for 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Plan for a proof of parametricity theorem
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Need to prove the naturality law for 
\begin_inset Formula $t^{A}:P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 written as
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}=f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}
\]

\end_inset


\end_layout

\begin_layout Itemize
The code of 
\begin_inset Formula $t$
\end_inset

 must be of the form 
\begin_inset Formula $p\rightarrow\text{expr}$
\end_inset

, where 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{expr}$
\end_inset


\begin_inset Quotes erd
\end_inset

 must be built up from some of the nine constructions
\end_layout

\begin_layout Itemize
Main idea: induction on the code of 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{expr}$
\end_inset


\begin_inset Quotes erd
\end_inset

, assuming that the naturality law holds for all sub-expressions
\end_layout

\begin_layout Itemize
Example: induction step for code construction 3 (
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
The code of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $p\rightarrow z\rightarrow r$
\end_inset

 and 
\begin_inset Formula $Q^{X,Y}\triangleq Z^{Y,X}\rightarrow R^{X,Y}$
\end_inset

 
\end_layout

\begin_layout Itemize
Inductive assumption is that any 
\begin_inset Formula $x\rightarrow r$
\end_inset

 satisfies the law; let 
\begin_inset Formula $x=p\times z$
\end_inset


\end_layout

\begin_layout Itemize
Assume that the law holds for 
\begin_inset Formula $u\triangleq p\times z\rightarrow r$
\end_inset

, 
\begin_inset Formula $u:P^{A,A}\times Z^{A,A}\rightarrow R^{A,A}$
\end_inset


\end_layout

\begin_layout Itemize
Derive the law for 
\begin_inset Formula $t=p\rightarrow z\rightarrow u(p\times z)$
\end_inset

 by a direct calculation
\end_layout

\end_deeper
\begin_layout Itemize
There are some technical difficulties (dinatural transformations do not
 generally compose) but these difficulties can be overcome with tricks
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Fully parametric code enables powerful mathematical reasoning:
\end_layout

\begin_deeper
\begin_layout Itemize
Naturality laws can be used for guaranteed correct refactoring
\end_layout

\begin_layout Itemize
Naturality laws allow us to reduce the number of type parameters
\end_layout

\begin_layout Itemize
In typeclass instances, all naturality laws hold, no need to check
\end_layout

\begin_layout Itemize
Functor, contrafunctor, and profunctor typeclass instances are unique
\end_layout

\begin_layout Itemize
Bifunctors and profunctors obey the commutativity law
\end_layout

\end_deeper
\begin_layout Itemize
Full details and proofs are in the free upcoming book (Appendix D)
\end_layout

\begin_deeper
\begin_layout Itemize
Draft of the book: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
