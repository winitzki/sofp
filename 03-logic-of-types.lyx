#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types]{Chapter 3: The Logic of Types}
\author{Sergei Winitzki}
\date{November 22, 2017}
\institute[ABTB]{Academy by the Bay}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tuples with names, or 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Pair of values: 
\family typewriter
\size footnotesize
\color blue
val a:
\begin_inset space \space{}
\end_inset

(Int, String) = (123, "xyz")
\end_layout

\begin_layout Itemize
For 
\emph on
convenience
\emph default
, we can define a name for this type:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue
type MyPair = (Int, String); val a:
\begin_inset space \space{}
\end_inset

MyPair = (123, "xyz")
\end_layout

\begin_layout Itemize
We can define a name for each value and also for the type:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class MySocks(size:
\begin_inset space \space{}
\end_inset

Double, color:
\begin_inset space \space{}
\end_inset

String)
\begin_inset Newline newline
\end_inset

val a:
\begin_inset space \space{}
\end_inset

MySocks = MySocks(10.5, "white")
\end_layout

\begin_layout Itemize
Case classes can be nested: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class BagOfSocks(socks:
\begin_inset space \space{}
\end_inset

MySocks, count:
\begin_inset space \space{}
\end_inset

Int)
\begin_inset Newline newline
\end_inset

val bag = BagOfSocks(MySocks(10.5, "white"), 6)
\end_layout

\begin_layout Itemize
Parts of the case class can be accessed by name: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

val c:
\begin_inset space \space{}
\end_inset

String = bag.socks.color
\end_layout

\begin_layout Itemize
Parts can be given in any order by using names:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

val y = MySocks(color = "black", size = 11.0) 
\end_layout

\begin_layout Itemize
Default values can be defined for parts: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class Shirt(color:
\begin_inset space \space{}
\end_inset

String = "blue", hasHoles:
\begin_inset space \space{}
\end_inset

Boolean = false)
\begin_inset Newline newline
\end_inset

val sock = Shirt(hasHoles = true)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tuples with one element and with zero elements
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A tuple type expression 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\family default
\size default
\color inherit
 is special syntax for parameterized type 
\family typewriter
\size footnotesize
\color blue
Tuple2[Int, String]
\end_layout

\begin_layout Itemize
Case class with no parts is called a 
\begin_inset Quotes eld
\end_inset

case object
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
What are tuples with one element or with zero elements?
\end_layout

\begin_deeper
\begin_layout Itemize
There is no 
\family typewriter
\size footnotesize
\color blue
Tuple0
\family default
\size default
\color inherit
 – it is a special type called 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tuples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Case classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(123, "xyz"):
\begin_inset space \space{}
\end_inset

Tuple2[Int, String]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case class A(x:
\begin_inset space \space{}
\end_inset

Int, y:
\begin_inset space \space{}
\end_inset

String)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(123,):
\begin_inset space \space{}
\end_inset

Tuple1[Int]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case class B(z:
\begin_inset space \space{}
\end_inset

Int)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(): Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
case object C
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Case classes can have one or more type parameters: 
\begin_inset Newline newline
\end_inset


\family typewriter
\size footnotesize
\color blue
case class Pairs[A, B](left:
\begin_inset space \space{}
\end_inset

A, right:
\begin_inset space \space{}
\end_inset

B, count:
\begin_inset space \space{}
\end_inset

Int)
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
\size footnotesize
\color blue
Tuple
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 types could be defined by this code:
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

case class Tuple2[A, B](_1:
\begin_inset space \space{}
\end_inset

A, _2:
\begin_inset space \space{}
\end_inset

B)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Pattern-matching syntax for case classes
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Scala allows pattern matching in two places:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val 
\family default
\emph on
pattern
\family typewriter
\emph default
 = ...

\family default
\size default
\color inherit
 (value assignment)
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
case 
\family default
\emph on
pattern
\family typewriter
\emph default
 
\family default

\begin_inset Formula $\Rightarrow$
\end_inset


\family typewriter
 ...

\family default
\size default
\color inherit
 (partial function)
\end_layout

\begin_layout Standard
Examples with case classes:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val a = MySocks(10.5, "white")
\begin_inset Newline newline
\end_inset

val MySocks(x, y) = a
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
val f:
\begin_inset space \space{}
\end_inset

BagOfSocks
\begin_inset Formula $\Rightarrow$
\end_inset

Int = { case BagOfSocks(MySocks(s, c), z)
\begin_inset Formula $\Rightarrow$
\end_inset

...}
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
def f(b:
\begin_inset space \space{}
\end_inset

BagOfSocks):
\begin_inset space \space{}
\end_inset

String = b match { 
\begin_inset Newline newline
\end_inset


\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

case BagOfSocks(MySocks(s, c), z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 c
\begin_inset Newline newline
\end_inset

}
\end_layout

\begin_layout Itemize
Note: 
\family typewriter
\size footnotesize
\color blue
s
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
c
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
z
\family default
\size default
\color inherit
 are defined as 
\series bold
pattern variables
\series default
 of correct types
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Disjunction type: 
\family typewriter
Either[A, B]
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Example: 
\family typewriter
\size footnotesize
\color blue
Either[String, Int]
\family default
\size default
\color inherit
 (may be used for error reporting)
\end_layout

\begin_layout Itemize
Represents a value that is 
\emph on
either
\emph default
 a 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 or an 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 (but not both)
\end_layout

\begin_layout Itemize
Example values: 
\family typewriter
\size footnotesize
\color blue
Left("blah")
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
Right(123)
\end_layout

\begin_layout Itemize
Use pattern matching to distinguish 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

 from 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def logError(x: Either[String, Int]): Int = x match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Left(error) 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"Got error: $error"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Right(res) 
\begin_inset Formula $\Rightarrow$
\end_inset

 res
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\family sans
\color gray
 // Left(
\begin_inset Quotes eld
\end_inset

blah
\begin_inset Quotes erd
\end_inset

) and Right(123) are possible values of type Either[String, Int]
\end_layout

\begin_layout Itemize
Now 
\family typewriter
\size footnotesize
\color blue
logError(Right(123))
\family default
\size default
\color inherit
 returns 
\family typewriter
\size footnotesize
\color blue
123
\family default
\size default
\color inherit
 while 
\family typewriter
\size footnotesize
\color blue
logError(Left("bad result"))
\family default
\size default
\color inherit
 prints the error and returns 
\family typewriter
\size footnotesize
\color blue
-1
\end_layout

\begin_layout Itemize
The 
\family typewriter
\size footnotesize
\color blue
case
\family default
\size default
\color inherit
 expression chooses among possible values of a given type
\end_layout

\begin_deeper
\begin_layout Itemize
Note the similarity with this code:
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f(x: Int): Int = x match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case 0 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"error: must be nonzero"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case 1 
\begin_inset Formula $\Rightarrow$
\end_inset

 println(s"error: must be greater than 1"); -1
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case res 
\begin_inset Formula $\Rightarrow$
\end_inset

 res
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\family sans
\color gray
 //0 and 1 are possible values of type Int
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
More general disjunction types: using case classes
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A future version of Scala 3 has a short syntax for disjunction types:
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
type MyIntOrStr = Int | String
\end_layout

\begin_layout Itemize
more generally, 
\family typewriter
\size footnotesize
\color blue
type MyType = List[Int] | (Int, Boolean) | MySocks
\end_layout

\begin_deeper
\begin_layout Itemize
Some (experimental) Scala libraries also provide shorter syntax
\end_layout

\end_deeper
\begin_layout Standard
For now, in Scala 2, we use the 
\begin_inset Quotes eld
\end_inset

long syntax
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
(specify a name for each case and for each part, use 
\begin_inset Quotes eld
\end_inset

trait
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

extends
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class HaveListInt(x: List[Int]) extends MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class HaveIntBool(s: Int, b: Boolean) extends MyType
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class HaveSocks(socks: MySocks) extends MyType
\end_layout

\begin_layout Standard
Pattern-matching example:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val x: MyType = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case HaveListInt(lst) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case HaveIntBool(p, q) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case HaveSocks(s) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Types and propositional logic
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
The Curry-Howard correspondence
\end_layout

\begin_layout Standard
This code:
\family typewriter
\size footnotesize
\color blue
 val x:
\begin_inset space \space{}
\end_inset

T = ...

\family default
\size default
\color inherit
 means that we can compute a value of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 as part of our program
\end_layout

\begin_layout Itemize
Let's denote this 
\emph on
proposition
\emph default
 by 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 – 
\begin_inset Quotes eld
\end_inset

Code Has a value of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
We have the following correspondence:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Short notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(T)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
or
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\oplus B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
implies
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Nothing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
type parameter 
\family typewriter
\size footnotesize
\color blue
[T]
\family default
\size default
\color inherit
 means 
\begin_inset Formula $\forall T$
\end_inset

, for example the type of the function
\family typewriter
\size footnotesize
\color blue

\begin_inset Newline newline
\end_inset

def dupl[A](x:
\begin_inset space \space{}
\end_inset

A):
\begin_inset space \space{}
\end_inset

(A, A)
\family default
\size default
\color inherit
 corresponds to the (valid) proposition:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A:A\Rightarrow A\times A$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Example 1:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetName(first: String, last: String) extends UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetEmail(email: String) extends UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetUserId(id: Long) extends UserAction
\end_layout

\begin_layout Itemize
Short notation: 
\family typewriter
\size footnotesize
\color blue
UserAction
\family default
\size default
\color inherit
 
\begin_inset Formula $=$
\end_inset

 (
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\begin_inset Formula $\times$
\end_inset

 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
)
\family typewriter
\size footnotesize
\color blue
 
\begin_inset Formula $\oplus$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula $\oplus$
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size footnotesize
\color blue
Long
\end_layout

\begin_layout Itemize
Example 2: parameterized type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Left[A, B, C](x: A) extends Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Middle[A, B, C](x: B) extends Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Right[A, B, C](x: C) extends Either3[A, B, C]
\end_layout

\begin_layout Itemize
Short notation: 
\begin_inset Formula $\forall A\forall B\forall C:$
\end_inset

 Either3
\begin_inset Formula $[A,B,C]=A\oplus B\oplus C$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Using known properties of propositional logic
\end_layout

\begin_layout Itemize
Some standard identities in logic:
\begin_inset Formula 
\begin{align*}
A\times1 & =A\\
A+1 & =1\\
(A\times B)\times C & =A\times(B\times C)\\
(A\oplus B)\oplus C & =A\oplus(B\oplus C)\\
A\times(B\oplus C) & =(A\times B)\oplus(A\times C)\\
A\oplus(B\times C) & =(A\oplus B)\times(A\oplus C)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Each identity gives functions that map both ways
\end_layout

\begin_layout Itemize
Some of these identities yield 
\emph on
isomorphisms of types
\end_layout

\begin_deeper
\begin_layout Itemize
Which ones do 
\emph on
not
\emph default
 yield isomorphisms, and why?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Algebraic computations with types
\end_layout

\begin_layout Itemize
Example 3: Recursive type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait IntList
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case object Empty extends IntList
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Nonempty(head: Int, tail: IntList) extends IntList
\end_layout

\begin_layout Itemize
Short notation: (the sign 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $=$
\end_inset


\begin_inset Quotes erd
\end_inset

 here means type isomorphism)
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula 
\begin{align*}
\text{IntList} & =1+\text{Int}\times\text{IntList}=1+\text{Int}\times(1+\text{Int}\times(1+\text{Int}\times(...)...)\\
 & =1+\text{Int}+\text{Int}\times\text{Int}+\text{Int}\times\text{Int}\times\text{Int}+...
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Any valid proposition can be implemented in code
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def identity[A](x:A):A = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def toUnit[A](x:A): Unit = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow A\,|\,B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def inLeft[A,B](x:A):Either[A,B] = Left(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\,\&\,B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def first[A,B](p:(A,B)):A = p._1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow(B\Rightarrow A)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def const[A,B](x:A):B
\begin_inset Formula $\Rightarrow$
\end_inset

A = (y:B)
\begin_inset Formula $\Rightarrow$
\end_inset

x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Invalid propositions 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_deeper
\begin_layout Itemize
Examples:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\Rightarrow A$
\end_inset

; 
\begin_inset Formula $\forall A\forall B:A\,|\,B\Rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\Rightarrow A\,\&\,B$
\end_inset

; 
\begin_inset Formula $\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Given a type, can we decide whether it is implementable?
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\forall A\forall B:((((A\Rightarrow B)\Rightarrow B)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Propositional constructive logic has a decision algorithm
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for programming language design
\end_layout

\begin_layout Itemize
The CH correspondence maps the type system of each programming language
 into a certain system of logical propositions 
\end_layout

\begin_layout Itemize
Scala, Haskell, OCaml, F#, Swift, Rust, etc.
\begin_inset space ~
\end_inset

are mapped into the full constructive logic (all logical operations are
 available)
\end_layout

\begin_deeper
\begin_layout Itemize
C, C++, Java, C#, etc.
\begin_inset space ~
\end_inset

are mapped to 
\emph on
incomplete
\emph default
 logics – without 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

 and without 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Python, JavaScript, Ruby, Clojure, etc.
\begin_inset space ~
\end_inset

have only one type (
\begin_inset Quotes eld
\end_inset

any value
\begin_inset Quotes erd
\end_inset

) and are mapped to logics with only one proposition
\end_layout

\end_deeper
\begin_layout Itemize
The CH correspondence is a principle for designing type systems:
\end_layout

\begin_deeper
\begin_layout Itemize
Choose a complete logic, free of inconsistency
\end_layout

\begin_deeper
\begin_layout Itemize
Mathematicians have studied all kinds of logics and determined which ones
 are interesting, and found the minimal sets of axioms for them
\end_layout

\end_deeper
\begin_layout Itemize
Provide a type constructor for each basic operation (e.g.
\begin_inset space ~
\end_inset


\begin_inset Quotes eld
\end_inset


\emph on
or
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
and
\emph default

\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
What problems can we solve now?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
What problems can we solve now?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
a
\end_layout

\end_deeper
\begin_layout Frame

\end_layout

\end_body
\end_document
