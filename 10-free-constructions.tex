\batchmode
\makeatletter
\def\input@path{{/Users/sergei.winitzki/Code/talks/ftt-fp/}}
\makeatother
\documentclass[english,,russian]{beamer}
\usepackage[T2A,T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{tipa}
\usepackage{tipx}
\usepackage{amsmath}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
% this default might be overridden by plain title style
\newcommand\makebeamertitle{\frame{\maketitle}}%
% (ERT) argument for the TOC
\AtBeginDocument{%
  \let\origtableofcontents=\tableofcontents
  \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
  \def\gobbletableofcontents#1{\origtableofcontents}
}
\newenvironment{lyxcode}
  {\par\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \setlength{\listparindent}{0pt}% needed for AMS classes
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \normalfont\ttfamily}%
   \def\{{\char`\{}
   \def\}{\char`\}}
   \def\textasciitilde{\char`\~}
   \item[]}
  {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 10: Free type constructions]{Chapter 10: Free type constructions}
%\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-11-22}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\usepackage[nocenter]{qtree}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY
\newcommand{\shui}{\begin{CJK}{UTF8}{gbsn}水\end{CJK}}
\usepackage{CJKutf8} % For occasional Chinese characters. Also, add "russian" to documentclass.

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{The interpreter pattern I. Expression trees}

Main idea: Represent a program as a data structure, run it later
\begin{itemize}
\item Example: a simple DSL for complex numbers
\end{itemize}
\vspace{-0.35cm}%
\begin{minipage}[t]{0.35\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~a~=~\textquotedbl 1+2{*}i\textquotedbl .toComplex}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~b~=~a~{*}~\textquotedbl 3-4{*}i\textquotedbl .toComplex}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}b.conj}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}%
\begin{minipage}[t]{0.45\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}Conj(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Mul(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~Str(\textquotedbl 1+2{*}i\textquotedbl ),~Str(\textquotedbl 3-4{*}i\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}))}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}
\begin{itemize}
\item \emph{Unevaluated} operations \texttt{\textcolor{blue}{\footnotesize{}Literal}},
\texttt{\textcolor{blue}{\footnotesize{}Mul}}, \texttt{\textcolor{blue}{\footnotesize{}Conj}}
are defined as case classes:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Str(s:~String)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Mul(p1:~Prg,~p2:~Prg)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Conj(p:~Prg)~extends~Prg}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item An \emph{interpreter} will ``run'' the program and return a complex
number
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~run(prg:~Prg):~(Double,~Double)~=~...}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Benefits: programs are data, can compose \& transform before running
\item Shortcomings: this DSL works only with simple expressions
\begin{itemize}
\item Cannot represent variable binding and conditional computations
\item Cannot use any non-DSL code (e.g.~a numerical algorithms library)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern II. Variable binding}

\vspace{-0.1cm}A DSL with variable binding and conditional computations
\begin{itemize}
\item Example: imperative API for reading and writing files
\begin{itemize}
\item Need to bind a \emph{non-DSL variable} to a value computed by DSL
\item Later, need to use that non-DSL variable in DSL expressions
\end{itemize}
\item The rest of the DSL program is a (Scala) function of that variable
\end{itemize}
\vspace{-0.15cm}%
\begin{minipage}[t]{0.35\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~p~=~path(\textquotedbl /file\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~str:~String~=~read(p)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~read(path(str))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}else~\textquotedbl Error:~empty~path\textquotedbl}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}%
\begin{minipage}[t]{0.45\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}Bind(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Read(Path(Literal(\textquotedbl /file\textquotedbl ))),}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\{~str~$\Rightarrow$}\textcolor{darkgray}{\footnotesize{}~//~read~value~`str`}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~Read(Path(Literal(str)))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Literal(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\})}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}
\begin{itemize}
\item \vspace{0.1cm}Unevaluated operations are implemented via case classes:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind(p:~Prg,~f:~String~$\Rightarrow$~Prg)~extends~Prg~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg)~extends~Prg}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.1cm}Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def
run(prg: Prg): String = ...}} 
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern III. Type safety}
\begin{itemize}
\item So far, the DSL has no type safety: every value is a \texttt{\textcolor{blue}{\footnotesize{}Prg}} 
\item We want to avoid errors, e.g. \texttt{\textcolor{blue}{\footnotesize{}Read(Read(...))}}
should not compile
\item Let \texttt{\textcolor{blue}{\footnotesize{}Prg{[}A{]}}} denote a
DSL program returning value of type \texttt{\textcolor{blue}{\footnotesize{}A}}
\emph{when run}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind(p:~Prg{[}String{]},~f:~String~$\Rightarrow$~Prg{[}String{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~extends~Prg{[}String{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg{[}String{]}~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg{[}String{]})~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg{[}nio.file.Path{]})~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def run(prg: Prg{[}String{]}): String
= ...}}{\footnotesize\par}
\item Our example DSL program is type-safe now:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~prg:~Prg{[}String{]}~=~Bind(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Read(Path(Literal(\textquotedbl /file\textquotedbl ))),}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~\{~str:~String~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~Read(Path(Literal(str)))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Literal(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\})}{\footnotesize\par}
\end{lyxcode}
\end{frame}

\begin{frame}{The interpreter pattern IV. Cleaning up the DSL}

\vspace{-0.15cm}Our DSL so far:
\begin{lyxcode}
\vspace{-0.35cm}\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}~\{~def~bind(f:~String$\Rightarrow$Prg{[}String{]}):~Prg{[}String{]}~\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg{[}String{]})~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg{[}nio.file.Path{]})~extends~Prg{[}String{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
Problems with this DSL:
\begin{itemize}
\item Cannot use \texttt{\textcolor{blue}{\footnotesize{}Read(p: nio.file.Path)}},
only \texttt{\textcolor{blue}{\footnotesize{}Read(p: Prg{[}nio.file.Path{]})}} 
\item Cannot bind variables or return values other than \texttt{\textcolor{blue}{\footnotesize{}String}} 
\end{itemize}
To fix these problems:
\begin{itemize}
\item Promote \texttt{\textcolor{blue}{\footnotesize{}Literal}} to a fully
parameterized operation
\item Replace \texttt{\textcolor{blue}{\footnotesize{}Prg{[}A{]}}} by \texttt{\textcolor{blue}{\footnotesize{}A}}
in case class arguments
\end{itemize}
Resulting DSL:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~String)~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~nio.file.Path)~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}Note the \texttt{\textcolor{blue}{\footnotesize{}flatMap}}-like
type signature of \texttt{\textcolor{blue}{\footnotesize{}Bind}} 
\end{itemize}
\begin{lyxcode}
\end{lyxcode}
\end{frame}

\begin{frame}{The interpreter pattern V. Define \texttt{Monad}-like methods}
\begin{itemize}
\item \vspace{-0.3cm}We can actually define the methods \texttt{\textcolor{blue}{\footnotesize{}map}},
\texttt{\textcolor{blue}{\footnotesize{}flatMap}}, \texttt{\textcolor{blue}{\footnotesize{}pure}}:
\end{itemize}
\begin{lyxcode}
\vspace{-0.1cm}\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~def~flatMap{[}B{]}(f:~A~$\Rightarrow$~Prg{[}B{]}):~Prg{[}B{]}~=~Bind(this,~f)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~def~map{[}B{]}(f:~A~$\Rightarrow$~B):~Prg{[}B{]}~=~flatMap(this,~f~andThen~Prg.pure)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}object~Prg~\{~def~pure{[}A{]}(a:~A):~Prg{[}A{]}~=~Literal(a)~\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}These methods don't run anything, only create unevaluated
structures
\item DSL programs can now be written as functor blocks and composed:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~readPath(p:~String):~Prg{[}String{]}~=~for~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~path~$\leftarrow$~Path(p)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~str~~$\leftarrow$~Read(path)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~str}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~prg:~Prg{[}String{]}~=~for~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~str~$\leftarrow$~readPath(\textquotedbl /file\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~result~$\leftarrow$~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~readPath(str)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Prg.pure(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~result}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def
run{[}A{]}(prg: Prg{[}A{]}): A = ...}} 
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern VI. Refactoring to an abstract DSL}
\begin{itemize}
\item Write a DSL for complex numbers in a similar way:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}~\{~def~flatMap~...~\}}\textcolor{darkgray}{\footnotesize{}~//~no~code~changes}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}type~Complex~=~(Double,~Double)}\textcolor{darkgray}{\footnotesize{}~//~custom~code~starts~here}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Str(s:~String)~extends~Prg{[}Complex{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Mul(c1:~Complex,~C2:~Complex)~extends~Prg{[}Complex{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Conj(c:~Complex)~extends~Prg{[}Complex{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Refactor this DSL to separate common code from custom code:
\end{itemize}
\begin{lyxcode}
\vspace{-0.15cm}\textcolor{blue}{\footnotesize{}sealed~trait~DSL{[}F{[}\_{]},~A{]}~\{~def~flatMap~...~\}}\textcolor{darkgray}{\footnotesize{}~//~no~code~changes}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}type~Prg{[}A{]}~=~DSL{[}F,~A{]}}\textcolor{darkgray}{\footnotesize{}~//~just~for~convenience}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Ops{[}A{]}(f:~F{[}A{]})~extends~Prg{[}A{]}}\textcolor{darkgray}{\footnotesize{}~//~custom~operations~here}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Interpreter is parameterized by a ``value extractor'' $ex:\forall A.F^{A}\Rightarrow A$
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~run{[}F{[}\_{]},~A{]}(ex:~Ex{[}F{]})(p:~DSL{[}F,~A{]}):~A~=~...}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item The constructor \texttt{\textcolor{blue}{\footnotesize{}DSL{[}F{[}\_{]},
A{]}}} is called a \textbf{free monad} over \texttt{\textcolor{blue}{\footnotesize{}F}} 
\end{itemize}
\end{frame}

\begin{frame}{Free}
\begin{itemize}
\item Consider 
\end{itemize}
\end{frame}

\begin{frame}{Free}
\begin{itemize}
\item Consider 
\end{itemize}
\end{frame}

\begin{frame}{Free constructions in mathematics: Example I}
\begin{itemize}
\item Consider the Russian letter ц (ts\`{e}) and the Chinese word \begin{CJK}{UTF8}{gbsn}水\end{CJK}
(shu\textipa{\v i})
\item We want to \emph{multiply} ц by \shui. Multiply how?
\item Say, we want an associative (but noncommutative) product of them
\begin{itemize}
\item So we want to define a \emph{semigroup} that \emph{contains} ц and
\shui~as elements
\begin{itemize}
\item while we still know nothing about ц and \shui
\end{itemize}
\end{itemize}
\item Consider the set of all \emph{unevaluated expressions} such as ц$\cdot$\shui$\cdot$\shui$\cdot$ц$\cdot$\shui
\begin{itemize}
\item Here ц$\cdot$\shui~is different from \shui$\cdot$ц but $\left(a\cdot b\right)\cdot c=a\cdot\left(b\cdot c\right)$
\end{itemize}
\item All these expressions form a \textbf{free semigroup} generated by
ц and \shui
\item Example calculation: (\shui$\cdot$\shui)$\cdot$(ц$\cdot$mple calculation: (\shui$\cdot$\shui)$\cdot$(ц$\cdot$\shui)$\cdot$ц
$=$ \shui$\cdot$\shui$\cdot$ц$\cdot$\shui$\cdot$ц
\end{itemize}
How to represent this as a data type:
\begin{itemize}
\item Redundant encoding, as the full expression tree: ((\shui,\shui),(ц,\shui)),ц)
\begin{itemize}
\item Implement the operation $a\cdot b$ as pair constructor (easy and
cheap)
\end{itemize}
\item Reduced encoding, as a ``smart'' structure: List(\shui,\shui,ц,\shui,ц)
\begin{itemize}
\item Implement the opration $a\cdot b$ by concatenating the lists (more
expensive)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Free constructions in mathematics: Example II}
\begin{itemize}
\item Want to define a product operation for $n$-dimensional vectors: $\mathbf{v}_{1}\otimes\mathbf{v}_{2}$
\item The $\otimes$ must be linear and distributive (but not commutative):
\begin{align*}
\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\left(\mathbf{u}_{2}\otimes\mathbf{v}_{2}+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\right) & =\left(\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}\right)+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\\
\mathbf{u}\otimes\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & =a_{1}\left(\mathbf{u}\otimes\mathbf{v}_{1}\right)+a_{2}\left(\mathbf{u}\otimes\mathbf{v}_{2}\right)\\
\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & \otimes\mathbf{u}=a_{1}\left(\mathbf{v}_{1}\otimes\mathbf{u}\right)+a_{2}\left(\mathbf{v}_{2}\otimes\mathbf{u}\right)
\end{align*}

\begin{itemize}
\item We have such a product for 3-dimensional vectors only; ignore that
\end{itemize}
\item Consider \emph{unevaluated} \emph{expressions} of the form $\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}+...$
\begin{itemize}
\item A free vector space generated by pairs of vectors
\end{itemize}
\item Impose the equivalence relationships shown above
\begin{itemize}
\item The result is known as the \textbf{tensor product}
\end{itemize}
\item Redundant encoding: unevaluated expression tree
\begin{itemize}
\item A list of any number of vector pairs $\sum_{i}\mathbf{u}_{i}\otimes\mathbf{v}_{i}$
\end{itemize}
\item Reduced encoding: a matrix
\begin{itemize}
\item Reduced encoding requires proof and more complex operations
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
\item {\footnotesize{}\vspace{-0.15cm}Show that }{\footnotesize\par}
\end{enumerate}
\end{frame}

\end{document}
