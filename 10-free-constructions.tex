\batchmode
\makeatletter
\def\input@path{{/Users/sergei.winitzki/Code/talks/ftt-fp/}}
\makeatother
\documentclass[english,,russian]{beamer}
\usepackage[T2A,T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{tipa}
\usepackage{tipx}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage[all]{xy}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
% this default might be overridden by plain title style
\newcommand\makebeamertitle{\frame{\maketitle}}%
% (ERT) argument for the TOC
\AtBeginDocument{%
  \let\origtableofcontents=\tableofcontents
  \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
  \def\gobbletableofcontents#1{\origtableofcontents}
}
\newenvironment{lyxcode}
  {\par\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \setlength{\listparindent}{0pt}% needed for AMS classes
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \normalfont\ttfamily}%
   \def\{{\char`\{}
   \def\}{\char`\}}
   \def\textasciitilde{\char`\~}
   \item[]}
  {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 10: Free type constructions]{Chapter 10: Free type constructions}
%\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-11-22}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\usepackage[nocenter]{qtree}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY
\newcommand{\shui}{\begin{CJK}{UTF8}{gbsn}æ°´\end{CJK}}
\usepackage{CJKutf8} % For occasional Chinese characters. Also, add "russian" to documentclass.

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{The interpreter pattern I. Expression trees}

Main idea: Represent a program as a data structure, run it later
\begin{itemize}
\item Example: a simple DSL for complex numbers
\end{itemize}
\vspace{-0.35cm}%
\begin{minipage}[t]{0.35\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~a~=~\textquotedbl 1+2{*}i\textquotedbl .toComplex}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~b~=~a~{*}~\textquotedbl 3-4{*}i\textquotedbl .toComplex}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}b.conj}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}%
\begin{minipage}[t]{0.45\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}Conj(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Mul(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~Str(\textquotedbl 1+2{*}i\textquotedbl ),~Str(\textquotedbl 3-4{*}i\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}))}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}
\begin{itemize}
\item \emph{Unevaluated} operations \texttt{\textcolor{blue}{\footnotesize{}Str}},
\texttt{\textcolor{blue}{\footnotesize{}Mul}}, \texttt{\textcolor{blue}{\footnotesize{}Conj}}
are defined as case classes:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Str(s:~String)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Mul(p1:~Prg,~p2:~Prg)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Conj(p:~Prg)~extends~Prg}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item An \emph{interpreter} will ``run'' the program and return a complex
number
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~run(prg:~Prg):~(Double,~Double)~=~...}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Benefits: programs are data, can compose \& transform before running
\item Shortcomings: this DSL works only with simple expressions
\begin{itemize}
\item Cannot represent variable binding and conditional computations
\item Cannot use any non-DSL code (e.g.~a numerical algorithms library)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern II. Variable binding}

\vspace{-0.1cm}A DSL with variable binding and conditional computations
\begin{itemize}
\item Example: imperative API for reading and writing files
\begin{itemize}
\item Need to bind a \emph{non-DSL variable} to a value computed by DSL
\item Later, need to use that non-DSL variable in DSL expressions
\item The rest of the DSL program is a (Scala) function of that variable
\end{itemize}
\end{itemize}
\vspace{-0.15cm}%
\begin{minipage}[t]{0.35\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~p~=~path(\textquotedbl /file\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~str:~String~=~read(p)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~read(path(str))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}else~\textquotedbl Error:~empty~path\textquotedbl}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}%
\begin{minipage}[t]{0.45\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}Bind(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Read(Path(Literal(\textquotedbl /file\textquotedbl ))),}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\{~str~$\Rightarrow$}\textcolor{darkgray}{\footnotesize{}~//~read~value~`str`}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~Read(Path(Literal(str)))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Literal(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\})}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}
\begin{itemize}
\item \vspace{0.1cm}Unevaluated operations are implemented via case classes:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind(p:~Prg,~f:~String~$\Rightarrow$~Prg)~extends~Prg~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg)~extends~Prg}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.1cm}Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def
run(prg: Prg): String = ...}} 
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern III. Type safety}
\begin{itemize}
\item So far, the DSL has no type safety: every value is a \texttt{\textcolor{blue}{\footnotesize{}Prg}} 
\begin{itemize}
\item We want to avoid errors, e.g. \texttt{\textcolor{blue}{\footnotesize{}Read(Read(...))}}
should not compile
\end{itemize}
\item Let \texttt{\textcolor{blue}{\footnotesize{}Prg{[}A{]}}} denote a
DSL program returning value of type \texttt{\textcolor{blue}{\footnotesize{}A}}
\emph{when run}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind(p:~Prg{[}String{]},~f:~String~$\Rightarrow$~Prg{[}String{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~extends~Prg{[}String{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg{[}String{]}~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg{[}String{]})~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg{[}nio.file.Path{]})~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def run(prg: Prg{[}String{]}): String
= ...}}{\footnotesize\par}
\item Our example DSL program is type-safe now:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~prg:~Prg{[}String{]}~=~Bind(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Read(Path(Literal(\textquotedbl /file\textquotedbl ))),}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~\{~str:~String~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~Read(Path(Literal(str)))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Literal(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\})}{\footnotesize\par}
\end{lyxcode}
\end{frame}

\begin{frame}{The interpreter pattern IV. Cleaning up the DSL}

\vspace{-0.2cm}Our DSL so far:
\begin{lyxcode}
\vspace{-0.0cm}\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind(p:~Prg{[}String{]},~f:~String~$\Rightarrow$~Prg{[}String{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~extends~Prg{[}String{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg{[}String{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg{[}String{]})~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg{[}nio.file.Path{]})~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
Problems with this DSL:
\begin{itemize}
\item Cannot use \texttt{\textcolor{blue}{\footnotesize{}Read(p: nio.file.Path)}},
only \texttt{\textcolor{blue}{\footnotesize{}Read(p: Prg{[}nio.file.Path{]})}} 
\item Cannot bind variables or return values other than \texttt{\textcolor{blue}{\footnotesize{}String}} 
\end{itemize}
To fix these problems, make \texttt{\textcolor{blue}{\footnotesize{}Literal}}
a fully parameterized operation and replace \texttt{\textcolor{blue}{\footnotesize{}Prg{[}A{]}}}
by \texttt{\textcolor{blue}{\footnotesize{}A}} in case class arguments
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~String)~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~nio.file.Path)~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.0cm}The type signatures of \texttt{\textcolor{blue}{\footnotesize{}Bind}}
and \texttt{\textcolor{blue}{\footnotesize{}Literal}} are like \texttt{\textcolor{blue}{\footnotesize{}flatMap}}
and \texttt{\textcolor{blue}{\footnotesize{}pure}} 
\end{itemize}
\begin{lyxcode}
\end{lyxcode}
\end{frame}

\begin{frame}{The interpreter pattern V. Define \texttt{Monad}-like methods}
\begin{itemize}
\item \vspace{-0.3cm}We can actually define the methods \texttt{\textcolor{blue}{\footnotesize{}map}},
\texttt{\textcolor{blue}{\footnotesize{}flatMap}}, \texttt{\textcolor{blue}{\footnotesize{}pure}}:
\end{itemize}
\begin{lyxcode}
\vspace{-0.1cm}\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~def~flatMap{[}B{]}(f:~A~$\Rightarrow$~Prg{[}B{]}):~Prg{[}B{]}~=~Bind(this,~f)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~def~map{[}B{]}(f:~A~$\Rightarrow$~B):~Prg{[}B{]}~=~flatMap(this,~f~andThen~Prg.pure)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}object~Prg~\{~def~pure{[}A{]}(a:~A):~Prg{[}A{]}~=~Literal(a)~\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}These methods don't run anything, only create unevaluated
structures
\item DSL programs can now be written as functor blocks and composed:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~readPath(p:~String):~Prg{[}String{]}~=~for~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~path~$\leftarrow$~Path(p)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~str~~$\leftarrow$~Read(path)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~str}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~prg:~Prg{[}String{]}~=~for~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~str~$\leftarrow$~readPath(\textquotedbl /file\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~result~$\leftarrow$~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~readPath(str)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Prg.pure(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~result}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def
run{[}A{]}(prg: Prg{[}A{]}): A = ...}} 
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern VI. Refactoring to an abstract DSL}
\begin{itemize}
\item Write a DSL for complex numbers in a similar way:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}~\{~def~flatMap~...~\}}\textcolor{darkgray}{\footnotesize{}~//~no~code~changes}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}type~Complex~=~(Double,~Double)}\textcolor{darkgray}{\footnotesize{}~//~custom~code~starts~here}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Str(s:~String)~extends~Prg{[}Complex{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Mul(c1:~Complex,~C2:~Complex)~extends~Prg{[}Complex{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Conj(c:~Complex)~extends~Prg{[}Complex{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Refactor this DSL to separate common code from custom code:
\end{itemize}
\begin{lyxcode}
\vspace{-0.15cm}\textcolor{blue}{\footnotesize{}sealed~trait~DSL{[}F{[}\_{]},~A{]}~\{~def~flatMap~...~\}}\textcolor{darkgray}{\footnotesize{}~//~no~code~changes}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}type~Prg{[}A{]}~=~DSL{[}F,~A{]}}\textcolor{darkgray}{\footnotesize{}~//~just~for~convenience}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Ops{[}A{]}(f:~F{[}A{]})~extends~Prg{[}A{]}}\textcolor{darkgray}{\footnotesize{}~//~custom~operations~here}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Interpreter is parameterized by a ``value extractor'' $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow A\right)$
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~run{[}F{[}\_{]},~A{]}(ex:~Ex{[}F{]})(prg:~DSL{[}F,~A{]}):~A~=~...}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item The constructor \texttt{\textcolor{blue}{\footnotesize{}DSL{[}F{[}\_{]},
A{]}}} is called a \textbf{free monad} over \texttt{\textcolor{blue}{\footnotesize{}F}} 
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern VII. Handling errors}
\begin{itemize}
\item \vspace{-0.15cm}To handle errors, we want to evaluate \texttt{\textcolor{blue}{\footnotesize{}DSL{[}F{[}\_{]},
A{]}}} to \texttt{\textcolor{blue}{\footnotesize{}Either{[}Err, A{]}}} 
\item Suppose we have a value extractor of type $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow\text{Err}+A\right)$
\item The code of the interpreter is almost unchanged:
\end{itemize}
\begin{lyxcode}
\vspace{-0.4cm}\textcolor{blue}{\footnotesize{}def~run{[}F{[}\_{]},~A{]}(extract:~Ex{[}F{]})(prg:~DSL{[}F,~A{]}):~Either{[}Err,~A{]}~=}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~prg~match~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~case~b:~Bind{[}F,~\_,~A{]}~\ensuremath{\Rightarrow}~b~match~\{~case~Bind(p,~f)~\ensuremath{\Rightarrow}~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~~~run(extract)(p).flatMap(f~andThen~run(extract))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~\}}\textcolor{darkgray}{\footnotesize{}~~~~~//~Here,~the~.flatMap~is~from~Either.}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~case~Literal(a)~\ensuremath{\Rightarrow}~Right(a)}\textcolor{darkgray}{\footnotesize{}~//~pure:~A~$\Rightarrow$~Err~+~A}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~case~Ops(f)~\ensuremath{\Rightarrow}~extract(f)~~~~~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}The code of \texttt{\textcolor{blue}{\footnotesize{}run}}
only uses \texttt{\textcolor{blue}{\footnotesize{}flatMap}} and \texttt{\textcolor{blue}{\footnotesize{}pure}}
from \texttt{\textcolor{blue}{\footnotesize{}Either}} 
\item We can generalize to any other monad $M^{A}$ instead of \texttt{\textcolor{blue}{\footnotesize{}Either{[}Err,
A{]}}} 
\end{itemize}
The resulting construction:
\begin{itemize}
\item Start with an ``operations type constructor'' $F^{A}$ (often not
a functor)
\item Use $\text{DSL}^{F,A}$ and interpreter {\footnotesize{}$\text{run}^{M,A}:\left(\forall X.F^{X}\Rightarrow M^{X}\right)\Rightarrow\text{DSL}^{F,A}\Rightarrow M^{A}$}{\footnotesize\par}
\item Create a DSL program $\text{prg}:\text{DSL}^{F,A}$ and an extractor
$\text{ex}^{X}:F^{X}\Rightarrow M^{X}$
\item Run the program with the extractor: \texttt{\textcolor{blue}{\footnotesize{}run(ex)(prg)}};
get a value $M^{A}$
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern VIII. Monadic DSLs: summary}
\begin{itemize}
\item \vspace{-0.15cm}Begin with a number of operations, which are typically
functions of fixed known types such as $A_{1}\Rightarrow B_{1}$,
$A_{2}\Rightarrow B_{2}$ etc.
\item Define a type constructor (typically not a functor) encapsulating
all the operations as case classes, with or without type parameters
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~F{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Op1(a1:~A1)~extends~F{[}B1{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Op2(a1:~A2)~extends~F{[}B2{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Use \texttt{\textcolor{blue}{\footnotesize{}DSL{[}F,A{]}}} with this
\texttt{\textcolor{blue}{\footnotesize{}F}} to write monadic DSL programs
\texttt{\textcolor{blue}{\footnotesize{}prg:~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             $S_{i}$
require many ``extractors'' $\text{ex}_{i}:Z\Rightarrow S_{i}$
\item Refactor extractors $\text{ex}_{i}$ into evidence of a typeclass
constraint on $S_{i}$
\end{itemize}
\begin{lyxcode}
\textcolor{darkgray}{\footnotesize{}//~Typeclass~ExZ{[}S{]}~has~the~single~method~`extract:~Z~$\Rightarrow$~S`.}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}implicit~val~exZ:~ExZ{[}MySemigroup{]}~=~\{~z~$\Rightarrow$~...~\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~run{[}S:~ExZ:~Semigroup{]}(fm:~FM{[}Z{]}):~S~=~fm~match~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~case~Wrap(z)~$\Rightarrow$~implicitly{[}ExZ{[}S{]}{]}.extract(z)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~case~Comb(x,~y)~$\Rightarrow$~run(x)~|+|~run(y)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}Refactor \texttt{\textcolor{blue}{\footnotesize{}run}}
using a helper function \texttt{\textcolor{blue}{\footnotesize{}wrap}} 
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~wrap{[}S:~ExZ{]}(z:~Z):~S~=~implicitly{[}ExZ{[}S{]}{]}.extract(z)}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.1cm}}Refactor the rest of \texttt{\textcolor{blue}{\footnotesize{}run}}
into functions with constraint \texttt{\textcolor{blue}{\footnotesize{}{[}S: ExZ{]}}},
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~x{[}S:~ExZ~:~Semigroup{]}:~S~=~wrap(1)~|+|~wrap(2)}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item The type of \texttt{\textcolor{blue}{\footnotesize{}x}} is {\footnotesize{}$\forall S.\left(Z\Rightarrow S\right)\times\left(S\times S\Rightarrow S\right)\Rightarrow S$};
equivalently:{\footnotesize{}
\[
\forall S.\left(Z\Rightarrow S\right)\times\left(S\times S\Rightarrow S\right)\Rightarrow S\ \cong\ \forall S.\left(\left(Z+S\times S\right)\Rightarrow S\right)\Rightarrow S
\]
}{\footnotesize\par}
\item {\footnotesize{}\vspace{-0.1cm}}This is known as the ``\textbf{Church
encoding}'' (for the free semigroup)
\item Church encoding works for any type: $A\cong\forall X.\left(A\Rightarrow X\right)\Rightarrow X$
\begin{itemize}
\item which \emph{resembles} the type of the continuation monad, $\left(A\Rightarrow R\right)\Rightarrow R$
\item but $\forall X$ makes the function fully generic and a natural transformation
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Church encoding II. Disjunction types}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}Consider the Church encoding for
the disjunction type $P+Q$ 
\begin{itemize}
\item The encoding is {\footnotesize{}$\forall X.\left(P+Q\Rightarrow X\right)\Rightarrow X\cong\forall X.\left(P\Rightarrow X\right)\Rightarrow\left(Q\Rightarrow X\right)\Rightarrow X$}{\footnotesize\par}
\end{itemize}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}trait~Disj{[}P,~Q{]}~\{~def~run{[}X{]}(cp:~P~$\Rightarrow$~X)(cq:~Q~$\Rightarrow$~X):~X~\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Define some values of this type:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~left{[}P,~Q{]}(p:~P)~=~new~Disj{[}P,~Q{]}~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~def~run{[}X{]}(cp:~P~$\Rightarrow$~X)(cq:~Q~$\Rightarrow$~X):~X~=~cp(p)~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.1cm}}Now we can implement the analog of
the \texttt{\textcolor{blue}{\footnotesize{}case}} expression simply
as
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~result~=~disj.run~\{p~$\Rightarrow$~...\}~\{q~$\Rightarrow$~...\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item This works in programming languages that have no disjunction types
\end{itemize}
General recipe for implementing the Church encoding: 
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}trait~Blah~\{~def~run{[}X{]}(cont:~...~$\Rightarrow$~X):~X~\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item For convenience, define a type class \texttt{\textcolor{blue}{\footnotesize{}Ex}}
describing the inner function:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}trait~Ex{[}X{]}~\{~def~cp:~P~$\Rightarrow$~X;~def~cq:~Q~$\Rightarrow$~X~\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Different methods of this class return \texttt{\textcolor{blue}{\footnotesize{}X}};
convenient with disjunctions
\end{itemize}
\item Church-encoded types have to be ``run'' for pattern-matching
\end{itemize}
\end{frame}

\begin{frame}{Church encoding III. How it works}

Why is the type $\text{Ch}^{A}\equiv\forall X.\left(A\Rightarrow X\right)\Rightarrow X$
equivalent to the type $A$?
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}trait~Ch{[}A{]}~\{~def~run{[}X{]}(cont:~A~$\Rightarrow$~X):~X~\}}{\footnotesize\par}
\end{lyxcode}
\texttt{\textcolor{blue}{\footnotesize{}}}%
\begin{minipage}[t]{0.65\textwidth}%
\begin{itemize}
\item {\footnotesize{}\vspace{-0.25cm}}If we have a value of $A$, we can
get a $\text{Ch}^{A}$
\end{itemize}
\begin{lyxcode}
{\footnotesize{}\vspace{-0.15cm}}\textcolor{blue}{\footnotesize{}def~a2c{[}A{]}(a:~A):~Ch{[}A{]}~=~new~Ch{[}A{]}~\{~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~def~run{[}X{]}(cont:~A~$\Rightarrow$~X):~X~=~cont(a)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.3cm}}If we have a $\text{ch}:\text{Ch}^{A}$,
we can get an $a:A$ 
\end{itemize}
\begin{lyxcode}
{\footnotesize{}\vspace{-0.5cm}}\textcolor{blue}{\footnotesize{}def~c2a{[}A{]}(ch:~Ch{[}A{]}):~A~=~ch.run{[}A{]}(a$\Rightarrow$a)}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}%
\begin{minipage}[t]{0.3\columnwidth}%
{\footnotesize{}
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc}\text{id}:\left(A\Rightarrow A\right)\ar[r]\sp(0.65){\text{ch}.\text{run}^{A}}\ar[d]\sp(0.5){\text{fmap}_{\text{Reader}_{A}}\left(f\right)} & A\ar[d]\sp(0.45){f}\\
f:\left(A\Rightarrow X\right)\ar[r]\sb(0.65){\text{ch}.\text{run}^{X}} & X
}
\]
}%
\end{minipage}\texttt{\textcolor{blue}{\footnotesize{}\hfill{}}}{\footnotesize\par}
\begin{itemize}
\item The functions \texttt{\textcolor{blue}{\footnotesize{}a2c}} and \texttt{\textcolor{blue}{\footnotesize{}c2a}}
are inverses of each other
\begin{itemize}
\item To implement a value $\text{ch}^{:\text{Ch}^{A}}$, we must compute
an $x^{:X}$ given $f^{:A\Rightarrow X}$, for \emph{any} $X$, which
\emph{requires} having a value $a^{:A}$ available
\end{itemize}
\item To show that \texttt{\textcolor{blue}{\footnotesize{}ch = a2c(c2a(ch))}},
apply both sides to an \texttt{\textcolor{blue}{\footnotesize{}f:~A$\Rightarrow$X}}
and get \texttt{\textcolor{blue}{\footnotesize{}ch.run(f) = a2c(c2a(ch)).run(f)
= f(c2a(ch)) = f(ch.run(a$\Rightarrow$a))}} 
\begin{itemize}
\item This is naturality of \texttt{\textcolor{blue}{\footnotesize{}ch.run}}
as a transformation between \texttt{\textcolor{blue}{\footnotesize{}Reader}}
and \texttt{\textcolor{blue}{\footnotesize{}Id}} 
\begin{itemize}
\item Naturality of \texttt{\textcolor{blue}{\footnotesize{}ch.run}} follows
from parametricity of its code
\end{itemize}
\item It is straightforward to compute \texttt{\textcolor{blue}{\footnotesize{}c2a(a2c(a))
= identity(a) = a}} 
\end{itemize}
\item Church encoding satisfies laws: it is built up from parts of \texttt{\textcolor{blue}{\footnotesize{}run}}
method
\end{itemize}
\end{frame}

\begin{frame}{Church encoding IV. Recursive types and type constructors}
\begin{itemize}
\item Consider the recursive type $P\equiv Z+P\times P$ (tree with Z-typed
leaves)
\begin{itemize}
\item The Church encoding is {\footnotesize{}$\forall X.\left(\left(Z+X\times X\right)\Rightarrow X\right)\Rightarrow X$}{\footnotesize\par}
\item This is \emph{non-recursive}: the recursive use of $P$ is replaced
by $X$
\end{itemize}
\item Generalize to recursive type $P\equiv S^{P}$ where $S$ is a ``structure
functor'':
\begin{itemize}
\item The Church encoding is {\footnotesize{}$\forall X.\left(S^{X}\Rightarrow X\right)\Rightarrow X$}{\footnotesize\par}
\begin{itemize}
\item Church encoding of recursive types is non-recursive
\end{itemize}
\end{itemize}
\item Church encoding for a type constructor $P^{\bullet}$:
\begin{itemize}
\item Notation: $P^{\bullet}$ is a type function; Scala syntax is \texttt{\textcolor{blue}{\footnotesize{}P{[}\_{]}}} 
\item The Church encoding is {\footnotesize{}$\text{Ch}^{P^{\bullet},A}=\forall F^{\bullet}.\left(\forall X.P^{X}\Rightarrow F^{X}\right)\Rightarrow F^{A}$}{\footnotesize\par}
\item Note: $\forall X.P^{X}\Rightarrow F^{X}$ or $P^{\bullet}\leadsto F^{\bullet}$
resembles a natural transformation
\begin{itemize}
\item Except that $P^{\bullet}$ and $F^{\bullet}$ are not necessarily
functors, so no naturality law
\end{itemize}
\end{itemize}
\item Church encoding for a recursively defined type constructor $P^{\bullet}$:
\begin{itemize}
\item Definition: $P^{A}\equiv S^{P^{\bullet},A}$ where $S^{\bullet^{\bullet},A}$
is the ``structure transformation''
\item Notation: {\footnotesize{}$S^{\bullet^{\bullet},A}$} is a higher-order
type function; Scala syntax: \texttt{\textcolor{blue}{\footnotesize{}S{[}\_{[}\_{]},A{]}}} 
\begin{itemize}
\item {\footnotesize{}\vspace{-0.3cm}}Example: $\text{List}^{A}\equiv1+A\times\text{List}^{A}\equiv S^{\text{List}^{\bullet},A}$
where $S^{P^{\bullet},A}\equiv1+A\times P^{A}$ 
\end{itemize}
\item The Church encoding of $P^{A}$ is {\footnotesize{}$\text{Ch}^{P^{\bullet},A}=\forall F^{\bullet}.\left(S^{F^{\bullet}}\leadsto F^{\bullet}\right)\Rightarrow F^{A}$}{\footnotesize\par}
\end{itemize}
\item Works the same if $P^{\bullet}$ belongs to a typeclass -- use $\forall F^{\bullet}:C.\left(...\right)$
\begin{itemize}
\item Laws of the typeclass are satisfied automatically
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Properties of free type constructions}

Generalizing from our examples so far:
\begin{itemize}
\item We ``enriched'' $Z$ to a monoid $\text{FM}^{Z}$ and $F^{A}$ to
a monad $\text{DSL}^{F,A}$ 
\begin{itemize}
\item The ``enrichment'' adds case classes representing the needed operations
\item Very similar recipes for a type $Z$ and for a type constructor $F^{A}$
\end{itemize}
\item Obtain a \textbf{free type construction}, which performs no computations
\begin{itemize}
\item wrap $Z$ in just enough stuff to make it look like a monoid
\end{itemize}
\item A value of a free construction can be ``run'' to yield concrete
values 
\end{itemize}
Questions:
\begin{itemize}
\item Can we construct a free typeclass $C$ over any type constructor $F^{A}$?
\begin{itemize}
\item Yes, with typeclasses: (contra)functor, filterable, monad, applicative
\end{itemize}
\item Which of the possible encodings to use?
\begin{itemize}
\item Tree encoding, reduced encodings, Church encoding
\end{itemize}
\item What are the laws for the $\text{FreeC}^{F,A}$ -- ``free instance
of $C$ over $F$''?
\begin{itemize}
\item For all $F^{\bullet}$, must have \texttt{\textcolor{blue}{\footnotesize{}wrap{[}A{]}}}
$:F^{A}\Rightarrow\text{FreeC}^{F,A}$ or $F^{\bullet}\leadsto\text{FreeC}^{F,\bullet}$
\item For all $M^{\bullet}:C$, given $F^{\bullet}\leadsto M^{\bullet}$,
must have \texttt{\textcolor{blue}{\footnotesize{}run}} $:\text{FreeC}^{F,\bullet}\leadsto M^{\bullet}$
\item The laws of typeclass $C$ must hold after interpreting into an $M^{\bullet}:C$
\item Given any \texttt{\textcolor{blue}{\footnotesize{}t}}$:F^{\bullet}\leadsto G^{\bullet}$,
must have \texttt{\textcolor{blue}{\footnotesize{}fmap(t)}}$:\text{FreeC}^{F,\bullet}\leadsto\text{FreeC}^{G,\bullet}$
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Worked example III: free functor}
\begin{itemize}
\item Only one operation: $F^{Z}\times\left(Z\Rightarrow A\right)\Rightarrow F^{A}$ 
\item Tree encoding: $\text{FreeF}^{F^{\bullet},A}\equiv F^{A}+\exists Z.\text{FreeF}^{F^{\bullet},Z}\times\left(Z\Rightarrow A\right)$
\begin{itemize}
\item The existential quantifier is represented by an extra type parameter
\item It is not $\forall Z$ because a specific $Z$ is used when building
up a value
\end{itemize}
\item Reduced encoding: $\text{FreeF}^{F^{\bullet},A}\equiv\exists Z.F^{Z}\times\left(Z\Rightarrow A\right)$
\begin{itemize}
\item Substituted $F^{Z}$ instead of $\text{FreeF}^{F^{\bullet},Z}$ and
eliminated the case $F^{A}$
\item The reduced encoding is non-recursive
\item Requires a proof that this encoding is equivalent to the tree encoding
\begin{itemize}
\item If $F^{\bullet}$ is already a functor, can show $F^{A}\cong\exists Z.F^{Z}\times\left(Z\Rightarrow A\right)$
\end{itemize}
\end{itemize}
\item Church encoding (starting from the tree encoding): $\text{FreeF}^{F^{\bullet},A}\equiv\forall P^{\bullet}.\left(\forall C.\big(F^{C}+\exists Z.P^{Z}\times\left(Z\Rightarrow C\right)\big)\leadsto P^{C}\right)\Rightarrow P^{A}$
\end{itemize}
\end{frame}

\begin{frame}{Encoding with a hidden type: how it works}
\begin{itemize}
\item We have 
\begin{align*}
\exists Z.Z\times\left(Z\Rightarrow A\right) & \cong A\\
\exists Z.F^{Z}\times\left(Z\Rightarrow A\right) & \cong F^{A}\quad\text{if }F^{\bullet}\text{ is a functor}
\end{align*}

\begin{itemize}
\item How can we construct a value of type $\exists Z.Z\times\left(Z\Rightarrow A\right)$?
\item To construct a value of type
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Worked examples IV: free contrafunctor}
\begin{itemize}
\item Operation $\text{contramap}:C^{A}\times\left(B\Rightarrow A\right)\Rightarrow C^{B}$ 
\item Tree encoding: $\text{FreeCF}^{F^{\bullet},B}\equiv F^{B}+\exists A.\text{FreeCF}^{F^{\bullet},A}\times\left(B\Rightarrow A\right)$
\item Reduced encoding: $\text{FreeCF}^{F^{\bullet},B}\equiv\exists A.F^{A}\times\left(B\Rightarrow A\right)$
\begin{itemize}
\item The reduced encoding is non-recursive
\end{itemize}
\item Example: $F^{A}\equiv A$, ``interpret'' into the contrafunctor
$C^{A}\equiv A\Rightarrow\text{String}$
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~prefixLog{[}A{]}(p:~A):~A~$\Rightarrow$~String~=~a~$\Rightarrow$~p.toString~+~a.toString}{\footnotesize\par}
\end{lyxcode}
\end{frame}

\begin{frame}{Worked examples V: free pointed functor}

Given an arbitrary type constructor $F^{\bullet}$:
\begin{itemize}
\item Pointed functor operations: $A\Rightarrow\text{P}^{A}$ and $P^{A}\times\left(A\Rightarrow B\right)\Rightarrow P^{B}$
\item Tree encoding: $\text{FreeP}^{F^{\bullet},A}\equiv A+F^{A}+\exists Z.\text{FreeP}^{F^{\bullet},Z}\times\left(Z\Rightarrow A\right)$
\item Reduced encoding: $\text{FreeP}^{F^{\bullet},A}\equiv A+\exists Z.F^{Z}\times\left(Z\Rightarrow A\right)$
\item This reuses the free functor as $\text{FreeP}^{F^{\bullet},A}=A+\text{FreeF}^{F^{\bullet},A}$
\end{itemize}
If the type constructor $F^{\bullet}$ is \emph{already} a functor,
$\text{FreeF}^{F^{\bullet},A}\cong F^{A}$ and so:
\begin{itemize}
\item Free functor over a functor $F^{\bullet}$ is $\text{FreeF}^{F^{\bullet},A}\equiv A+F^{A}$
\end{itemize}
\end{frame}

\begin{frame}{Worked example: free filterable functor}
\begin{itemize}
\item Operations: 
\begin{align*}
\text{map} & :F^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow F^{B}\\
\text{mapOpt} & :F^{A}\Rightarrow\left(A\Rightarrow1+B\right)\Rightarrow F^{B}
\end{align*}
Can recover \texttt{\textcolor{blue}{\footnotesize{}map}} from \texttt{\textcolor{blue}{\footnotesize{}mapOpt}},
so let us keep only \texttt{\textcolor{blue}{\footnotesize{}mapOpt}} 
\item Tree encoding: $\text{FreeFi}^{F^{\bullet},A}\equiv F^{A}+\exists Z.\text{FreeFi}^{F^{\bullet},Z}\times\left(Z\Rightarrow1+A\right)$
\item Reduced encoding: $\text{FreeFi}^{F^{\bullet},A}\equiv\exists Z.F^{Z}\times\left(Z\Rightarrow1+A\right)$,
non-recursive
\item If $F^{\bullet}$ is already a functor, can simplify: $\text{FreeFi}^{F^{\bullet},A}=F^{1+A}$
\end{itemize}
\end{frame}

\begin{frame}{Worked example: free monad}
\begin{itemize}
\item Operations:
\begin{align*}
\text{pure} & :A\Rightarrow F^{A}\\
\text{flatMap} & :F^{A}\Rightarrow\left(A\Rightarrow F^{B}\right)\Rightarrow F^{B}
\end{align*}
\item Free monad when starting from a functor $F$
\end{itemize}
\end{frame}

\begin{frame}{Worked example: free applicative}
\begin{itemize}
\item Generalize
\end{itemize}
\end{frame}

\begin{frame}{Free constructions as ``universal'' DSL programs}
\begin{itemize}
\item Generalize
\end{itemize}
\end{frame}

\begin{frame}{Type classes not available for free constructions}
\begin{itemize}
\item Generalize
\end{itemize}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
\item {\footnotesize{}\vspace{-0.15cm}Implement a free semigroup generated
by a type $Z$ in the tree encoding and in the reduced encoding. Show
that the semigroup laws hold for the reduced encoding but not for
the tree encoding before interpreting into a lawful semigroup $S$.}{\footnotesize\par}
\item {\footnotesize{}Consider a free monoid generated by a type $Z$ when
$Z$ is already a monoid. Show that the resulting type is not equivalent
to $Z$.yes}{\footnotesize\par}
\end{enumerate}
\end{frame}

\end{document}
