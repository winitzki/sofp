\batchmode
\makeatletter
\def\input@path{{/Users/sergei.winitzki/Code/talks/ftt-fp/}}
\makeatother
\documentclass[english,,russian]{beamer}
\usepackage[T2A,T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{tipa}
\usepackage{tipx}
\usepackage{amsmath}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
% this default might be overridden by plain title style
\newcommand\makebeamertitle{\frame{\maketitle}}%
% (ERT) argument for the TOC
\AtBeginDocument{%
  \let\origtableofcontents=\tableofcontents
  \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
  \def\gobbletableofcontents#1{\origtableofcontents}
}
\newenvironment{lyxcode}
  {\par\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \setlength{\listparindent}{0pt}% needed for AMS classes
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \normalfont\ttfamily}%
   \def\{{\char`\{}
   \def\}{\char`\}}
   \def\textasciitilde{\char`\~}
   \item[]}
  {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 10: Free type constructions]{Chapter 10: Free type constructions}
%\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-11-22}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\usepackage[nocenter]{qtree}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY
\newcommand{\shui}{\begin{CJK}{UTF8}{gbsn}水\end{CJK}}
\usepackage{CJKutf8} % For occasional Chinese characters. Also, add "russian" to documentclass.

\makeatother

\begin{document}
\frame{\titlepage}
\begin{frame}{The interpreter pattern I. Expression trees}

Main idea: Represent a program as a data structure, run it later
\begin{itemize}
\item Example: a simple DSL for complex numbers
\end{itemize}
\vspace{-0.35cm}%
\begin{minipage}[t]{0.35\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~a~=~\textquotedbl 1+2{*}i\textquotedbl .toComplex}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~b~=~a~{*}~\textquotedbl 3-4{*}i\textquotedbl .toComplex}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}b.conj}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}%
\begin{minipage}[t]{0.45\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}Conj(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Mul(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~Str(\textquotedbl 1+2{*}i\textquotedbl ),~Str(\textquotedbl 3-4{*}i\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}))}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}
\begin{itemize}
\item \emph{Unevaluated} operations \texttt{\textcolor{blue}{\footnotesize{}Literal}},
\texttt{\textcolor{blue}{\footnotesize{}Mul}}, \texttt{\textcolor{blue}{\footnotesize{}Conj}}
are defined as case classes:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Str(s:~String)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Mul(p1:~Prg,~p2:~Prg)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Conj(p:~Prg)~extends~Prg}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item An \emph{interpreter} will ``run'' the program and return a complex
number
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~run(prg:~Prg):~(Double,~Double)~=~...}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Benefits: programs are data, can compose \& transform before running
\item Shortcomings: this DSL works only with simple expressions
\begin{itemize}
\item Cannot represent variable binding and conditional computations
\item Cannot use any non-DSL code (e.g.~a numerical algorithms library)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern II. Variable binding}

\vspace{-0.1cm}A DSL with variable binding and conditional computations
\begin{itemize}
\item Example: imperative API for reading and writing files
\begin{itemize}
\item Need to bind a \emph{non-DSL variable} to a value computed by DSL
\item Later, need to use that non-DSL variable in DSL expressions
\end{itemize}
\item The rest of the DSL program is a (Scala) function of that variable
\end{itemize}
\vspace{-0.15cm}%
\begin{minipage}[t]{0.35\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~p~=~path(\textquotedbl /file\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~str:~String~=~read(p)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~read(path(str))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}else~\textquotedbl Error:~empty~path\textquotedbl}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}%
\begin{minipage}[t]{0.45\columnwidth}%
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}Bind(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Read(Path(Literal(\textquotedbl /file\textquotedbl ))),}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\{~str~$\Rightarrow$}\textcolor{darkgray}{\footnotesize{}~//~read~value~`str`}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~Read(Path(Literal(str)))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Literal(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\})}{\footnotesize\par}
\end{lyxcode}
%
\end{minipage}\hspace*{\fill}
\begin{itemize}
\item \vspace{0.1cm}Unevaluated operations are implemented via case classes:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind(p:~Prg,~f:~String~$\Rightarrow$~Prg)~extends~Prg~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg)~extends~Prg}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg)~extends~Prg}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.1cm}Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def
run(prg: Prg): String = ...}} 
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern III. Type safety}
\begin{itemize}
\item So far, the DSL has no type safety: every value is a \texttt{\textcolor{blue}{\footnotesize{}Prg}} 
\item We want to avoid errors, e.g. \texttt{\textcolor{blue}{\footnotesize{}Read(Read(...))}}
should not compile
\item Let \texttt{\textcolor{blue}{\footnotesize{}Prg{[}A{]}}} denote a
DSL program returning value of type \texttt{\textcolor{blue}{\footnotesize{}A}}
\emph{when run}:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind(p:~Prg{[}String{]},~f:~String~$\Rightarrow$~Prg{[}String{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~extends~Prg{[}String{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg{[}String{]}~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg{[}String{]})~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg{[}nio.file.Path{]})~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def run(prg: Prg{[}String{]}): String
= ...}}{\footnotesize\par}
\item Our example DSL program is type-safe now:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}val~prg:~Prg{[}String{]}~=~Bind(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~Read(Path(Literal(\textquotedbl /file\textquotedbl ))),}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~\{~str:~String~$\Rightarrow$}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~Read(Path(Literal(str)))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Literal(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~\})}{\footnotesize\par}
\end{lyxcode}
\end{frame}

\begin{frame}{The interpreter pattern IV. Cleaning up the DSL}

\vspace{-0.15cm}Our DSL so far:
\begin{lyxcode}
\vspace{-0.35cm}\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}~\{~def~bind(f:~String$\Rightarrow$Prg{[}String{]}):~Prg{[}String{]}~\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~Prg{[}String{]})~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~Prg{[}nio.file.Path{]})~extends~Prg{[}String{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal(s:~String)~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
Problems with this DSL:
\begin{itemize}
\item Cannot use \texttt{\textcolor{blue}{\footnotesize{}Read(p: nio.file.Path)}},
only \texttt{\textcolor{blue}{\footnotesize{}Read(p: Prg{[}nio.file.Path{]})}} 
\item Cannot bind variables or return values other than \texttt{\textcolor{blue}{\footnotesize{}String}} 
\end{itemize}
To fix these problems:
\begin{itemize}
\item Promote \texttt{\textcolor{blue}{\footnotesize{}Literal}} to a fully
parameterized operation
\item Replace \texttt{\textcolor{blue}{\footnotesize{}Prg{[}A{]}}} by \texttt{\textcolor{blue}{\footnotesize{}A}}
in case class arguments
\end{itemize}
Resulting DSL:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Path(s:~String)~extends~Prg{[}nio.file.Path{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Read(p:~nio.file.Path)~extends~Prg{[}String{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}Note the \texttt{\textcolor{blue}{\footnotesize{}flatMap}}-like
type signature of \texttt{\textcolor{blue}{\footnotesize{}Bind}} 
\end{itemize}
\begin{lyxcode}
\end{lyxcode}
\end{frame}

\begin{frame}{The interpreter pattern V. Define \texttt{Monad}-like methods}
\begin{itemize}
\item \vspace{-0.3cm}We can actually define the methods \texttt{\textcolor{blue}{\footnotesize{}map}},
\texttt{\textcolor{blue}{\footnotesize{}flatMap}}, \texttt{\textcolor{blue}{\footnotesize{}pure}}:
\end{itemize}
\begin{lyxcode}
\vspace{-0.1cm}\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~def~flatMap{[}B{]}(f:~A~$\Rightarrow$~Prg{[}B{]}):~Prg{[}B{]}~=~Bind(this,~f)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~def~map{[}B{]}(f:~A~$\Rightarrow$~B):~Prg{[}B{]}~=~flatMap(this,~f~andThen~Prg.pure)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}object~Prg~\{~def~pure{[}A{]}(a:~A):~Prg{[}A{]}~=~Literal(a)~\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}These methods don't run anything, only create unevaluated
structures
\item DSL programs can now be written as functor blocks and composed:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~readPath(p:~String):~Prg{[}String{]}~=~for~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~path~$\leftarrow$~Path(p)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~str~~$\leftarrow$~Read(path)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~str}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}val~prg:~Prg{[}String{]}~=~for~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~str~$\leftarrow$~readPath(\textquotedbl /file\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~result~$\leftarrow$~~if~(str.nonEmpty)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~readPath(str)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~else~Prg.pure(\textquotedbl Error:~empty~path\textquotedbl )}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~result}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}Interpreter: \texttt{\textcolor{blue}{\footnotesize{}def
run{[}A{]}(prg: Prg{[}A{]}): A = ...}} 
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern VI. Refactoring to an abstract DSL}
\begin{itemize}
\item Write a DSL for complex numbers in a similar way:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Prg{[}A{]}~\{~def~flatMap~...~\}}\textcolor{darkgray}{\footnotesize{}~//~no~code~changes}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}type~Complex~=~(Double,~Double)}\textcolor{darkgray}{\footnotesize{}~//~custom~code~starts~here}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Str(s:~String)~extends~Prg{[}Complex{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Mul(c1:~Complex,~C2:~Complex)~extends~Prg{[}Complex{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Conj(c:~Complex)~extends~Prg{[}Complex{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Refactor this DSL to separate common code from custom code:
\end{itemize}
\begin{lyxcode}
\vspace{-0.15cm}\textcolor{blue}{\footnotesize{}sealed~trait~DSL{[}F{[}\_{]},~A{]}~\{~def~flatMap~...~\}}\textcolor{darkgray}{\footnotesize{}~//~no~code~changes}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}type~Prg{[}A{]}~=~DSL{[}F,~A{]}}\textcolor{darkgray}{\footnotesize{}~//~just~for~convenience}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}A,~B{]}(p:~Prg{[}A{]},~f:~A$\Rightarrow$Prg{[}B{]})~extends~Prg{[}B{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Literal{[}A{]}(a:~A)~extends~Prg{[}A{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Ops{[}A{]}(f:~F{[}A{]})~extends~Prg{[}A{]}}\textcolor{darkgray}{\footnotesize{}~//~custom~operations~here}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Interpreter is parameterized by a ``value extractor'' $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow A\right)$
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~run{[}F{[}\_{]},~A{]}(ex:~Ex{[}F{]})(prg:~DSL{[}F,~A{]}):~A~=~...}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item The constructor \texttt{\textcolor{blue}{\footnotesize{}DSL{[}F{[}\_{]},
A{]}}} is called a \textbf{free monad} over \texttt{\textcolor{blue}{\footnotesize{}F}} 
\end{itemize}
\end{frame}

\begin{frame}{The interpreter pattern VII. Handling errors}
\begin{itemize}
\item \vspace{-0.15cm}To handle errors, we want to evaluate \texttt{\textcolor{blue}{\footnotesize{}DSL{[}F{[}\_{]},
A{]}}} to \texttt{\textcolor{blue}{\footnotesize{}Either{[}Err, A{]}}} 
\item Suppose we have a value extractor of type $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow\text{Err}+A\right)$
\item The code of the interpreter is almost unchanged:
\end{itemize}
\begin{lyxcode}
\vspace{-0.4cm}\textcolor{blue}{\footnotesize{}def~run{[}F{[}\_{]},~A{]}(extract:~Ex{[}F{]})(prg:~DSL{[}F,~A{]}):~Either{[}Err,~A{]}~=}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~prg~match~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~case~b:~Bind{[}F,~\_,~A{]}~\ensuremath{\Rightarrow}~b~match~\{~case~Bind(p,~f)~\ensuremath{\Rightarrow}~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~~~run(extract)(p).flatMap(f~andThen~run(extract))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~\}}\textcolor{darkgray}{\footnotesize{}~~~~~//~Here,~the~.flatMap~is~from~Either.}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~case~Literal(a)~\ensuremath{\Rightarrow}~Right(a)}\textcolor{darkgray}{\footnotesize{}~//~pure:~A~$\Rightarrow$~Err~+~A}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~case~Ops(f)~\ensuremath{\Rightarrow}~extract(f)~~~~~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item \vspace{-0.15cm}The code of \texttt{\textcolor{blue}{\footnotesize{}run}}
only uses \texttt{\textcolor{blue}{\footnotesize{}flatMap}} and \texttt{\textcolor{blue}{\footnotesize{}pure}}
from \texttt{\textcolor{blue}{\footnotesize{}Either}} 
\item We can generalize to any other monad $M^{A}$ instead of \texttt{\textcolor{blue}{\footnotesize{}Either{[}Err,
A{]}}} 
\end{itemize}
The resulting construction:
\begin{itemize}
\item Start with an ``operations type constructor'' $F^{A}$ (often not
a functor)
\item Use $\text{DSL}^{F,A}$ and interpreter {\footnotesize{}$\text{run}:\left(\forall X.F^{X}\Rightarrow M^{X}\right)\Rightarrow\text{DSL}^{F,A}\Rightarrow M^{A}$}{\footnotesize\par}
\item Create a DSL program $\text{prg}:\text{DSL}^{F,A}$ and an extractor
$\text{ex}^{X}:F^{X}\Rightarrow M^{X}$
\item Run the program with the extractor: $\text{run}\left(\text{ex}\right)\left(\text{prg}\right)$;
get a value $M^{A}$
\end{itemize}
\end{frame}

\begin{frame}{Monad laws for DSL programs}

Monad laws hold for DSL programs only after evaluating them
\begin{itemize}
\item Consider the law $\text{flm}\left(\text{pure}\right)=\text{id}$;
both functions $\text{DSL}^{F,A}\Rightarrow\text{DSL}^{F,A}$
\item Apply both sides to some $\text{prg}:\text{DSL}^{F,A}$ and get the
new value
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}prg.flatMap(pure)~==~Bind(prg,~a~$\Rightarrow$~Literal(a))}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item This new value is \emph{not equal} to \texttt{\textcolor{blue}{\footnotesize{}prg}},
so this monad law fails!
\begin{itemize}
\item Other laws fail as well because operations never reduce anything
\end{itemize}
\item After interpreting this program into a target monad $M^{A}$, the
law holds:
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}run(ex)(prg).flatMap((a~$\Rightarrow$~Literal(a))~andThen~run(ex))~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~==~run(ex)(prg).flatMap(a~$\Rightarrow$~run(ex)(Literal(a))~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~==~run(ex)(prg).flatMap(a~$\Rightarrow$~Right(a))}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~==~run(ex)(prg)}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item Here we have assumed that the laws hold for $M^{A}$
\item All other laws also hold after interpreting into a lawful monad $M^{A}$
\end{itemize}
\end{itemize}
The monad law violations are ``not observable''
\end{frame}

\begin{frame}{Free constructions in mathematics: Example I}
\begin{itemize}
\item Consider the Russian letter ц (ts\`{e}) and the Chinese word \begin{CJK}{UTF8}{gbsn}水\end{CJK}
(shu\textipa{\v i})
\item We want to \emph{multiply} ц by \shui. Multiply how?
\item Say, we want an associative (but noncommutative) product of them
\begin{itemize}
\item So we want to define a \emph{semigroup} that \emph{contains} ц and
\shui~as elements
\begin{itemize}
\item while we still know nothing about ц and \shui
\end{itemize}
\end{itemize}
\item Consider the set of all \emph{unevaluated expressions} such as ц$\cdot$\shui$\cdot$\shui$\cdot$ц$\cdot$\shui
\begin{itemize}
\item Here ц$\cdot$\shui~is different from \shui$\cdot$ц but $\left(a\cdot b\right)\cdot c=a\cdot\left(b\cdot c\right)$
\end{itemize}
\item All these expressions form a \textbf{free semigroup} generated by
ц and \shui
\item Example calculation: (\shui$\cdot$\shui)$\cdot$(ц$\cdot$\shui)$\cdot$ц
$=$ \shui$\cdot$\shui$\cdot$ц$\cdot$\shui$\cdot$ц
\end{itemize}
How to represent this as a data type:
\begin{itemize}
\item Tree encoding: the full expression tree: ((\shui,\shui),(ц,\shui)),ц)
\begin{itemize}
\item Implement the operation $a\cdot b$ as pair constructor (easy and
cheap)
\end{itemize}
\item Reduced encoding, as a ``smart'' structure: List(\shui,\shui,ц,\shui,ц)
\begin{itemize}
\item Implement $a\cdot b$ by concatenating the lists (more expensive)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Free constructions in mathematics: Example II}
\begin{itemize}
\item Want to define a product operation for $n$-dimensional vectors: $\mathbf{v}_{1}\otimes\mathbf{v}_{2}$
\item The $\otimes$ must be linear and distributive (but not commutative):
\begin{align*}
\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\left(\mathbf{u}_{2}\otimes\mathbf{v}_{2}+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\right) & =\left(\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}\right)+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\\
\mathbf{u}\otimes\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & =a_{1}\left(\mathbf{u}\otimes\mathbf{v}_{1}\right)+a_{2}\left(\mathbf{u}\otimes\mathbf{v}_{2}\right)\\
\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & \otimes\mathbf{u}=a_{1}\left(\mathbf{v}_{1}\otimes\mathbf{u}\right)+a_{2}\left(\mathbf{v}_{2}\otimes\mathbf{u}\right)
\end{align*}

\begin{itemize}
\item We have such a product for 3-dimensional vectors only; ignore that
\end{itemize}
\item Consider \emph{unevaluated} \emph{expressions} of the form $\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}+...$
\begin{itemize}
\item A free vector space generated by pairs of vectors
\end{itemize}
\item Impose the equivalence relationships shown above
\begin{itemize}
\item The result is known as the \textbf{tensor product}
\end{itemize}
\item Tree encoding: full unevaluated expression tree
\begin{itemize}
\item A list of any number of vector pairs $\sum_{i}\mathbf{u}_{i}\otimes\mathbf{v}_{i}$
\end{itemize}
\item Reduced encoding: a matrix
\begin{itemize}
\item Reduced encoding requires proof and more complex operations
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Worked example: Free semigroup}

{\footnotesize{}\vspace{-0.15cm}}Implement a free semigroup \texttt{\textcolor{blue}{\footnotesize{}FSIS}}
generated by two types \texttt{\textcolor{blue}{\footnotesize{}Int}}
and \texttt{\textcolor{blue}{\footnotesize{}String}} 
\begin{itemize}
\item A value of \texttt{\textcolor{blue}{\footnotesize{}FSIS}} can be an
\texttt{\textcolor{blue}{\footnotesize{}Int}}; it can also be a \texttt{\textcolor{blue}{\footnotesize{}String}} 
\item If \texttt{\textcolor{blue}{\footnotesize{}x}}, \texttt{\textcolor{blue}{\footnotesize{}y}}
are of type \texttt{\textcolor{blue}{\footnotesize{}FSIS}} then so
is \texttt{\textcolor{blue}{\footnotesize{}Mul(x, y)}} 
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~FSIS~}\textcolor{darkgray}{\footnotesize{}//~tree~encoding:~full~expression~tree}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Wrap1(x:~Int)~extends~FSIS}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Wrap2(x:~String)~extends~FSIS}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Mul(x:~FSIS,~y:~FSIS)~extends~FSIS}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}Short type notation: $\text{FSIS}\equiv\text{Int}+\text{String}+\text{FSIS}\times\text{FSIS}$ 
\item For a semigroup $S$ and given $\text{Int}\Rightarrow S$ and $\text{String}\Rightarrow S$,
map $\text{FSIS}\Rightarrow S$
\item Simplify and generalize this construction by setting $Z=\text{Int}+\text{String}$
\item The redundant encoding is $\text{FS}^{Z}=Z+\text{FS}^{Z}\times\text{FS}^{Z}$
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~mul(x:~FS{[}Z{]},~y:~FS{[}Z{]}):~FS{[}Z{]}~=~Mul(x,~y)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~run{[}S:~Semigroup,~Z{]}(extract:~Z~$\Rightarrow$~S):~FS{[}Z{]}~$\Rightarrow$~S~=~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~case~F(z)~$\Rightarrow$~extract(z)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~case~Mul(x,~y)~$\Rightarrow$or{blue}{\footnotesize{}~~case~Mul(x,~y)~$\Rightarrow$~run(extract)(x)~|+|~run(extract)(y)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~}\textcolor{darkgray}{\footnotesize{}//~Semigroup~laws~hold~after~applying~run().}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}The reduced encoding is $\text{FSR}^{Z}\equiv Z\times\text{List}^{Z}$
(non-empty list of $Z$'s)
\begin{itemize}
\item The multiplication requires concatenating the lists 
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Worked example: Free monoid}

{\footnotesize{}\vspace{-0.15cm}}Implement a free monoid \texttt{\textcolor{blue}{\footnotesize{}FM{[}Z{]}}}
generated by type \texttt{\textcolor{blue}{\footnotesize{}Z}} 
\begin{itemize}
\item A value of \texttt{\textcolor{blue}{\footnotesize{}FM{[}Z{]}}} can
be the empty value; it can also be a \texttt{\textcolor{blue}{\footnotesize{}Z}} 
\item If \texttt{\textcolor{blue}{\footnotesize{}x}}, \texttt{\textcolor{blue}{\footnotesize{}y}}
are of type \texttt{\textcolor{blue}{\footnotesize{}FM{[}Z{]}}} then
so is \texttt{\textcolor{blue}{\footnotesize{}Mul(x, y)}} 
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~FM{[}Z{]}~}\textcolor{darkgray}{\footnotesize{}//~tree~encoding}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Empty{[}Z{]}()~extends~FM{[}Z{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Wrap{[}Z{]}(z:~Z)~extends~FM{[}Z{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Mul{[}Z{]}(x:~FM{[}Z{]},~y:~FM{[}Z{]})~extends~FM{[}Z{]}}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}Short type notation: $\text{FM}^{Z}\equiv1+Z+\text{FM}^{Z}\times\text{FM}^{Z}$ 
\item For a monoid $M$ and given $Z\Rightarrow M$, map $\text{FM}^{Z}\Rightarrow M$
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~mul(x:~FM{[}Z{]},~y:~FM{[}Z{]}):~FM{[}Z{]}~=~Mul(x,~y)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~run{[}M:~Monoid,~Z{]}(extract:~Z~$\Rightarrow$~M):~FM{[}Z{]}~$\Rightarrow$~M~=~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~case~Empty()~$\Rightarrow$~Monoid{[}M{]}.empty}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~case~Wrap(z)~$\Rightarrow$~extract(z)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~case~Mul(x,~y)~$\Rightarrow$~run(extract)(x)~|+|~run(extract)(y)}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~}\textcolor{darkgray}{\footnotesize{}//~Monoid~laws~hold~after~applying~run().}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}The reduced encoding is $\text{FMR}^{Z}\equiv\text{List}^{Z}$
(list of $Z$'s)
\begin{itemize}
\item The multiplication requires concatenating the lists 
\end{itemize}
\item Reduced encoding and tree encodings give identical results after \texttt{\textcolor{blue}{\footnotesize{}run()}} 
\end{itemize}
\end{frame}

\begin{frame}{Exercises}
\begin{enumerate}
\item {\footnotesize{}\vspace{-0.15cm}Show that }{\footnotesize\par}
\end{enumerate}
\end{frame}

\end{document}
