#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Generating code with Curry-Howard]{Generating code from type signatures
using the Curry-Howard correspondence}
\subtitle{With implementations in Haskell and Scala}
\author{Sergei Winitzki}
\date{March 22, 2018}
\institute[BAHUG]{Bay Area Haskell Users' Group}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type-directed coding
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
How to implement functions given their type?
\end_layout

\begin_layout Standard
We write code 
\begin_inset Quotes eld
\end_inset

guided by the types
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
Implement 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 for the Reader monad,
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}::\left(a\rightarrow b\right)\rightarrow\left(e\rightarrow a\right)\rightarrow\left(e\rightarrow b\right)
\]

\end_inset


\end_layout

\begin_layout Enumerate
Show that one cannot implement
\size footnotesize
 
\begin_inset Formula $\left(e\rightarrow f\right)\rightarrow\left(e\rightarrow a\right)\rightarrow\left(f\rightarrow a\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Implement 
\size footnotesize

\begin_inset Formula $\text{fmap}::\left(a\rightarrow b\right)\rightarrow\left(e\rightarrow\text{Maybe}\,a\right)\rightarrow\left(e\rightarrow\text{Maybe}\,b\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Implement the distributive law: 
\family typewriter
\size footnotesize
\color blue

\begin_inset Formula 
\begin{align*}
\left(A+B\right)\times C & \Leftrightarrow A\times C+B\times C\\
(\text{Either}\,a\,b,c) & \equiv\text{Either}\left(a,c\right)\left(b,c\right)
\end{align*}

\end_inset


\family default
\size default
\color inherit
Can we generate the code automatically?
\end_layout

\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "djinn-ghc"
target "https://hackage.haskell.org/package/djinn-ghc"

\end_inset

 compiler plugin and the 
\begin_inset CommandInset href
LatexCommand href
name "JustDoIt plugin"
target "https://github.com/nomeata/ghc-justdoit"

\end_inset

 generate Haskell code from type (need 
\begin_inset CommandInset href
LatexCommand href
name "tooling"
target "https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#working-with-holes"

\end_inset

 to use)
\end_layout

\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"

\end_inset

 library generates Scala code from type signatures
\end_layout

\begin_layout Standard
Often, there is only one 
\begin_inset Quotes eld
\end_inset

useful
\begin_inset Quotes erd
\end_inset

 implementation out of many
\end_layout

\begin_layout Standard
The 
\family typewriter
\size footnotesize
\color blue
djinn
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
curryhoward
\family default
\size default
\color inherit
 libraries try to generate that implementation
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Haskell: Using the 
\family typewriter
djinn
\family default
 tool
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Demo time
\end_layout

\begin_layout Standard
Features:
\end_layout

\begin_layout Itemize
Haskell syntax, supports algebraic data types and type classes
\end_layout

\begin_layout Itemize
Constant types (
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
, etc.) are treated as type parameters
\end_layout

\begin_layout Itemize
If several implementations are available, chooses 
\begin_inset Quotes eld
\end_inset

intelligently
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Can output several implementations if desired
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
Djinn> f1 ? (a -> b) -> (e -> a) -> (e -> b)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
f1 :: (a -> b) -> (e -> a) -> e -> b
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
f1 a b c = a (b c)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
Djinn> f2 ? (a, a, a) -> Maybe (a, a, a) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
f :: (a, a, a) -> Maybe (a, a, a)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
f (a, b, c) = Just (c, b, a)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Scala: Using the 
\family typewriter
curryhoward
\family default
 library
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Two main use cases:
\end_layout

\begin_layout Enumerate
Define a method and provide an automatic implementation
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def map[E, A, B](readerA: E 
\begin_inset Formula $\Rightarrow$
\end_inset

 A, f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): E 
\begin_inset Formula $\Rightarrow$
\end_inset

 B = implement
\end_layout

\end_deeper
\begin_layout Enumerate
Automatically build an expression from previously computed values
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Boolean 
\begin_inset Formula $\Rightarrow$
\end_inset

 Int = {...}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Result(x: Int, name: String)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result = ofType[Result]("abc", f, true)
\end_layout

\end_deeper
\begin_layout Standard
Features:
\end_layout

\begin_layout Itemize
Compile-time code generation via Scala macros
\end_layout

\begin_layout Itemize
Supports functions, tuples, sealed trait / case classes / case objects
\end_layout

\begin_layout Itemize
Constant types (
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
, etc.) are treated as type parameters
\end_layout

\begin_layout Itemize
If several implementations are available, chooses 
\begin_inset Quotes eld
\end_inset

intelligently
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Lambda-calculus evaluator available for symbolic law checking
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Benefits and limitations of this method
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Benefits:
\end_layout

\begin_layout Itemize
Save time implementing 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 functions
\end_layout

\begin_layout Itemize
With some more work, can verify algebraic laws
\end_layout

\begin_layout Itemize
In many practical use cases, supports type class derivation
\end_layout

\begin_layout Standard
Limitations:
\end_layout

\begin_layout Itemize
Heuristics often fail with certain kinds of data (repeated types)
\end_layout

\begin_layout Itemize
Cannot generate recursive code
\end_layout

\begin_layout Itemize
Cannot depend on existing type class instances (
\family typewriter
\size footnotesize
\color blue
Functor f 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\family default
\size default
\color inherit
)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructions in functional programming
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
The common ground between Haskell, Scala, Rust, OCaml, and other languages
\end_layout

\begin_layout Standard
Type constructions common in FP languages:
\end_layout

\begin_layout Itemize
Tuple (
\begin_inset Quotes eld
\end_inset

product
\begin_inset Quotes erd
\end_inset

) type: 
\begin_inset Formula $\text{Int}\times\text{String}$
\end_inset


\end_layout

\begin_layout Itemize
Function type: 
\begin_inset Formula $\text{Int}\Rightarrow\text{String}$
\end_inset


\end_layout

\begin_layout Itemize
Disjunction (
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

) type: 
\begin_inset Formula $\text{Int}+\text{String}$
\end_inset


\end_layout

\begin_layout Itemize
Unit type (
\begin_inset Quotes eld
\end_inset

empty tuple
\begin_inset Quotes erd
\end_inset

): 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Itemize
Type parameters: 
\begin_inset Formula $\text{List}^{T}$
\end_inset


\end_layout

\begin_layout Standard
Up to differences in syntax, the FP languages share all these features
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructions: Haskell syntax
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tuple type: 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
pair = (123, "abc")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
(_, y) = pair
\end_layout

\end_deeper
\begin_layout Itemize
Function type: 
\family typewriter
\size footnotesize
\color blue
Int -> String
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
f = 
\backslash
x -> "Value is " ++ show x
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
y = f 123
\end_layout

\end_deeper
\begin_layout Itemize
Disjunction type: 
\family typewriter
\size footnotesize
\color blue
data E = Left Int | Right String
\end_layout

\begin_deeper
\begin_layout Itemize
Create:
\begin_inset Newline newline
\end_inset


\begin_inset space \space{}
\end_inset

 
\family typewriter
\size footnotesize
\color blue
x = Left 123
\begin_inset Newline newline
\end_inset

 y = Right "abc"
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
z = case x of
\begin_inset Newline newline
\end_inset

 Left i -> i > 0
\begin_inset Newline newline
\end_inset

 Right _ -> false
\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Unit type: 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
x = ()
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type constructions: Scala syntax
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tuple type: 
\family typewriter
\size footnotesize
\color blue
(Int, String)
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
val pair:
\begin_inset space \space{}
\end_inset

(Int, String) = (123, "abc")
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
val y:
\begin_inset space \space{}
\end_inset

String = pair._2
\end_layout

\end_deeper
\begin_layout Itemize
Function type: 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
def f:
\begin_inset space \space{}
\end_inset

(Int 
\begin_inset Formula $\Rightarrow$
\end_inset

 String) = x 
\begin_inset Formula $\Rightarrow$
\end_inset

 "Value is " + x.toString
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
val y:
\begin_inset space \space{}
\end_inset

String = f(123)
\end_layout

\end_deeper
\begin_layout Itemize
Disjunction type: 
\family typewriter
\size footnotesize
\color blue
Either[Int, String]
\family default
\size default
\color inherit
 defined in standard library
\end_layout

\begin_deeper
\begin_layout Itemize
Create:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size footnotesize
\color blue

\begin_inset space \space{}
\end_inset

val x:
\begin_inset space \space{}
\end_inset

Either[Int, String] = Left(123)
\begin_inset Newline newline
\end_inset

 val y:
\begin_inset space \space{}
\end_inset

Either[Int, String] = Right("abc")
\end_layout

\begin_layout Itemize
Use: 
\family typewriter
\size footnotesize
\color blue
val z:
\begin_inset space \space{}
\end_inset

Boolean = x match {
\begin_inset Newline newline
\end_inset

 case Left(i) 
\begin_inset Formula $\Rightarrow$
\end_inset

 i > 0
\begin_inset Newline newline
\end_inset

 case Right(_) 
\begin_inset Formula $\Rightarrow$
\end_inset

 false
\begin_inset Newline newline
\end_inset

}
\end_layout

\end_deeper
\begin_layout Itemize
Unit type: 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\family typewriter
\size footnotesize
\color blue
val x:
\begin_inset space \space{}
\end_inset

Unit = ()
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
From types to propositions
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The code 
\family typewriter
\size footnotesize
\color blue
x::
\begin_inset space \space{}
\end_inset

t; x =
\family default
\size default
\color inherit
 ...
 shows that 
\emph on
we can compute a value
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
t
\family default
\size default
\color inherit
 as part of our program expression
\end_layout

\begin_layout Itemize
Let's denote this 
\emph on
proposition
\emph default
 by 
\begin_inset Formula ${\cal CH}(t)$
\end_inset

 â€“ 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathcal{C}$
\end_inset

ode 
\begin_inset Formula $\mathcal{H}$
\end_inset

as a value of type 
\family typewriter
\size footnotesize
\color blue
t
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Correspondence between types and propositions, for a given program:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Short notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(t)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(a, b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(a)$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula ${\cal CH}(b)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a\wedge b$
\end_inset

; 
\begin_inset Formula $a\times b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
A a | B b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(a)$
\end_inset

 
\emph on
or
\emph default
 
\begin_inset Formula ${\cal CH}(b)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a\vee b$
\end_inset

; 
\begin_inset Formula $a+b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
a 
\begin_inset Formula $\rightarrow$
\end_inset

 b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(a)$
\end_inset

 
\emph on
implies
\emph default
 
\begin_inset Formula ${\cal CH}(b)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a\Rightarrow b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Type parameter in a function type means 
\begin_inset Formula $\forall t$
\end_inset


\end_layout

\begin_layout Itemize
Example: 
\family typewriter
\size footnotesize
\color blue
dupl::
\begin_inset space \space{}
\end_inset

a 
\begin_inset Formula $\rightarrow$
\end_inset

 (a, a)
\family default
\size default
\color inherit
.
 The type of this function, 
\begin_inset Formula $a\Rightarrow a\times a$
\end_inset

, corresponds to the theorem 
\begin_inset Formula $\forall a:a\Rightarrow a\wedge a$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Translating language constructions into the logic I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
How to represent logical relationships between 
\begin_inset Formula ${\cal CH}(...)$
\end_inset

 propositions?
\end_layout

\begin_layout Standard
Code expressions create
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
,
\end_layout

\end_inset


\emph on
logical relationships
\emph default
 between propositions 
\begin_inset Formula ${\cal CH}(...)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Logical relationships
\begin_inset Quotes erd
\end_inset

 = what will be true if something given is true
\end_layout

\begin_layout Itemize
The elementary proof task is represented by a 
\series bold
sequent
\end_layout

\begin_deeper
\begin_layout Itemize
Notation: 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

; the 
\series bold
premises
\series default
 are 
\begin_inset Formula $A,B,C$
\end_inset

 and the 
\series bold
goal
\series default
 is G
\end_layout

\end_deeper
\begin_layout Itemize
Proofs are achieved via axioms and derivation rules
\end_layout

\begin_deeper
\begin_layout Itemize
Axioms: such and such sequents are already true
\end_layout

\begin_layout Itemize
Derivation rules: this sequent is true if such and such sequents are true
\end_layout

\end_deeper
\begin_layout Itemize
To make connection with logic, represent code fragments as 
\series bold
sequents
\end_layout

\begin_layout Itemize

\color blue
\begin_inset Formula $a,b\vdash c$
\end_inset


\color inherit
 represents an 
\emph on
expression
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
c
\family default
\size default
\color inherit
 that uses 
\family typewriter
\size footnotesize
\color blue
x ::
\begin_inset space \space{}
\end_inset

a
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
y ::
\begin_inset space \space{}
\end_inset

b
\end_layout

\begin_layout Itemize
Examples in Haskell (assume 
\family typewriter
\size footnotesize
\color blue
x ::
\begin_inset space \space{}
\end_inset

Int
\family default
\size default
\color inherit
):
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
show x ++ "abc"
\family default
\size default
\color inherit
 is an expression of type 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 that uses an 
\family typewriter
\size footnotesize
\color blue
x::
\begin_inset space \space{}
\end_inset

Int
\family default
\size default
\color inherit
, and is represented by the sequent 
\begin_inset Formula $\text{Int}\vdash\text{String}$
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue

\backslash
x 
\begin_inset Formula $\rightarrow$
\end_inset

 show x + "abc"
\family default
\size default
\color inherit
 is an expression of type 
\family typewriter
\size footnotesize
\color blue
Int 
\begin_inset Formula $\rightarrow$
\end_inset

 String
\family default
\size default
\color inherit
 and is represented by the sequent 
\begin_inset Formula $\emptyset\vdash\text{Int}\Rightarrow\text{String}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sequents only describe the 
\emph on
types
\emph default
 of expressions and their parts
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Translating language constructions into the logic II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
What are the derivation rules for the logic of types?
\end_layout

\begin_layout Standard
Write all the constructions in FP languages as sequents
\end_layout

\begin_layout Itemize
This will give all the derivation rules for the logic of types
\end_layout

\begin_deeper
\begin_layout Itemize
Each type construction has an expression for creating it and an expression
 for using it
\end_layout

\end_deeper
\begin_layout Itemize
Tuple type 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\begin_inset Formula $A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
Use: 
\begin_inset Formula $A\times B\vdash A$
\end_inset

 and also 
\begin_inset Formula $A\times B\vdash B$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Function type 
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create: if we have 
\begin_inset Formula $A\vdash B$
\end_inset

 then we will have 
\begin_inset Formula $\emptyset\vdash A\Rightarrow B$
\end_inset

 
\end_layout

\begin_layout Itemize
Use: 
\begin_inset Formula $A\Rightarrow B,A\vdash B$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Disjunction type 
\begin_inset Formula $A+B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\begin_inset Formula $A\vdash A+B$
\end_inset

 and also 
\begin_inset Formula $B\vdash A+B$
\end_inset


\end_layout

\begin_layout Itemize
Use: 
\begin_inset Formula $A+B,A\Rightarrow C,B\Rightarrow C\vdash C$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Unit type 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Create: 
\begin_inset Formula $\emptyset\vdash1$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Translating language constructions into the logic III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Additional rules for the logic of types
\end_layout

\begin_layout Standard
In addition to constructions that use types, we have 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 constructions:
\end_layout

\begin_layout Itemize
a single, unmodified value of type 
\begin_inset Formula $A$
\end_inset

 is a valid expression of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
For any 
\begin_inset Formula $A$
\end_inset

 we have the sequent 
\begin_inset Formula $A\vdash A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
if a value can be computed using some given data, it can also be computed
 if given
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
,
\end_layout

\end_inset


\emph on
additional
\emph default
 data
\end_layout

\begin_deeper
\begin_layout Itemize
If we have 
\begin_inset Formula $A,...,C\vdash G$
\end_inset

 then also 
\begin_inset Formula $A,...,C,D\vdash G$
\end_inset

 for any 
\begin_inset Formula $D$
\end_inset


\end_layout

\begin_layout Itemize
For brevity, we denote by 
\begin_inset Formula $\Gamma$
\end_inset

 a sequence of arbitrary premises
\end_layout

\end_deeper
\begin_layout Itemize
the order in which data is given does not matter, we can still compute all
 the same things given the same premises in different order
\end_layout

\begin_deeper
\begin_layout Itemize
If we have 
\begin_inset Formula $\Gamma,A,B\vdash G$
\end_inset

 then we also have 
\begin_inset Formula $\Gamma,B,A\vdash G$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Syntax conventions:
\end_layout

\begin_layout Itemize
the implication operation associates 
\emph on
to the right
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A\Rightarrow B\Rightarrow C$
\end_inset

 means 
\begin_inset Formula $A\Rightarrow\left(B\Rightarrow C\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
precedence order: implication, disjunction, conjunction
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A+B\times C\Rightarrow D$
\end_inset

 means 
\begin_inset Formula $\left(A+\left(B\times C\right)\right)\Rightarrow D$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Quantifiers: implicitly, all our type variables are universally quantified
\end_layout

\begin_layout Itemize
When we write 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset

, we mean 
\begin_inset Formula $\forall A:\forall B:A\Rightarrow B\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The logic of types I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Now we have all the axioms and the derivation rules of the logic of types.
\end_layout

\begin_layout Itemize
What theorems can we derive in this logic?
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Start with an axiom 
\begin_inset Formula $A\vdash A$
\end_inset

; add an unused extra premise 
\begin_inset Formula $B$
\end_inset

: 
\begin_inset Formula $A,B\vdash A$
\end_inset


\end_layout

\begin_layout Itemize
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

, get 
\begin_inset Formula $A\vdash B\Rightarrow A$
\end_inset


\end_layout

\begin_layout Itemize
Use the 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule with 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B\Rightarrow A$
\end_inset

, get the final sequent 
\begin_inset Formula $\emptyset\vdash A\Rightarrow B\Rightarrow A$
\end_inset

 showing that 
\begin_inset Formula $A\Rightarrow B\Rightarrow A$
\end_inset

 is a 
\series bold
theorem
\series default
 since it is derived from no premises
\end_layout

\end_deeper
\begin_layout Itemize
What code does this describe?
\end_layout

\begin_deeper
\begin_layout Itemize
The axiom 
\begin_inset Formula $A\vdash A$
\end_inset

 represents the expression 
\begin_inset Formula $x^{A}$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 is of type 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Itemize
The unused premise 
\begin_inset Formula $B$
\end_inset

 corresponds to unused variable 
\begin_inset Formula $y^{B}$
\end_inset

 of type 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives the function 
\begin_inset Formula $y^{B}\Rightarrow x^{A}$
\end_inset


\end_layout

\begin_layout Itemize
The second 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 rule gives 
\begin_inset Formula $x^{A}\Rightarrow\left(y^{B}\Rightarrow x\right)$
\end_inset


\end_layout

\begin_layout Itemize
Haskell code:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
f :: A 
\begin_inset Formula $\rightarrow$
\end_inset

 B 
\begin_inset Formula $\rightarrow$
\end_inset

 A
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
f = 
\backslash
x 
\begin_inset Formula $\rightarrow$
\end_inset

 
\backslash
y 
\begin_inset Formula $\rightarrow$
\end_inset

 x
\end_layout

\end_deeper
\begin_layout Itemize
Any code expression's type can be translated into a sequent
\end_layout

\begin_layout Itemize
A proof of a theorem directly guides us in writing code for that type
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Correspondence between programs and proofs
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
By construction, any theorem can be implemented in code
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
identity x = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
toUnit x = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Left :: a 
\begin_inset Formula $\rightarrow$
\end_inset

 Either a b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\times B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
fst :: (a, b) 
\begin_inset Formula $\rightarrow$
\end_inset

 a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
const = 
\backslash
x 
\begin_inset Formula $\rightarrow$
\end_inset

 
\backslash
y 
\begin_inset Formula $\rightarrow$
\end_inset

 x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Also, non-theorems 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_deeper
\begin_layout Itemize
Examples of non-theorems:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\Rightarrow A$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:A+B\Rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\Rightarrow A\times B$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Given a type's formula, can we implement it in code? Not obvious.
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\forall A\forall B:((((A\Rightarrow B)\Rightarrow A)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Can we write a function with this type? Can we prove this formula?
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The logic of types II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
What kind of logic is this? What do mathematicians call this logic?
\end_layout

\begin_layout Standard
This is called 
\begin_inset Quotes eld
\end_inset

intuitionistic propositional logic
\begin_inset Quotes erd
\end_inset

, IPL (also 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
This is a 
\begin_inset Quotes eld
\end_inset

nonclassical
\begin_inset Quotes erd
\end_inset

 logic because it is different from Boolean logic
\end_layout

\begin_layout Itemize
Disjunction works very differently from Boolean logic
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $A\Rightarrow B+C\vdash(A\Rightarrow B)+(A\Rightarrow C)$
\end_inset

 does not hold in IPL
\end_layout

\begin_layout Itemize
This is counter-intuitive!
\end_layout

\begin_layout Itemize
We cannot implement a function with this type:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
q :: (a 
\begin_inset Formula $\rightarrow$
\end_inset

 Either b c) 
\begin_inset Formula $\rightarrow$
\end_inset

 Either (a 
\begin_inset Formula $\rightarrow$
\end_inset

 b) (a 
\begin_inset Formula $\rightarrow$
\end_inset

 c)
\end_layout

\begin_layout Itemize
Disjunction is 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

: need to supply one of the parts
\end_layout

\begin_deeper
\begin_layout Itemize
...but 
\family typewriter
\size footnotesize
\color blue
Either (a 
\begin_inset Formula $\rightarrow$
\end_inset

 b) (a 
\begin_inset Formula $\rightarrow$
\end_inset

 c)
\family default
\size default
\color inherit
 is not a function of 
\family typewriter
\size footnotesize
\color blue
a
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Implication works somewhat differently
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\left(\left(A\Rightarrow B\right)\Rightarrow A\right)\Rightarrow A$
\end_inset

 holds in Boolean logic but not in IPL
\end_layout

\begin_layout Itemize
Cannot compute an 
\family typewriter
\size footnotesize
\color blue
x ::
\begin_inset space \space{}
\end_inset

A
\family default
\size default
\color inherit
 because of insufficient data
\end_layout

\end_deeper
\begin_layout Itemize
Conjunction works the same as in Boolean logic
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula 
\[
A\Rightarrow B\times C\vdash\left(A\Rightarrow B\right)\times\left(A\Rightarrow C\right)
\]

\end_inset

 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The logic of types III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
How to determine whether a given IPL formula is a theorem?
\end_layout

\begin_layout Itemize
The IPL cannot have a truth table with a fixed number of truth values
\end_layout

\begin_deeper
\begin_layout Itemize
This was shown by G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
"
\end_layout

\end_inset

odel in 1932 (see 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia page"
target "https://en.wikipedia.org/wiki/Many-valued_logic"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
The IPL has a decision procedure (algorithm) that either finds a proof for
 a given IPL formula, or determines that there is no proof
\end_layout

\begin_layout Itemize
There may be several inequivalent proofs of an IPL theorem
\end_layout

\begin_layout Itemize
Each proof can be 
\emph on
automatically translated
\emph default
 into code
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "djinn-ghc"
target "https://hackage.haskell.org/package/djinn-ghc"

\end_inset

 compiler plugin and the 
\begin_inset CommandInset href
LatexCommand href
name "JustDoIt plugin"
target "https://github.com/nomeata/ghc-justdoit"

\end_inset

 implement an IPL prover in Haskell, and generate Haskell code from types
\end_layout

\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"

\end_inset

 library implements an IPL prover as a Scala macro, and generates Scala
 code from types
\end_layout

\end_deeper
\begin_layout Itemize
All these IPL provers use the same basic algorithm called LJT 
\end_layout

\begin_deeper
\begin_layout Itemize
and all cite the same paper 
\size footnotesize

\begin_inset CommandInset href
LatexCommand href
name "[Dyckhoff 1992]"
target "https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf"

\end_inset


\end_layout

\begin_layout Itemize
because most other papers on this subject are incomprehensible to non-specialist
s, or describe algorithms that are too complicated
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search I: looking for an algorithm
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Why our initial presentation of IPL does not give a proof search algorithm
\end_layout

\begin_layout Standard
The FP type constructions give nine axioms and three derivation rules:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Itemize
\begin_inset Formula $\Gamma,A,B\vdash A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash A$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\times B\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\Rightarrow B,A\vdash B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A+B$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,B\vdash A+B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A+B,A\Rightarrow C,B\Rightarrow C\vdash C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma\vdash1$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma,A\vdash A$
\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma,A\vdash B}{\Gamma\vdash A\Rightarrow B}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma\vdash G}{\Gamma,D\vdash G}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma,A,B\vdash G}{\Gamma,B,A\vdash G}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Can we use these rules to obtain a finite and complete search tree? No.
\end_layout

\begin_layout Itemize
Try proving 
\begin_inset Formula $A,B+C\vdash A\times B+C$
\end_inset

: cannot find matching rules
\end_layout

\begin_deeper
\begin_layout Itemize
Need a better formulation of the logic
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search II: Gentzen's calculus LJ (1935)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

complete and sound calculus
\begin_inset Quotes erd
\end_inset

 is a set of axioms and derivation rules that will yield all (and only!)
 theorems of the logic
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{}{\Gamma,{\color{blue}X}\vdash X}\:Id & \qquad\frac{}{\Gamma\vdash{\color{blue}\top}}\,\top\\
\frac{\Gamma,A\Rightarrow B\vdash A\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A\Rightarrow B}\vdash C}\:L\Rightarrow & \qquad\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\Rightarrow B}}\,R\Rightarrow\\
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+ & \qquad\frac{\Gamma\vdash A_{i}}{\Gamma\vdash{\color{blue}A_{1}+A_{2}}}\,R+_{i}\\
\frac{\Gamma,A_{i}\vdash C}{\Gamma,{\color{blue}A_{1}\times A_{2}}\vdash C}\:L\times_{i} & \qquad\frac{\Gamma\vdash A\quad\;\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\times B}}\,R\times
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Two axioms and eight derivation rules
\end_layout

\begin_deeper
\begin_layout Itemize
Each derivation rule says: The sequent at bottom will be proved if proofs
 are given for sequent(s) at top
\end_layout

\end_deeper
\begin_layout Itemize
Use these rules 
\begin_inset Quotes eld
\end_inset

bottom-up
\begin_inset Quotes erd
\end_inset

 to perform a proof search
\end_layout

\begin_deeper
\begin_layout Itemize
Sequents are nodes and proofs are edges in the proof search tree
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search example I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Example: to prove 
\begin_inset Formula $\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q$
\end_inset


\end_layout

\begin_layout Itemize
Root sequent 
\begin_inset Formula $S_{0}:\emptyset\vdash\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{0}$
\end_inset

 with rule 
\begin_inset Formula $R\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{1}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash Q$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{1}$
\end_inset

 with rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{2}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash R\Rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{3}:Q\vdash Q$
\end_inset


\end_layout

\begin_layout Itemize
Sequent 
\begin_inset Formula $S_{3}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom; it remains to prove 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{4}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash R\Rightarrow R$
\end_inset

 and 
\begin_inset Formula $S_{5}:Q\vdash R\Rightarrow R$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We are stuck here because 
\begin_inset Formula $S_{4}=S_{2}$
\end_inset

 (we are in a loop)
\end_layout

\begin_layout Itemize
We can prove 
\begin_inset Formula $S_{5}$
\end_inset

, but that will not help
\end_layout

\begin_layout Itemize
So we backtrack (erase 
\begin_inset Formula $S_{4}$
\end_inset

, 
\begin_inset Formula $S_{5}$
\end_inset

) and apply another rule to 
\begin_inset Formula $S_{2}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $S_{2}$
\end_inset

 with rule 
\begin_inset Formula $R\Rightarrow$
\end_inset

 yields 
\begin_inset Formula $S_{6}:\left(R\Rightarrow R\right)\Rightarrow Q;R\vdash R$
\end_inset


\end_layout

\begin_layout Itemize
Sequent 
\begin_inset Formula $S_{6}$
\end_inset

 follows from the 
\begin_inset Formula $Id$
\end_inset

 axiom
\end_layout

\begin_layout Standard
Therefore we have proved 
\begin_inset Formula $S_{0}$
\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q$
\end_inset

 is derived from no premises, it is a theorem
\end_layout

\begin_layout Standard
\begin_inset Formula $Q.E.D.$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search III: The calculus LJT
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Vorobieff-Hudelmaier-Dyckhoff, 1950-1990
\end_layout

\begin_layout Itemize
The Gentzen calculus LJ will loop if rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 is applied 
\begin_inset Formula $\geq2$
\end_inset

 times
\end_layout

\begin_layout Itemize
The calculus LJT keeps all rules of LJ except rule 
\begin_inset Formula $L\Rightarrow$
\end_inset


\end_layout

\begin_layout Itemize
Replace rule 
\begin_inset Formula $L\Rightarrow$
\end_inset

 by pattern-matching on 
\begin_inset Formula $A$
\end_inset

 in the premise 
\begin_inset Formula $A\Rightarrow B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{(}X\text{ is atomic)\,}\frac{\Gamma,X,B\vdash D}{\Gamma,X,{\color{blue}X\Rightarrow B}\vdash D}\:L\Rightarrow_{1}\\
\frac{\Gamma,A\Rightarrow B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\Rightarrow C}\vdash D}\:L\Rightarrow_{2}\\
\frac{\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A+B)\Rightarrow C}\vdash D}\:L\Rightarrow_{3}\\
\frac{\Gamma,B\Rightarrow C\vdash A\Rightarrow B\quad\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\Rightarrow B)\Rightarrow C}\vdash D}\:L\Rightarrow_{4}
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
When using LJT rules, the proof tree has no loops and terminates
\end_layout

\begin_deeper
\begin_layout Itemize
See 
\begin_inset CommandInset href
LatexCommand href
name "this paper"
target "http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2618"

\end_inset

 for an explicit decreasing measure on the proof tree
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search IV: The calculus LJT
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
\begin_inset Quotes eld
\end_inset


\emph on
It is obvious that it is obvious
\emph default

\begin_inset Quotes erd
\end_inset

 â€“ a mathematician after thinking for a half-hour
\end_layout

\begin_layout Itemize
Rule 
\begin_inset Formula $L\Rightarrow_{4}$
\end_inset

 is based on the key theorem: 
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\Rightarrow B\right)\Rightarrow C\right)\Rightarrow\left(A\Rightarrow B\right)\,\Longleftrightarrow\,\left(B\Rightarrow C\right)\Rightarrow\left(A\Rightarrow B\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
The key theorem for rule 
\begin_inset Formula $L\Rightarrow_{4}$
\end_inset

 is attributed to Vorobieff (1958):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Vorobieff-lemma.png
	display false
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
\align center

\size footnotesize
[R.
 Dyckhoff, 
\emph on
Contraction-Free Sequent Calculi for Intuitionistic Logic
\emph default
, 1992]
\end_layout

\begin_layout Itemize
A stepping stone to this theorem:
\size footnotesize

\begin_inset Formula 
\[
\left(\left(A\Rightarrow B\right)\Rightarrow C\right)\Rightarrow B\Rightarrow C
\]

\end_inset


\size default
Proof (
\emph on
obviously
\emph default
 trivial): 
\begin_inset Formula $f^{\left(A\Rightarrow B\right)\Rightarrow C}\Rightarrow b^{B}\Rightarrow f\:(x^{A}\Rightarrow b)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Details are left as exercise for the reader
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search V: From deduction rules to code
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The new rules are equivalent to the old rules, therefore...
\end_layout

\begin_deeper
\begin_layout Itemize
Proof of a sequent 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 code/expression 
\begin_inset Formula $t(a,b,c):G$
\end_inset


\end_layout

\begin_layout Itemize
Also can be seen as a function 
\begin_inset Formula $t$
\end_inset

 from 
\begin_inset Formula $A,B,C$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sequent in a proof follows from an axiom or from a transforming rule
\end_layout

\begin_deeper
\begin_layout Itemize
The two axioms are fixed expressions, 
\begin_inset Formula $x^{A}\Rightarrow x$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Itemize
Each rule has a 
\emph on
proof transformer
\emph default
 function: 
\begin_inset Formula $\text{PT}_{R\Rightarrow}$
\end_inset

 , 
\begin_inset Formula $\text{PT}_{L+}$
\end_inset

 , etc.
\end_layout

\end_deeper
\begin_layout Itemize
Examples of proof transformer functions:
\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\:L+\\
PT_{L+}(t_{1}^{A\Rightarrow C},t_{2}^{B\Rightarrow C})=x^{A+B}\Rightarrow & \ x\ \text{match}\begin{cases}
a^{A}\Rightarrow t_{1}(a)\\
b^{B}\Rightarrow t_{2}(b)
\end{cases}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\Rightarrow B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\Rightarrow C}\vdash D}\:L\Rightarrow_{2}\\
PT_{L\Rightarrow_{2}}(f^{\left(A\Rightarrow B\Rightarrow C\right)\Rightarrow D})=g^{A\times B\Rightarrow C}\Rightarrow & f\,(x^{A}\Rightarrow y^{B}\Rightarrow g(x,y))
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Verify that we can indeed produce PTs for every rule of LJT
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof search example II: deriving code
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Once a proof tree is found, start from leaves and apply PTs
\end_layout

\begin_layout Itemize
For each sequent 
\begin_inset Formula $S_{i}$
\end_inset

, this will derive a 
\series bold
proof expression
\series default
 
\begin_inset Formula $t_{i}$
\end_inset


\end_layout

\begin_layout Itemize
Example: to prove 
\begin_inset Formula $S_{0}$
\end_inset

, start from 
\begin_inset Formula $S_{6}$
\end_inset

 backwards:
\size footnotesize

\begin_inset Formula 
\begin{align*}
S_{6}:\left(R\Rightarrow R\right)\Rightarrow Q;R\vdash R\quad(\text{axiom }Id)\quad & t_{6}(rrq,r)=r\\
S_{2}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash\left(R\Rightarrow R\right)\quad\text{PT}_{R\Rightarrow}(t_{6})\quad & t_{2}(rrq)=\left(r\Rightarrow t_{6}(rrq,r)\right)\\
S_{3}:Q\vdash Q\quad(\text{axiom }Id)\quad & t_{3}(q)=q\\
S_{1}:\left(R\Rightarrow R\right)\Rightarrow Q\vdash Q\quad\text{PT}_{L\Rightarrow}(t_{2},t_{3})\quad & t_{1}(rrq)=t_{3}(rrq(t_{2}(rrq)))\\
S_{0}:\emptyset\vdash\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q\quad\text{PT}_{R\Rightarrow}(t_{1})\quad & t_{0}=\left(rrq\Rightarrow t_{1}(rrq)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
The proof expression for 
\begin_inset Formula $S_{0}$
\end_inset

 is then obtained as
\begin_inset Formula 
\begin{align*}
t_{0} & =rrq\Rightarrow t_{3}\left(rrq\left(t_{2}\left(rrq\right)\right)\right)=rrq\Rightarrow rrq(r\Rightarrow t_{6}\left(rrq,r\right)\\
 & =rrq\Rightarrow rrq\left(r\Rightarrow r\right)
\end{align*}

\end_inset

Simplified final code having the required type: 
\begin_inset Formula 
\[
t_{0}:\left(\left(R\Rightarrow R\right)\Rightarrow Q\right)\Rightarrow Q=\left(rrq\Rightarrow rrq\left(r\Rightarrow r\right)\right)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The CH correspondence maps the type system of each programming language
 into a certain system of logical propositions 
\end_layout

\begin_layout Itemize
If that logic is decidable, we can automatically produce code from type
 signatures
\end_layout

\begin_layout Itemize
Simply-typed Lambda Calculus corresponds to IPL, which is decidable
\end_layout

\begin_layout Itemize
In practice, many types have more than one implementation
\end_layout

\begin_layout Itemize
To make this into a practical tool, need heuristics or algebraic laws
\end_layout

\begin_layout Itemize
Implementations available in Scala and Haskell
\end_layout

\end_deeper
\end_body
\end_document
